package description

import (
	"bytes"
	"encoding/base64"
	"encoding/json"
	"fmt"
	"io"
	"net/http"
	"os"
	"time"

	descModel "github.com/Checkmarx/kics/pkg/description/model"
	"github.com/rs/zerolog/log"
)

//
// The requested description content is CIS Proprietary Content owned
// by CIS Center for Internet Security Inc. (cissecurity.org)
//
//  Apache License 2.0 shall not apply to any content generated by KICS
//  which is marked as being “Proprietary to CIS” (the “CIS Proprietary Content”).
//
//  The CIS Proprietary Content is exclusively owned by the Center for Internet Security, Inc.
//  and you are granted a limited, non-exclusively, non-transferable, non-sublicensable license
//  to view the CIS Proprietary Content in connection with your use of KICS
//
// ******************************
// *  NOT FOR SECURITY PURPOSES *
// ******************************
var authKey = []rune{80, 114, 111, 112, 101, 114, 116, 121, 95, 111, 102, 95, 67, 101, 110, 116,
	101, 114, 95, 102, 111, 114, 95, 73, 110, 116, 101, 114, 110, 101, 116, 95, 83, 101, 99, 117,
	114, 105, 116, 121, 95, 99, 105, 115, 101, 99, 117, 114, 105, 116, 121, 46, 111, 114, 103}

var baseURL = os.Getenv("KICS_DESCRIPTIONS_ENDPOINT")

// GetDescriptions - gets CIS descriptions from endpoint
func GetDescriptions(descriptionIDs []string) (map[string]string, error) {
	endpointURL := fmt.Sprintf("%s/%s", baseURL, "descriptions")

	descriptionRequest := descModel.DescriptionRequest{
		DescriptionIDs: descriptionIDs,
	}

	requestBody, err := json.Marshal(descriptionRequest)
	if err != nil {
		log.Err(err).Msg("Unable to marshal request body")
		return nil, err
	}
	req, err := http.NewRequest(http.MethodPost, endpointURL, bytes.NewBuffer(requestBody))
	req.Header.Add("Content-Type", "application/json")
	req.Header.Add("Authorization", fmt.Sprintf("Bearer %s", base64.StdEncoding.EncodeToString([]byte(string(authKey)))))

	log.Debug().Msgf("HTTP POST to descriptions endpoint")
	startTime := time.Now()
	if err != nil {
		log.Err(err).Msgf("Unable to create request")
		return nil, err
	}

	client := &http.Client{Timeout: time.Second * 30}
	resp, err := client.Do(req)
	if err != nil {
		log.Err(err).Msg("Unable to perform HTTP request")
		return nil, err
	}

	defer resp.Body.Close()
	endTime := time.Since(startTime)
	log.Debug().Msgf("HTTP Status: %d %s %v", resp.StatusCode, http.StatusText(resp.StatusCode), endTime)

	b, err := io.ReadAll(resp.Body)
	if err != nil {
		log.Err(err).Msg("Unable to read response body")
		return nil, err
	}

	var getDescriptionsResponse descModel.DescriptionResponse
	err = json.Unmarshal(b, &getDescriptionsResponse)
	if err != nil {
		log.Err(err).Msg("Unable to unmarshal response body")
		return nil, err
	}

	return getDescriptionsResponse.Descriptions, nil
}
