package engine

import (
	"fmt"
	"path/filepath"
	"runtime"
	"testing"

	"github.com/Checkmarx/kics/pkg/model"
	"github.com/stretchr/testify/require"
)

type computeSimilarityIDParams struct {
	filePath    string
	queryID     string
	searchKey   string
	searchValue string
}

type computeSimilarityIDSubTest struct {
	calls            []computeSimilarityIDParams
	expectedFunction func(t *testing.T, firstHash, secondHash *string)
}

func TestComputeSimilarityID(t *testing.T) {
	tests := []computeSimilarityIDSubTest{
		{
			calls: []computeSimilarityIDParams{
				{
					filePath:    "test.yaml",
					queryID:     "e96ccbb0-8d74-49ef-87f8-b9613b63b6a8",
					searchKey:   "Resources.MySearchKeyExample",
					searchValue: "TCP,22",
				},
				{
					filePath:    "test1.yaml", // change
					queryID:     "e96ccbb0-8d74-49ef-87f8-b9613b63b6a8",
					searchKey:   "Resources.MySearchKeyExample",
					searchValue: "TCP,22",
				},
			},
			expectedFunction: func(t *testing.T, firstHash, secondHash *string) {
				require.NotEqual(t, *firstHash, *secondHash)
			},
		},
		{
			calls: []computeSimilarityIDParams{
				{
					filePath:    "test.yaml",
					queryID:     "e96ccbb0-8d74-49ef-87f8-b9613b63b6a8",
					searchKey:   "Resources.MySearchKeyExample",
					searchValue: "",
				},
				{
					filePath:    "test.yaml",
					queryID:     "OTHER-8d74-49ef-87f8-b9613b63b6a8", // change
					searchKey:   "Resources.MySearchKeyExample",
					searchValue: "",
				},
			},
			expectedFunction: func(t *testing.T, firstHash, secondHash *string) {
				require.NotEqual(t, *firstHash, *secondHash)
			},
		},
		{
			calls: []computeSimilarityIDParams{
				{
					filePath:    "test.yaml",
					queryID:     "e96ccbb0-8d74-49ef-87f8-b9613b63b6a8",
					searchKey:   "Resources.MySearchKeyExample",
					searchValue: "",
				},
				{
					filePath:    "test.yaml",
					queryID:     "e96ccbb0-8d74-49ef-87f8-b9613b63b6a8",
					searchKey:   "Resources.MyOther.SearchKey", // change
					searchValue: "",
				},
			},
			expectedFunction: func(t *testing.T, firstHash, secondHash *string) {
				require.NotEqual(t, *firstHash, *secondHash)
			},
		},
		{
			calls: []computeSimilarityIDParams{
				{
					filePath:    "my/filesystem/test.yaml",
					queryID:     "e96ccbb0-8d74-49ef-87f8-b9613b63b6a8",
					searchKey:   "Resources.MySearchKeyExample",
					searchValue: "",
				},
				{
					filePath:    "my/filesystem/other/test.yaml", // change
					queryID:     "e96ccbb0-8d74-49ef-87f8-b9613b63b6a8",
					searchKey:   "Resources.MySearchKeyExample",
					searchValue: "",
				},
			},
			expectedFunction: func(t *testing.T, firstHash, secondHash *string) {
				require.NotEqual(t, *firstHash, *secondHash)
			},
		},
		{
			calls: []computeSimilarityIDParams{
				{
					filePath:    "my/directory",
					queryID:     "e96ccbb0-8d74-49ef-87f8-b9613b63b6a8",
					searchKey:   "Resources.MySearchKeyExample",
					searchValue: "TCP,22",
				},
				{
					filePath:    "my/directory",
					queryID:     "e96ccbb0-8d74-49ef-87f8-b9613b63b6a8",
					searchKey:   "Resources.MySearchKeyExample",
					searchValue: "TCP,22",
				},
			},
			expectedFunction: func(t *testing.T, firstHash, secondHash *string) {
				require.Equal(t, *firstHash, *secondHash)
			},
		},
		{
			calls: []computeSimilarityIDParams{
				{
					filePath:    "my/directory/../test.yaml/",
					queryID:     "e96ccbb0-8d74-49ef-87f8-b9613b63b6a8",
					searchKey:   "Resources.MySearchKeyExample",
					searchValue: "",
				},
				{
					filePath:    "my/test.yaml",
					queryID:     "e96ccbb0-8d74-49ef-87f8-b9613b63b6a8",
					searchKey:   "Resources.MySearchKeyExample",
					searchValue: "",
				},
			},
			expectedFunction: func(t *testing.T, firstHash, secondHash *string) {
				require.Equal(t, *firstHash, *secondHash)
			},
		},
		{
			calls: []computeSimilarityIDParams{
				{
					filePath:    "../assets/queries/",
					queryID:     "e96ccbb0-8d74-49ef-87f8-b9613b63b6a8",
					searchKey:   "Resources.MySearchKeyExample",
					searchValue: "",
				},
				{
					filePath:    "../assets/queries/",
					queryID:     "e96ccbb0-8d74-49ef-87f8-b9613b63b6a8",
					searchKey:   "Resources.MySearchKeyExample",
					searchValue: "",
				},
			},
			expectedFunction: func(t *testing.T, firstHash, secondHash *string) {
				require.Equal(t, *firstHash, *secondHash)
			},
		},
	}

	for _, tc := range tests {
		firstHash, err := ComputeSimilarityID(tc.calls[0].filePath, tc.calls[0].queryID, tc.calls[0].searchKey, tc.calls[0].searchValue)
		require.NoError(t, err)
		require.NotEmpty(t, *firstHash)
		secondHash, err := ComputeSimilarityID(tc.calls[1].filePath, tc.calls[1].queryID, tc.calls[1].searchKey, tc.calls[1].searchValue)
		require.NoError(t, err)
		require.NotEmpty(t, *secondHash)

		tc.expectedFunction(t, firstHash, secondHash)
	}
}

func TestStandarizeFilePathEquals(t *testing.T) {
	tests := []struct {
		input            string
		expectedOutput   string
		expectedFunction func(t *testing.T, expected, actual string)
	}{
		{
			input:          "my/filesystem/test.yaml",
			expectedOutput: "my/filesystem/test.yaml",
			expectedFunction: func(t *testing.T, expected, actual string) {
				require.Equal(t, expected, actual)
			},
		},
		{
			input:          "my//filesystem///test.yaml",
			expectedOutput: "my/filesystem/test.yaml",
			expectedFunction: func(t *testing.T, expected, actual string) {
				require.Equal(t, expected, actual)
			},
		},
		{
			input:          "my//filesystem//../test.yaml",
			expectedOutput: "my/test.yaml",
			expectedFunction: func(t *testing.T, expected, actual string) {
				require.Equal(t, expected, actual)
			},
		},
		{
			input:          "my/filesystem/other/test.yaml",
			expectedOutput: "my/filesystem/test.yaml",
			expectedFunction: func(t *testing.T, expected, actual string) {
				require.NotEqual(t, expected, actual)
			},
		},
	}

	for _, tc := range tests {
		path := filepath.FromSlash(tc.input)
		standardPath, err := standarizeFilePath(path)
		require.NoError(t, err)
		require.NotEmpty(t, standardPath)
		tc.expectedFunction(t, tc.expectedOutput, standardPath)
	}
}

func TestStandarizeFilePathAbsoluteError(t *testing.T) {
	var path string
	if runtime.GOOS == "windows" {
		path = filepath.FromSlash("C://" + "my/filesystem/other/test.yaml")
	} else {
		path = filepath.FromSlash("/" + "my/filesystem/other/test.yaml")
	}
	_, err := standarizeFilePath(path)
	require.Error(t, err)
}

func TestDetectDockerLine(t *testing.T) {
	testCases := []struct {
		expected  int
		searchKey string
		ctx       QueryContext
		file      *model.FileMetadata
	}{
		{
			expected: 10,
			searchKey: "FROM={{alpine:3.9}}.RUN={{apk update && apk upgrade && apk add kubectl=1.20.0-r0 	\u0026\u0026 rm -rf /var/cache/apk/*}}",
			ctx: QueryContext{
				scanID: "Test2",
			},
			file: &model.FileMetadata{
				ScanID: "Test2",
				ID:     "Test2",
				Kind:   model.KindDOCKER,
				OriginalData: `FROM alpine:3.7
RUN apk update \
	&& apk upgrade \
	&& apk add kubectl=1.20.0-r0 \
	&& rm -rf /var/cache/apk/*
ENTRYPOINT ["kubectl"]

FROM alpine:3.9
RUN apk update
RUN apk update && apk upgrade && apk add kubectl=1.20.0-r0 \
	&& rm -rf /var/cache/apk/*
ENTRYPOINT ["kubectl"]
`,
			},
		},
		{
			expected:  17,
			searchKey: "FROM=openjdk:11-jdk.{{ADD ${JAR_FILE} apps.jar}}",
			ctx: QueryContext{
				scanID: "Test3",
			},
			file: &model.FileMetadata{
				ScanID: "Test3",
				ID:     "Test3",
				Kind:   model.KindDOCKER,
				OriginalData: `FROM openjdk:10-jdk
VOLUME /tmp
ADD http://source.file/package.file.tar.gz /temp
RUN tar -xjf /temp/package.file.tar.gz \
	&& make -C /tmp/package.file \
	&& rm /tmp/ package.file.tar.gz
ARG JAR_FILE
ADD ${JAR_FILE} app.jar

FROM openjdk:11-jdk
VOLUME /tmp
ADD http://source.file/package.file.tar.gz /temp
RUN tar -xjf /temp/package.file.tar.gz \
  && make -C /tmp/package.file \
  && rm /tmp/ package.file.tar.gz
ARG JAR_FILE
ADD ${JAR_FILE} apps.jar
`,
			},
		},
		{
			expected:  6,
			searchKey: "FROM={{alpine:3.7}}.ENTRYPOINT[kubectl]",
			ctx: QueryContext{
				scanID: "Test",
			},
			file: &model.FileMetadata{
				ScanID: "Test",
				ID:     "Test",
				Kind:   model.KindDOCKER,
				OriginalData: `FROM alpine:3.7
RUN apk update \
	&& apk upgrade \
	&& apk add kubectl=1.20.0-r0 \
	&& rm -rf /var/cache/apk/*
ENTRYPOINT ["kubectl"]
`,
			},
		},
	}

	for i, testCase := range testCases {
		t.Run(fmt.Sprintf("detectDockerLine-%d", i), func(t *testing.T) {
			v := detectDockerLine(testCase.ctx, testCase.file, testCase.searchKey)
			require.Equal(t, testCase.expected, v)
		})
	}
}

func TestSelectLineWithMinimumDistance(t *testing.T) {
	values := []struct {
		distances      map[int]int
		startingFrom   int
		expectedResult int
	}{
		{
			distances: map[int]int{
				12: 0,
			},
			startingFrom:   0,
			expectedResult: 12,
		},
		{
			distances: map[int]int{
				12: 0,
				24: 0,
			},
			startingFrom:   11,
			expectedResult: 12,
		},
		{
			distances: map[int]int{
				1: 26,
				2: 5,
				3: 0,
			},
			startingFrom:   1,
			expectedResult: 3,
		},
	}

	for i, testCase := range values {
		t.Run(fmt.Sprintf("selectLineWithMinimumDistance-%d", i), func(t *testing.T) {
			v := selectLineWithMinimumDistance(testCase.distances, testCase.startingFrom)
			require.Equal(t, testCase.expectedResult, v)
		})
	}
}
