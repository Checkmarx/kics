package engine

import (
	"fmt"
	"reflect"
	"testing"

	"github.com/Checkmarx/kics/internal/tracker"
	"github.com/Checkmarx/kics/pkg/model"
	"github.com/rs/zerolog"
	"github.com/stretchr/testify/require"
)

// TestDetectDockerLine tests the functions [DetectDockerLine()] and all the methods called by them
func TestDetectDockerLine(t *testing.T) {
	testCases := []struct {
		expected  int
		searchKey string
		ctx       QueryContext
		file      *model.FileMetadata
	}{
		{
			expected: 10,
			searchKey: "FROM={{alpine:3.9}}.RUN={{apk update && apk upgrade && apk add kubectl=1.20.0-r0 	\u0026\u0026 rm -rf /var/cache/apk/*}}",
			ctx: QueryContext{
				scanID: "Test2",
			},
			file: &model.FileMetadata{
				ScanID: "Test2",
				ID:     "Test2",
				Kind:   model.KindDOCKER,
				OriginalData: `FROM alpine:3.7
RUN apk update \
	&& apk upgrade \
	&& apk add kubectl=1.20.0-r0 \
	&& rm -rf /var/cache/apk/*
ENTRYPOINT ["kubectl"]

FROM alpine:3.9
RUN apk update
RUN apk update && apk upgrade && apk add kubectl=1.20.0-r0 \
	&& rm -rf /var/cache/apk/*
ENTRYPOINT ["kubectl"]
`,
			},
		},
		{
			expected:  17,
			searchKey: "FROM=openjdk:11-jdk.{{ADD ${JAR_FILE} apps.jar}}",
			ctx: QueryContext{
				scanID: "Test3",
			},
			file: &model.FileMetadata{
				ScanID: "Test3",
				ID:     "Test3",
				Kind:   model.KindDOCKER,
				OriginalData: `FROM openjdk:10-jdk
VOLUME /tmp
ADD http://source.file/package.file.tar.gz /temp
RUN tar -xjf /temp/package.file.tar.gz \
	&& make -C /tmp/package.file \
	&& rm /tmp/ package.file.tar.gz
ARG JAR_FILE
ADD ${JAR_FILE} app.jar

FROM openjdk:11-jdk
VOLUME /tmp
ADD http://source.file/package.file.tar.gz /temp
RUN tar -xjf /temp/package.file.tar.gz \
  && make -C /tmp/package.file \
  && rm /tmp/ package.file.tar.gz
ARG JAR_FILE
ADD ${JAR_FILE} apps.jar
`,
			},
		},
		{
			expected:  6,
			searchKey: "FROM={{alpine:3.7}}.ENTRYPOINT[kubectl]",
			ctx: QueryContext{
				scanID: "Test",
			},
			file: &model.FileMetadata{
				ScanID: "Test",
				ID:     "Test",
				Kind:   model.KindDOCKER,
				OriginalData: `FROM alpine:3.7
RUN apk update \
	&& apk upgrade \
	&& apk add kubectl=1.20.0-r0 \
	&& rm -rf /var/cache/apk/*
ENTRYPOINT ["kubectl"]
`,
			},
		},
	}

	for i, testCase := range testCases {
		t.Run(fmt.Sprintf("detectDockerLine-%d", i), func(t *testing.T) {
			v := detectDockerLine(testCase.file, testCase.searchKey, &zerolog.Logger{})
			require.Equal(t, testCase.expected, v)
		})
	}
}

// TestSelectLineWithMinimumDistance tests the functions [SelectLineWithMinimumDistance()] and all the methods called by them
func TestSelectLineWithMinimumDistance(t *testing.T) {
	values := []struct {
		distances      map[int]int
		startingFrom   int
		expectedResult int
	}{
		{
			distances: map[int]int{
				12: 0,
			},
			startingFrom:   0,
			expectedResult: 12,
		},
		{
			distances: map[int]int{
				12: 0,
				24: 0,
			},
			startingFrom:   11,
			expectedResult: 12,
		},
		{
			distances: map[int]int{
				1: 26,
				2: 5,
				3: 0,
			},
			startingFrom:   1,
			expectedResult: 3,
		},
	}

	for i, testCase := range values {
		t.Run(fmt.Sprintf("selectLineWithMinimumDistance-%d", i), func(t *testing.T) {
			v := selectLineWithMinimumDistance(testCase.distances, testCase.startingFrom)
			require.Equal(t, testCase.expectedResult, v)
		})
	}
}

// TestMapKeyToString tests the functions [MapKeyToString()] and all the methods called by them
func TestMapKeyToString(t *testing.T) {
	testCases := []struct {
		payload  interface{}
		expected string
	}{
		{
			payload:  "test",
			expected: "test",
		},
		{
			payload:  123,
			expected: "123",
		},
		{
			payload:  0.123,
			expected: "0.123",
		},
		{
			payload:  false,
			expected: "false",
		},
		{
			payload:  nil,
			expected: "null",
		},
	}

	for i, testCase := range testCases {
		t.Run(fmt.Sprintf("mapKeyToString-%d", i), func(t *testing.T) {
			v, err := mapKeyToString(map[string]interface{}{"key": testCase.payload}, "key", false)
			require.Nil(t, err)
			require.Equal(t, testCase.expected, *v)
		})
	}
	for i, testCase := range testCases {
		t.Run(fmt.Sprintf("mapKeyToString-%d", i), func(t *testing.T) {
			_, err := mapKeyToString(map[string]interface{}{"t": testCase.payload}, "key", false)
			require.Error(t, err)
		})
	}
}

// Test_mergeWithMetadata tests the functions [mergeWithMetadata()] and all the methods called by them
func Test_mergeWithMetadata(t *testing.T) {
	type args struct {
		base       map[string]interface{}
		additional map[string]interface{}
	}
	tests := []struct {
		name string
		args args
		want map[string]interface{}
	}{
		{
			name: "mergeWithMetadata",
			args: args{
				base: map[string]interface{}{
					"key": "123",
				},
				additional: map[string]interface{}{
					"key": "teste",
				},
			},
			want: map[string]interface{}{
				"key": "123",
			},
		},
		{
			name: "mergeWithMetadata_2",
			args: args{
				base: map[string]interface{}{
					"key": "123",
				},
				additional: map[string]interface{}{
					"r": "teste2",
				},
			},
			want: map[string]interface{}{
				"key": "123",
				"r":   "teste2",
			},
		},
	}
	for _, tt := range tests {
		t.Run(tt.name, func(t *testing.T) {
			if got := mergeWithMetadata(tt.args.base, tt.args.additional); !reflect.DeepEqual(got, tt.want) {
				t.Errorf("mergeWithMetadata() = %v, want %v", got, tt.want)
			}
		})
	}
}

// Test_detectLine tests the functions [detectLine()] and all the methods called by them
func Test_detectLine(t *testing.T) {
	type args struct {
		ctx       QueryContext
		file      *model.FileMetadata
		searchKey string
	}
	tests := []struct {
		name string
		args args
		want int
	}{
		{
			name: "detect_line",
			args: args{
				ctx: QueryContext{
					scanID: "scanID",
				},
				file: &model.FileMetadata{
					ScanID: "scanID",
					ID:     "Test",
					Kind:   model.KindTerraform,
					OriginalData: `resource "aws_s3_bucket" "b" {
						bucket = "my-tf-test-bucket"
						acl    = "authenticated-read"

						tags = {
						  Name        = "My bucket"
						  Environment = "Dev"
						}
					      }
					      `,
				},
				searchKey: "aws_s3_bucket[b].acl",
			},
			want: 3,
		},
		{
			name: "detect_line_with_curly_brackets",
			args: args{
				ctx: QueryContext{
					scanID: "scanID",
				},
				file: &model.FileMetadata{
					ScanID: "scanID",
					ID:     "Test",
					Kind:   model.KindTerraform,
					OriginalData: `resource "aws_s3_bucket" "b" {
						bucket = "my-tf-test-bucket"
						acl    = "authenticated-read"

						tags = {
						  Name        = "My bucket"
						  Environment = "Dev.123"
						  Environment = "test"
						}
					      }
					      `,
				},
				searchKey: "aws_s3_bucket[b].Environment={{Dev.123}}",
			},
			want: 7,
		},
	}
	for _, tt := range tests {
		t.Run(tt.name, func(t *testing.T) {
			if got := detectLine(tt.args.file, tt.args.searchKey, &zerolog.Logger{}); got != tt.want {
				t.Errorf("detectLine() = %v, want %v", got, tt.want)
			}
		})
	}
}

// Test_mustMapKeyToString tests the functions [mustMapKeyToString()] and all the methods called by them
func Test_mustMapKeyToString(t *testing.T) {
	type args struct {
		m   map[string]interface{}
		key string
	}
	tests := []struct {
		name string
		args args
		want string
	}{
		{
			name: "mustMapKeyToString",
			args: args{
				m: map[string]interface{}{
					"key": 123,
				},
				key: "key",
			},
			want: "123",
		},
	}
	for _, tt := range tests {
		t.Run(tt.name, func(t *testing.T) {
			got := mustMapKeyToString(tt.args.m, tt.args.key)
			require.Equal(t, tt.want, *got)
		})
	}
}

// Test_ptrStringToString tests the functions [ptrStringToString()] and all the methods called by them
func Test_ptrStringToString(t *testing.T) {
	type args struct {
		v string
	}
	tests := []struct {
		name string
		args args
		want string
	}{
		{
			name: "ptrStringToString",
			args: args{
				v: "123",
			},
			want: "123",
		},
		{
			name: "ptrStringToString_empty",
			args: args{
				v: "nil",
			},
			want: "",
		},
	}
	for _, tt := range tests {
		t.Run(tt.name, func(t *testing.T) {
			if tt.args.v == "nil" {
				if got := ptrStringToString(nil); got != tt.want {
					t.Errorf("ptrStringToString() = %v, want %v", got, tt.want)
				}
			} else {
				if got := ptrStringToString(&tt.args.v); got != tt.want {
					t.Errorf("ptrStringToString() = %v, want %v", got, tt.want)
				}
			}
		})
	}
}

// TestDefaultVulnerabilityBuilder tests the functions [DefaultVulnerabilityBuilder] and all the methods called by them
func TestDefaultVulnerabilityBuilder(t *testing.T) {
	type args struct {
		ctx     QueryContext
		v       interface{}
		tracker Tracker
	}
	tests := []struct {
		name    string
		args    args
		want    model.Vulnerability
		wantErr bool
	}{
		{
			name: "DefaultVulnerabilityBuilder",
			args: args{
				tracker: &tracker.CITracker{},
				ctx: QueryContext{
					scanID: "ScanID",
					query: &preparedQuery{
						metadata: model.QueryMetadata{
							Metadata: map[string]interface{}{
								"key":       "123",
								"severity":  "INFO",
								"issueType": "IncorrectValue",
								"searchKey": "testSearchKey",
							},
							Query: "TestQuery",
						},
					},
					files: map[string]model.FileMetadata{
						"testV": {},
					},
				},
				v: map[string]interface{}{
					"documentId": "testV",
				},
			},
			want: model.Vulnerability{
				ID:               0,
				SimilarityID:     "2fefa27cc667decf203d10f103b7ffdec232e9af16e361f47d626e72c72b8d63",
				ScanID:           "ScanID",
				FileID:           "",
				FileName:         "",
				QueryID:          "Undefined",
				QueryName:        "Anonymous",
				Severity:         "INFO",
				Line:             -1,
				IssueType:        "IncorrectValue",
				SearchKey:        "testSearchKey",
				KeyActualValue:   "",
				KeyExpectedValue: "",
				Value:            nil,
				Output:           `{"documentId":"testV","issueType":"IncorrectValue","key":"123","searchKey":"testSearchKey","severity":"INFO"}`,
			},
			wantErr: false,
		},
	}

	for _, tt := range tests {
		t.Run(tt.name, func(t *testing.T) {
			got, err := DefaultVulnerabilityBuilder(tt.args.ctx, tt.args.tracker, tt.args.v)
			if (err != nil) != tt.wantErr {
				t.Errorf("DefaultVulnerabilityBuilder() error = %v, wantErr %v", err, tt.wantErr)
				return
			}
			if !reflect.DeepEqual(got, tt.want) {
				t.Errorf("DefaultVulnerabilityBuilder() = %v, want %v", got, tt.want)
			}
		})
	}
}
