package engine

import (
	"fmt"
	"reflect"
	"testing"

	"github.com/Checkmarx/kics/internal/tracker"
	"github.com/Checkmarx/kics/pkg/model"
	"github.com/Checkmarx/kics/test"
	"github.com/rs/zerolog"
	"github.com/stretchr/testify/require"
)

// TestDetectDockerLine tests the functions [DetectDockerLine()] and all the methods called by them
func TestDetectDockerLine(t *testing.T) { //nolint
	testCases := []struct {
		expected  vulnerabilityLines
		searchKey string
		ctx       *QueryContext
		file      *model.FileMetadata
	}{
		{
			expected: vulnerabilityLines{
				line: 10,
				vulnLine: model.VulnLines{
					Positions: []int{9, 10, 11},
					Lines: []string{
						"RUN apk update",
						"RUN apk update && apk upgrade && apk add kubectl=1.20.0-r0 \\",
						"\t&& rm -rf /var/cache/apk/*",
					},
				},
			},
			searchKey: "FROM={{alpine:3.9}}.RUN={{apk update && apk upgrade && apk add kubectl=1.20.0-r0 	\u0026\u0026 rm -rf /var/cache/apk/*}}",
			ctx: &QueryContext{
				scanID: "Test2",
			},
			file: &model.FileMetadata{
				ScanID: "Test2",
				ID:     "Test2",
				Kind:   model.KindDOCKER,
				OriginalData: `FROM alpine:3.7
RUN apk update \
	&& apk upgrade \
	&& apk add kubectl=1.20.0-r0 \
	&& rm -rf /var/cache/apk/*
ENTRYPOINT ["kubectl"]

FROM alpine:3.9
RUN apk update
RUN apk update && apk upgrade && apk add kubectl=1.20.0-r0 \
	&& rm -rf /var/cache/apk/*
ENTRYPOINT ["kubectl"]
`,
			},
		},
		{
			expected: vulnerabilityLines{
				line: 17,
				vulnLine: model.VulnLines{
					Positions: []int{16, 17, 18},
					Lines: []string{
						"ARG JAR_FILE",
						"ADD ${JAR_FILE} apps.jar",
						"",
					},
				},
			},
			searchKey: "FROM=openjdk:11-jdk.{{ADD ${JAR_FILE} apps.jar}}",
			ctx: &QueryContext{
				scanID: "Test3",
			},
			file: &model.FileMetadata{
				ScanID: "Test3",
				ID:     "Test3",
				Kind:   model.KindDOCKER,
				OriginalData: `FROM openjdk:10-jdk
VOLUME /tmp
ADD http://source.file/package.file.tar.gz /temp
RUN tar -xjf /temp/package.file.tar.gz \
	&& make -C /tmp/package.file \
	&& rm /tmp/ package.file.tar.gz
ARG JAR_FILE
ADD ${JAR_FILE} app.jar

FROM openjdk:11-jdk
VOLUME /tmp
ADD http://source.file/package.file.tar.gz /temp
RUN tar -xjf /temp/package.file.tar.gz \
  && make -C /tmp/package.file \
  && rm /tmp/ package.file.tar.gz
ARG JAR_FILE
ADD ${JAR_FILE} apps.jar
`,
			},
		},
		{
			expected: vulnerabilityLines{
				line: 6,
				vulnLine: model.VulnLines{
					Positions: []int{5, 6, 7},
					Lines: []string{
						`	&& apk add kubectl=1.20.0-r0 \`,
						"	&& rm -rf /var/cache/apk/*",
						`ENTRYPOINT ["kubectl"]`,
					},
				},
			},
			searchKey: "FROM={{alpine:3.7}}.ENTRYPOINT[kubectl]",
			ctx: &QueryContext{
				scanID: "Test",
			},
			file: &model.FileMetadata{
				ScanID: "Test",
				ID:     "Test",
				Kind:   model.KindDOCKER,
				OriginalData: `FROM alpine:3.7
RUN apk update \
	&& apk upgrade \
	&& apk add kubectl=1.20.0-r0 \
	&& rm -rf /var/cache/apk/*
ENTRYPOINT ["kubectl"]`,
			},
		},
	}

	for i, testCase := range testCases {
		t.Run(fmt.Sprintf("detectDockerLine-%d", i), func(t *testing.T) {
			v := detectDockerLine(testCase.file, testCase.searchKey, &zerolog.Logger{}, 3)
			require.Equal(t, testCase.expected, v)
		})
	}
}

// TestSelectLineWithMinimumDistance tests the functions [SelectLineWithMinimumDistance()] and all the methods called by them
func TestSelectLineWithMinimumDistance(t *testing.T) {
	values := []struct {
		distances      map[int]int
		startingFrom   int
		expectedResult int
	}{
		{
			distances: map[int]int{
				12: 0,
			},
			startingFrom:   0,
			expectedResult: 12,
		},
		{
			distances: map[int]int{
				12: 0,
				24: 0,
			},
			startingFrom:   11,
			expectedResult: 12,
		},
		{
			distances: map[int]int{
				1: 26,
				2: 5,
				3: 0,
			},
			startingFrom:   1,
			expectedResult: 3,
		},
	}

	for i, testCase := range values {
		t.Run(fmt.Sprintf("selectLineWithMinimumDistance-%d", i), func(t *testing.T) {
			v := selectLineWithMinimumDistance(testCase.distances, testCase.startingFrom)
			require.Equal(t, testCase.expectedResult, v)
		})
	}
}

// TestMapKeyToString tests the functions [MapKeyToString()] and all the methods called by them
func TestMapKeyToString(t *testing.T) {
	testCases := []struct {
		payload  interface{}
		expected string
	}{
		{
			payload:  "test",
			expected: "test",
		},
		{
			payload:  123,
			expected: "123",
		},
		{
			payload:  0.123,
			expected: "0.123",
		},
		{
			payload:  false,
			expected: "false",
		},
		{
			payload:  nil,
			expected: "null",
		},
	}

	for i, testCase := range testCases {
		t.Run(fmt.Sprintf("mapKeyToString-%d", i), func(t *testing.T) {
			v, err := mapKeyToString(map[string]interface{}{"key": testCase.payload}, "key", false)
			require.Nil(t, err)
			require.Equal(t, testCase.expected, *v)
		})
	}
	for i, testCase := range testCases {
		t.Run(fmt.Sprintf("mapKeyToString-%d", i), func(t *testing.T) {
			_, err := mapKeyToString(map[string]interface{}{"t": testCase.payload}, "key", false)
			require.Error(t, err)
		})
	}
}

// Test_mergeWithMetadata tests the functions [mergeWithMetadata()] and all the methods called by them
func Test_mergeWithMetadata(t *testing.T) {
	type args struct {
		base       map[string]interface{}
		additional map[string]interface{}
	}
	tests := []struct {
		name string
		args args
		want map[string]interface{}
	}{
		{
			name: "mergeWithMetadata",
			args: args{
				base: map[string]interface{}{
					"key": "123",
				},
				additional: map[string]interface{}{
					"key": "teste",
				},
			},
			want: map[string]interface{}{
				"key": "123",
			},
		},
		{
			name: "mergeWithMetadata_2",
			args: args{
				base: map[string]interface{}{
					"key": "123",
				},
				additional: map[string]interface{}{
					"r": "teste2",
				},
			},
			want: map[string]interface{}{
				"key": "123",
				"r":   "teste2",
			},
		},
	}
	for _, tt := range tests {
		t.Run(tt.name, func(t *testing.T) {
			if got := mergeWithMetadata(tt.args.base, tt.args.additional); !reflect.DeepEqual(got, tt.want) {
				t.Errorf("mergeWithMetadata() = %v, want %v", got, tt.want)
			}
		})
	}
}

// Test_detectLine tests the functions [detectLine()] and all the methods called by them
func Test_detectLine(t *testing.T) { //nolint
	type args struct {
		ctx       *QueryContext
		file      *model.FileMetadata
		searchKey string
	}
	tests := []struct {
		name string
		args args
		want vulnerabilityLines
	}{
		{
			name: "detect_line",
			args: args{
				ctx: &QueryContext{
					scanID: "scanID",
				},
				file: &model.FileMetadata{
					ScanID: "scanID",
					ID:     "Test",
					Kind:   model.KindTerraform,
					OriginalData: `resource "aws_s3_bucket" "b" {
						bucket = "my-tf-test-bucket"
						acl    = "authenticated-read"

						tags = {
						  Name        = "My bucket"
						  Environment = "Dev"
						}
					      }
					      `,
				},
				searchKey: "aws_s3_bucket[b].acl",
			},
			want: vulnerabilityLines{
				line: 3,
				vulnLine: model.VulnLines{
					Positions: []int{2, 3, 4},
					Lines: []string{
						`						bucket = "my-tf-test-bucket"`,
						`						acl    = "authenticated-read"`,
						"",
					},
				},
			},
		},
		{
			name: "detect_line_with_curly_brackets",
			args: args{
				ctx: &QueryContext{
					scanID: "scanID",
				},
				file: &model.FileMetadata{
					ScanID: "scanID",
					ID:     "Test",
					Kind:   model.KindTerraform,
					OriginalData: `resource "aws_s3_bucket" "b" {
						bucket = "my-tf-test-bucket"
						acl    = "authenticated-read"

						tags = {
						  Name        = "My bucket"
						  Environment = "Dev.123"
						  Environment = "test"
						}
					      }
					      `,
				},
				searchKey: "aws_s3_bucket[b].Environment={{Dev.123}}",
			},
			want: vulnerabilityLines{
				line: 7,
				vulnLine: model.VulnLines{
					Positions: []int{6, 7, 8},
					Lines: []string{
						`						  Name        = "My bucket"`,
						`						  Environment = "Dev.123"`,
						`						  Environment = "test"`,
					},
				},
			},
		},
		{
			name: "detect_line_error",
			args: args{
				ctx: &QueryContext{
					scanID: "scanID",
				},
				file: &model.FileMetadata{
					ScanID: "scanID",
					ID:     "Test",
					Kind:   model.KindTerraform,
					OriginalData: `resource "aws_s3_bucket" "b" {
						bucket = "my-tf-test-bucket"
						acl    = "authenticated-read"

						tags = {
						  Name        = "My bucket"
						  Environment = "Dev.123"
						  Environment = "test"
						}
					      }
					      `,
				},
				searchKey: "testing.error",
			},
			want: vulnerabilityLines{
				line:     -1,
				vulnLine: model.VulnLines{},
			},
		},
	}
	for _, tt := range tests {
		t.Run(tt.name, func(t *testing.T) {
			got := detectLine(tt.args.file, tt.args.searchKey, &zerolog.Logger{}, 3)
			gotStrVulnerabilities, err := test.StringifyStruct(got)
			require.Nil(t, err)
			wantStrVulnerabilities, err := test.StringifyStruct(tt.want)
			require.Nil(t, err)
			if !reflect.DeepEqual(gotStrVulnerabilities, wantStrVulnerabilities) {
				t.Errorf("detectLine() = %v, want %v", gotStrVulnerabilities, wantStrVulnerabilities)
			}
		})
	}
}

// Test_mustMapKeyToString tests the functions [mustMapKeyToString()] and all the methods called by them
func Test_mustMapKeyToString(t *testing.T) {
	type args struct {
		m   map[string]interface{}
		key string
	}
	tests := []struct {
		name string
		args args
		want string
	}{
		{
			name: "mustMapKeyToString",
			args: args{
				m: map[string]interface{}{
					"key": 123,
				},
				key: "key",
			},
			want: "123",
		},
	}
	for _, tt := range tests {
		t.Run(tt.name, func(t *testing.T) {
			got := mustMapKeyToString(tt.args.m, tt.args.key)
			require.Equal(t, tt.want, *got)
		})
	}
}

// Test_ptrStringToString tests the functions [ptrStringToString()] and all the methods called by them
func Test_ptrStringToString(t *testing.T) {
	type args struct {
		v string
	}
	tests := []struct {
		name string
		args args
		want string
	}{
		{
			name: "ptrStringToString",
			args: args{
				v: "123",
			},
			want: "123",
		},
		{
			name: "ptrStringToString_empty",
			args: args{
				v: "nil",
			},
			want: "",
		},
	}
	for _, tt := range tests {
		t.Run(tt.name, func(t *testing.T) {
			if tt.args.v == "nil" {
				if got := ptrStringToString(nil); got != tt.want {
					t.Errorf("ptrStringToString() = %v, want %v", got, tt.want)
				}
			} else {
				if got := ptrStringToString(&tt.args.v); got != tt.want {
					t.Errorf("ptrStringToString() = %v, want %v", got, tt.want)
				}
			}
		})
	}
}

// TestDefaultVulnerabilityBuilder tests the functions [DefaultVulnerabilityBuilder] and all the methods called by them
func TestDefaultVulnerabilityBuilder(t *testing.T) {
	type args struct {
		ctx     *QueryContext
		v       interface{}
		tracker Tracker
	}
	tests := []struct {
		name    string
		args    args
		want    model.Vulnerability
		wantErr bool
	}{
		{
			name: "DefaultVulnerabilityBuilder",
			args: args{
				tracker: &tracker.CITracker{},
				ctx: &QueryContext{
					scanID: "ScanID",
					query: &preparedQuery{
						metadata: model.QueryMetadata{
							Metadata: map[string]interface{}{
								"key":       "123",
								"severity":  model.SeverityInfo,
								"issueType": "IncorrectValue",
								"searchKey": "testSearchKey",
							},
							Query: "TestQuery",
						},
					},
					files: map[string]model.FileMetadata{
						"testV": {},
					},
				},
				v: map[string]interface{}{
					"documentId": "testV",
				},
			},
			want: model.Vulnerability{
				ID:               0,
				SimilarityID:     "2fefa27cc667decf203d10f103b7ffdec232e9af16e361f47d626e72c72b8d63",
				ScanID:           "ScanID",
				FileID:           "",
				FileName:         "",
				QueryID:          "Undefined",
				QueryName:        "Anonymous",
				Severity:         model.SeverityInfo,
				Line:             -1,
				IssueType:        "IncorrectValue",
				SearchKey:        "testSearchKey",
				KeyActualValue:   "",
				KeyExpectedValue: "",
				Value:            nil,
				Output:           `{"documentId":"testV","issueType":"IncorrectValue","key":"123","searchKey":"testSearchKey","severity":"INFO"}`,
			},
			wantErr: false,
		},
	}

	for _, tt := range tests {
		t.Run(tt.name, func(t *testing.T) {
			got, err := DefaultVulnerabilityBuilder(tt.args.ctx, tt.args.tracker, tt.args.v)
			if (err != nil) != tt.wantErr {
				t.Errorf("DefaultVulnerabilityBuilder() error = %v, wantErr %v", err, tt.wantErr)
				return
			}
			if !reflect.DeepEqual(got, tt.want) {
				t.Errorf("DefaultVulnerabilityBuilder() = %v, want %v", got, tt.want)
			}
		})
	}
}

// TestGetBracketValues tests the functions [getBracketValues()] and all the methods called by them
func TestGetBracketValues(t *testing.T) {
	type args struct {
		expr string
	}
	tests := []struct {
		name string
		args args
		want [][]string
	}{
		{
			name: "no_brackets",
			args: args{
				expr: "password",
			},
			want: [][]string{
				{
					"{{password}}",
					"password",
				},
			},
		},
		{
			name: "single_brackets",
			args: args{
				expr: "{{password}}",
			},
			want: [][]string{
				{
					"{{password}}",
					"password",
				},
			},
		},
		{
			name: "double_brackets",
			args: args{
				expr: "{{ {{password}} }}",
			},
			want: [][]string{
				{
					"{{ {{password}}}}",
					" {{password}}",
				},
			},
		},
		{
			name: "multiple_brackets",
			args: args{
				expr: "FROM={{open-jdk}}.{{ {{password}} }}",
			},
			want: [][]string{
				{
					"{{open-jdk}}",
					"open-jdk",
				},
				{
					"{{ {{password}}}}",
					" {{password}}",
				},
			},
		},
	}

	for _, tt := range tests {
		var got [][]string
		t.Run(tt.name, func(t *testing.T) {
			got = getBracketValues(tt.args.expr, got, "")
			if !reflect.DeepEqual(got, tt.want) {
				t.Errorf("DefaultVulnerabilityBuilder() = %v, want %v", got, tt.want)
			}
		})
	}
}

// TestGetAdjacents tests the functions [GetAdjacents()] and all the methods called by them
func TestGetAdjacents(t *testing.T) { //nolint
	type args struct {
		idx   int
		adj   int
		lines []string
	}
	tests := []struct {
		name string
		args args
		want model.VulnLines
	}{
		{
			name: "test_start_of_file",
			args: args{
				idx: 0,
				adj: 3,
				lines: []string{
					"firstline",
					"secondline",
					"thirdline",
					"forthline",
				},
			},
			want: model.VulnLines{
				Positions: []int{1, 2, 3},
				Lines: []string{
					"firstline",
					"secondline",
					"thirdline",
				},
			},
		},
		{
			name: "test_end_of_file",
			args: args{
				idx: 3,
				adj: 3,
				lines: []string{
					"firstline",
					"secondline",
					"thirdline",
					"forthline",
				},
			},
			want: model.VulnLines{
				Positions: []int{3, 4, 5},
				Lines: []string{
					"secondline",
					"thirdline",
					"forthline",
				},
			},
		},
		{
			name: "test_midle_of_file",
			args: args{
				idx: 1,
				adj: 3,
				lines: []string{
					"firstline",
					"secondline",
					"thirdline",
					"forthline",
				},
			},
			want: model.VulnLines{
				Positions: []int{1, 2, 3},
				Lines: []string{
					"firstline",
					"secondline",
					"thirdline",
				},
			},
		},
		{
			name: "test_even_adj",
			args: args{
				idx: 1,
				adj: 2,
				lines: []string{
					"firstline",
					"secondline",
					"thirdline",
					"forthline",
				},
			},
			want: model.VulnLines{
				Positions: []int{2, 3},
				Lines: []string{
					"secondline",
					"thirdline",
				},
			},
		},
		{
			name: "test_even_adj_first_line",
			args: args{
				idx: 0,
				adj: 2,
				lines: []string{
					"firstline",
					"secondline",
					"thirdline",
					"forthline",
				},
			},
			want: model.VulnLines{
				Positions: []int{1, 2},
				Lines: []string{
					"firstline",
					"secondline",
				},
			},
		},
		{
			name: "test_one_adj",
			args: args{
				idx: 3,
				adj: 1,
				lines: []string{
					"firstline",
					"secondline",
					"thirdline",
					"forthline",
				},
			},
			want: model.VulnLines{
				Positions: []int{4},
				Lines: []string{
					"forthline",
				},
			},
		},
		{
			name: "test_adj_bigger_than_file",
			args: args{
				idx: 3,
				adj: 5,
				lines: []string{
					"firstline",
					"secondline",
					"thirdline",
					"forthline",
				},
			},
			want: model.VulnLines{
				Positions: []int{1, 2, 3, 4},
				Lines: []string{
					"firstline",
					"secondline",
					"thirdline",
					"forthline",
				},
			},
		},
	}

	for _, tt := range tests {
		t.Run(tt.name, func(t *testing.T) {
			got := getAdjacentLines(tt.args.idx, tt.args.adj, tt.args.lines)
			gotStrVulnerabilities, err := test.StringifyStruct(got)
			require.Nil(t, err)
			wantStrVulnerabilities, err := test.StringifyStruct(tt.want)
			require.Nil(t, err)
			if !reflect.DeepEqual(gotStrVulnerabilities, wantStrVulnerabilities) {
				t.Errorf("getAdjacents() = %v, want = %v", gotStrVulnerabilities, wantStrVulnerabilities)
			}
		})
	}
}
