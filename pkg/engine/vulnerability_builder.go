package engine

import (
	"encoding/json"
	"fmt"
	"regexp"
	"sort"
	"strconv"
	"strings"

	"github.com/Checkmarx/kics/pkg/model"
	"github.com/agnivade/levenshtein"
	"github.com/pkg/errors"
	"github.com/rs/zerolog"
	"github.com/rs/zerolog/log"
)

var (
	nameRegex             = regexp.MustCompile(`^([A-Za-z0-9-_]+)\[([A-Za-z0-9-_{}]+)]$`)
	nameRegexDocker       = regexp.MustCompile(`{{(.*?)}}`)
	nameRegexDockerFileML = regexp.MustCompile(`.+\s+\\$`)
)

const (
	namePartsLength  = 3
	valuePartsLength = 2
)

type vulnerabilityLines struct {
	line                 int
	vulnLine             model.VulnLines
	lineWithVulnerabilty string
}

type detectCurlLine struct {
	foundRes   bool
	lineRes    int
	breakRes   bool
	lastUnique dupHistory
}

// dupHistory keeps the history of uniques
type dupHistory struct {
	unique         bool
	lastUniqueLine int
}

func getStringFromMap(vulnParam, defaultParam string, vOjb map[string]interface{}, logWithFields *zerolog.Logger) string {
	ts, err := mapKeyToString(vOjb, vulnParam, false)
	if err != nil {
		logWithFields.Err(err).
			Msgf("Saving result. failed to detect %s", vulnParam)
		return defaultParam
	}
	return *ts
}

// DefaultVulnerabilityBuilder defines a vulnerability builder to execute default actions of scan
var DefaultVulnerabilityBuilder = func(ctx *QueryContext, tracker Tracker, v interface{}) (model.Vulnerability, error) {
	vObj, ok := v.(map[string]interface{})
	if !ok {
		return model.Vulnerability{}, ErrInvalidResult
	}

	vObj = mergeWithMetadata(vObj, ctx.query.metadata.Metadata)

	var err error
	var output []byte

	output, err = json.Marshal(vObj)
	if err != nil {
		return model.Vulnerability{}, errors.Wrap(err, "failed to marshall query output")
	}

	var fileID *string

	fileID, err = mapKeyToString(vObj, "documentId", false)
	if err != nil {
		return model.Vulnerability{}, errors.Wrap(err, "failed to recognize file id")
	}

	file, ok := ctx.files[*fileID]
	if !ok {
		return model.Vulnerability{}, errors.New("failed to find file from query response")
	}

	logWithFields := log.With().
		Str("scanID", ctx.scanID).
		Str("fileName", file.FileName).
		Str("queryName", ctx.query.metadata.Query).
		Logger()

	linesVulne := vulnerabilityLines{
		line:     UndetectedVulnerabilityLine,
		vulnLine: model.VulnLines{},
	}
	searchKey := ""
	if s, ok := vObj["searchKey"]; ok {
		searchKey = s.(string)
		switch file.Kind {
		case model.KindDOCKER:
			linesVulne = detectDockerLine(&file, searchKey, &logWithFields, tracker.GetOutputLines())
		case model.KindHELM:
			// Update search key to make use of the auxiliary lines
			tempSearchKey := fmt.Sprintf("%s.%s", strings.TrimRight(strings.TrimLeft(file.HelmID, "# "), ":"), searchKey)
			linesVulne = detectHelmLine(&file, tempSearchKey, &logWithFields, tracker.GetOutputLines())
		default:
			linesVulne = detectLine(&file, searchKey, &logWithFields, tracker.GetOutputLines())
		}
	} else {
		logWithFields.Error().Msg("Saving result. failed to detect line")
	}

	searchValue := ""
	if s, ok := vObj["searchValue"]; ok {
		searchValue = s.(string)
	}

	queryID := getStringFromMap("id", DefaultQueryID, vObj, &logWithFields)

	var severity model.Severity = model.SeverityInfo
	var s *string

	if s, err = mapKeyToString(vObj, "severity", false); err == nil {
		su := strings.ToUpper(*s)
		var found bool
		for _, si := range model.AllSeverities {
			if su == string(si) {
				severity = si
				found = true
				break
			}
		}

		if !found {
			logWithFields.Warn().Str("severity", *s).Msg("Saving result. invalid severity constant value")
		}
	} else {
		logWithFields.Info().Msg("Saving result. failed to detect severity")
	}

	issueType := DefaultIssueType
	if v := mustMapKeyToString(vObj, "issueType"); v != nil {
		issueType = model.IssueType(*v)
	}

	var similarityID *string

	similarityID, err = ComputeSimilarityID(ctx.baseScanPath, file.FileName, queryID, searchKey, searchValue)
	if err != nil {
		logWithFields.Err(err).Send()
		tracker.FailedComputeSimilarityID()
	}

	return model.Vulnerability{
		ID:               0,
		SimilarityID:     ptrStringToString(similarityID),
		ScanID:           ctx.scanID,
		FileID:           file.ID,
		FileName:         file.FileName,
		QueryName:        getStringFromMap("queryName", DefaultQueryName, vObj, &logWithFields),
		QueryID:          queryID,
		QueryURI:         getStringFromMap("descriptionUrl", DefaultQueryURI, vObj, &logWithFields),
		Category:         getStringFromMap("category", "", vObj, &logWithFields),
		Description:      getStringFromMap("descriptionText", "", vObj, &logWithFields),
		Severity:         severity,
		Platform:         getStringFromMap("platform", "", vObj, &logWithFields),
		Line:             linesVulne.line,
		VulnLines:        linesVulne.vulnLine,
		IssueType:        issueType,
		SearchKey:        searchKey,
		SearchValue:      searchValue,
		KeyExpectedValue: ptrStringToString(mustMapKeyToString(vObj, "keyExpectedValue")),
		KeyActualValue:   ptrStringToString(mustMapKeyToString(vObj, "keyActualValue")),
		Value:            mustMapKeyToString(vObj, "value"),
		Output:           string(output),
	}, nil
}

func mergeWithMetadata(base, additional map[string]interface{}) map[string]interface{} {
	for k, v := range additional {
		if _, ok := base[k]; ok {
			continue
		}

		base[k] = v
	}

	return base
}

/*
	detectHelmLine is used to detect line on the helm template,
	it looks only at the keys of the template and will make use of the auxiliary added
	lines (ex: "# KICS_HELM_ID_")
*/
func detectHelmLine(file *model.FileMetadata, searchKey string, logWithFields *zerolog.Logger, outputLines int) vulnerabilityLines {
	text := strings.ReplaceAll(file.OriginalData, "\r", "")
	lines := strings.Split(text, "\n")
	curLineRes := detectCurlLine{
		foundRes: false,
		lineRes:  0,
		breakRes: false,
	}
	var extractedString [][]string
	extractedString = getBracketValues(searchKey, extractedString, "")
	sanitizedSubstring := searchKey
	for idx, str := range extractedString {
		sanitizedSubstring = strings.Replace(sanitizedSubstring, str[0], `{{`+strconv.Itoa(idx)+`}}`, -1)
	}

	helmID, err := strconv.Atoi(strings.TrimSuffix(strings.TrimPrefix(file.HelmID, "# KICS_HELM_ID_"), ":"))
	if err != nil {
		helmID = -1
	}

	// Since we are only looking at keys we can ignore the second value passed through '=' and '[]'
	for _, key := range strings.Split(sanitizedSubstring, ".") {
		substr1, _ := generateSubstrings(key, extractedString)
		curLineRes = curLineRes.detectCurrentLine(lines, fmt.Sprintf("%s:", substr1), "", true, file.IDInfo, helmID)

		if curLineRes.breakRes {
			break
		}
	}

	// Look at dupHistory to see if the last element was duplicate, if so
	// change the line to the last unique key
	if !curLineRes.lastUnique.unique {
		curLineRes.lineRes = curLineRes.lastUnique.lastUniqueLine
	}

	if curLineRes.foundRes {
		lineRemove := make(map[int]int)
		count := 0
		for i, line := range lines { // Remove auxiliary lines
			if strings.Contains(line, "# KICS_HELM_ID_") {
				count++
				lineRemove[i] = count
				lines = append(lines[:i], lines[i+1:]...)
			}
		}
		// Update found line
		curLineRes.lineRes = removeLines(curLineRes.lineRes, lineRemove)
		return vulnerabilityLines{
			line:                 curLineRes.lineRes + 1,
			vulnLine:             getAdjacentLines(curLineRes.lineRes, outputLines, lines),
			lineWithVulnerabilty: strings.Split(lines[curLineRes.lineRes], ": ")[0],
		}
	}

	logWithFields.Warn().Msgf("failed to detect line, query response %s", searchKey)

	return vulnerabilityLines{
		line:     UndetectedVulnerabilityLine,
		vulnLine: model.VulnLines{},
	}
}

// removeLines is used to update the vulnerability line after removing the "# KICS_HELM_ID_"
func removeLines(current int, lineRemove map[int]int) int {
	orderByKey := make([]int, len(lineRemove))
	i := 0
	for k := range lineRemove {
		orderByKey[i] = k
		i++
	}
	remove := 0
	sort.Ints(orderByKey)
	for _, k := range orderByKey {
		if current > k {
			remove = lineRemove[k]
		} else {
			break
		}
	}
	current -= remove
	return current
}

func detectDockerLine(file *model.FileMetadata, searchKey string, logWithFields *zerolog.Logger, outputLines int) vulnerabilityLines {
	text := strings.ReplaceAll(file.OriginalData, "\r", "")
	lines := prepareDockerFileLines(text)
	curLineRes := detectCurlLine{
		foundRes: false,
		lineRes:  0,
		breakRes: false,
	}
	var extractedString [][]string
	extractedString = getBracketValues(searchKey, extractedString, "")
	sKey := searchKey
	for idx, str := range extractedString {
		sKey = strings.Replace(sKey, str[0], `{{`+strconv.Itoa(idx)+`}}`, -1)
	}

	for _, key := range strings.Split(sKey, ".") {
		substr1, substr2 := generateSubstrings(key, extractedString)

		curLineRes = curLineRes.detectCurrentLine(lines, substr1, substr2, false, nil, -1)

		if curLineRes.breakRes {
			break
		}
	}

	if curLineRes.foundRes {
		return vulnerabilityLines{
			line:     curLineRes.lineRes + 1,
			vulnLine: getAdjacentLines(curLineRes.lineRes, outputLines, strings.Split(text, "\n")),
		}
	}

	logWithFields.Warn().Msgf("Failed to detect Docker line, query response %s", searchKey)

	return vulnerabilityLines{
		line:     UndetectedVulnerabilityLine,
		vulnLine: model.VulnLines{},
	}
}

func detectLine(file *model.FileMetadata, searchKey string, logWithFields *zerolog.Logger, outputLines int) vulnerabilityLines {
	text := strings.ReplaceAll(file.OriginalData, "\r", "")
	lines := strings.Split(text, "\n")
	curLineRes := detectCurlLine{
		foundRes: false,
		lineRes:  0,
		breakRes: false,
	}
	var extractedString [][]string
	extractedString = getBracketValues(searchKey, extractedString, "")
	sanitizedSubstring := searchKey
	for idx, str := range extractedString {
		sanitizedSubstring = strings.Replace(sanitizedSubstring, str[0], `{{`+strconv.Itoa(idx)+`}}`, -1)
	}

	for _, key := range strings.Split(sanitizedSubstring, ".") {
		substr1, substr2 := generateSubstrings(key, extractedString)

		curLineRes = curLineRes.detectCurrentLine(lines, substr1, substr2, false, nil, -1)

		if curLineRes.breakRes {
			break
		}
	}

	if curLineRes.foundRes {
		return vulnerabilityLines{
			line:                 curLineRes.lineRes + 1,
			vulnLine:             getAdjacentLines(curLineRes.lineRes, outputLines, lines),
			lineWithVulnerabilty: lines[curLineRes.lineRes],
		}
	}

	logWithFields.Warn().Msgf("Failed to detect line, query response %s", searchKey)

	return vulnerabilityLines{
		line:     UndetectedVulnerabilityLine,
		vulnLine: model.VulnLines{},
	}
}

// getAdjacent is used to get the lines adjecent to the line that contains the vulnerability
// adj is the amount of lines wanted
func getAdjacentLines(idx, adj int, lines []string) model.VulnLines {
	var endPos int
	var startPos int
	if adj <= len(lines) {
		endPos = idx + adj/2 + 1 // if adj lines passes the number of lines in file
		if len(lines) < endPos {
			endPos = len(lines)
		}
		startAdj := adj
		if adj%2 == 0 {
			startAdj--
		}

		startPos = idx - startAdj/2 // if adj lines passes the first line in the file
		if startPos < 0 {
			startPos = 0
		}
	} else { // in case adj is bigger than number of lines in file
		adj = len(lines)
		endPos = len(lines)
		startPos = 0
	}

	switch idx {
	case 0:
		return model.VulnLines{ // case vulnerability is the first line of the file
			Positions: generatePosArr(adj, 1),
			Lines:     lines[:adj],
		}
	case len(lines) - 1: // case vulnerability is the last line of the file
		return model.VulnLines{
			Positions: generatePosArr(adj, startPos+1),
			Lines:     lines[len(lines)-adj:],
		}
	default:
		return model.VulnLines{ // case vulnerability is in the midle of the file
			Positions: generatePosArr(adj, startPos+1),
			Lines:     lines[startPos:endPos],
		}
	}
}

// generatePosArr is the function that will  generate the array that contains the lines numbers
// used to alter the color of the line that contains the vulnerability
func generatePosArr(adj, start int) []int {
	posArr := make([]int, adj)
	for i := 0; i < adj; i++ {
		posArr[i] = start
		start++
	}
	return posArr
}

func generateSubstrings(key string, extractedString [][]string) (substr1Res, substr2Res string) {
	var substr1, substr2 string
	if parts := nameRegex.FindStringSubmatch(key); len(parts) == namePartsLength {
		substr1, substr2 = getKeyWithCurlyBrackets(key, extractedString, parts)
	} else if parts := strings.Split(key, "="); len(parts) == valuePartsLength {
		substr1, substr2 = getKeyWithCurlyBrackets(key, extractedString, parts)
	} else {
		parts := []string{key, ""}
		substr1, substr2 = getKeyWithCurlyBrackets(key, extractedString, parts)
	}
	return substr1, substr2
}

func selectLineWithMinimumDistance(distances map[int]int, startingFrom int) int {
	minDistance, lineOfMinDistance := 1000000000000, startingFrom
	for line, distance := range distances {
		if distance < minDistance || distance == minDistance && line < lineOfMinDistance {
			minDistance = distance
			lineOfMinDistance = line
		}
	}

	return lineOfMinDistance
}

func extractLineFragment(line, substr string, key bool) string {
	// If detecting line by keys only
	if key {
		return line[:strings.Index(line, ":")]
	}
	start := strings.Index(line, substr)
	end := start + len(substr)

	for start >= 0 {
		if line[start] == ' ' {
			break
		}

		start--
	}

	for end < len(line) {
		if line[end] == ' ' {
			break
		}

		end++
	}

	result := line[start+1 : end]
	// workaround for selecting yaml keys
	if result[len(result)-1] == ':' {
		end--
	}
	return line[start+1 : end]
}

func mustMapKeyToString(m map[string]interface{}, key string) *string {
	res, err := mapKeyToString(m, key, true)
	if err != nil && key != "value" {
		log.Warn().
			Str("reason", err.Error()).
			Msgf("Failed to get key %s in map", key)
	}

	return res
}

func mapKeyToString(m map[string]interface{}, key string, allowNil bool) (*string, error) {
	v, ok := m[key]
	if !ok {
		return nil, fmt.Errorf("key '%s' not found in map", key)
	}

	switch vv := v.(type) {
	case json.Number:
		return stringToPtrString(vv.String()), nil
	case string:
		return stringToPtrString(vv), nil
	case int, int32, int64:
		return stringToPtrString(fmt.Sprintf("%d", vv)), nil
	case float32:
		return stringToPtrString(strconv.FormatFloat(float64(vv), 'f', -1, 64)), nil
	case float64:
		return stringToPtrString(strconv.FormatFloat(vv, 'f', -1, 64)), nil
	case nil:
		if allowNil {
			return nil, nil
		}
		return stringToPtrString("null"), nil
	case bool:
		return stringToPtrString(fmt.Sprintf("%v", vv)), nil
	}

	log.Debug().
		Msg("Detecting line. can't format item to string")

	if allowNil {
		return nil, nil
	}

	return stringToPtrString(""), nil
}

func stringToPtrString(v string) *string {
	return &v
}

func ptrStringToString(v *string) string {
	if v == nil {
		return ""
	}
	return *v
}

func getKeyWithCurlyBrackets(key string, extractedString [][]string, parts []string) (substr1Res, substr2Res string) {
	var substr1, substr2 string
	extractedPart := nameRegexDocker.FindStringSubmatch(key)
	if len(extractedPart) == valuePartsLength {
		for idx, key := range parts {
			if extractedPart[0] == key {
				switch idx {
				case (len(parts) - 2):
					i, _ := strconv.Atoi(extractedPart[1])
					substr1 = extractedString[i][1]
				case len(parts) - 1:
					i, _ := strconv.Atoi(extractedPart[1])
					substr2 = extractedString[i][1]
				}
			} else {
				substr1 = generateSubstr(substr1, parts, 2)
				substr2 = generateSubstr(substr2, parts, 1)
			}
		}
	} else {
		substr1 = parts[len(parts)-2]
		substr2 = parts[len(parts)-1]
	}

	return substr1, substr2
}

func generateSubstr(substr string, parts []string, leng int) string {
	if substr == "" {
		substr = parts[len(parts)-leng]
	}
	return substr
}

func prepareDockerFileLines(text string) []string {
	textSplit := strings.Split(text, "\n")
	for idx, key := range textSplit {
		textSplit[idx] = multiLineSpliter(textSplit, key, idx)
	}
	return textSplit
}

func (d detectCurlLine) detectCurrentLine(lines []string, str1,
	str2 string, byKey bool, idInfo map[int]interface{}, id int) detectCurlLine {
	distances := make(map[int]int)
	for i := d.lineRes; i < len(lines); i++ {
		if str1 != "" && str2 != "" {
			if strings.Contains(lines[i], str1) && strings.Contains(lines[i], str2) {
				distances[i] = levenshtein.ComputeDistance(extractLineFragment(lines[i], str2, byKey), str2)
			}
		} else if str1 != "" {
			if strings.Contains(lines[i], str1) {
				distances[i] = levenshtein.ComputeDistance(extractLineFragment(strings.TrimSpace(lines[i]), str1, byKey), str1)
			}
		}
	}

	lastSingle := d.lastUnique.lastUniqueLine

	if len(distances) == 0 {
		return detectCurlLine{
			foundRes: d.foundRes,
			lineRes:  d.lineRes,
			breakRes: true,
			lastUnique: dupHistory{
				lastUniqueLine: lastSingle,
				unique:         d.lastUnique.unique,
			},
		}
	}

	lineResponse := selectLineWithMinimumDistance(distances, d.lineRes)
	// if lineResponse is unique
	unique := detectLastSingle(lineResponse, distances, idInfo, id)
	if unique {
		lastSingle = lineResponse
	}

	return detectCurlLine{
		foundRes: true,
		lineRes:  lineResponse,
		breakRes: false,
		lastUnique: dupHistory{
			unique:         unique,
			lastUniqueLine: lastSingle,
		},
	}
}

// detectLastSingle checks if the line is unique or a duplicate
func detectLastSingle(line int, dis map[int]int, idInfo map[int]interface{}, id int) bool {
	if idInfo == nil {
		return true
	}
	for key, value := range dis {
		if value == dis[line] && key != line {
			// check if we are only looking at original data equivalent to the vulnerability
			if ok := idInfo[id].(map[int]int)[key]; ok != 0 {
				return false
			}
		}
	}
	return true
}

func multiLineSpliter(textSplit []string, key string, idx int) string {
	if nameRegexDockerFileML.MatchString(key) {
		i := idx + 1
		for textSplit[i] == "" {
			i++
		}
		textSplit[idx] = strings.ReplaceAll(textSplit[idx], " \\", " "+textSplit[i])
		textSplit[i] = ""
		textSplit[idx] = multiLineSpliter(textSplit, textSplit[idx], idx)
	}
	return textSplit[idx]
}

// getBracketValues gets values inside "{{ }}" ignoring any "{{" or "}}" inside
func getBracketValues(expr string, list [][]string, restOfString string) [][]string {
	var tempList []string
	firstOpen := strings.Index(expr, "{{")
	firstClose := strings.Index(expr, "}}")
	switchVal := firstClose - firstOpen
	if switchVal == 0 { // if there is no "{{" and no "}}"
		if expr != "" {
			tempList = append(tempList, fmt.Sprintf("{{%s}}", expr), expr)
			list = append(list, tempList)
		}
		if restOfString == "" {
			return list // if there is no more string to read from return value of list
		}
		list = getBracketValues(restOfString, list, "") // recursive call to the rest of the string
	} else if switchVal > 0 { // if the position of  the first "}}" is bigger than than the position of "{{"
		list = getBracketValues(expr[firstOpen+2:firstClose], list, expr[firstClose+2:]) // recursive with the value inside of curly brackets
	} else { // if the position of  the first "{{" is bigger than than the position of "}}"
		nextClose := strings.Index(restOfString, "}}")
		tempList = append(tempList, fmt.Sprintf("{{%s%s}}", expr, restOfString[nextClose:]), fmt.Sprintf("%s%s", expr, restOfString[nextClose:]))
		list = append(list, tempList)
		list = getBracketValues(restOfString[nextClose+2:], list, "") // recursive call to the rest of the string
	}
	return list
}
