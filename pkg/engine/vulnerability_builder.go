package engine

import (
	"encoding/json"
	"strings"

	dec "github.com/Checkmarx/kics/v2/pkg/detector"
	"github.com/Checkmarx/kics/v2/pkg/engine/similarity"
	"github.com/Checkmarx/kics/v2/pkg/model"
	"github.com/pkg/errors"
	"github.com/rs/zerolog"
	"github.com/rs/zerolog/log"
)

const (
	formatFloat64   = 64
	searchKeyMinLen = 3
)

func modifyVulSearchKeyReference(doc interface{}, originalSearchKey string, stringVulList []string) (string, bool) {
	for index, vulSplit := range stringVulList {
		switch docTyped := doc.(type) {
		case map[string]interface{}:
			if strings.HasPrefix(vulSplit, "{{") && strings.HasSuffix(vulSplit, "}}") {
				vulSplit = vulSplit[2 : len(vulSplit)-2]
			}
			if vulSplitEqual := strings.Split(vulSplit, "="); len(vulSplitEqual) != 1 {
				vulSplit = vulSplitEqual[0]
			}
			newDoc, foundEntry := docTyped[vulSplit]
			if metadataRefDoc, ok := docTyped["RefMetadata"]; ok && foundEntry && index < len(stringVulList) {
				newSearchKey := strings.Join(stringVulList[:index], ".") + ".$ref=" + (metadataRefDoc.(map[string]interface{})["$ref"].(string))
				return newSearchKey, true
			} else if foundEntry {
				doc = newDoc
			} else {
				return originalSearchKey, false
			}
		case []interface{}:
			for _, listDoc := range docTyped {
				if newSearchKey, modified := modifyVulSearchKeyReference(listDoc, originalSearchKey, stringVulList[index:]); modified {
					return strings.Join(stringVulList[:index], ".") + "." + newSearchKey, true
				}
			}
			return originalSearchKey, false
		default:
			if index != len(stringVulList)-1 {
				return originalSearchKey, false
			}
		}
	}
	return originalSearchKey, false
}

// DefaultVulnerabilityBuilder defines a vulnerability builder to execute default actions of scan
var DefaultVulnerabilityBuilder = func(ctx *QueryContext,
	tracker Tracker,
	v interface{},
	detector *dec.DetectLine,
	useOldSeverities bool,
	kicsComputeNewSimID bool) (*model.Vulnerability, error) {
	vObj, ok := v.(map[string]interface{})
	if !ok {
		return &model.Vulnerability{}, ErrInvalidResult
	}

	vObj = mergeWithMetadata(vObj, ctx.Query.Metadata.Metadata)

	var err error
	var output []byte

	output, err = json.Marshal(vObj)
	if err != nil {
		return &model.Vulnerability{}, errors.Wrap(err, "failed to marshall query output")
	}

	var fileID *string

	fileID, err = mapKeyToString(vObj, "documentId", false)
	if err != nil {
		return &model.Vulnerability{}, errors.Wrap(err, "failed to recognize file id")
	}

	file, ok := ctx.Files[*fileID]
	if !ok {
		return &model.Vulnerability{}, errors.New("failed to find file from query response")
	}

	logWithFields := log.With().
		Str("scanID", ctx.scanID).
		Str("fileName", file.FilePath).
		Str("queryName", ctx.Query.Metadata.Query).
		Logger()

	detector.SetupLogs(&logWithFields)

	linesVulne := model.VulnerabilityLines{
		Line:      -1,
		VulnLines: &[]model.CodeLine{},
	}

	similarityIDLineInfo := ""
	searchKey := ""
	if s, ok := vObj["searchKey"]; ok {
		searchKey = s.(string)
		similarityIDLineInfo = searchKey
		intDoc := file.LineInfoDocument
		vulsSplit := strings.Split(searchKey, ".")

		if file.Kind == model.KindINI {
			vulsSplit, searchKey = sanitizeINIKey(vulsSplit)
		}

		if strings.Contains(vulsSplit[len(vulsSplit)-1], "RefMetadata") {
			return &model.Vulnerability{}, ErrNoResult
		}

		// modify the search key in cases where it should be referencing a ref instead of part of the resolved object
		searchKey, _ = modifyVulSearchKeyReference(intDoc, searchKey, vulsSplit)
		vObj["searchKey"] = searchKey
		linesVulne = detector.DetectLine(&file, searchKey, &logWithFields)
	} else {
		logWithFields.Error().Msg("Saving result. failed to detect line")
	}

	lineNumber := 0
	var similarityIDLineInfoOld = similarityIDLineInfo
	if file.Kind != model.KindHELM && len(file.ResolvedFiles) == 0 {
		searchLineCalc := &searchLineCalculator{
			lineNr:               -1,
			vObj:                 vObj,
			file:                 file,
			detector:             detector,
			similarityIDLineInfo: similarityIDLineInfo,
			linesVulne:           linesVulne,
		}
		// calculate search Line if possible (default uses values of search key)
		lineNumber, similarityIDLineInfoOld, linesVulne = calculeSearchLine(searchLineCalc)
	}

	if linesVulne.Line == -1 {
		logWithFields.Warn().Msgf("Failed to detect line, query response %s", searchKey)
		linesVulne.Line = 1
	}

	searchValue := ""
	if s, ok := vObj["searchValue"]; ok {
		searchValue = s.(string)
	}

	overrideKey := ""
	if s, ok := vObj["overrideKey"]; ok {
		overrideKey = s.(string)
	}

	queryID := getStringFromMap("id", DefaultQueryID, overrideKey, vObj, &logWithFields)

	severity := getResolvedSeverity(vObj, &logWithFields, overrideKey, useOldSeverities)

	issueType := DefaultIssueType
	if v := mustMapKeyToString(vObj, "issueType"); v != nil {
		issueType = model.IssueType(*v)
	}

	similarityID, oldSimilarityID := generateSimilaritiesID(ctx, linesVulne.ResolvedFile, queryID, similarityIDLineInfo, searchValue,
		searchKey, similarityIDLineInfoOld, kicsComputeNewSimID, &logWithFields, tracker)

	return &model.Vulnerability{
		ID:               0,
		SimilarityID:     PtrStringToString(similarityID),
		OldSimilarityID:  PtrStringToString(oldSimilarityID),
		ScanID:           ctx.scanID,
		FileID:           file.ID,
		FileName:         linesVulne.ResolvedFile,
		QueryName:        getStringFromMap("queryName", DefaultQueryName, overrideKey, vObj, &logWithFields),
		QueryID:          queryID,
		Experimental:     getBoolFromMap("experimental", DefaultExperimental, overrideKey, vObj, &logWithFields),
		QueryURI:         getStringFromMap("descriptionUrl", DefaultQueryURI, overrideKey, vObj, &logWithFields),
		Category:         getStringFromMap("category", "", overrideKey, vObj, &logWithFields),
		Description:      getStringFromMap("descriptionText", "", overrideKey, vObj, &logWithFields),
		DescriptionID:    getStringFromMap("descriptionID", DefaultQueryDescriptionID, overrideKey, vObj, &logWithFields),
		Severity:         severity,
		Platform:         getStringFromMap("platform", "", overrideKey, vObj, &logWithFields),
		CWE:              getStringFromMap("cwe", "", overrideKey, vObj, &logWithFields),
		Line:             linesVulne.Line,
		VulnLines:        linesVulne.VulnLines,
		ResourceType:     PtrStringToString(mustMapKeyToString(vObj, "resourceType")),
		ResourceName:     PtrStringToString(mustMapKeyToString(vObj, "resourceName")),
		IssueType:        issueType,
		SearchKey:        searchKey,
		SearchLine:       lineNumber,
		SearchValue:      searchValue,
		KeyExpectedValue: PtrStringToString(mustMapKeyToString(vObj, "keyExpectedValue")),
		KeyActualValue:   PtrStringToString(mustMapKeyToString(vObj, "keyActualValue")),
		Value:            mustMapKeyToString(vObj, "value"),
		Output:           string(output),
		CloudProvider:    getCloudProvider(overrideKey, vObj, &logWithFields),
		Remediation:      PtrStringToString(mustMapKeyToString(vObj, "remediation")),
		RemediationType:  PtrStringToString(mustMapKeyToString(vObj, "remediationType")),
	}, nil
}

// <editor-fold desc="similarity id">
func generateSimilaritiesID(ctx *QueryContext,
	resolvedFile, queryID, similarityIDLineInfo, searchValue, searchKey, similarityIDLineInfoOld string,
	kicsComputeNewSimID bool,
	logWithFields *zerolog.Logger,
	tracker Tracker) (similarityID, oldSimilarityID *string) {
	if kicsComputeNewSimID {
		similarityID, err := buildSimilarityID(ctx, resolvedFile, queryID, similarityIDLineInfo, searchValue)
		if err != nil {
			logWithFields.Err(err).Send()
			tracker.FailedComputeSimilarityID()
		}

		oldSimilarityID, err = oldBuildSimilarityID(ctx, resolvedFile, queryID, searchKey, similarityIDLineInfoOld, searchValue)
		if err != nil {
			logWithFields.Err(err).Send()
			tracker.FailedComputeOldSimilarityID()
		}
		return similarityID, oldSimilarityID
	} else {
		similarityID, err := oldBuildSimilarityID(ctx, resolvedFile, queryID, searchKey, similarityIDLineInfoOld, searchValue)
		if err != nil {
			logWithFields.Err(err).Send()
			tracker.FailedComputeSimilarityID()
		}
		return similarityID, oldSimilarityID
	}
}

func buildSimilarityID(
	ctx *QueryContext,
	resolvedFile,
	queryID,
	searchKey,
	searchValue string) (*string, error) {
	return similarity.ComputeSimilarityID(ctx.BaseScanPaths, resolvedFile, queryID, searchKey, searchValue)
}

// <editor-fold desc="old similarity id">
func oldBuildSimilarityID(
	ctx *QueryContext,
	resolvedFile,
	queryID,
	searchKey,
	similarityIDLineInfo,
	searchValue string) (*string, error) {
	if checkMinified(ctx, resolvedFile) {
		return similarity.ComputeSimilarityID(ctx.BaseScanPaths, resolvedFile, queryID, searchKey, searchValue)
	} else {
		return similarity.ComputeSimilarityID(ctx.BaseScanPaths, resolvedFile, queryID, similarityIDLineInfo, searchValue)
	}
}

func checkMinified(ctx *QueryContext, resolvedFile string) bool {
	for i := range ctx.Files {
		if ctx.Files[i].FilePath == resolvedFile {
			return ctx.Files[i].IsMinified
		}
	}
	return false
}

// </editor-fold>
// </editor-fold>

func getCloudProvider(overrideKey string, vObj map[string]interface{}, logWithFields *zerolog.Logger) string {
	cloudProvider := ""
	if _, ok := vObj["cloudProvider"]; ok {
		cloudProvider = getStringFromMap("cloudProvider", "", overrideKey, vObj, logWithFields)
	}
	return cloudProvider
}

// calculate search Line if possible (default uses values of search key)
func calculeSearchLine(searchLineCalc *searchLineCalculator) (lineNumber int,
	similarityIDLineInfo string, linesVulne model.VulnerabilityLines) {
	searchLineCalc.calculate()
	lineNumber = searchLineCalc.lineNr
	similarityIDLineInfo = searchLineCalc.similarityIDLineInfo
	linesVulne = searchLineCalc.linesVulne

	return lineNumber, similarityIDLineInfo, linesVulne
}

func getResolvedSeverity(vObj map[string]interface{}, logWithFields *zerolog.Logger,
	overrideKey string, useOldSeverities bool) model.Severity {
	var severity model.Severity = model.SeverityInfo
	s, err := mapKeyToString(vObj, "severity", false)

	if err == nil {
		sev := getSeverity(strings.ToUpper(*s))
		if sev == "" {
			logWithFields.Warn().Str("severity", *s).Msg("Saving result. invalid severity constant value")
		} else {
			severity = sev
			overrideValue := tryOverride(overrideKey, "severity", vObj)
			if overrideValue != nil {
				sev = getSeverity(strings.ToUpper(*overrideValue))
				if sev != "" {
					severity = sev
				}
			} else if useOldSeverities {
				oldS, errOld := mapKeyToString(vObj, "oldSeverity", false)
				if errOld == nil {
					oldSev := getSeverity(strings.ToUpper(*oldS))
					severity = oldSev
				}
			}
		}
	} else {
		logWithFields.Info().Msg("Saving result. failed to detect severity")
	}

	return severity
}

// sanitizeINIKey removes useless searchkey elements like "all" and "children"
func sanitizeINIKey(vulsSplit []string) (vulsRefact []string, searchKey string) {
	length := len(vulsSplit)
	vulsRefact = vulsSplit
	if length >= searchKeyMinLen {
		vulsRefact = []string{"[" + vulsSplit[2] + "]"}

		if length >= searchKeyMinLen+2 {
			vulsRefact = append(vulsRefact, vulsSplit[4])

			if length >= searchKeyMinLen+4 {
				vulsRefact = append(vulsRefact, vulsSplit[6])
			}
		}
	}
	return vulsRefact, strings.Join(vulsRefact, ".")
}
