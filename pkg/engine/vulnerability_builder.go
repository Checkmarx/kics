package engine

import (
	"encoding/json"
	"strings"

	dec "github.com/Checkmarx/kics/pkg/detector"
	"github.com/Checkmarx/kics/pkg/engine/similarity"
	"github.com/Checkmarx/kics/pkg/model"
	"github.com/pkg/errors"
	"github.com/rs/zerolog"
	"github.com/rs/zerolog/log"
)

const (
	formatFloat64 = 64
)

// DefaultVulnerabilityBuilder defines a vulnerability builder to execute default actions of scan
var DefaultVulnerabilityBuilder = func(ctx *QueryContext, tracker Tracker,
	v interface{}, detector *dec.DetectLine) (model.Vulnerability, error) {
	vObj, ok := v.(map[string]interface{})
	if !ok {
		return model.Vulnerability{}, ErrInvalidResult
	}

	vObj = mergeWithMetadata(vObj, ctx.query.metadata.Metadata)

	var err error
	var output []byte

	output, err = json.Marshal(vObj)
	if err != nil {
		return model.Vulnerability{}, errors.Wrap(err, "failed to marshall query output")
	}

	var fileID *string

	fileID, err = mapKeyToString(vObj, "documentId", false)
	if err != nil {
		return model.Vulnerability{}, errors.Wrap(err, "failed to recognize file id")
	}

	file, ok := ctx.files[*fileID]
	if !ok {
		return model.Vulnerability{}, errors.New("failed to find file from query response")
	}

	logWithFields := log.With().
		Str("scanID", ctx.scanID).
		Str("fileName", file.FilePath).
		Str("queryName", ctx.query.metadata.Query).
		Logger()

	detector.SetupLogs(&logWithFields)

	linesVulne := model.VulnerabilityLines{
		Line:      -1,
		VulnLines: []model.CodeLine{},
	}

	similarityIDLineInfo := ""
	searchKey := ""
	if s, ok := vObj["searchKey"]; ok {
		searchKey = s.(string)
		similarityIDLineInfo = searchKey
		linesVulne = detector.DetectLine(&file, searchKey)
	} else {
		logWithFields.Error().Msg("Saving result. failed to detect line")
	}

	lineNumber := 0
	if file.Kind != model.KindHELM {
		searchLineCalc := &searchLineCalculator{
			lineNr:               -1,
			vObj:                 vObj,
			file:                 file,
			detector:             detector,
			similarityIDLineInfo: similarityIDLineInfo,
			linesVulne:           linesVulne,
		}
		// calculate search Line if possible (default uses values of search key)
		lineNumber, similarityIDLineInfo, linesVulne = calculeSearchLine(searchLineCalc)
	}

	if linesVulne.Line == -1 {
		logWithFields.Warn().Msgf("Failed to detect line, query response %s", searchKey)
		linesVulne.Line = 1
	}

	searchValue := ""
	if s, ok := vObj["searchValue"]; ok {
		searchValue = s.(string)
	}

	overrideKey := ""
	if s, ok := vObj["overrideKey"]; ok {
		overrideKey = s.(string)
	}

	queryID := getStringFromMap("id", DefaultQueryID, overrideKey, vObj, &logWithFields)

	severity := getResolvedSeverity(vObj, &logWithFields, overrideKey)

	issueType := DefaultIssueType
	if v := mustMapKeyToString(vObj, "issueType"); v != nil {
		issueType = model.IssueType(*v)
	}

	var similarityID *string

	similarityID, err = similarity.ComputeSimilarityID(ctx.baseScanPaths, file.FilePath, queryID, similarityIDLineInfo, searchValue)
	if err != nil {
		logWithFields.Err(err).Send()
		tracker.FailedComputeSimilarityID()
	}

	platform := getStringFromMap("platform", "", overrideKey, vObj, &logWithFields)

	return model.Vulnerability{
		ID:               0,
		SimilarityID:     PtrStringToString(similarityID),
		ScanID:           ctx.scanID,
		FileID:           file.ID,
		FileName:         file.FilePath,
		QueryName:        getStringFromMap("queryName", DefaultQueryName, overrideKey, vObj, &logWithFields),
		QueryID:          queryID,
		QueryURI:         getStringFromMap("descriptionUrl", DefaultQueryURI, overrideKey, vObj, &logWithFields),
		Category:         getStringFromMap("category", "", overrideKey, vObj, &logWithFields),
		Description:      getStringFromMap("descriptionText", "", overrideKey, vObj, &logWithFields),
		DescriptionID:    getStringFromMap("descriptionID", DefaultQueryDescriptionID, overrideKey, vObj, &logWithFields),
		Severity:         severity,
		Platform:         getStringFromMap("platform", "", overrideKey, vObj, &logWithFields),
		Line:             linesVulne.Line,
		VulnLines:        linesVulne.VulnLines,
		ResourceType:     PtrStringToString(mustMapKeyToString(vObj, "resourceType")),
		ResourceName:     PtrStringToString(mustMapKeyToString(vObj, "resourceName")),
		IssueType:        issueType,
		SearchKey:        searchKey,
		SearchLine:       lineNumber,
		SearchValue:      searchValue,
		KeyExpectedValue: PtrStringToString(mustMapKeyToString(vObj, "keyExpectedValue")),
		KeyActualValue:   PtrStringToString(mustMapKeyToString(vObj, "keyActualValue")),
		Value:            mustMapKeyToString(vObj, "value"),
		Output:           string(output),
		CloudProvider:    getCloudProvider(platform, overrideKey, vObj, &logWithFields),
	}, nil
}

func getCloudProvider(platform, overrideKey string, vObj map[string]interface{}, logWithFields *zerolog.Logger) string {
	cloudProvider := ""
	if platform == "Terraform" || platform == "CloudFormation" || platform == "Ansible" {
		cloudProvider = getStringFromMap("cloudProvider", "", overrideKey, vObj, logWithFields)
	}

	return cloudProvider
}

// calculate search Line if possible (default uses values of search key)
func calculeSearchLine(searchLineCalc *searchLineCalculator) (lineNumber int,
	similarityIDLineInfo string, linesVulne model.VulnerabilityLines) {
	searchLineCalc.calculate()
	lineNumber = searchLineCalc.lineNr
	similarityIDLineInfo = searchLineCalc.similarityIDLineInfo
	linesVulne = searchLineCalc.linesVulne

	return lineNumber, similarityIDLineInfo, linesVulne
}

func getResolvedSeverity(vObj map[string]interface{}, logWithFields *zerolog.Logger, overrideKey string) model.Severity {
	var severity model.Severity = model.SeverityInfo
	s, err := mapKeyToString(vObj, "severity", false)
	if err == nil {
		sev := getSeverity(strings.ToUpper(*s))
		if sev == "" {
			logWithFields.Warn().Str("severity", *s).Msg("Saving result. invalid severity constant value")
		} else {
			severity = sev
			overrideValue := tryOverride(overrideKey, "severity", vObj)
			if overrideValue != nil {
				sev = getSeverity(strings.ToUpper(*overrideValue))
				if sev != "" {
					severity = sev
				}
			}
		}
	} else {
		logWithFields.Info().Msg("Saving result. failed to detect severity")
	}

	return severity
}
