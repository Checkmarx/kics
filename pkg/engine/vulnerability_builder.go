package engine

import (
	"crypto/sha256"
	"encoding/hex"
	"encoding/json"
	"fmt"
	"path/filepath"
	"regexp"
	"strconv"
	"strings"

	"github.com/Checkmarx/kics/pkg/model"
	"github.com/agnivade/levenshtein"
	"github.com/pkg/errors"
	"github.com/rs/zerolog/log"
)

var (
	nameRegex             = regexp.MustCompile(`^([A-Za-z0-9-_]+)\[([A-Za-z0-9-_{}]+)]$`)
	nameRegexDocker       = regexp.MustCompile(`{{(.*?)}}`)
	nameRegexDockerFileML = regexp.MustCompile(`.+\s+\\$`)
)

const (
	namePartsLength  = 3
	valuePartsLength = 2
)

var DefaultVulnerabilityBuilder = func(ctx QueryContext, v interface{}) (model.Vulnerability, error) {
	vOjb, ok := v.(map[string]interface{})
	if !ok {
		return model.Vulnerability{}, ErrInvalidResult
	}

	vOjb = mergeWithMetadata(vOjb, ctx.query.metadata.Metadata)

	var err error
	var output []byte

	output, err = json.Marshal(vOjb)
	if err != nil {
		return model.Vulnerability{}, errors.Wrap(err, "failed to marshall query output")
	}

	var fileID *string

	fileID, err = mapKeyToString(vOjb, "documentId", false)
	if err != nil {
		return model.Vulnerability{}, errors.Wrap(err, "failed to recognize file id")
	}

	file, ok := ctx.files[*fileID]
	if !ok {
		return model.Vulnerability{}, errors.New("failed to find file from query response")
	}

	logWithFields := log.With().
		Str("scanID", ctx.scanID).
		Str("fileID", file.ID).
		Str("queryName", ctx.query.metadata.Query).
		Logger()

	line := UndetectedVulnerabilityLine
	searchKey := ""
	if s, ok := vOjb["searchKey"]; ok {
		searchKey = s.(string)
		if file.Kind == model.KindDOCKER {
			line = detectDockerLine(ctx, &file, searchKey)
		} else {
			line = detectLine(ctx, &file, searchKey)
		}
	} else {
		logWithFields.Warn().Msg("saving result. failed to detect line")
	}

	queryName := DefaultQueryName

	var qn *string

	if qn, err = mapKeyToString(vOjb, "queryName", false); err == nil {
		queryName = *qn
	} else {
		logWithFields.Warn().Msg("saving result. failed to detect query name")
	}

	queryID := DefaultQueryID

	if qn, err = mapKeyToString(vOjb, "id", false); err == nil {
		queryID = *qn
	} else {
		logWithFields.Warn().Msg("saving result. failed to detect query id")
	}

	var severity model.Severity = model.SeverityInfo
	var s *string

	if s, err = mapKeyToString(vOjb, "severity", false); err == nil {
		su := strings.ToUpper(*s)
		var found bool
		for _, si := range model.AllSeverities {
			if su == string(si) {
				severity = si
				found = true
				break
			}
		}

		if !found {
			logWithFields.Warn().Str("severity", *s).Msg("saving result. invalid severity constant value")
		}
	} else {
		logWithFields.Info().Msg("saving result. failed to detect severity")
	}

	issueType := DefaultIssueType
	if v := mustMapKeyToString(vOjb, "issueType"); v != nil {
		issueType = model.IssueType(*v)
	}

	var similarityID *string

	similarityID, err = computeSimilarityID(file.FileName, queryID, searchKey)
	if err != nil {
		return model.Vulnerability{}, err
	}

	return model.Vulnerability{
		ID:               0,
		SimilarityID:     ptrStringToString(similarityID),
		ScanID:           ctx.scanID,
		FileID:           file.ID,
		FileName:         file.FileName,
		QueryName:        queryName,
		QueryID:          queryID,
		Severity:         severity,
		Line:             line,
		IssueType:        issueType,
		SearchKey:        searchKey,
		KeyExpectedValue: ptrStringToString(mustMapKeyToString(vOjb, "keyExpectedValue")),
		KeyActualValue:   ptrStringToString(mustMapKeyToString(vOjb, "keyActualValue")),
		Value:            mustMapKeyToString(vOjb, "value"),
		Output:           string(output),
	}, nil
}

func computeSimilarityID(filePath, queryID, searchKey string) (*string, error) {
	standarizedPath, err := standarizeFilePath(filePath)
	if err != nil {
		return nil, errors.Wrap(err, "Unable to compute similarity id")
	}

	var stringNode = standarizedPath + queryID + searchKey

	hashSum := sha256.Sum256([]byte(stringNode))

	return stringToPtrString(hex.EncodeToString(hashSum[:])), nil
}

func standarizeFilePath(path string) (string, error) {
	cleanPath := filepath.Clean(path)
	standardPath := filepath.ToSlash(cleanPath)
	if filepath.IsAbs(standardPath) {
		return "", errors.New("illegal absolute path to file")
	}
	return standardPath, nil
}

func mergeWithMetadata(base, additional map[string]interface{}) map[string]interface{} {
	for k, v := range additional {
		if _, ok := base[k]; ok {
			continue
		}

		base[k] = v
	}

	return base
}

func detectDockerLine(ctx QueryContext, file *model.FileMetadata, searchKey string) int {
	text := strings.ReplaceAll(file.OriginalData, "\r", "")
	lines := prepareDockerFileLines(text)
	isBreak := false
	foundAtLeastOne := false
	currentLine := 0
	extractedString := nameRegexDocker.FindAllStringSubmatch(searchKey, -1)
	test := searchKey
	for idx, str := range extractedString {
		test = strings.Replace(test, str[0], `{{`+strconv.Itoa(idx)+`}}`, -1)
	}

	for _, key := range strings.Split(test, ".") {
		var substr1, substr2 string
		if parts := nameRegex.FindStringSubmatch(key); len(parts) == namePartsLength {
			substr1, substr2 = getKeyWithCurlyBrackets(key, extractedString, parts)
		} else if parts := strings.Split(key, "="); len(parts) == valuePartsLength {
			substr1, substr2 = getKeyWithCurlyBrackets(key, extractedString, parts)
		} else {
			parts := []string{key, ""}
			substr1, substr2 = getKeyWithCurlyBrackets(key, extractedString, parts)
		}

		foundAtLeastOne, currentLine, isBreak = detectCurrentLine(lines, substr1, substr2, currentLine, foundAtLeastOne)

		if isBreak {
			break
		}
	}

	if foundAtLeastOne {
		return currentLine + 1
	}

	log.Warn().
		Str("scanID", ctx.scanID).
		Str("fileID", file.ID).
		Msgf("failed to detect line, query response %s", searchKey)

	return UndetectedVulnerabilityLine
}

func detectLine(ctx QueryContext, file *model.FileMetadata, searchKey string) int {
	text := strings.ReplaceAll(file.OriginalData, "\r", "")
	lines := strings.Split(text, "\n")
	foundAtLeastOne := false
	currentLine := 0
	isBreak := false

	extractedString := nameRegexDocker.FindAllStringSubmatch(searchKey, -1)
	sanitizedSubstring := searchKey
	for idx, str := range extractedString {
		sanitizedSubstring = strings.Replace(sanitizedSubstring, str[0], `{{`+strconv.Itoa(idx)+`}}`, -1)
	}

	for _, key := range strings.Split(sanitizedSubstring, ".") {
		var substr1, substr2 string
		if parts := nameRegex.FindStringSubmatch(key); len(parts) == namePartsLength {
			substr1, substr2 = getKeyWithCurlyBrackets(key, extractedString, parts)
		} else if parts := strings.Split(key, "="); len(parts) == valuePartsLength {
			substr1, substr2 = getKeyWithCurlyBrackets(key, extractedString, parts)
		} else {
			parts := []string{key, ""}
			substr1, substr2 = getKeyWithCurlyBrackets(key, extractedString, parts)
		}

		foundAtLeastOne, currentLine, isBreak = detectCurrentLine(lines, substr1, substr2, currentLine, foundAtLeastOne)

		if isBreak {
			break
		}
	}

	if foundAtLeastOne {
		return currentLine + 1
	}

	log.Warn().
		Str("scanID", ctx.scanID).
		Str("fileID", file.ID).
		Msgf("failed to detect line, query response %s", searchKey)

	return UndetectedVulnerabilityLine
}

func selectLineWithMinimumDistance(distances map[int]int, startingFrom int) int {
	minDistance, lineOfMinDistance := 1000000000000, startingFrom
	for line, distance := range distances {
		if distance < minDistance {
			minDistance = distance
			lineOfMinDistance = line
		} else if distance == minDistance && line < lineOfMinDistance { // taking first line with minimum distance
			minDistance = distance
			lineOfMinDistance = line
		}
	}

	return lineOfMinDistance
}

func extractLineFragment(line, substr string) string {
	start := strings.Index(line, substr)
	end := start + len(substr)

	for start >= 0 {
		if line[start] == ' ' {
			break
		}

		start--
	}

	for end < len(line) {
		if line[end] == ' ' {
			break
		}

		end++
	}

	result := line[start+1 : end]
	// workaround for selecting yaml keys
	if result[len(result)-1] == ':' {
		end--
	}
	return line[start+1 : end]
}

func mustMapKeyToString(m map[string]interface{}, key string) *string {
	res, err := mapKeyToString(m, key, true)
	if err != nil && key != "value" {
		log.Warn().
			Str("reason", err.Error()).
			Msgf("failed to get key %s in map", key)
	}

	return res
}

func mapKeyToString(m map[string]interface{}, key string, allowNil bool) (*string, error) {
	v, ok := m[key]
	if !ok {
		return nil, fmt.Errorf("key '%s' not found in map", key)
	}

	switch vv := v.(type) {
	case json.Number:
		return stringToPtrString(vv.String()), nil
	case string:
		return stringToPtrString(vv), nil
	case int, int32, int64:
		return stringToPtrString(fmt.Sprintf("%d", vv)), nil
	case float32:
		return stringToPtrString(strconv.FormatFloat(float64(vv), 'f', -1, 64)), nil
	case float64:
		return stringToPtrString(strconv.FormatFloat(vv, 'f', -1, 64)), nil
	case nil:
		if allowNil {
			return nil, nil
		}
		return stringToPtrString("null"), nil
	case bool:
		return stringToPtrString(fmt.Sprintf("%v", vv)), nil
	}

	log.Debug().
		Msg("detecting line. can't format item to string")

	if allowNil {
		return nil, nil
	}

	return stringToPtrString(""), nil
}

func stringToPtrString(v string) *string {
	return &v
}

func ptrStringToString(v *string) string {
	if v == nil {
		return ""
	}
	return *v
}

func getKeyWithCurlyBrackets(key string, extractedString [][]string, parts []string) (substr1Res, substr2Res string) {
	var substr1, substr2 string
	extractedPart := nameRegexDocker.FindStringSubmatch(key)
	if len(extractedPart) == valuePartsLength {
		for idx, test := range parts {
			if extractedPart[0] == test {
				switch idx {
				case (len(parts) - 2):
					i, _ := strconv.Atoi(extractedPart[1])
					substr1 = extractedString[i][1]
				case len(parts) - 1:
					i, _ := strconv.Atoi(extractedPart[1])
					substr2 = extractedString[i][1]
				}
			} else {
				if substr1 == "" {
					substr1 = parts[len(parts)-2]
				}
				if substr2 == "" {
					substr2 = parts[len(parts)-1]
				}
			}
		}
	} else {
		substr1 = parts[len(parts)-2]
		substr2 = parts[len(parts)-1]
	}

	return substr1, substr2
}

func prepareDockerFileLines(text string) []string {
	textSplit := strings.Split(text, "\n")
	for idx, key := range textSplit {
		textSplit[idx] = multiLineSpliter(textSplit, key, idx)
	}
	return textSplit
}

func detectCurrentLine(lines []string, str1, str2 string, curLine int, foundOne bool) (foundRes bool, lineRes int, breakRes bool) {
	distances := make(map[int]int)
	for i := curLine; i < len(lines); i++ {
		if str1 != "" && str2 != "" {
			if strings.Contains(lines[i], str1) && strings.Contains(lines[i], str2) {
				distances[i] = levenshtein.ComputeDistance(extractLineFragment(lines[i], str2), str2)
			}
		} else if str1 != "" {
			if strings.Contains(lines[i], str1) {
				distances[i] = levenshtein.ComputeDistance(extractLineFragment(lines[i], str1), str1)
			}
		}
	}

	if len(distances) == 0 {
		return foundOne, curLine, true
	}

	return true, selectLineWithMinimumDistance(distances, curLine), false
}

func multiLineSpliter(textSplit []string, key string, idx int) string {
	if nameRegexDockerFileML.MatchString(key) {
		i := idx + 1
		for textSplit[i] == "" {
			i++
		}
		textSplit[idx] = strings.ReplaceAll(textSplit[idx], " \\", " "+textSplit[i])
		textSplit[i] = ""
		textSplit[idx] = multiLineSpliter(textSplit, textSplit[idx], idx)
	}
	return textSplit[idx]
}
