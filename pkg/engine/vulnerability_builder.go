package engine

import (
	"bufio"
	"encoding/json"
	"fmt"
	"regexp"
	"strconv"
	"strings"

	"github.com/checkmarxDev/ice/internal/logger"
	"github.com/checkmarxDev/ice/pkg/model"
	"github.com/pkg/errors"
)

var (
	nameRegex = regexp.MustCompile(`^([A-Za-z0-9-_]+)\[([A-Za-z0-9-_]+)]$`)
)

const (
	namePartsLength  = 3
	valuePartsLength = 2
)

var DefaultVulnerabilityBuilder = func(ctx QueryContext, v interface{}) (model.Vulnerability, error) {
	vOjb, ok := v.(map[string]interface{})
	if !ok {
		return model.Vulnerability{}, ErrInvalidResult
	}

	output, err := json.Marshal(vOjb)
	if err != nil {
		return model.Vulnerability{}, errors.Wrap(err, "failed to marshall query output")
	}

	fileID, err := mapKeyToString(ctx, vOjb, "documentId", false)
	if err != nil {
		return model.Vulnerability{}, errors.Wrap(err, "failed to recognize file id")
	}

	file, ok := ctx.files[*fileID]
	if !ok {
		return model.Vulnerability{}, errors.New("failed to find file from query response")
	}

	logWithFields := logger.GetLoggerWithFieldsFromContext(ctx.ctx).With().
		Str("scanID", ctx.scanID).
		Int("fileID", file.ID).
		Str("queryName", ctx.query.metadata.FileName).
		Logger()

	line := UndetectedVulnerabilityLine
	searchKey := ""
	if s, ok := vOjb["searchKey"]; ok {
		searchKey = s.(string)
		line = detectLine(ctx, &file, searchKey)
	} else {
		logWithFields.Warn().Msg("saving result. failed to detect line")
	}

	queryName := DefaultQueryName
	if qn, err := mapKeyToString(ctx, vOjb, "name", false); err == nil {
		queryName = *qn
	} else {
		logWithFields.Warn().Msg("saving result. failed to detect query name")
	}

	queryID := DefaultQueryID
	if qn, err := mapKeyToString(ctx, vOjb, "id", false); err == nil {
		queryID = *qn
	} else {
		logWithFields.Warn().Msg("saving result. failed to detect query id")
	}

	var severity model.Severity = model.SeverityInfo
	if s, err := mapKeyToString(ctx, vOjb, "severity", false); err == nil {
		su := strings.ToUpper(*s)
		var found bool
		for _, si := range model.AllSeverities {
			if su == string(si) {
				severity = si
				found = true
				break
			}
		}

		if !found {
			logWithFields.Warn().Str("severity", *s).Msg("saving result. invalid severity constant value")
		}
	} else {
		logWithFields.Info().Msg("saving result. failed to detect severity")
	}

	issueType := DefaultIssueType
	if v := mustMapKeyToString(ctx, vOjb, "issueType"); v != nil {
		issueType = model.IssueType(*v)
	}

	return model.Vulnerability{
		ID:               0,
		ScanID:           ctx.scanID,
		FileID:           file.ID,
		QueryName:        queryName,
		QueryID:          queryID,
		Severity:         severity,
		Line:             line,
		IssueType:        issueType,
		SearchKey:        searchKey,
		KeyExpectedValue: mustMapKeyToString(ctx, vOjb, "keyExpectedValue"),
		KeyActualValue:   mustMapKeyToString(ctx, vOjb, "keyActualValue"),
		Value:            mustMapKeyToString(ctx, vOjb, "value"),
		Output:           string(output),
	}, nil
}

func detectLine(ctx QueryContext, file *model.FileMetadata, s string) int {
	logUndetected := func() {
		logger.GetLoggerWithFieldsFromContext(ctx.ctx).
			Warn().
			Str("scanID", ctx.scanID).
			Int("fileID", file.ID).
			Msgf("filed to detect line, query response %s", s)
	}

	scanner := bufio.NewScanner(strings.NewReader(file.OriginalData))
	var (
		line, lastMatchedLine int
		foundAtLeastOne       bool
	)

	keys := strings.Split(s, ".")
	for _, key := range keys {
		var name string
		if parts := nameRegex.FindStringSubmatch(key); len(parts) == namePartsLength {
			key = parts[1]
			name = parts[2]
		} else if parts := strings.Split(key, "="); len(parts) == valuePartsLength {
			key = parts[0]
			name = parts[1]
		}

		for scanner.Scan() {
			line++

			if strings.Contains(scanner.Text(), key) && (name == "" || strings.Contains(scanner.Text(), name)) {
				lastMatchedLine = line
				foundAtLeastOne = true
				break
			}
		}
	}

	if err := scanner.Err(); err != nil {
		logger.GetLoggerWithFieldsFromContext(ctx.ctx).
			Err(err).
			Str("scanID", ctx.scanID).
			Msgf("detecting line. scanner err for file id %d, search %s", file.ID, s)
	}

	if foundAtLeastOne {
		return lastMatchedLine
	}

	logUndetected()
	return UndetectedVulnerabilityLine
}

func mustMapKeyToString(ctx QueryContext, m map[string]interface{}, key string) *string {
	res, err := mapKeyToString(ctx, m, key, true)
	if err != nil {
		logger.GetLoggerWithFieldsFromContext(ctx.ctx).
			Warn().
			Str("reason", err.Error()).
			Msgf("failed to get key %s in map", key)
	}

	return res
}

func mapKeyToString(ctx QueryContext, m map[string]interface{}, key string, allowNil bool) (*string, error) {
	v, ok := m[key]
	if !ok {
		return nil, fmt.Errorf("key '%s' not found in map", key)
	}

	switch vv := v.(type) {
	case json.Number:
		return prtString(vv.String()), nil
	case string:
		return prtString(vv), nil
	case int, int32, int64:
		return prtString(fmt.Sprintf("%d", vv)), nil
	case float32:
		return prtString(strconv.FormatFloat(float64(vv), 'f', -1, 64)), nil
	case float64:
		return prtString(strconv.FormatFloat(vv, 'f', -1, 64)), nil
	case nil:
		if allowNil {
			return nil, nil
		}
		return prtString("null"), nil
	case bool:
		return prtString(fmt.Sprintf("%v", vv)), nil
	}

	logger.GetLoggerWithFieldsFromContext(ctx.ctx).
		Debug().
		Msg("detecting line. can't format item to string")

	if allowNil {
		return nil, nil
	}

	return prtString(""), nil
}

func prtString(v string) *string {
	return &v
}
