package engine

import (
	"encoding/json"
	"fmt"
	"strconv"
	"strings"

	"github.com/Checkmarx/kics/pkg/detector"
	"github.com/Checkmarx/kics/pkg/model"
	"github.com/pkg/errors"
	"github.com/rs/zerolog"
	"github.com/rs/zerolog/log"
)

const (
	formatFloat64 = 64
)

func tryOverride(overrideKey, vulnParam string, vObj map[string]interface{}) *string {
	if overrideKey != "" {
		if override, ok := vObj["override"].(map[string]interface{}); ok {
			if overrideObject, ok := override[overrideKey].(map[string]interface{}); ok {
				if _, ok := overrideObject[vulnParam]; ok {
					overrideValue, err := mapKeyToString(overrideObject, vulnParam, true)
					if err != nil {
						return nil
					} else if overrideValue != nil {
						return overrideValue
					}
				}
			}
		}
	}
	return nil
}

func getStringFromMap(vulnParam, defaultParam, overrideKey string, vObj map[string]interface{}, logWithFields *zerolog.Logger) string {
	ts, err := mapKeyToString(vObj, vulnParam, false)
	if err != nil {
		logWithFields.Err(err).
			Msgf("Saving result. failed to detect %s", vulnParam)
		return defaultParam
	}
	overrideValue := tryOverride(overrideKey, vulnParam, vObj)
	if overrideValue != nil {
		ts = overrideValue
	}
	return *ts
}

func getSeverity(severity string) model.Severity {
	for _, si := range model.AllSeverities {
		if severity == string(si) {
			return si
		}
	}
	return ""
}

// DefaultVulnerabilityBuilder defines a vulnerability builder to execute default actions of scan
var DefaultVulnerabilityBuilder = func(ctx *QueryContext, tracker Tracker,
	v interface{}, detector *detector.DetectLine) (model.Vulnerability, error) {
	vObj, ok := v.(map[string]interface{})
	if !ok {
		return model.Vulnerability{}, ErrInvalidResult
	}

	vObj = mergeWithMetadata(vObj, ctx.query.metadata.Metadata)

	var err error
	var output []byte

	output, err = json.Marshal(vObj)
	if err != nil {
		return model.Vulnerability{}, errors.Wrap(err, "failed to marshall query output")
	}

	var fileID *string

	fileID, err = mapKeyToString(vObj, "documentId", false)
	if err != nil {
		return model.Vulnerability{}, errors.Wrap(err, "failed to recognize file id")
	}

	file, ok := ctx.files[*fileID]
	if !ok {
		return model.Vulnerability{}, errors.New("failed to find file from query response")
	}

	logWithFields := log.With().
		Str("scanID", ctx.scanID).
		Str("fileName", file.FileName).
		Str("queryName", ctx.query.metadata.Query).
		Logger()

	detector.SetupLogs(&logWithFields)

	linesVulne := model.VulnerabilityLines{
		Line:      -1,
		VulnLines: []model.CodeLine{},
	}

	searchKey := ""
	if s, ok := vObj["searchKey"]; ok {
		searchKey = s.(string)
		linesVulne = detector.DetectLine(&file, searchKey)
	} else {
		logWithFields.Error().Msg("Saving result. failed to detect line")
	}

	searchValue := ""
	if s, ok := vObj["searchValue"]; ok {
		searchValue = s.(string)
	}

	overrideKey := ""
	if s, ok := vObj["overrideKey"]; ok {
		overrideKey = s.(string)
	}

	queryID := getStringFromMap("id", DefaultQueryID, overrideKey, vObj, &logWithFields)

	var severity model.Severity = model.SeverityInfo
	var s *string

	if s, err = mapKeyToString(vObj, "severity", false); err == nil {
		sev := getSeverity(strings.ToUpper(*s))
		if sev == "" {
			logWithFields.Warn().Str("severity", *s).Msg("Saving result. invalid severity constant value")
		} else {
			severity = sev
			overrideValue := tryOverride(overrideKey, "severity", vObj)
			if overrideValue != nil {
				sev = getSeverity(strings.ToUpper(*overrideValue))
				if sev != "" {
					severity = sev
				}
			}
		}
	} else {
		logWithFields.Info().Msg("Saving result. failed to detect severity")
	}

	issueType := DefaultIssueType
	if v := mustMapKeyToString(vObj, "issueType"); v != nil {
		issueType = model.IssueType(*v)
	}

	var similarityID *string

	similarityID, err = ComputeSimilarityID(ctx.baseScanPaths, file.FileName, queryID, searchKey, searchValue)
	if err != nil {
		logWithFields.Err(err).Send()
		tracker.FailedComputeSimilarityID()
	}

	return model.Vulnerability{
		ID:               0,
		SimilarityID:     ptrStringToString(similarityID),
		ScanID:           ctx.scanID,
		FileID:           file.ID,
		FileName:         file.FileName,
		QueryName:        getStringFromMap("queryName", DefaultQueryName, overrideKey, vObj, &logWithFields),
		QueryID:          queryID,
		QueryURI:         getStringFromMap("descriptionUrl", DefaultQueryURI, overrideKey, vObj, &logWithFields),
		Category:         getStringFromMap("category", "", overrideKey, vObj, &logWithFields),
		Description:      getStringFromMap("descriptionText", "", overrideKey, vObj, &logWithFields),
		DescriptionID:    getStringFromMap("descriptionID", DefaultQueryDescriptionID, overrideKey, vObj, &logWithFields),
		Severity:         severity,
		Platform:         getStringFromMap("platform", "", overrideKey, vObj, &logWithFields),
		Line:             linesVulne.Line,
		VulnLines:        linesVulne.VulnLines,
		IssueType:        issueType,
		SearchKey:        searchKey,
		SearchValue:      searchValue,
		KeyExpectedValue: ptrStringToString(mustMapKeyToString(vObj, "keyExpectedValue")),
		KeyActualValue:   ptrStringToString(mustMapKeyToString(vObj, "keyActualValue")),
		Value:            mustMapKeyToString(vObj, "value"),
		Output:           string(output),
	}, nil
}

func mergeWithMetadata(base, additional map[string]interface{}) map[string]interface{} {
	for k, v := range additional {
		if _, ok := base[k]; ok {
			continue
		}

		base[k] = v
	}

	return base
}

func mustMapKeyToString(m map[string]interface{}, key string) *string {
	res, err := mapKeyToString(m, key, true)
	if err != nil && key != "value" {
		log.Warn().
			Str("reason", err.Error()).
			Msgf("Failed to get key %s in map", key)
	}

	return res
}

func mapKeyToString(m map[string]interface{}, key string, allowNil bool) (*string, error) {
	v, ok := m[key]
	if !ok {
		return nil, fmt.Errorf("key '%s' not found in map", key)
	}

	switch vv := v.(type) {
	case json.Number:
		return stringToPtrString(vv.String()), nil
	case string:
		return stringToPtrString(vv), nil
	case int, int32, int64:
		return stringToPtrString(fmt.Sprintf("%d", vv)), nil
	case float32:
		return stringToPtrString(strconv.FormatFloat(float64(vv), 'f', -1, formatFloat64)), nil
	case float64:
		return stringToPtrString(strconv.FormatFloat(vv, 'f', -1, formatFloat64)), nil
	case nil:
		if allowNil {
			return nil, nil
		}
		return stringToPtrString("null"), nil
	case bool:
		return stringToPtrString(fmt.Sprintf("%v", vv)), nil
	}

	log.Debug().
		Msg("Detecting line. can't format item to string")

	if allowNil {
		return nil, nil
	}

	return stringToPtrString(""), nil
}

func stringToPtrString(v string) *string {
	return &v
}

func ptrStringToString(v *string) string {
	if v == nil {
		return ""
	}
	return *v
}
