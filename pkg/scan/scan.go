// Package scan implements functions and helpers to ensure the proper scan of the specified files
package scan

import (
	"context"
	"encoding/json"
	"os"
	"strings"

	"github.com/Checkmarx/kics/assets"
	"github.com/Checkmarx/kics/pkg/engine"
	"github.com/Checkmarx/kics/pkg/engine/provider"
	"github.com/Checkmarx/kics/pkg/engine/secrets"
	"github.com/Checkmarx/kics/pkg/engine/source"
	"github.com/Checkmarx/kics/pkg/kics"
	"github.com/Checkmarx/kics/pkg/model"
	"github.com/Checkmarx/kics/pkg/parser"
	buildahParser "github.com/Checkmarx/kics/pkg/parser/buildah"
	dockerParser "github.com/Checkmarx/kics/pkg/parser/docker"
	protoParser "github.com/Checkmarx/kics/pkg/parser/grpc"
	jsonParser "github.com/Checkmarx/kics/pkg/parser/json"
	terraformParser "github.com/Checkmarx/kics/pkg/parser/terraform"
	yamlParser "github.com/Checkmarx/kics/pkg/parser/yaml"
	"github.com/Checkmarx/kics/pkg/resolver"
	"github.com/Checkmarx/kics/pkg/resolver/helm"
	"github.com/Checkmarx/kics/pkg/scanner"
	"github.com/google/uuid"

	"github.com/rs/zerolog/log"
)

// Results represents a result generated by a single scan
type Results struct {
	Results        []model.Vulnerability
	ExtractedPaths provider.ExtractedPath
	Files          model.FileMetadatas
	FailedQueries  map[string]error
}

type executeScanParameters struct {
	services       []*kics.Service
	inspector      *engine.Inspector
	extractedPaths provider.ExtractedPath
}

type Document struct {
	LineInfoDocument map[string]interface{}
	DocumentContent  model.Document
	FilePath         string
}
type Reloaded struct {
	Documents []Document
	Platforms []string
	BasePaths []string
}

type ReloadedFileContent struct {
	FileType string
	Types    []string
	Reloaded []Reloaded
}

func (c *Client) initScan(ctx context.Context) (*executeScanParameters, error) {
	progressBar := c.ProBarBuilder.BuildCircle("Preparing Scan Assets: ")
	go progressBar.Start()

	extractedPaths, err := c.prepareAndAnalyzePaths(ctx)
	if err != nil {
		log.Err(err)
		return nil, err
	}

	if len(extractedPaths.Path) == 0 {
		return nil, nil
	}

	usingReloaded := strings.HasPrefix(c.ScanParams.Path[0], "kics-reloaded::")
	reloaded := ReloadedFileContent{}

	if usingReloaded {
		kicsReloadedPath := strings.Split(c.ScanParams.Path[0], "kics-reloaded::")[1]
		reloadedFileContent, err := os.ReadFile(kicsReloadedPath)
		if err != nil {
			log.Err(err)
			return nil, err
		}
		err = json.Unmarshal(reloadedFileContent, &reloaded)
		if err != nil {
			log.Err(err)
			return nil, err
		}
		c.ScanParams.Platform = reloaded.Types
	}

	querySource := source.NewFilesystemSource(
		c.ScanParams.QueriesPath,
		c.ScanParams.Platform,
		c.ScanParams.CloudProvider,
		c.ScanParams.LibrariesPath)

	queryFilter := c.createQueryFilter()

	inspector, err := engine.NewInspector(ctx,
		querySource,
		engine.DefaultVulnerabilityBuilder,
		c.Tracker,
		queryFilter,
		c.ExcludeResultsMap,
		c.ScanParams.QueryExecTimeout,
		true,
	)
	if err != nil {
		return nil, err
	}

	secretsRegexRulesContent, err := getSecretsRegexRules(c.ScanParams.SecretsRegexesPath)
	if err != nil {
		return nil, err
	}

	isCustomSecretsRegexes := len(c.ScanParams.SecretsRegexesPath) > 0

	secretsInspector, err := secrets.NewInspector(
		ctx,
		c.ExcludeResultsMap,
		c.Tracker,
		queryFilter,
		c.ScanParams.DisableSecrets,
		c.ScanParams.QueryExecTimeout,
		secretsRegexRulesContent,
		isCustomSecretsRegexes,
	)
	if err != nil {
		log.Err(err)
		return nil, err
	}

	services, err := c.createService(
		inspector,
		secretsInspector,
		extractedPaths.Path,
		c.Tracker,
		c.Storage,
		querySource,
	)
	if err != nil {
		log.Err(err)
		return nil, err
	}
	if usingReloaded {
		err = importReloaded(reloaded, c.ScanParams.ScanID, &services, c)
		if err != nil {
			log.Err(err)
			return nil, err
		}
	}

	if err := progressBar.Close(); err != nil {
		log.Debug().Msgf("Failed to close progress bar: %s", err.Error())
	}

	return &executeScanParameters{
		services:       services,
		inspector:      inspector,
		extractedPaths: extractedPaths,
	}, nil
}

func saveReloadedFile(reloadedPath string, services []*kics.Service, types []string) error {
	reloaded := ReloadedFileContent{}
	reloaded.FileType = "KICS-RELOADED"
	for _, service := range services {
		reloadedService := getReloadedFromService(service)
		reloaded.Reloaded = append(reloaded.Reloaded, reloadedService)
	}
	reloaded.Types = types

	jsonReloaded, err := json.Marshal(reloaded)
	if err != nil {
		return err
	}
	file, err := os.Create(reloadedPath)
	if err != nil {
		return err
	}
	_, err = file.Write(jsonReloaded)
	if err != nil {
		return err
	}
	err = file.Close()
	if err != nil {
		return err
	}
	return nil
}

func importReloaded(reloaded ReloadedFileContent, scanID string, services *[]*kics.Service, c *Client) error {
	for index, reloadedService := range reloaded.Reloaded {
		for _, doc := range reloadedService.Documents {
			linesString := []string{}
			lines, err := os.ReadFile(doc.FilePath)
			if err != nil {
				log.Err(err)
			} else {
				linesString = strings.Split(string(lines), "\n")
			}
			fileToSave := model.FileMetadata{ID: uuid.New().String(), ScanID: scanID, Document: doc.DocumentContent, LineInfoDocument: doc.LineInfoDocument, FilePath: doc.FilePath, LinesOriginalData: &linesString}
			(*services)[index].SaveFile(fileToSave)
		}
		(*services)[index].SourceProvider.SetBasePaths(reloadedService.BasePaths)
		(*services)[index].Parser.Platform = reloadedService.Platforms
	}
	return nil
}

func getReloadedFromService(service *kics.Service) Reloaded {
	reloaded := Reloaded{}
	reloaded.Documents = []Document{}
	reloaded.Platforms = []string{}
	for _, file := range service.GetFiles() {
		document := Document{file.LineInfoDocument, file.Document, file.FilePath}
		reloaded.Documents = append(reloaded.Documents, document)
		reloaded.BasePaths = append(reloaded.BasePaths, service.SourceProvider.GetBasePaths()...)
	}
	reloaded.Platforms = service.Parser.Platform
	return reloaded
}

func (c *Client) executeScan(ctx context.Context) (*Results, error) {
	executeScanParameters, err := c.initScan(ctx)

	if err != nil {
		log.Err(err)
		return nil, err
	}

	if executeScanParameters == nil {
		return nil, nil
	}

	filepath := c.ScanParams.Path[0]

	isKicsReloaded := strings.HasPrefix(filepath, "kics-reloaded::")

	if isKicsReloaded {
		err = scanner.StartScan(ctx, c.ScanParams.ScanID, *c.ProBarBuilder, executeScanParameters.services)
		if err != nil {
			return nil, err
		}
	} else {
		if err = scanner.PrepareAndScan(ctx, c.ScanParams.ScanID, *c.ProBarBuilder, executeScanParameters.services); err != nil {
			log.Err(err)
			return nil, err
		}

		if c.ScanParams.SaveReloadedPath != "" {
			err = saveReloadedFile(c.ScanParams.SaveReloadedPath, executeScanParameters.services, c.ScanParams.Platform)
			if err != nil {
				log.Err(err)
				return nil, err
			}
		}
	}

	failedQueries := executeScanParameters.inspector.GetFailedQueries()

	if err != nil {
		return nil, err
	}

	results, err := c.Storage.GetVulnerabilities(ctx, c.ScanParams.ScanID)
	if err != nil {
		log.Err(err)
		return nil, err
	}

	files, err := c.Storage.GetFiles(ctx, c.ScanParams.ScanID)
	if err != nil {
		log.Err(err)
		return nil, err
	}
	if isKicsReloaded {
		files = make(model.FileMetadatas, 0)
		for _, service := range executeScanParameters.services {
			files = append(files, service.GetFiles()...)
		}
	}

	return &Results{
		Results:        results,
		ExtractedPaths: executeScanParameters.extractedPaths,
		Files:          files,
		FailedQueries:  failedQueries,
	}, nil
}

func getExcludeResultsMap(excludeResults []string) map[string]bool {
	excludeResultsMap := make(map[string]bool)
	for _, er := range excludeResults {
		excludeResultsMap[er] = true
	}
	return excludeResultsMap
}

func getSecretsRegexRules(regexRulesPath string) (regexRulesContent string, err error) {
	if len(regexRulesPath) > 0 {
		b, err := os.ReadFile(regexRulesPath)
		if err != nil {
			return regexRulesContent, err
		}
		regexRulesContent = string(b)
	} else {
		regexRulesContent = assets.SecretsQueryRegexRulesJSON
	}

	return regexRulesContent, nil
}

func (c *Client) createQueryFilter() *source.QueryInspectorParameters {
	excludeQueries := source.ExcludeQueries{
		ByIDs:        c.ScanParams.ExcludeQueries,
		ByCategories: c.ScanParams.ExcludeCategories,
		BySeverities: c.ScanParams.ExcludeSeverities,
	}

	includeQueries := source.IncludeQueries{
		ByIDs: c.ScanParams.IncludeQueries,
	}

	queryFilter := source.QueryInspectorParameters{
		IncludeQueries: includeQueries,
		ExcludeQueries: excludeQueries,
		InputDataPath:  c.ScanParams.InputData,
		BomQueries:     c.ScanParams.BillOfMaterials,
	}

	return &queryFilter
}

func (c *Client) createService(
	inspector *engine.Inspector,
	secretsInspector *secrets.Inspector,
	paths []string,
	t kics.Tracker,
	store kics.Storage,
	querySource *source.FilesystemSource) ([]*kics.Service, error) {
	filesSource, err := c.getFileSystemSourceProvider(paths)
	if err != nil {
		return nil, err
	}

	combinedParser, err := parser.NewBuilder().
		Add(&jsonParser.Parser{}).
		Add(&yamlParser.Parser{}).
		Add(terraformParser.NewDefault()).
		Add(&dockerParser.Parser{}).
		Add(&protoParser.Parser{}).
		Add(&buildahParser.Parser{}).
		Build(querySource.Types, querySource.CloudProviders)
	if err != nil {
		return nil, err
	}

	// combinedResolver to be used to resolve files and templates
	combinedResolver, err := resolver.NewBuilder().
		Add(&helm.Resolver{}).
		Build()
	if err != nil {
		return nil, err
	}

	services := make([]*kics.Service, 0, len(combinedParser))

	for _, parser := range combinedParser {
		services = append(
			services,
			&kics.Service{
				SourceProvider:   filesSource,
				Storage:          store,
				Parser:           parser,
				Inspector:        inspector,
				SecretsInspector: secretsInspector,
				Tracker:          t,
				Resolver:         combinedResolver,
			},
		)
	}
	return services, nil
}

func (c *Client) getFileSystemSourceProvider(paths []string) (*provider.FileSystemSourceProvider, error) {
	var excludePaths []string
	if c.ScanParams.PayloadPath != "" {
		excludePaths = append(excludePaths, c.ScanParams.PayloadPath)
	}

	if len(c.ScanParams.ExcludePaths) > 0 {
		excludePaths = append(excludePaths, c.ScanParams.ExcludePaths...)
	}

	filesSource, err := provider.NewFileSystemSourceProvider(paths, excludePaths)
	if err != nil {
		return nil, err
	}
	return filesSource, nil
}
