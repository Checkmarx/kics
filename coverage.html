
<!DOCTYPE html>
<html>
	<head>
		<meta http-equiv="Content-Type" content="text/html; charset=utf-8">
		<title>assets: Go Coverage Report</title>
		<style>
			body {
				background: black;
				color: rgb(80, 80, 80);
			}
			body, pre, #legend span {
				font-family: Menlo, monospace;
				font-weight: bold;
			}
			#topbar {
				background: black;
				position: fixed;
				top: 0; left: 0; right: 0;
				height: 42px;
				border-bottom: 1px solid rgb(80, 80, 80);
			}
			#content {
				margin-top: 50px;
			}
			#nav, #legend {
				float: left;
				margin-left: 10px;
			}
			#legend {
				margin-top: 12px;
			}
			#nav {
				margin-top: 10px;
			}
			#legend span {
				margin: 0 5px;
			}
			.cov0 { color: rgb(192, 0, 0) }
.cov1 { color: rgb(128, 128, 128) }
.cov2 { color: rgb(116, 140, 131) }
.cov3 { color: rgb(104, 152, 134) }
.cov4 { color: rgb(92, 164, 137) }
.cov5 { color: rgb(80, 176, 140) }
.cov6 { color: rgb(68, 188, 143) }
.cov7 { color: rgb(56, 200, 146) }
.cov8 { color: rgb(44, 212, 149) }
.cov9 { color: rgb(32, 224, 152) }
.cov10 { color: rgb(20, 236, 155) }

		</style>
	</head>
	<body>
		<div id="topbar">
			<div id="nav">
				<select id="files">
				
				<option value="file0">github.com/Checkmarx/kics/v2/assets/assets.go (100.0%)</option>
				
				<option value="file1">github.com/Checkmarx/kics/v2/cmd/builder/main.go (0.0%)</option>
				
				<option value="file2">github.com/Checkmarx/kics/v2/cmd/console/main.go (0.0%)</option>
				
				<option value="file3">github.com/Checkmarx/kics/v2/internal/console/analyze.go (73.2%)</option>
				
				<option value="file4">github.com/Checkmarx/kics/v2/internal/console/flags/flags.go (94.4%)</option>
				
				<option value="file5">github.com/Checkmarx/kics/v2/internal/console/flags/flags_utils.go (86.1%)</option>
				
				<option value="file6">github.com/Checkmarx/kics/v2/internal/console/flags/validate.go (50.0%)</option>
				
				<option value="file7">github.com/Checkmarx/kics/v2/internal/console/flags/validate_multi_str.go (87.9%)</option>
				
				<option value="file8">github.com/Checkmarx/kics/v2/internal/console/flags/validate_path.go (100.0%)</option>
				
				<option value="file9">github.com/Checkmarx/kics/v2/internal/console/flags/validate_str.go (100.0%)</option>
				
				<option value="file10">github.com/Checkmarx/kics/v2/internal/console/generate_id.go (80.0%)</option>
				
				<option value="file11">github.com/Checkmarx/kics/v2/internal/console/helpers/exit_handler.go (100.0%)</option>
				
				<option value="file12">github.com/Checkmarx/kics/v2/internal/console/helpers/helpers.go (58.2%)</option>
				
				<option value="file13">github.com/Checkmarx/kics/v2/internal/console/kics.go (78.6%)</option>
				
				<option value="file14">github.com/Checkmarx/kics/v2/internal/console/list_platforms.go (100.0%)</option>
				
				<option value="file15">github.com/Checkmarx/kics/v2/internal/console/pre_scan.go (83.0%)</option>
				
				<option value="file16">github.com/Checkmarx/kics/v2/internal/console/remediate.go (82.6%)</option>
				
				<option value="file17">github.com/Checkmarx/kics/v2/internal/console/scan.go (72.2%)</option>
				
				<option value="file18">github.com/Checkmarx/kics/v2/internal/console/version.go (100.0%)</option>
				
				<option value="file19">github.com/Checkmarx/kics/v2/internal/constants/constants.go (83.3%)</option>
				
				<option value="file20">github.com/Checkmarx/kics/v2/internal/metrics/cpu_metric.go (91.7%)</option>
				
				<option value="file21">github.com/Checkmarx/kics/v2/internal/metrics/mem_metric.go (92.9%)</option>
				
				<option value="file22">github.com/Checkmarx/kics/v2/internal/metrics/metrics.go (90.3%)</option>
				
				<option value="file23">github.com/Checkmarx/kics/v2/internal/sentry/sentry.go (92.3%)</option>
				
				<option value="file24">github.com/Checkmarx/kics/v2/internal/storage/memory.go (95.2%)</option>
				
				<option value="file25">github.com/Checkmarx/kics/v2/internal/tracker/ci.go (93.8%)</option>
				
				<option value="file26">github.com/Checkmarx/kics/v2/pkg/analyzer/analyzer.go (92.4%)</option>
				
				<option value="file27">github.com/Checkmarx/kics/v2/pkg/builder/engine/engine.go (71.8%)</option>
				
				<option value="file28">github.com/Checkmarx/kics/v2/pkg/builder/model/model.go (100.0%)</option>
				
				<option value="file29">github.com/Checkmarx/kics/v2/pkg/builder/parser/comment/comments.go (85.7%)</option>
				
				<option value="file30">github.com/Checkmarx/kics/v2/pkg/builder/parser/tag/tag_parser.go (92.0%)</option>
				
				<option value="file31">github.com/Checkmarx/kics/v2/pkg/builder/writer/rego.go (89.8%)</option>
				
				<option value="file32">github.com/Checkmarx/kics/v2/pkg/descriptions/client.go (74.4%)</option>
				
				<option value="file33">github.com/Checkmarx/kics/v2/pkg/descriptions/descriptions.go (85.7%)</option>
				
				<option value="file34">github.com/Checkmarx/kics/v2/pkg/descriptions/mock/client_mock.go (100.0%)</option>
				
				<option value="file35">github.com/Checkmarx/kics/v2/pkg/descriptions/version.go (100.0%)</option>
				
				<option value="file36">github.com/Checkmarx/kics/v2/pkg/detector/default_detect.go (80.6%)</option>
				
				<option value="file37">github.com/Checkmarx/kics/v2/pkg/detector/detector.go (100.0%)</option>
				
				<option value="file38">github.com/Checkmarx/kics/v2/pkg/detector/docker/docker_detect.go (82.9%)</option>
				
				<option value="file39">github.com/Checkmarx/kics/v2/pkg/detector/helm/helm_detect.go (86.8%)</option>
				
				<option value="file40">github.com/Checkmarx/kics/v2/pkg/detector/helper.go (93.8%)</option>
				
				<option value="file41">github.com/Checkmarx/kics/v2/pkg/detector/search_line_detector.go (95.0%)</option>
				
				<option value="file42">github.com/Checkmarx/kics/v2/pkg/engine/inspector.go (81.4%)</option>
				
				<option value="file43">github.com/Checkmarx/kics/v2/pkg/engine/mock/source.go (100.0%)</option>
				
				<option value="file44">github.com/Checkmarx/kics/v2/pkg/engine/provider/extract.go (80.0%)</option>
				
				<option value="file45">github.com/Checkmarx/kics/v2/pkg/engine/provider/filesystem.go (81.0%)</option>
				
				<option value="file46">github.com/Checkmarx/kics/v2/pkg/engine/secrets/inspector.go (82.4%)</option>
				
				<option value="file47">github.com/Checkmarx/kics/v2/pkg/engine/similarity/similarity_id.go (94.7%)</option>
				
				<option value="file48">github.com/Checkmarx/kics/v2/pkg/engine/source/filesystem.go (74.1%)</option>
				
				<option value="file49">github.com/Checkmarx/kics/v2/pkg/engine/source/source.go (67.9%)</option>
				
				<option value="file50">github.com/Checkmarx/kics/v2/pkg/engine/vulnerability_builder.go (77.8%)</option>
				
				<option value="file51">github.com/Checkmarx/kics/v2/pkg/engine/vulnerability_utils.go (76.0%)</option>
				
				<option value="file52">github.com/Checkmarx/kics/v2/pkg/kics/resolver_sink.go (83.7%)</option>
				
				<option value="file53">github.com/Checkmarx/kics/v2/pkg/kics/service.go (44.4%)</option>
				
				<option value="file54">github.com/Checkmarx/kics/v2/pkg/kics/sink.go (38.2%)</option>
				
				<option value="file55">github.com/Checkmarx/kics/v2/pkg/kuberneter/auth.go (100.0%)</option>
				
				<option value="file56">github.com/Checkmarx/kics/v2/pkg/kuberneter/kuberneter.go (25.0%)</option>
				
				<option value="file57">github.com/Checkmarx/kics/v2/pkg/kuberneter/utils.go (70.0%)</option>
				
				<option value="file58">github.com/Checkmarx/kics/v2/pkg/minified/minified.go (100.0%)</option>
				
				<option value="file59">github.com/Checkmarx/kics/v2/pkg/model/comment_yaml.go (78.4%)</option>
				
				<option value="file60">github.com/Checkmarx/kics/v2/pkg/model/comments.go (100.0%)</option>
				
				<option value="file61">github.com/Checkmarx/kics/v2/pkg/model/model.go (89.7%)</option>
				
				<option value="file62">github.com/Checkmarx/kics/v2/pkg/model/model_yaml.go (86.1%)</option>
				
				<option value="file63">github.com/Checkmarx/kics/v2/pkg/model/summary.go (87.0%)</option>
				
				<option value="file64">github.com/Checkmarx/kics/v2/pkg/parser/ansible/ini/comments/comments.go (96.8%)</option>
				
				<option value="file65">github.com/Checkmarx/kics/v2/pkg/parser/ansible/ini/config/parser.go (75.0%)</option>
				
				<option value="file66">github.com/Checkmarx/kics/v2/pkg/parser/ansible/ini/hosts/parser.go (88.5%)</option>
				
				<option value="file67">github.com/Checkmarx/kics/v2/pkg/parser/bicep/antlr/parser/bicep_base_visitor.go (0.0%)</option>
				
				<option value="file68">github.com/Checkmarx/kics/v2/pkg/parser/bicep/antlr/parser/bicep_lexer.go (100.0%)</option>
				
				<option value="file69">github.com/Checkmarx/kics/v2/pkg/parser/bicep/antlr/parser/bicep_parser.go (51.1%)</option>
				
				<option value="file70">github.com/Checkmarx/kics/v2/pkg/parser/bicep/parser.go (92.6%)</option>
				
				<option value="file71">github.com/Checkmarx/kics/v2/pkg/parser/buildah/comments.go (100.0%)</option>
				
				<option value="file72">github.com/Checkmarx/kics/v2/pkg/parser/buildah/parser.go (89.5%)</option>
				
				<option value="file73">github.com/Checkmarx/kics/v2/pkg/parser/docker/comments.go (100.0%)</option>
				
				<option value="file74">github.com/Checkmarx/kics/v2/pkg/parser/docker/parser.go (95.7%)</option>
				
				<option value="file75">github.com/Checkmarx/kics/v2/pkg/parser/grpc/converter/converter.go (86.6%)</option>
				
				<option value="file76">github.com/Checkmarx/kics/v2/pkg/parser/grpc/parser.go (85.7%)</option>
				
				<option value="file77">github.com/Checkmarx/kics/v2/pkg/parser/json/json_line.go (93.0%)</option>
				
				<option value="file78">github.com/Checkmarx/kics/v2/pkg/parser/json/parser.go (78.1%)</option>
				
				<option value="file79">github.com/Checkmarx/kics/v2/pkg/parser/json/tfplan.go (84.6%)</option>
				
				<option value="file80">github.com/Checkmarx/kics/v2/pkg/parser/jsonfilter/parser/error_listener.go (100.0%)</option>
				
				<option value="file81">github.com/Checkmarx/kics/v2/pkg/parser/jsonfilter/parser/jsonfilter_base_visitor.go (0.0%)</option>
				
				<option value="file82">github.com/Checkmarx/kics/v2/pkg/parser/jsonfilter/parser/jsonfilter_lexer.go (100.0%)</option>
				
				<option value="file83">github.com/Checkmarx/kics/v2/pkg/parser/jsonfilter/parser/jsonfilter_parser.go (57.9%)</option>
				
				<option value="file84">github.com/Checkmarx/kics/v2/pkg/parser/jsonfilter/parser/jsonfilter_tree_visitor.go (70.8%)</option>
				
				<option value="file85">github.com/Checkmarx/kics/v2/pkg/parser/parser.go (88.5%)</option>
				
				<option value="file86">github.com/Checkmarx/kics/v2/pkg/parser/terraform/comment/comment.go (96.9%)</option>
				
				<option value="file87">github.com/Checkmarx/kics/v2/pkg/parser/terraform/converter/default.go (78.2%)</option>
				
				<option value="file88">github.com/Checkmarx/kics/v2/pkg/parser/terraform/data_source.go (76.8%)</option>
				
				<option value="file89">github.com/Checkmarx/kics/v2/pkg/parser/terraform/functions/default.go (71.4%)</option>
				
				<option value="file90">github.com/Checkmarx/kics/v2/pkg/parser/terraform/terraform.go (75.0%)</option>
				
				<option value="file91">github.com/Checkmarx/kics/v2/pkg/parser/terraform/variables.go (85.3%)</option>
				
				<option value="file92">github.com/Checkmarx/kics/v2/pkg/parser/utils/certificate_utils.go (81.6%)</option>
				
				<option value="file93">github.com/Checkmarx/kics/v2/pkg/parser/yaml/parser.go (82.6%)</option>
				
				<option value="file94">github.com/Checkmarx/kics/v2/pkg/printer/options.go (85.5%)</option>
				
				<option value="file95">github.com/Checkmarx/kics/v2/pkg/printer/printer.go (84.9%)</option>
				
				<option value="file96">github.com/Checkmarx/kics/v2/pkg/printer/utils.go (80.0%)</option>
				
				<option value="file97">github.com/Checkmarx/kics/v2/pkg/progress/circle/circle_progress.go (100.0%)</option>
				
				<option value="file98">github.com/Checkmarx/kics/v2/pkg/progress/counter/counter_progress.go (63.6%)</option>
				
				<option value="file99">github.com/Checkmarx/kics/v2/pkg/progress/progress.go (100.0%)</option>
				
				<option value="file100">github.com/Checkmarx/kics/v2/pkg/remediation/remediation.go (84.2%)</option>
				
				<option value="file101">github.com/Checkmarx/kics/v2/pkg/remediation/scan.go (64.8%)</option>
				
				<option value="file102">github.com/Checkmarx/kics/v2/pkg/remediation/utils.go (80.0%)</option>
				
				<option value="file103">github.com/Checkmarx/kics/v2/pkg/report/asff.go (87.5%)</option>
				
				<option value="file104">github.com/Checkmarx/kics/v2/pkg/report/code_climate.go (87.5%)</option>
				
				<option value="file105">github.com/Checkmarx/kics/v2/pkg/report/commons.go (81.8%)</option>
				
				<option value="file106">github.com/Checkmarx/kics/v2/pkg/report/csv.go (88.9%)</option>
				
				<option value="file107">github.com/Checkmarx/kics/v2/pkg/report/cyclonedx.go (81.8%)</option>
				
				<option value="file108">github.com/Checkmarx/kics/v2/pkg/report/gitlab_sast.go (93.3%)</option>
				
				<option value="file109">github.com/Checkmarx/kics/v2/pkg/report/html.go (88.1%)</option>
				
				<option value="file110">github.com/Checkmarx/kics/v2/pkg/report/json.go (92.3%)</option>
				
				<option value="file111">github.com/Checkmarx/kics/v2/pkg/report/junit.go (92.3%)</option>
				
				<option value="file112">github.com/Checkmarx/kics/v2/pkg/report/model/asff.go (85.3%)</option>
				
				<option value="file113">github.com/Checkmarx/kics/v2/pkg/report/model/code_climate.go (100.0%)</option>
				
				<option value="file114">github.com/Checkmarx/kics/v2/pkg/report/model/csv.go (100.0%)</option>
				
				<option value="file115">github.com/Checkmarx/kics/v2/pkg/report/model/cyclonedx.go (93.1%)</option>
				
				<option value="file116">github.com/Checkmarx/kics/v2/pkg/report/model/gitlab_sast.go (85.7%)</option>
				
				<option value="file117">github.com/Checkmarx/kics/v2/pkg/report/model/junit.go (94.4%)</option>
				
				<option value="file118">github.com/Checkmarx/kics/v2/pkg/report/model/sarif.go (68.6%)</option>
				
				<option value="file119">github.com/Checkmarx/kics/v2/pkg/report/model/sarif_categories.go (100.0%)</option>
				
				<option value="file120">github.com/Checkmarx/kics/v2/pkg/report/model/sonarqube.go (92.9%)</option>
				
				<option value="file121">github.com/Checkmarx/kics/v2/pkg/report/pdf.go (89.5%)</option>
				
				<option value="file122">github.com/Checkmarx/kics/v2/pkg/report/sarif.go (77.8%)</option>
				
				<option value="file123">github.com/Checkmarx/kics/v2/pkg/report/sonarqube.go (90.9%)</option>
				
				<option value="file124">github.com/Checkmarx/kics/v2/pkg/resolver/file/file.go (70.5%)</option>
				
				<option value="file125">github.com/Checkmarx/kics/v2/pkg/resolver/helm/helm.go (88.5%)</option>
				
				<option value="file126">github.com/Checkmarx/kics/v2/pkg/resolver/helm/resolver.go (84.0%)</option>
				
				<option value="file127">github.com/Checkmarx/kics/v2/pkg/resolver/resolver.go (90.5%)</option>
				
				<option value="file128">github.com/Checkmarx/kics/v2/pkg/scan/client.go (44.4%)</option>
				
				<option value="file129">github.com/Checkmarx/kics/v2/pkg/scan/post_scan.go (81.2%)</option>
				
				<option value="file130">github.com/Checkmarx/kics/v2/pkg/scan/preview_secrets_mask.go (72.6%)</option>
				
				<option value="file131">github.com/Checkmarx/kics/v2/pkg/scan/scan.go (70.1%)</option>
				
				<option value="file132">github.com/Checkmarx/kics/v2/pkg/scan/utils.go (85.5%)</option>
				
				<option value="file133">github.com/Checkmarx/kics/v2/pkg/scanner/scanner.go (56.4%)</option>
				
				<option value="file134">github.com/Checkmarx/kics/v2/pkg/utils/ansible_vault.go (88.9%)</option>
				
				<option value="file135">github.com/Checkmarx/kics/v2/pkg/utils/contains.go (60.0%)</option>
				
				<option value="file136">github.com/Checkmarx/kics/v2/pkg/utils/get_extension.go (78.3%)</option>
				
				<option value="file137">github.com/Checkmarx/kics/v2/pkg/utils/line_counter.go (84.6%)</option>
				
				<option value="file138">github.com/Checkmarx/kics/v2/pkg/utils/map.go (100.0%)</option>
				
				<option value="file139">github.com/Checkmarx/kics/v2/pkg/utils/panic_handler.go (0.0%)</option>
				
				<option value="file140">github.com/Checkmarx/kics/v2/pkg/utils/random.go (100.0%)</option>
				
				<option value="file141">github.com/Checkmarx/kics/v2/pkg/utils/split_lines.go (100.0%)</option>
				
				<option value="file142">github.com/Checkmarx/kics/v2/pkg/utils/validations.go (100.0%)</option>
				
				<option value="file143">github.com/Checkmarx/kics/v2/test/helpers.go (37.5%)</option>
				
				</select>
			</div>
			<div id="legend">
				<span>not tracked</span>
			
				<span class="cov0">no coverage</span>
				<span class="cov1">low coverage</span>
				<span class="cov2">*</span>
				<span class="cov3">*</span>
				<span class="cov4">*</span>
				<span class="cov5">*</span>
				<span class="cov6">*</span>
				<span class="cov7">*</span>
				<span class="cov8">*</span>
				<span class="cov9">*</span>
				<span class="cov10">high coverage</span>
			
			</div>
		</div>
		<div id="content">
		
		<pre class="file" id="file0" style="display: none">package assets

import "embed" // used for embedding KICS libraries

//go:embed libraries/*.rego
var embeddedLibraries embed.FS

//go:embed libraries/*.json
var embeddedLibraryData embed.FS

//go:embed queries/common/passwords_and_secrets/metadata.json
var SecretsQueryMetadataJSON string

//go:embed queries/common/passwords_and_secrets/regex_rules.json
var SecretsQueryRegexRulesJSON string

// GetEmbeddedLibrary returns the embedded library.rego for the platform passed in the argument
func GetEmbeddedLibrary(platform string) (string, error) <span class="cov10" title="11157">{
        content, err := embeddedLibraries.ReadFile("libraries/" + platform + ".rego")

        return string(content), err
}</span>

// GetEmbeddedLibrary returns the embedded library.rego for the platform passed in the argument
func GetEmbeddedLibraryData(platform string) (string, error) <span class="cov9" title="11151">{
        content, err := embeddedLibraryData.ReadFile("libraries/" + platform + ".json")

        return string(content), err
}</span>
</pre>
		
		<pre class="file" id="file1" style="display: none">package main

import (
        "context"
        "os"
        "path"
        "path/filepath"

        "github.com/Checkmarx/kics/v2/pkg/builder/engine"
        "github.com/Checkmarx/kics/v2/pkg/builder/writer"
        "github.com/rs/zerolog"
        "github.com/rs/zerolog/log"
        "github.com/spf13/cobra"
)

func main() <span class="cov0" title="0">{
        var (
                inPath  string
                outPath string
        )

        ctx := context.Background()
        log.Logger = log.Output(zerolog.ConsoleWriter{Out: os.Stdout})
        zerolog.SetGlobalLevel(zerolog.DebugLevel)

        rootCmd := &amp;cobra.Command{
                Use:   "inspect",
                Short: "Tool to build new query from example file",
                RunE: func(cmd *cobra.Command, args []string) error </span><span class="cov0" title="0">{
                        content, err := os.ReadFile(filepath.Clean(inPath))
                        if err != nil </span><span class="cov0" title="0">{
                                return err
                        }</span>

                        <span class="cov0" title="0">rules, err := engine.Run(content, path.Base(inPath))
                        if err != nil </span><span class="cov0" title="0">{
                                return err
                        }</span>

                        <span class="cov0" title="0">regoWriter, err := writer.NewRegoWriter()
                        if err != nil </span><span class="cov0" title="0">{
                                return err
                        }</span>

                        <span class="cov0" title="0">outContent, err := regoWriter.Render(rules)
                        if err != nil </span><span class="cov0" title="0">{
                                return err
                        }</span>

                        <span class="cov0" title="0">return saveFile(outPath, outContent)</span>
                },
        }

        <span class="cov0" title="0">rootCmd.Flags().StringVarP(&amp;inPath, "in", "i", "", "path for in file")
        rootCmd.Flags().StringVarP(&amp;outPath, "out", "o", "", "path for out path")

        if err := rootCmd.MarkFlagRequired("in"); err != nil </span><span class="cov0" title="0">{
                log.Err(err).Msg("Failed to add command required flags")
        }</span>
        <span class="cov0" title="0">if err := rootCmd.MarkFlagRequired("out"); err != nil </span><span class="cov0" title="0">{
                log.Err(err).Msg("Failed to add command required flags")
        }</span>

        <span class="cov0" title="0">if err := rootCmd.ExecuteContext(ctx); err != nil </span><span class="cov0" title="0">{
                os.Exit(-1)
        }</span>
}

func saveFile(filePath string, content []byte) error <span class="cov0" title="0">{
        f, err := os.OpenFile(filepath.Clean(filePath), os.O_CREATE|os.O_WRONLY|os.O_TRUNC, os.ModePerm)
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>

        <span class="cov0" title="0">defer func() </span><span class="cov0" title="0">{
                if err := f.Close(); err != nil </span><span class="cov0" title="0">{
                        log.Err(err).Msgf("failed to close '%s'", filePath)
                }</span>
        }()

        <span class="cov0" title="0">if _, err := f.Write(content); err != nil </span><span class="cov0" title="0">{
                return err
        }</span>
        <span class="cov0" title="0">return nil</span>
}
</pre>
		
		<pre class="file" id="file2" style="display: none">package main

import (
        "os"

        "github.com/Checkmarx/kics/v2/internal/console"
        "github.com/Checkmarx/kics/v2/internal/console/helpers"
        "github.com/Checkmarx/kics/v2/internal/constants"
)

func main() <span class="cov0" title="0">{
        if err := console.Execute(); err != nil </span><span class="cov0" title="0">{
                if helpers.ShowError("errors") </span><span class="cov0" title="0">{
                        os.Exit(constants.EngineErrorCode)
                }</span>
        }
}
</pre>
		
		<pre class="file" id="file3" style="display: none">package console

import (
        _ "embed" // Embed kics CLI img and analyze-flags
        "encoding/json"
        "os"
        "path/filepath"

        "github.com/Checkmarx/kics/v2/internal/console/flags"
        sentryReport "github.com/Checkmarx/kics/v2/internal/sentry"
        "github.com/Checkmarx/kics/v2/pkg/analyzer"
        "github.com/Checkmarx/kics/v2/pkg/engine/source"
        "github.com/Checkmarx/kics/v2/pkg/model"
        "github.com/rs/zerolog/log"
        "github.com/spf13/cobra"
)

var (
        //go:embed assets/analyze-flags.json
        analyzeFlagsListContent string
)

const (
        perms = 0640
)

// NewAnalyzeCmd creates a new instance of the analyze Command
func NewAnalyzeCmd() *cobra.Command <span class="cov10" title="21">{
        return &amp;cobra.Command{
                Use:   "analyze",
                Short: "Determines the detected platforms of a certain project",
                RunE: func(cmd *cobra.Command, args []string) error </span><span class="cov1" title="1">{
                        return analyze()
                }</span>,
        }
}

func initAnalyzeCmd(analyzeCmd *cobra.Command) error <span class="cov10" title="21">{
        if err := flags.InitJSONFlags(
                analyzeCmd,
                analyzeFlagsListContent,
                false,
                source.ListSupportedPlatforms(),
                source.ListSupportedCloudProviders()); err != nil </span><span class="cov0" title="0">{
                return err
        }</span>

        <span class="cov10" title="21">if err := analyzeCmd.MarkFlagRequired(flags.AnalyzePath); err != nil </span><span class="cov0" title="0">{
                sentryReport.ReportSentry(&amp;sentryReport.Report{
                        Message:  "Failed to add command required flags",
                        Err:      err,
                        Location: "func initAnalyzeCmd()",
                }, true)
                log.Err(err).Msg("Failed to add command required flags")
        }</span>
        <span class="cov10" title="21">return nil</span>
}

func analyze() error <span class="cov1" title="1">{
        // save the analyze parameters into the AnalyzeParameters struct
        analyzeParams := getAnalyzeParameters()

        return executeAnalyze(analyzeParams)
}</span>

func getAnalyzeParameters() *analyzer.Parameters <span class="cov1" title="1">{
        analyzeParams := analyzer.Parameters{
                Path:        flags.GetMultiStrFlag(flags.AnalyzePath),
                Results:     flags.GetStrFlag(flags.AnalyzeResults),
                MaxFileSize: flags.GetIntFlag(flags.MaxFileSizeFlag),
        }

        return &amp;analyzeParams
}</span>

func executeAnalyze(analyzeParams *analyzer.Parameters) error <span class="cov1" title="1">{
        log.Debug().Msg("console.scan()")

        for _, warn := range warnings </span><span class="cov9" title="20">{
                log.Warn().Msgf(warn)
        }</span>

        <span class="cov1" title="1">console := newConsole()

        console.preScan()

        analyzerStruct := &amp;analyzer.Analyzer{
                Paths:             analyzeParams.Path,
                Types:             []string{""},
                ExcludeTypes:      []string{""},
                Exc:               []string{""},
                ExcludeGitIgnore:  false,
                GitIgnoreFileName: "",
                MaxFileSize:       analyzeParams.MaxFileSize,
        }

        analyzedPaths, err := analyzer.Analyze(analyzerStruct)

        if err != nil </span><span class="cov0" title="0">{
                log.Err(err)
                return err
        }</span>

        <span class="cov1" title="1">err = writeToFile(analyzeParams.Results, analyzedPaths)

        if err != nil </span><span class="cov0" title="0">{
                log.Err(err)
                return err
        }</span>

        <span class="cov1" title="1">return nil</span>
}

func writeToFile(resultsPath string, analyzerResults model.AnalyzedPaths) error <span class="cov1" title="1">{
        err := os.MkdirAll(filepath.Dir(resultsPath), perms)
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>

        <span class="cov1" title="1">f, err := os.Create(resultsPath)
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>

        <span class="cov1" title="1">defer f.Close()

        content, err := json.Marshal(analyzerResults)
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>

        <span class="cov1" title="1">_, err = f.Write(content)
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>

        <span class="cov1" title="1">return nil</span>
}
</pre>
		
		<pre class="file" id="file4" style="display: none">package flags

import (
        "encoding/json"
        "regexp"
        "strconv"
        "strings"

        "github.com/Checkmarx/kics/v2/internal/console/helpers"
        "github.com/Checkmarx/kics/v2/internal/constants"
        "github.com/rs/zerolog/log"
        "github.com/spf13/cobra"
        "github.com/spf13/pflag"
)

var (
        flagsMultiStrReferences = make(map[string]*[]string)
        flagsStrReferences      = make(map[string]*string)
        flagsBoolReferences     = make(map[string]*bool)
        flagsIntReferences      = make(map[string]*int)

        validations = make(map[string][]string)
)

type flagJSON struct {
        FlagType       string
        ShorthandFlag  string
        DefaultValue   *string
        Usage          string
        Hidden         bool
        Deprecated     bool
        DeprecatedInfo string
        Validation     string
}

func evalUsage(usage string, supportedPlatforms, supportedCloudProviders []string) string <span class="cov8" title="19">{
        variables := map[string]string{
                "sliceInstructions":  "can be provided multiple times or as a comma separated string",
                "supportedLogLevels": strings.Join(constants.AvailableLogLevels, ","),
                "supportedPlatforms": strings.Join(supportedPlatforms, ", "),
                "supportedProviders": strings.Join(supportedCloudProviders, ", "),
                "supportedReports":   strings.Join(append([]string{"all"}, helpers.ListReportFormats()...), ", "),
                "defaultLogFile":     constants.DefaultLogFile,
                "logFormatPretty":    constants.LogFormatPretty,
                "logFormatJSON":      constants.LogFormatJSON,
        }
        variableRegex := regexp.MustCompile(`\$\{(\w+)\}`)
        match := variableRegex.FindAllStringSubmatch(usage, -1)
        for i := range match </span><span class="cov6" title="8">{
                usage = strings.ReplaceAll(usage, "${"+match[i][1]+"}", variables[match[i][1]])
        }</span>
        <span class="cov8" title="19">return usage</span>
}

func checkHiddenAndDeprecated(flagSet *pflag.FlagSet, flagName string, flagProps flagJSON) error <span class="cov8" title="14">{ //nolint:gocritic
        if flagProps.Hidden </span><span class="cov1" title="1">{
                err := flagSet.MarkHidden(flagName)
                if err != nil </span><span class="cov0" title="0">{
                        log.Err(err).Msg("Loading flags: could not mark flag as hidden")
                        return err
                }</span>
        }
        <span class="cov8" title="14">if flagProps.Deprecated </span><span class="cov1" title="1">{
                err := flagSet.MarkDeprecated(flagName, flagProps.DeprecatedInfo)
                if err != nil </span><span class="cov0" title="0">{
                        log.Err(err).Msg("Loading flags: could not mark flag as deprecated")
                        return err
                }</span>
        }
        <span class="cov8" title="14">return nil</span>
}

// InitJSONFlags initialize cobra flags
func InitJSONFlags(
        cmd *cobra.Command,
        flagsListContent string,
        persistentFlag bool,
        supportedPlatforms,
        supportedCloudProviders []string) error <span class="cov6" title="7">{
        var flagsList map[string]flagJSON
        err := json.Unmarshal([]byte(flagsListContent), &amp;flagsList)
        if err != nil </span><span class="cov1" title="1">{
                log.Err(err).Msg("Loading flags: could not unmarshal flags")
                return err
        }</span>

        <span class="cov5" title="6">flagSet := cmd.Flags()
        if persistentFlag </span><span class="cov5" title="5">{
                flagSet = cmd.PersistentFlags()
        }</span>

        <span class="cov5" title="6">for flagName, flagProps := range flagsList </span><span class="cov8" title="16">{
                flagProps.Usage = evalUsage(flagProps.Usage, supportedPlatforms, supportedCloudProviders)

                switch flagProps.FlagType </span>{
                case "multiStr":<span class="cov1" title="1">
                        var flag []string
                        flagsMultiStrReferences[flagName] = &amp;flag
                        defaultValues := make([]string, 0)
                        if flagProps.DefaultValue != nil </span><span class="cov1" title="1">{
                                defaultValues = strings.Split(*flagProps.DefaultValue, ",")
                        }</span>
                        <span class="cov1" title="1">flagSet.StringSliceVarP(flagsMultiStrReferences[flagName], flagName, flagProps.ShorthandFlag, defaultValues, flagProps.Usage)</span>
                case "str":<span class="cov5" title="5">
                        var flag string
                        flagsStrReferences[flagName] = &amp;flag
                        flagSet.StringVarP(flagsStrReferences[flagName], flagName, flagProps.ShorthandFlag, *flagProps.DefaultValue, flagProps.Usage)</span>
                case "bool":<span class="cov6" title="7">
                        var flag bool
                        flagsBoolReferences[flagName] = &amp;flag
                        defaultValue, err := strconv.ParseBool(*flagProps.DefaultValue)
                        if err != nil </span><span class="cov1" title="1">{
                                log.Err(err).Msg("Loading flags: could not convert default values")
                                return err
                        }</span>
                        <span class="cov5" title="6">flagSet.BoolVarP(flagsBoolReferences[flagName], flagName, flagProps.ShorthandFlag, defaultValue, flagProps.Usage)</span>
                case "int":<span class="cov2" title="2">
                        var flag int
                        flagsIntReferences[flagName] = &amp;flag
                        defaultValue, err := strconv.Atoi(*flagProps.DefaultValue)
                        if err != nil </span><span class="cov1" title="1">{
                                log.Err(err).Msg("Loading flags: could not convert default values")
                                return err
                        }</span>
                        <span class="cov1" title="1">flagSet.IntVarP(flagsIntReferences[flagName], flagName, flagProps.ShorthandFlag, defaultValue, flagProps.Usage)</span>
                default:<span class="cov1" title="1">
                        log.Error().Msgf("Flag %s has unknown type %s", flagName, flagProps.FlagType)</span>
                }

                <span class="cov8" title="14">err := checkHiddenAndDeprecated(flagSet, flagName, flagProps)
                if err != nil </span><span class="cov0" title="0">{
                        return err
                }</span>

                <span class="cov8" title="14">if flagProps.Validation != "" </span><span class="cov2" title="2">{
                        validations[flagName] = strings.Split(flagProps.Validation, ",")
                }</span>
        }
        <span class="cov4" title="4">return nil</span>
}

// GetStrFlag get a string flag by its name
func GetStrFlag(flagName string) string <span class="cov9" title="24">{
        if value, ok := flagsStrReferences[flagName]; ok </span><span class="cov9" title="22">{
                return *value
        }</span>
        <span class="cov2" title="2">log.Debug().Msgf("Could not find string flag %s", flagName)
        return ""</span>
}

// GetMultiStrFlag get a slice of strings flag by its name
func GetMultiStrFlag(flagName string) []string <span class="cov10" title="29">{
        if value, ok := flagsMultiStrReferences[flagName]; ok </span><span class="cov9" title="24">{
                return *value
        }</span>
        <span class="cov5" title="5">log.Debug().Msgf("Could not find string slice flag %s", flagName)
        return []string{}</span>
}

// GetBoolFlag get a boolean flag by its name
func GetBoolFlag(flagName string) bool <span class="cov2" title="2">{
        if value, ok := flagsBoolReferences[flagName]; ok </span><span class="cov1" title="1">{
                return *value
        }</span>
        <span class="cov1" title="1">log.Debug().Msgf("Could not find boolean flag %s", flagName)
        return false</span>
}

// GetIntFlag get a integer flag by its name
func GetIntFlag(flagName string) int <span class="cov5" title="5">{
        if value, ok := flagsIntReferences[flagName]; ok </span><span class="cov4" title="4">{
                return *value
        }</span>
        <span class="cov1" title="1">log.Debug().Msgf("Could not find integer flag %s", flagName)
        return -1</span>
}

// SetStrFlag set a string flag using its name
func SetStrFlag(flagName, value string) <span class="cov2" title="2">{
        if _, ok := flagsStrReferences[flagName]; ok </span><span class="cov1" title="1">{
                *flagsStrReferences[flagName] = value
        }</span> else<span class="cov1" title="1"> {
                log.Debug().Msgf("Could not set string flag %s", flagName)
        }</span>
}

// SetMultiStrFlag set a slice of strings flag using its name
func SetMultiStrFlag(flagName string, value []string) <span class="cov2" title="2">{
        if _, ok := flagsMultiStrReferences[flagName]; ok </span><span class="cov1" title="1">{
                *flagsMultiStrReferences[flagName] = value
        }</span> else<span class="cov1" title="1"> {
                log.Debug().Msgf("Could not set string slice flag %s", flagName)
        }</span>
}

// GetAllFlags returns all flags values
func GetAllFlags() map[string]interface{} <span class="cov1" title="1">{
        flags := make(map[string]interface{})
        for flag, value := range flagsBoolReferences </span><span class="cov1" title="1">{
                flags[flag] = value
        }</span>
        <span class="cov1" title="1">for flag, value := range flagsIntReferences </span><span class="cov1" title="1">{
                flags[flag] = value
        }</span>
        <span class="cov1" title="1">for flag, value := range flagsMultiStrReferences </span><span class="cov1" title="1">{
                flags[flag] = value
        }</span>
        <span class="cov1" title="1">for flag, value := range flagsStrReferences </span><span class="cov1" title="1">{
                flags[flag] = value
        }</span>

        <span class="cov1" title="1">return flags</span>
}
</pre>
		
		<pre class="file" id="file5" style="display: none">package flags

import (
        "fmt"
        "strings"

        "github.com/pkg/errors"
        "github.com/rs/zerolog/log"
        "github.com/spf13/cobra"
        "github.com/spf13/pflag"
        "github.com/spf13/viper"
)

// FormatNewError reports the impossibility of flag1 and flag2 usage simultaneously
func FormatNewError(flag1, flag2 string) error <span class="cov10" title="5">{
        return errors.Errorf("can't provide '%s' and '%s' flags simultaneously",
                flag1,
                flag2)
}</span>

// ValidateQuerySelectionFlags reports the impossibility of include and exclude flags usage simultaneously
func ValidateQuerySelectionFlags() error <span class="cov7" title="3">{
        if len(GetMultiStrFlag(IncludeQueriesFlag)) &gt; 0 &amp;&amp; len(GetMultiStrFlag(ExcludeQueriesFlag)) &gt; 0 </span><span class="cov1" title="1">{
                return FormatNewError(IncludeQueriesFlag, ExcludeQueriesFlag)
        }</span>
        <span class="cov4" title="2">if len(GetMultiStrFlag(IncludeQueriesFlag)) &gt; 0 &amp;&amp; len(GetMultiStrFlag(ExcludeCategoriesFlag)) &gt; 0 </span><span class="cov1" title="1">{
                return FormatNewError(IncludeQueriesFlag, ExcludeCategoriesFlag)
        }</span>
        <span class="cov1" title="1">return nil</span>
}

// ValidateTypeSelectionFlags reports the impossibility of include and exclude flags usage simultaneously
func ValidateTypeSelectionFlags() error <span class="cov7" title="3">{
        if len(GetMultiStrFlag(TypeFlag)) &gt; 1 &amp;&amp; len(GetMultiStrFlag(ExcludeTypeFlag)) &gt; 1 </span><span class="cov1" title="1">{
                return FormatNewError(TypeFlag, ExcludeTypeFlag)
        }</span>
        <span class="cov4" title="2">if GetMultiStrFlag(TypeFlag)[0] != "" &amp;&amp; GetMultiStrFlag(ExcludeTypeFlag)[0] != "" </span><span class="cov0" title="0">{
                return FormatNewError(TypeFlag, ExcludeTypeFlag)
        }</span>
        <span class="cov4" title="2">return nil</span>
}

// BindFlags fill flags values with config file or environment variables data
func BindFlags(cmd *cobra.Command, v *viper.Viper) error <span class="cov1" title="1">{
        log.Debug().Msg("console.bindFlags()")
        settingsMap := v.AllSettings()
        cmd.Flags().VisitAll(func(f *pflag.Flag) </span><span class="cov7" title="3">{
                settingsMap[f.Name] = true
                if strings.Contains(f.Name, "-") </span><span class="cov7" title="3">{
                        envVarSuffix := strings.ToUpper(strings.ReplaceAll(f.Name, "-", "_"))
                        variableName := fmt.Sprintf("%s_%s", "KICS", envVarSuffix)
                        if err := v.BindEnv(f.Name, variableName); err != nil </span><span class="cov0" title="0">{
                                log.Err(err).Msg("Failed to bind Viper flags")
                        }</span>
                }
                <span class="cov7" title="3">if !f.Changed &amp;&amp; v.IsSet(f.Name) </span><span class="cov4" title="2">{
                        val := v.Get(f.Name)
                        setBoundFlags(f.Name, val, cmd)
                }</span>
        })
        <span class="cov1" title="1">for key, val := range settingsMap </span><span class="cov7" title="3">{
                if val != true </span><span class="cov0" title="0">{
                        return fmt.Errorf("unknown configuration key: '%s'\nShowing help for '%s' command", key, cmd.Name())
                }</span>
        }
        <span class="cov1" title="1">return nil</span>
}

func setBoundFlags(flagName string, val interface{}, cmd *cobra.Command) <span class="cov4" title="2">{
        switch t := val.(type) </span>{
        case []interface{}:<span class="cov1" title="1">
                var paramSlice []string
                for _, param := range t </span><span class="cov4" title="2">{
                        paramSlice = append(paramSlice, param.(string))
                }</span>
                <span class="cov1" title="1">valStr := strings.Join(paramSlice, ",")
                if err := cmd.Flags().Set(flagName, valStr); err != nil </span><span class="cov0" title="0">{
                        log.Err(err).Msg("Failed to set Viper flags")
                }</span>
        default:<span class="cov1" title="1">
                if err := cmd.Flags().Set(flagName, fmt.Sprintf("%v", val)); err != nil </span><span class="cov0" title="0">{
                        log.Err(err).Msg("Failed to set Viper flags")
                }</span>
        }
}
</pre>
		
		<pre class="file" id="file6" style="display: none">package flags

import "regexp"

type flagValidationFuncsMap map[string]func(flagName string) error

var flagValidationFuncs = flagValidationFuncsMap{
        "sliceFlagsShouldNotStartWithFlags": sliceFlagsShouldNotStartWithFlags,
        "validateMultiStrEnum":              validateMultiStrEnum,
        "validateStrEnum":                   validateStrEnum,
        "allQueriesID":                      allQueriesID,
        "validateWorkersFlag":               validateWorkersFlag,
        "validatePath":                      validatePath,
}

func isQueryID(id string) bool <span class="cov5" title="5">{
        re := regexp.MustCompile(`^[0-9a-fA-F]{8}\b-[0-9a-fA-F]{4}\b-[0-9a-fA-F]{4}\b-[0-9a-fA-F]{4}\b-[0-9a-fA-F]{12}$`)
        return re.MatchString(id)
}</span>

func convertSliceToDummyMap(slice []string) map[string]string <span class="cov5" title="5">{
        returnMap := make(map[string]string, len(slice))
        for _, element := range slice </span><span class="cov10" title="32">{
                returnMap[element] = ""
        }</span>
        <span class="cov5" title="5">return returnMap</span>
}

// Validate validate if flag values are ok, if not, returns an error
func Validate() error <span class="cov0" title="0">{
        for validation, validationFuncs := range validations </span><span class="cov0" title="0">{
                for _, validationFunc := range validationFuncs </span><span class="cov0" title="0">{
                        if function, ok := flagValidationFuncs[validationFunc]; ok </span><span class="cov0" title="0">{
                                if err := function(validation); err != nil </span><span class="cov0" title="0">{
                                        return err
                                }</span>
                        }
                }
        }
        <span class="cov0" title="0">return nil</span>
}
</pre>
		
		<pre class="file" id="file7" style="display: none">package flags

import (
        "fmt"
        "regexp"
        "runtime"
        "strings"
        "time"

        "github.com/Checkmarx/kics/v2/internal/console/helpers"
        "github.com/Checkmarx/kics/v2/internal/constants"
        "github.com/Checkmarx/kics/v2/pkg/utils"
)

var validMultiStrEnums = map[string]map[string]string{
        CloudProviderFlag:     constants.AvailableCloudProviders,
        ExcludeCategoriesFlag: constants.AvailableCategories,
        ExcludeSeveritiesFlag: convertSliceToDummyMap(constants.AvailableSeverities),
        FailOnFlag:            convertSliceToDummyMap(constants.AvailableSeverities),
        ReportFormatsFlag:     convertSliceToDummyMap(append([]string{"all"}, helpers.ListReportFormats()...)),
        TypeFlag:              constants.AvailablePlatforms,
        ExcludeTypeFlag:       constants.AvailablePlatforms,
}

func sliceFlagsShouldNotStartWithFlags(flagName string) error <span class="cov3" title="3">{
        values := GetMultiStrFlag(flagName)
        re := regexp.MustCompile(`^--[a-z-]+$`)
        if len(values) &gt; 0 </span><span class="cov3" title="3">{
                firstArg := values[0]
                if strings.HasPrefix(firstArg, "-") &amp;&amp; len(firstArg) == 2 || re.MatchString(firstArg) </span><span class="cov2" title="2">{
                        return fmt.Errorf("flag needs an argument: %s", flagName)
                }</span>
        }
        <span class="cov1" title="1">return nil</span>
}

func allQueriesID(flagName string) error <span class="cov2" title="2">{
        queriesID := GetMultiStrFlag(flagName)
        for _, queryID := range queriesID </span><span class="cov3" title="3">{
                if !isQueryID(queryID) </span><span class="cov1" title="1">{
                        return fmt.Errorf("invalid argument --%s: %s is not a valid query ID", flagName, queryID)
                }</span>
        }
        <span class="cov1" title="1">return nil</span>
}

func validateMultiStrEnum(flagName string) error <span class="cov4" title="4">{
        enums := GetMultiStrFlag(flagName)
        invalidEnum := make([]string, 0)
        caseInsensitiveMap := make(map[string]string)
        for key, value := range validMultiStrEnums[flagName] </span><span class="cov10" title="62">{
                caseInsensitiveMap[strings.ToLower(key)] = value
        }</span>
        <span class="cov4" title="4">for _, enum := range enums </span><span class="cov4" title="6">{
                if _, ok := caseInsensitiveMap[strings.ToLower(enum)]; enum != "" &amp;&amp; !ok </span><span class="cov3" title="3">{
                        invalidEnum = append(invalidEnum, enum)
                }</span>
        }
        <span class="cov4" title="4">validEnumsValues := utils.SortedKeys(validMultiStrEnums[flagName])
        if len(invalidEnum) &gt; 0 </span><span class="cov2" title="2">{
                return fmt.Errorf(
                        "unknown argument(s) for --%s: %s\nvalid arguments:\n  %s",
                        flagName,
                        strings.Join(invalidEnum, ", "),
                        strings.Join(validEnumsValues, "\n  "),
                )
        }</span>
        <span class="cov2" title="2">return nil</span>
}

func validateWorkersFlag(flagName string) error <span class="cov3" title="3">{
        workers := GetIntFlag(flagName)
        if workers &lt; 0 </span><span class="cov1" title="1">{
                return fmt.Errorf("invalid argument --%s: value must be greater or equal to 0", flagName)
        }</span>
        <span class="cov2" title="2">if workers &gt; runtime.GOMAXPROCS(-1) </span><span class="cov0" title="0">{
                now := time.Now()
                timeStr := now.Format("03:04PM")
                fmt.Println("\x1b[90m" + timeStr + " \x1b[31mWRN\x1b[0m Number of workers is greater than the number of logical CPUs")
                return nil
        }</span>
        <span class="cov2" title="2">return nil</span>
}
</pre>
		
		<pre class="file" id="file8" style="display: none">package flags

import (
        "errors"
        "regexp"
)

func validatePath(flagName string) error <span class="cov10" title="18">{
        relPath := `^(?:\.\.\\|\.\\|\.\.\/|\.\/|\\|\/)?(?:[^&lt;&gt;:"\/\\|?*]+[\\\/])*[^&lt;&gt;:"\/\\|?*]+(\/|\\)?$`
        absPath := `^[a-zA-Z]:[\\\/](?:[^&lt;&gt;:"\/\\|?*]+[\\\/])*[^&lt;&gt;:"\/\\|?*]+(?:\/|\\)?$`
        regex := regexp.MustCompile(relPath + `|` + absPath)

        path := GetStrFlag(flagName)
        isValid := regex.MatchString(path) || path == ""

        if !isValid </span><span class="cov7" title="9">{
                errorMsg := "the directory name you provided for the " + flagName + " flag contains invalid characters"
                return errors.New(errorMsg)
        }</span>

        <span class="cov7" title="9">return nil</span>
}
</pre>
		
		<pre class="file" id="file9" style="display: none">package flags

import (
        "fmt"
        "strings"

        "github.com/Checkmarx/kics/v2/internal/constants"
        "github.com/Checkmarx/kics/v2/pkg/utils"
)

var validStrEnums = map[string]map[string]string{
        LogLevelFlag: convertSliceToDummyMap(constants.AvailableLogLevels),
}

func validateStrEnum(flagName string) error <span class="cov3" title="2">{
        value := GetStrFlag(flagName)
        caseInsensitiveMap := make(map[string]string)
        for key, value := range validStrEnums[flagName] </span><span class="cov10" title="12">{
                caseInsensitiveMap[strings.ToLower(key)] = value
        }</span>
        <span class="cov3" title="2">validEnumsValues := utils.SortedKeys(validStrEnums[flagName])
        if _, ok := caseInsensitiveMap[strings.ToLower(value)]; value != "" &amp;&amp; !ok </span><span class="cov1" title="1">{
                return fmt.Errorf(
                        "unknown argument for --%s: %s\nvalid arguments:\n  %s",
                        flagName,
                        value,
                        strings.Join(validEnumsValues, "\n  "),
                )
        }</span>
        <span class="cov1" title="1">return nil</span>
}
</pre>
		
		<pre class="file" id="file10" style="display: none">package console

import (
        "fmt"

        "github.com/google/uuid"
        "github.com/rs/zerolog/log"
        "github.com/spf13/cobra"
)

// NewGenerateIDCmd creates a new instance of the generate-id Command
func NewGenerateIDCmd() *cobra.Command <span class="cov10" title="21">{
        return &amp;cobra.Command{
                Use:   "generate-id",
                Short: "Generates uuid for query",
                RunE: func(cmd *cobra.Command, args []string) error </span><span class="cov1" title="1">{
                        _, err := fmt.Fprintln(cmd.OutOrStdout(), uuid.New().String())
                        if err != nil </span><span class="cov0" title="0">{
                                log.Err(err).Msg("failed to get uuid")
                        }</span>
                        <span class="cov1" title="1">return err</span>
                },
        }
}
</pre>
		
		<pre class="file" id="file11" style="display: none">package helpers

import (
        "fmt"
        "strings"

        "github.com/Checkmarx/kics/v2/pkg/model"
)

var shouldIgnore string
var shouldFail map[string]struct{}

// ResultsExitCode calculate exit code base on severity of results, returns 0 if no results was reported
func ResultsExitCode(summary *model.Summary) int <span class="cov5" title="4">{
        // severityArr is needed to make sure 'for' cycle is made in an ordered fashion
        severityArr := []model.Severity{"CRITICAL", "HIGH", "MEDIUM", "LOW", "INFO", "TRACE"}
        codeMap := map[model.Severity]int{"CRITICAL": 60, "HIGH": 50, "MEDIUM": 40, "LOW": 30, "INFO": 20, "TRACE": 0}
        exitMap := summary.SeveritySummary.SeverityCounters
        for _, severity := range severityArr </span><span class="cov9" title="12">{
                if _, reportSeverity := shouldFail[strings.ToLower(string(severity))]; !reportSeverity </span><span class="cov7" title="7">{
                        continue</span>
                }
                <span class="cov6" title="5">if exitMap[severity] &gt; 0 </span><span class="cov4" title="3">{
                        return codeMap[severity]
                }</span>
        }
        <span class="cov1" title="1">return 0</span>
}

// InitShouldIgnoreArg initializes what kind of errors should be used on exit codes
func InitShouldIgnoreArg(arg string) error <span class="cov7" title="7">{
        validArgs := []string{"none", "all", "results", "errors"}
        for _, validArg := range validArgs </span><span class="cov10" title="16">{
                if strings.EqualFold(validArg, arg) </span><span class="cov6" title="6">{
                        shouldIgnore = strings.ToLower(arg)
                        return nil
                }</span>
        }
        <span class="cov1" title="1">return fmt.Errorf("unknown argument for --ignore-on-exit: %s\nvalid arguments:\n  %s", arg, strings.Join(validArgs, "\n  "))</span>
}

// InitShouldFailArg initializes which kind of vulnerability severity should changes exit code
func InitShouldFailArg(args []string) error <span class="cov5" title="4">{
        possibleArgs := map[string]struct{}{
                "critical": {},
                "high":     {},
                "medium":   {},
                "low":      {},
                "info":     {},
        }
        if len(args) == 0 </span><span class="cov1" title="1">{
                shouldFail = possibleArgs
                return nil
        }</span>

        <span class="cov4" title="3">argsConverted := make(map[string]struct{})
        for _, arg := range args </span><span class="cov7" title="7">{
                if _, ok := possibleArgs[strings.ToLower(arg)]; !ok </span><span class="cov1" title="1">{
                        validArgs := []string{"critical", "high", "medium", "low", "info"}
                        return fmt.Errorf("unknown argument for --fail-on: %s\nvalid arguments:\n  %s", arg, strings.Join(validArgs, "\n  "))
                }</span>
                <span class="cov6" title="6">argsConverted[strings.ToLower(arg)] = struct{}{}</span>
        }

        <span class="cov3" title="2">shouldFail = argsConverted
        return nil</span>
}

// ShowError returns true if should show error, otherwise returns false
func ShowError(kind string) bool <span class="cov5" title="4">{
        return strings.EqualFold(shouldIgnore, "none") || (!strings.EqualFold(shouldIgnore, "all") &amp;&amp; !strings.EqualFold(shouldIgnore, kind))
}</span>

// RemediateExitCode calculate exit code base on the difference between remediation selected and done
func RemediateExitCode(selectedRemediationNumber, actualRemediationDoneNumber int) int <span class="cov3" title="2">{
        statusCode := 70
        if selectedRemediationNumber != actualRemediationDoneNumber </span><span class="cov1" title="1">{
                // KICS AR was not able to remediate all the selected remediation
                return statusCode
        }</span>

        <span class="cov1" title="1">return 0</span>
}
</pre>
		
		<pre class="file" id="file12" style="display: none">package helpers

import (
        "bufio"
        "encoding/json"
        "errors"
        "fmt"
        "io"
        "os"
        "path/filepath"
        "runtime"
        "sort"
        "strconv"
        "strings"

        "github.com/BurntSushi/toml"
        "github.com/Checkmarx/kics/v2/internal/metrics"
        "github.com/Checkmarx/kics/v2/pkg/progress"
        "github.com/Checkmarx/kics/v2/pkg/report"
        "github.com/hashicorp/hcl"
        "github.com/rs/zerolog"
        "github.com/rs/zerolog/log"
        "gopkg.in/yaml.v3"
)

const divisor = float32(100000)

var reportGenerators = map[string]func(path, filename string, body interface{}) error{
        "json":        report.PrintJSONReport,
        "sarif":       report.PrintSarifReport,
        "html":        report.PrintHTMLReport,
        "glsast":      report.PrintGitlabSASTReport,
        "pdf":         report.PrintPdfReport,
        "sonarqube":   report.PrintSonarQubeReport,
        "cyclonedx":   report.PrintCycloneDxReport,
        "junit":       report.PrintJUnitReport,
        "asff":        report.PrintASFFReport,
        "csv":         report.PrintCSVReport,
        "codeclimate": report.PrintCodeClimateReport,
}

// CustomConsoleWriter creates an output to print log in a files
func CustomConsoleWriter(fileLogger *zerolog.ConsoleWriter) zerolog.ConsoleWriter <span class="cov1" title="1">{
        fileLogger.FormatLevel = func(i interface{}) string </span><span class="cov0" title="0">{
                return strings.ToUpper(fmt.Sprintf("| %-6s|", i))
        }</span>

        <span class="cov1" title="1">fileLogger.FormatFieldName = func(i interface{}) string </span><span class="cov0" title="0">{
                return fmt.Sprintf("%s:", i)
        }</span>

        <span class="cov1" title="1">fileLogger.FormatErrFieldName = func(i interface{}) string </span><span class="cov0" title="0">{
                return "ERROR:"
        }</span>

        <span class="cov1" title="1">fileLogger.FormatFieldValue = func(i interface{}) string </span><span class="cov0" title="0">{
                return fmt.Sprintf("%s", i)
        }</span>

        <span class="cov1" title="1">return *fileLogger</span>
}

// FileAnalyzer determines the type of extension in the passed config file by its content
func FileAnalyzer(path string) (string, error) <span class="cov10" title="12">{
        ostat, err := os.Open(filepath.Clean(path))
        if err != nil </span><span class="cov1" title="1">{
                return "", err
        }</span>
        <span class="cov9" title="11">rc, err := io.ReadAll(ostat)
        if err != nil </span><span class="cov0" title="0">{
                return "", err
        }</span>
        <span class="cov9" title="11">var temp map[string]interface{}

        // CxSAST query under review
        if err := json.Unmarshal(rc, &amp;temp); err == nil </span><span class="cov3" title="2">{
                return "json", nil
        }</span>

        // CxSAST query under review
        <span class="cov8" title="9">if err := yaml.Unmarshal(rc, &amp;temp); err == nil </span><span class="cov4" title="3">{
                return "yaml", nil
        }</span>

        // CxSAST query under review
        <span class="cov7" title="6">if _, err := toml.Decode(string(rc), &amp;temp); err == nil </span><span class="cov3" title="2">{
                return "toml", nil
        }</span>

        // CxSAST query under review
        <span class="cov6" title="4">if c, err := hcl.Parse(string(rc)); err == nil </span><span class="cov3" title="2">{
                if err = hcl.DecodeObject(&amp;temp, c); err == nil </span><span class="cov3" title="2">{
                        return "hcl", nil
                }</span>
        }

        <span class="cov3" title="2">return "", errors.New("invalid configuration file format")</span>
}

// GenerateReport execute each report function to generate report
func GenerateReport(path, filename string, body interface{}, formats []string, proBarBuilder progress.PbBuilder) error <span class="cov6" title="4">{
        log.Debug().Msgf("helpers.GenerateReport()")
        metrics.Metric.Start("generate_report")

        progressBar := proBarBuilder.BuildCircle("Generating Reports: ")

        var err error = nil
        go progressBar.Start()
        defer progressBar.Close()

        for _, format := range formats </span><span class="cov6" title="4">{
                format = strings.ToLower(format)
                if err = reportGenerators[format](path, filename, body); err != nil </span><span class="cov1" title="1">{
                        log.Error().Msgf("Failed to generate %s report", format)
                        break</span>
                }
        }
        <span class="cov6" title="4">metrics.Metric.Stop()
        return err</span>
}

// GetExecutableDirectory - returns the path to the directory containing KICS executable
func GetExecutableDirectory() string <span class="cov3" title="2">{
        log.Debug().Msg("helpers.GetExecutableDirectory()")
        path, err := os.Executable()
        if err != nil </span><span class="cov0" title="0">{
                log.Err(err)
        }</span>
        <span class="cov3" title="2">return filepath.Dir(path)</span>
}

// GetDefaultQueryPath - returns the default query path
func GetDefaultQueryPath(queriesPath string) (string, error) <span class="cov3" title="2">{
        log.Debug().Msg("helpers.GetDefaultQueryPath()")
        queriesDirectory, err := GetFullPath(queriesPath)
        if err != nil </span><span class="cov1" title="1">{
                return "", err
        }</span>
        <span class="cov1" title="1">log.Debug().Msgf("Queries found in %s", queriesDirectory)
        return queriesDirectory, nil</span>
}

// GetFulPath returns the full path of a partial path used for queries or experimental queries json path
func GetFullPath(partialPath string) (string, error) <span class="cov3" title="2">{
        executableDirPath := GetExecutableDirectory()
        fullPath := filepath.Join(executableDirPath, partialPath)
        if _, err := os.Stat(fullPath); os.IsNotExist(err) </span><span class="cov3" title="2">{
                currentWorkDir, err := os.Getwd()
                if err != nil </span><span class="cov0" title="0">{
                        return "", err
                }</span>
                <span class="cov3" title="2">idx := strings.Index(currentWorkDir, "kics")
                if idx != -1 </span><span class="cov3" title="2">{
                        currentWorkDir = currentWorkDir[:strings.LastIndex(currentWorkDir, "kics")] + "kics"
                }</span>
                <span class="cov3" title="2">fullPath = filepath.Join(currentWorkDir, partialPath)
                if _, err := os.Stat(fullPath); os.IsNotExist(err) </span><span class="cov1" title="1">{
                        return "", err
                }</span>
        }

        <span class="cov1" title="1">return fullPath, nil</span>
}

// ListReportFormats return a slice with all supported report formats
func ListReportFormats() []string <span class="cov1" title="1">{
        supportedFormats := make([]string, 0, len(reportGenerators))
        for reportFormats := range reportGenerators </span><span class="cov9" title="11">{
                supportedFormats = append(supportedFormats, reportFormats)
        }</span>
        <span class="cov1" title="1">sort.Strings(supportedFormats)
        return supportedFormats</span>
}

// GetNumCPU return the number of cpus available
func GetNumCPU() float32 <span class="cov1" title="1">{
        // Check if application is running inside docker
        _, err := os.Stat("/.dockerenv")
        if err == nil </span><span class="cov0" title="0">{
                numCPU, err := getCPUFromQuotaUS()
                if err == nil </span><span class="cov0" title="0">{
                        return numCPU
                }</span>
                <span class="cov0" title="0">numCPU, err = getCPUFromCPUMax()
                if err == nil </span><span class="cov0" title="0">{
                        return numCPU
                }</span>
        }

        <span class="cov1" title="1">return float32(runtime.NumCPU())</span>
}

func getCPUFromQuotaUS() (float32, error) <span class="cov0" title="0">{
        f, err := os.Open("/sys/fs/cgroup/cpu/cpu.cfs_quota_us")
        if err != nil </span><span class="cov0" title="0">{
                return -1, err
        }</span>

        <span class="cov0" title="0">defer func() </span><span class="cov0" title="0">{
                if err := f.Close(); err != nil </span><span class="cov0" title="0">{
                        log.Err(err).Msg("failed to close '/sys/fs/cgroup/cpu/cpu.cfs_quota_us'")
                }</span>
        }()

        <span class="cov0" title="0">scanner := bufio.NewScanner(f)
        if scanner.Scan() </span><span class="cov0" title="0">{
                text := scanner.Text()
                cpus, err := strconv.Atoi(text)
                if err != nil </span><span class="cov0" title="0">{
                        return float32(cpus) / divisor, err
                }</span>

                <span class="cov0" title="0">if cpus != -1 </span><span class="cov0" title="0">{
                        return float32(cpus) / divisor, nil
                }</span>

                <span class="cov0" title="0">return float32(runtime.NumCPU()), nil</span>
        }

        <span class="cov0" title="0">return float32(runtime.NumCPU()), nil</span>
}

func getCPUFromCPUMax() (float32, error) <span class="cov0" title="0">{
        f, err := os.Open("/sys/fs/cgroup/cpu.max")
        if err != nil </span><span class="cov0" title="0">{
                return -1, err
        }</span>

        <span class="cov0" title="0">defer func() </span><span class="cov0" title="0">{
                if err := f.Close(); err != nil </span><span class="cov0" title="0">{
                        log.Err(err).Msg("failed to close '/sys/fs/cgroup/cpu.max'")
                }</span>
        }()

        <span class="cov0" title="0">scanner := bufio.NewScanner(f)
        if scanner.Scan() </span><span class="cov0" title="0">{
                text := scanner.Text()
                stringCpus := strings.Split(text, " ")[0]
                cpus, err := strconv.Atoi(stringCpus)
                if err != nil </span><span class="cov0" title="0">{
                        return float32(cpus) / divisor, err
                }</span>

                <span class="cov0" title="0">if cpus != -1 </span><span class="cov0" title="0">{
                        return float32(cpus) / divisor, nil
                }</span>

                <span class="cov0" title="0">return float32(runtime.NumCPU()), nil</span>
        }

        <span class="cov0" title="0">return float32(runtime.NumCPU()), nil</span>
}
</pre>
		
		<pre class="file" id="file13" style="display: none">package console

import (
        "context"
        _ "embed" // Embed kics flags
        "os"
        "time"

        "github.com/Checkmarx/kics/v2/internal/console/flags"
        "github.com/Checkmarx/kics/v2/internal/constants"
        sentryReport "github.com/Checkmarx/kics/v2/internal/sentry"
        "github.com/Checkmarx/kics/v2/pkg/engine/source"
        "github.com/Checkmarx/kics/v2/pkg/printer"
        "github.com/getsentry/sentry-go"
        "github.com/rs/zerolog"
        "github.com/rs/zerolog/log"
        "github.com/spf13/cobra"
        "github.com/spf13/viper"
)

const (
        scanID = "console"
)

var (
        //go:embed assets/kics-flags.json
        kicsFlagsListContent string

        // warnings - a buffer to accumulate warnings before the printer gets initialized
        warnings = make([]string, 0)

        ctx = context.Background()
)

// NewKICSCmd creates a new instance of the kics Command
func NewKICSCmd() *cobra.Command <span class="cov10" title="21">{
        return &amp;cobra.Command{
                Use:   "kics",
                Short: constants.Fullname,
        }
}</span>

func initialize(rootCmd *cobra.Command) error <span class="cov10" title="21">{
        scanCmd := NewScanCmd()
        remediateCmd := NewRemediateCmd()
        analyzeCmd := NewAnalyzeCmd()
        rootCmd.AddCommand(NewVersionCmd())
        rootCmd.AddCommand(NewGenerateIDCmd())
        rootCmd.AddCommand(scanCmd)
        rootCmd.AddCommand(NewListPlatformsCmd())
        rootCmd.AddCommand(remediateCmd)
        rootCmd.AddCommand(analyzeCmd)
        rootCmd.CompletionOptions.DisableDefaultCmd = true

        if err := flags.InitJSONFlags(
                rootCmd,
                kicsFlagsListContent,
                true,
                source.ListSupportedPlatforms(),
                source.ListSupportedCloudProviders()); err != nil </span><span class="cov0" title="0">{
                return err
        }</span>

        <span class="cov10" title="21">if err := viper.BindPFlags(rootCmd.PersistentFlags()); err != nil </span><span class="cov0" title="0">{
                return err
        }</span>

        <span class="cov10" title="21">if err := initRemediateCmd(remediateCmd); err != nil </span><span class="cov0" title="0">{
                return err
        }</span>

        <span class="cov10" title="21">if err := initAnalyzeCmd(analyzeCmd); err != nil </span><span class="cov0" title="0">{
                return err
        }</span>

        <span class="cov10" title="21">return initScanCmd(scanCmd)</span>
}

// Execute starts kics execution
func Execute() error <span class="cov10" title="21">{
        zerolog.SetGlobalLevel(zerolog.InfoLevel)

        enableCrashReport()

        rootCmd := NewKICSCmd()

        if err := initialize(rootCmd); err != nil </span><span class="cov0" title="0">{
                sentryReport.ReportSentry(&amp;sentryReport.Report{
                        Message:  "Failed to initialize CLI",
                        Err:      err,
                        Location: "func Execute()",
                }, true)
                return err
        }</span>

        <span class="cov10" title="21">if err := rootCmd.ExecuteContext(ctx); err != nil </span><span class="cov5" title="5">{
                sentryReport.ReportSentry(&amp;sentryReport.Report{
                        Message:  "Failed to run application",
                        Err:      err,
                        Location: "func Execute()",
                }, printer.IsInitialized())
                return err
        }</span>

        <span class="cov9" title="16">return nil</span>
}

func enableCrashReport() <span class="cov10" title="21">{
        enableCrashReport, found := os.LookupEnv("DISABLE_CRASH_REPORT")
        if found &amp;&amp; (enableCrashReport == "0" || enableCrashReport == "false") </span><span class="cov0" title="0">{
                initSentry("")
        }</span> else<span class="cov10" title="21"> {
                initSentry(constants.SentryDSN)
        }</span>
}

func initSentry(dsn string) <span class="cov10" title="21">{
        var err error
        if dsn == "" </span><span class="cov10" title="21">{
                warnings = append(warnings, "KICS crash report disabled")
                err = sentry.Init(sentry.ClientOptions{
                        Release: constants.GetRelease(),
                })
        }</span> else<span class="cov0" title="0"> {
                err = sentry.Init(sentry.ClientOptions{
                        Dsn:     dsn,
                        Release: constants.GetRelease(),
                })
        }</span>
        <span class="cov10" title="21">if err != nil </span><span class="cov0" title="0">{
                log.Err(err).Msg("Failed to initialize sentry")
        }</span>
        <span class="cov10" title="21">sentry.Flush(constants.SentryRefreshRate * time.Second)</span>
}
</pre>
		
		<pre class="file" id="file14" style="display: none">package console

import (
        "fmt"

        "github.com/Checkmarx/kics/v2/pkg/engine/source"
        "github.com/spf13/cobra"
)

// NewListPlatformsCmd creates a new instance of the list-platforms Command
func NewListPlatformsCmd() *cobra.Command <span class="cov10" title="21">{
        return &amp;cobra.Command{
                Use:   "list-platforms",
                Short: "List supported platforms",
                RunE: func(cmd *cobra.Command, args []string) error </span><span class="cov1" title="1">{
                        for _, v := range source.ListSupportedPlatforms() </span><span class="cov9" title="17">{
                                fmt.Fprintf(cmd.OutOrStdout(), "%s\n", v)
                        }</span>
                        <span class="cov1" title="1">return nil</span>
                },
        }
}
</pre>
		
		<pre class="file" id="file15" style="display: none">package console

import (
        _ "embed" // Embed kics CLI img and scan-flags
        "fmt"
        "os"
        "path/filepath"
        "runtime"
        "strings"

        "code.cloudfoundry.org/bytefmt"
        "github.com/Checkmarx/kics/v2/internal/console/flags"
        consoleHelpers "github.com/Checkmarx/kics/v2/internal/console/helpers"
        "github.com/Checkmarx/kics/v2/internal/constants"
        "github.com/Checkmarx/kics/v2/internal/metrics"
        internalPrinter "github.com/Checkmarx/kics/v2/pkg/printer"
        "github.com/Checkmarx/kics/v2/pkg/progress"
        "github.com/mackerelio/go-osstat/memory"
        "github.com/pkg/errors"
        "github.com/rs/zerolog/log"
        "github.com/spf13/cobra"
        "github.com/spf13/viper"
)

func preRun(cmd *cobra.Command) error <span class="cov5" title="10">{
        err := initializeConfig(cmd)
        if err != nil </span><span class="cov1" title="1">{
                return errors.New(initError + err.Error())
        }</span>

        <span class="cov5" title="9">err = flags.Validate()
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>

        <span class="cov5" title="9">err = flags.ValidateQuerySelectionFlags()
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>

        <span class="cov5" title="9">err = flags.ValidateTypeSelectionFlags()
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>

        <span class="cov5" title="9">err = internalPrinter.SetupPrinter(cmd.InheritedFlags())
        if err != nil </span><span class="cov0" title="0">{
                return errors.New(initError + err.Error())
        }</span>
        <span class="cov5" title="9">err = metrics.InitializeMetrics(flags.GetStrFlag(flags.ProfilingFlag), flags.GetBoolFlag(flags.CIFlag))
        if err != nil </span><span class="cov0" title="0">{
                return errors.New(initError + err.Error())
        }</span>
        <span class="cov5" title="9">return nil</span>
}

func setupConfigFile() (bool, error) <span class="cov5" title="10">{
        if flags.GetStrFlag(flags.ConfigFlag) == "" </span><span class="cov5" title="8">{
                path := flags.GetMultiStrFlag(flags.PathFlag)
                if len(path) == 0 </span><span class="cov0" title="0">{
                        return true, nil
                }</span>
                <span class="cov5" title="8">if len(path) &gt; 1 </span><span class="cov1" title="1">{
                        warnings = append(warnings, "Any kics.config file will be ignored, please use --config if kics.config is wanted")
                        return true, nil
                }</span>
                <span class="cov4" title="7">configPath := path[0]
                info, err := os.Stat(configPath)
                if err != nil </span><span class="cov0" title="0">{
                        return true, nil
                }</span>
                <span class="cov4" title="7">if !info.IsDir() </span><span class="cov4" title="6">{
                        configPath = filepath.Dir(configPath)
                }</span>
                <span class="cov4" title="7">_, err = os.Stat(filepath.ToSlash(filepath.Join(configPath, constants.DefaultConfigFilename)))
                if err != nil </span><span class="cov4" title="7">{
                        if os.IsNotExist(err) </span><span class="cov4" title="7">{
                                return true, nil
                        }</span>
                        <span class="cov0" title="0">return true, err</span>
                }
                <span class="cov0" title="0">flags.SetStrFlag(flags.ConfigFlag, filepath.ToSlash(filepath.Join(configPath, constants.DefaultConfigFilename)))</span>
        }
        <span class="cov2" title="2">return false, nil</span>
}

func initializeConfig(cmd *cobra.Command) error <span class="cov5" title="10">{
        log.Debug().Msg("console.initializeConfig()")

        v := viper.New()
        v.SetEnvPrefix("KICS")
        v.AutomaticEnv()
        errBind := flags.BindFlags(cmd, v)
        if errBind != nil </span><span class="cov0" title="0">{
                return errBind
        }</span>

        <span class="cov5" title="10">exit, err := setupConfigFile()
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>
        <span class="cov5" title="10">if exit </span><span class="cov5" title="8">{
                return nil
        }</span>

        <span class="cov2" title="2">base := filepath.Base(flags.GetStrFlag(flags.ConfigFlag))
        v.SetConfigName(base)
        v.AddConfigPath(filepath.Dir(flags.GetStrFlag(flags.ConfigFlag)))
        ext, err := consoleHelpers.FileAnalyzer(flags.GetStrFlag(flags.ConfigFlag))
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>
        <span class="cov2" title="2">v.SetConfigType(ext)
        if err := v.ReadInConfig(); err != nil </span><span class="cov0" title="0">{
                return err
        }</span>

        <span class="cov2" title="2">errBind = flags.BindFlags(cmd, v)
        if errBind != nil </span><span class="cov1" title="1">{
                return errBind
        }</span>
        <span class="cov1" title="1">return nil</span>
}

type console struct {
        Printer       *internalPrinter.Printer
        ProBarBuilder *progress.PbBuilder
}

func newConsole() *console <span class="cov5" title="10">{
        return &amp;console{}
}</span>

// preScan is responsible for scan preparation
func (console *console) preScan() <span class="cov5" title="10">{
        log.Debug().Msg("console.scan()")
        for _, warn := range warnings </span><span class="cov10" title="93">{
                log.Warn().Msgf(warn)
        }</span>

        <span class="cov5" title="10">printer := internalPrinter.NewPrinter(flags.GetBoolFlag(flags.MinimalUIFlag))
        printer.Success.Printf("\n%s\n", banner)

        versionMsg := fmt.Sprintf("\nScanning with %s\n\n", constants.GetVersion())
        fmt.Println(versionMsg)
        log.Info().Msgf(strings.ReplaceAll(versionMsg, "\n", ""))

        log.Info().Msgf("Operating system: %s", runtime.GOOS)

        mem, err := memory.Get()
        if err != nil </span><span class="cov0" title="0">{
                log.Err(err)
        }</span> else<span class="cov5" title="10"> {
                log.Info().Msgf("Total memory: %s", bytefmt.ByteSize(mem.Total))
        }</span>

        <span class="cov5" title="10">cpu := consoleHelpers.GetNumCPU()
        log.Info().Msgf("CPU: %.1f", cpu)

        log.Info().Msgf("Max file size permitted for scanning: %d MB", flags.GetIntFlag(flags.MaxFileSizeFlag))
        log.Info().Msgf("Max resolver depth permitted for resolving files: %d", flags.GetIntFlag(flags.MaxResolverDepth))

        noProgress := flags.GetBoolFlag(flags.NoProgressFlag)
        if strings.EqualFold(flags.GetStrFlag(flags.LogLevelFlag), "debug") </span><span class="cov0" title="0">{
                noProgress = true
        }</span>

        <span class="cov5" title="10">proBarBuilder := progress.InitializePbBuilder(
                noProgress,
                flags.GetBoolFlag(flags.CIFlag),
                flags.GetBoolFlag(flags.SilentFlag))

        console.Printer = printer
        console.ProBarBuilder = proBarBuilder</span>
}
</pre>
		
		<pre class="file" id="file16" style="display: none">package console

import (
        _ "embed" // Embed remediate flags
        "encoding/json"
        "fmt"
        "os"
        "path/filepath"

        "github.com/Checkmarx/kics/v2/internal/console/flags"
        consoleHelpers "github.com/Checkmarx/kics/v2/internal/console/helpers"
        sentryReport "github.com/Checkmarx/kics/v2/internal/sentry"
        "github.com/Checkmarx/kics/v2/pkg/engine/source"
        internalPrinter "github.com/Checkmarx/kics/v2/pkg/printer"
        "github.com/Checkmarx/kics/v2/pkg/remediation"
        "github.com/pkg/errors"
        "github.com/rs/zerolog/log"
        "github.com/spf13/cobra"
)

var (
        //go:embed assets/remediate-flags.json
        remediateFlagsListContent string
)

// NewRemediateCmd creates a new instance of the remediate Command
func NewRemediateCmd() *cobra.Command <span class="cov10" title="21">{
        return &amp;cobra.Command{
                Use:   "remediate",
                Short: "Auto remediates the project",
                PersistentPreRunE: func(cmd *cobra.Command, args []string) error </span><span class="cov5" title="5">{
                        return preRemediate(cmd)
                }</span>,
                RunE: func(cmd *cobra.Command, args []string) error <span class="cov5" title="4">{
                        return remediate()
                }</span>,
        }
}

func initRemediateCmd(remediateCmd *cobra.Command) error <span class="cov10" title="21">{
        if err := flags.InitJSONFlags(
                remediateCmd,
                remediateFlagsListContent,
                false,
                source.ListSupportedPlatforms(),
                source.ListSupportedCloudProviders()); err != nil </span><span class="cov0" title="0">{
                return err
        }</span>

        <span class="cov10" title="21">if err := remediateCmd.MarkFlagRequired(flags.Results); err != nil </span><span class="cov0" title="0">{
                sentryReport.ReportSentry(&amp;sentryReport.Report{
                        Message:  "Failed to add command required flags",
                        Err:      err,
                        Location: "func initScanCmd()",
                }, true)
                log.Err(err).Msg("Failed to add command required flags")
        }</span>
        <span class="cov10" title="21">return nil</span>
}

func preRemediate(cmd *cobra.Command) error <span class="cov5" title="5">{
        err := flags.Validate()
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>

        <span class="cov5" title="5">err = flags.ValidateQuerySelectionFlags()
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>
        <span class="cov5" title="5">err = internalPrinter.SetupPrinter(cmd.InheritedFlags())
        if err != nil </span><span class="cov0" title="0">{
                return errors.New(initError + err.Error())
        }</span>
        <span class="cov5" title="5">return err</span>
}

func remediate() error <span class="cov5" title="4">{
        resultsPath := flags.GetStrFlag(flags.Results)
        include := flags.GetMultiStrFlag(flags.IncludeIds)
        openAPIResolveReferences := flags.GetBoolFlag(flags.OpenAPIReferencesFlag)
        maxResolverDepth := flags.GetIntFlag(flags.MaxResolverDepth)

        filepath.Clean(resultsPath)

        content, err := os.ReadFile(resultsPath)
        if err != nil </span><span class="cov1" title="1">{
                log.Error().Msgf("failed to read file: %s", err)
                return err
        }</span>

        <span class="cov4" title="3">results := remediation.Report{}

        err = json.Unmarshal(content, &amp;results)
        if err != nil </span><span class="cov1" title="1">{
                log.Error().Msgf("failed to unmarshal file: %s", err)
                return err
        }</span>

        <span class="cov3" title="2">summary := &amp;remediation.Summary{
                SelectedRemediationNumber:   0,
                ActualRemediationDoneNumber: 0,
        }

        // get all the remediationSets related to each filePath
        remediationSets := summary.GetRemediationSets(results, include)

        for filePath := range remediationSets </span><span class="cov3" title="2">{
                fix := remediationSets[filePath].(remediation.Set)
                err = summary.RemediateFile(filePath, fix, openAPIResolveReferences, maxResolverDepth)
                if err != nil </span><span class="cov0" title="0">{
                        return err
                }</span>
        }

        <span class="cov3" title="2">fmt.Printf("\nSelected remediation: %d\n", summary.SelectedRemediationNumber)
        fmt.Printf("Remediation done: %d\n", summary.ActualRemediationDoneNumber)

        exitCode := consoleHelpers.RemediateExitCode(summary.SelectedRemediationNumber, summary.ActualRemediationDoneNumber)
        if exitCode != 0 </span><span class="cov0" title="0">{
                os.Exit(exitCode)
        }</span>

        <span class="cov3" title="2">return nil</span>
}
</pre>
		
		<pre class="file" id="file17" style="display: none">package console

import (
        _ "embed" // Embed kics CLI img and scan-flags
        "os"
        "os/signal"
        "path/filepath"
        "strings"
        "syscall"

        "github.com/Checkmarx/kics/v2/internal/console/flags"
        consoleHelpers "github.com/Checkmarx/kics/v2/internal/console/helpers"
        "github.com/Checkmarx/kics/v2/internal/constants"
        sentryReport "github.com/Checkmarx/kics/v2/internal/sentry"
        "github.com/Checkmarx/kics/v2/pkg/engine/source"
        "github.com/Checkmarx/kics/v2/pkg/scan"
        "github.com/rs/zerolog/log"
        "github.com/spf13/cobra"
)

var (
        //go:embed assets/kics-console
        banner string

        //go:embed assets/scan-flags.json
        scanFlagsListContent string
)

const (
        scanCommandStr = "scan"
        initError      = "initialization error - "
)

// NewScanCmd creates a new instance of the scan Command
func NewScanCmd() *cobra.Command <span class="cov10" title="21">{
        return &amp;cobra.Command{
                Use:   scanCommandStr,
                Short: "Executes a scan analysis",
                PersistentPreRunE: func(cmd *cobra.Command, args []string) error </span><span class="cov7" title="10">{
                        return preRun(cmd)
                }</span>,
                RunE: func(cmd *cobra.Command, args []string) error <span class="cov7" title="9">{
                        return run(cmd)
                }</span>,
        }
}

func initScanCmd(scanCmd *cobra.Command) error <span class="cov10" title="21">{
        if err := flags.InitJSONFlags(
                scanCmd,
                scanFlagsListContent,
                false,
                source.ListSupportedPlatforms(),
                source.ListSupportedCloudProviders()); err != nil </span><span class="cov0" title="0">{
                return err
        }</span>

        <span class="cov10" title="21">if err := scanCmd.MarkFlagRequired(flags.PathFlag); err != nil </span><span class="cov0" title="0">{
                sentryReport.ReportSentry(&amp;sentryReport.Report{
                        Message:  "Failed to add command required flags",
                        Err:      err,
                        Location: "func initScanCmd()",
                }, true)
                log.Err(err).Msg("Failed to add command required flags")
        }</span>
        <span class="cov10" title="21">return nil</span>
}

func run(cmd *cobra.Command) error <span class="cov7" title="9">{
        changedDefaultQueryPath := cmd.Flags().Lookup(flags.QueriesPath).Changed
        changedDefaultLibrariesPath := cmd.Flags().Lookup(flags.LibrariesPath).Changed
        if err := consoleHelpers.InitShouldIgnoreArg(flags.GetStrFlag(flags.IgnoreOnExitFlag)); err != nil </span><span class="cov0" title="0">{
                return err
        }</span>
        <span class="cov7" title="9">if err := consoleHelpers.InitShouldFailArg(flags.GetMultiStrFlag(flags.FailOnFlag)); err != nil </span><span class="cov0" title="0">{
                return err
        }</span>
        <span class="cov7" title="9">if flags.GetStrFlag(flags.OutputPathFlag) != "" </span><span class="cov1" title="1">{
                updateReportFormats()
                flags.SetStrFlag(flags.OutputNameFlag, filepath.Base(flags.GetStrFlag(flags.OutputNameFlag)))
                if filepath.Ext(flags.GetStrFlag(flags.OutputPathFlag)) != "" </span><span class="cov1" title="1">{
                        flags.SetStrFlag(flags.OutputPathFlag, filepath.Join(flags.GetStrFlag(flags.OutputPathFlag), string(os.PathSeparator)))
                }</span>
                <span class="cov1" title="1">if err := os.MkdirAll(flags.GetStrFlag(flags.OutputPathFlag), os.ModePerm); err != nil </span><span class="cov0" title="0">{
                        return err
                }</span>
        }
        <span class="cov7" title="9">if flags.GetStrFlag(flags.PayloadPathFlag) != "" &amp;&amp; filepath.Dir(flags.GetStrFlag(flags.PayloadPathFlag)) != "." </span><span class="cov0" title="0">{
                if err := os.MkdirAll(filepath.Dir(flags.GetStrFlag(flags.PayloadPathFlag)), os.ModePerm); err != nil </span><span class="cov0" title="0">{
                        return err
                }</span>
        }
        <span class="cov7" title="9">gracefulShutdown()

        // save the scan parameters into the ScanParameters struct
        scanParams := getScanParameters(changedDefaultQueryPath, changedDefaultLibrariesPath)

        return executeScan(scanParams)</span>
}

func updateReportFormats() <span class="cov1" title="1">{
        for _, format := range flags.GetMultiStrFlag(flags.ReportFormatsFlag) </span><span class="cov1" title="1">{
                if strings.EqualFold(format, "all") </span><span class="cov0" title="0">{
                        flags.SetMultiStrFlag(flags.ReportFormatsFlag, consoleHelpers.ListReportFormats())
                        break</span>
                }
        }
}

func getScanParameters(changedDefaultQueryPath, changedDefaultLibrariesPath bool) *scan.Parameters <span class="cov7" title="9">{
        scanParams := scan.Parameters{
                CloudProvider:               flags.GetMultiStrFlag(flags.CloudProviderFlag),
                DisableFullDesc:             flags.GetBoolFlag(flags.DisableFullDescFlag),
                ExcludeCategories:           flags.GetMultiStrFlag(flags.ExcludeCategoriesFlag),
                ExcludePaths:                flags.GetMultiStrFlag(flags.ExcludePathsFlag),
                ExcludeQueries:              flags.GetMultiStrFlag(flags.ExcludeQueriesFlag),
                ExcludeResults:              flags.GetMultiStrFlag(flags.ExcludeResultsFlag),
                ExcludeSeverities:           flags.GetMultiStrFlag(flags.ExcludeSeveritiesFlag),
                ExperimentalQueries:         flags.GetBoolFlag(flags.ExperimentalQueriesFlag),
                IncludeQueries:              flags.GetMultiStrFlag(flags.IncludeQueriesFlag),
                InputData:                   flags.GetStrFlag(flags.InputDataFlag),
                OutputName:                  flags.GetStrFlag(flags.OutputNameFlag),
                OutputPath:                  flags.GetStrFlag(flags.OutputPathFlag),
                Path:                        flags.GetMultiStrFlag(flags.PathFlag),
                PayloadPath:                 flags.GetStrFlag(flags.PayloadPathFlag),
                PreviewLines:                flags.GetIntFlag(flags.PreviewLinesFlag),
                QueriesPath:                 flags.GetMultiStrFlag(flags.QueriesPath),
                LibrariesPath:               flags.GetStrFlag(flags.LibrariesPath),
                ReportFormats:               flags.GetMultiStrFlag(flags.ReportFormatsFlag),
                Platform:                    flags.GetMultiStrFlag(flags.TypeFlag),
                ExcludePlatform:             flags.GetMultiStrFlag(flags.ExcludeTypeFlag),
                TerraformVarsPath:           flags.GetStrFlag(flags.TerraformVarsPathFlag),
                QueryExecTimeout:            flags.GetIntFlag(flags.QueryExecTimeoutFlag),
                LineInfoPayload:             flags.GetBoolFlag(flags.LineInfoPayloadFlag),
                DisableSecrets:              flags.GetBoolFlag(flags.DisableSecretsFlag),
                SecretsRegexesPath:          flags.GetStrFlag(flags.SecretsRegexesPathFlag),
                ScanID:                      scanID,
                ChangedDefaultLibrariesPath: changedDefaultLibrariesPath,
                ChangedDefaultQueryPath:     changedDefaultQueryPath,
                BillOfMaterials:             flags.GetBoolFlag(flags.BomFlag),
                ExcludeGitIgnore:            flags.GetBoolFlag(flags.ExcludeGitIgnore),
                OpenAPIResolveReferences:    flags.GetBoolFlag(flags.OpenAPIReferencesFlag),
                ParallelScanFlag:            flags.GetIntFlag(flags.ParallelScanFile),
                MaxFileSizeFlag:             flags.GetIntFlag(flags.MaxFileSizeFlag),
                UseOldSeverities:            flags.GetBoolFlag(flags.UseOldSeveritiesFlag),
                MaxResolverDepth:            flags.GetIntFlag(flags.MaxResolverDepth),
                KicsComputeNewSimID:         flags.GetBoolFlag(flags.KicsComputeNewSimIDFlag),
        }

        return &amp;scanParams
}</span>

func executeScan(scanParams *scan.Parameters) error <span class="cov7" title="9">{
        log.Debug().Msg("console.scan()")

        console := newConsole()

        console.preScan()

        client, err := scan.NewClient(scanParams, console.ProBarBuilder, console.Printer)

        if err != nil </span><span class="cov0" title="0">{
                log.Err(err)
                return err
        }</span>

        <span class="cov7" title="9">err = client.PerformScan(ctx)

        if err != nil </span><span class="cov0" title="0">{
                log.Err(err)
                return err
        }</span>

        <span class="cov7" title="9">return nil</span>
}

// gracefulShutdown catches signal interrupt and returns the appropriate exit code
func gracefulShutdown() <span class="cov7" title="9">{
        c := make(chan os.Signal)
        // This line should not be lint, since golangci-lint has an issue about it (https://github.com/golang/go/issues/45043)
        signal.Notify(c, os.Interrupt, syscall.SIGTERM) //nolint
        showErrors := consoleHelpers.ShowError("errors")
        interruptCode := constants.SignalInterruptCode
        go func(showErrors bool, interruptCode int) </span><span class="cov7" title="9">{
                &lt;-c
                if showErrors </span><span class="cov0" title="0">{
                        os.Exit(interruptCode)
                }</span>
        }(showErrors, interruptCode)
}
</pre>
		
		<pre class="file" id="file18" style="display: none">package console

import (
        "fmt"

        "github.com/Checkmarx/kics/v2/internal/constants"
        "github.com/spf13/cobra"
)

// NewVersionCmd creates a new instance of the version Command
func NewVersionCmd() *cobra.Command <span class="cov10" title="21">{
        return &amp;cobra.Command{
                Use:   "version",
                Short: "Displays the current version",
                RunE: func(cmd *cobra.Command, args []string) error </span><span class="cov1" title="1">{
                        fmt.Fprintf(cmd.OutOrStdout(), "%s\n", constants.GetVersion())
                        return nil
                }</span>,
        }
}
</pre>
		
		<pre class="file" id="file19" style="display: none">package constants

import (
        "fmt"
        "math"
        "os"
        "path/filepath"
)

var (
        // Version - current KICS version
        Version = "development"
        // SCMCommit - Source control management commit identifier
        SCMCommit = "NOCOMMIT"
        // SentryDSN - sentry DSN, unset for disabling
        SentryDSN = ""
        // BaseURL - Descriptions endpoint URL
        BaseURL = ""
        // APIScanner - API scanner feature switch
        APIScanner = ""

        // AvailableCategories - All categories and its identifies
        AvailableCategories = map[string]string{
                "Access Control":          "CAT001",
                "Availability":            "CAT002",
                "Backup":                  "CAT003",
                "Best Practices":          "CAT004",
                "Build Process":           "CAT005",
                "Encryption":              "CAT006",
                "Insecure Configurations": "CAT007",
                "Insecure Defaults":       "CAT008",
                "Networking and Firewall": "CAT009",
                "Observability":           "CAT010",
                "Resource Management":     "CAT011",
                "Secret Management":       "CAT012",
                "Supply-Chain":            "CAT013",
                "Structure and Semantics": "CAT014",
                "Bill Of Materials":       "CAT015",
        }

        // AvailablePlatforms - All platforms available
        AvailablePlatforms = map[string]string{
                "Ansible":                 "ansible",
                "CICD":                    "cicd",
                "CloudFormation":          "cloudFormation",
                "Crossplane":              "crossplane",
                "Dockerfile":              "dockerfile",
                "DockerCompose":           "dockerCompose",
                "Knative":                 "knative",
                "Kubernetes":              "k8s",
                "OpenAPI":                 "openAPI",
                "Terraform":               "terraform",
                "AzureResourceManager":    "azureResourceManager",
                "Bicep":                   "bicep",
                "GoogleDeploymentManager": "googleDeploymentManager",
                "GRPC":                    "grpc",
                "Buildah":                 "buildah",
                "Pulumi":                  "pulumi",
                "ServerlessFW":            "serverlessFW",
        }

        // AvailableSeverities - All severities available
        AvailableSeverities = []string{
                "critical",
                "high",
                "medium",
                "low",
                "info",
                "trace",
        }

        // AvailableLogLevels - All log levels available
        AvailableLogLevels = []string{
                "TRACE",
                "DEBUG",
                "INFO",
                "WARN",
                "ERROR",
                "FATAL",
        }

        // AvailableCloudProviders - All cloud providers available
        AvailableCloudProviders = map[string]string{
                "alicloud":     "",
                "aws":          "",
                "azure":        "",
                "gcp":          "",
                "nifcloud":     "",
                "tencentcloud": "",
        }
)

const (
        // Fullname - KICS fullname
        Fullname = "Keeping Infrastructure as Code Secure"

        // URL - KICS url
        URL = "https://www.kics.io/"

        // DefaultLogFile - logfile name
        DefaultLogFile = "info.log"

        // DefaultConfigFilename - default configuration filename
        DefaultConfigFilename = "kics.config"

        // MinimumPreviewLines - default minimum preview lines number
        MinimumPreviewLines = 1

        // MaximumPreviewLines - default maximum preview lines number
        MaximumPreviewLines = 30

        // EngineErrorCode - Exit Status code for error in engine
        EngineErrorCode = 126

        // SignalInterruptCode - Exit Status code for a signal interrupt
        SignalInterruptCode = 130

        // MaxInteger - max possible integer in golang
        MaxInteger = math.MaxInt64

        // SentryRefreshRate - sentry crash report refresh rate
        SentryRefreshRate = 2

        // LogFormatJSON - print log as json
        LogFormatJSON = "json"

        // LogFormatPretty - print log more readable
        LogFormatPretty = "pretty"
)

// GetRelease - returns the current release in the format 'kics@version' to be used by sentry
func GetRelease() string <span class="cov8" title="1">{
        return fmt.Sprintf("kics@%s", Version)
}</span>

// GetVersion - returns the current version in the format 'Keeping Infrastructure as Code Secure &lt;version&gt;'
func GetVersion() string <span class="cov8" title="1">{
        return fmt.Sprintf("%s %s", Fullname, Version)
}</span>

// GetDefaultLogPath - returns the path where the default log file is located
func GetDefaultLogPath() (string, error) <span class="cov8" title="1">{
        currentWorkDir, err := os.Getwd()
        if err != nil </span><span class="cov0" title="0">{
                return "", err
        }</span>
        <span class="cov8" title="1">return filepath.Join(currentWorkDir, DefaultLogFile), nil</span>
}
</pre>
		
		<pre class="file" id="file20" style="display: none">package metrics

import (
        "bytes"
        "runtime/pprof"
        "time"

        "github.com/rs/zerolog/log"
)

type cpuMetric struct {
        close   func()
        writer  *bytes.Buffer
        idx     int
        typeMap map[string]float64
}

var cpuMap = map[string]float64{
        "ns":  float64(time.Nanosecond),
        "us":  float64(time.Microsecond),
        "ms":  float64(time.Millisecond),
        "s":   float64(time.Second),
        "hrs": float64(time.Hour),
}

func (c *cpuMetric) getDefault() string <span class="cov8" title="1">{
        return "ms"
}</span>

// Start - start gathering metrics for CPU usage
func (c *cpuMetric) start() <span class="cov8" title="1">{
        c.idx = 1
        c.typeMap = cpuMap

        c.writer = bytes.NewBuffer([]byte{})

        if err := pprof.StartCPUProfile(c.writer); err != nil </span><span class="cov0" title="0">{
                log.Error().Msgf("failed to write cpu profile")
        }</span>
        <span class="cov8" title="1">c.close = func() </span><span class="cov8" title="1">{
                pprof.StopCPUProfile()
        }</span>
}

// Stop - stop gathering metrics for CPU usage
func (c *cpuMetric) stop() <span class="cov8" title="1">{
        c.close()
}</span>

// getWriter returns the profile buffer
func (c *cpuMetric) getWriter() *bytes.Buffer <span class="cov8" title="1">{
        return c.writer
}</span>

// getIndex returns the cpu sample index
func (c *cpuMetric) getIndex() int <span class="cov8" title="1">{
        return c.idx
}</span>

// getMap returns the map used to format total value
func (c *cpuMetric) getMap() map[string]float64 <span class="cov8" title="1">{
        return c.typeMap
}</span>
</pre>
		
		<pre class="file" id="file21" style="display: none">package metrics

import (
        "bytes"
        "runtime"
        "runtime/pprof"

        "github.com/rs/zerolog/log"
)

type memMetric struct {
        close   func()
        writer  *bytes.Buffer
        idx     int
        typeMap map[string]float64
}

var (
        b  = 1
        kb = 10
        mb = 20
        gb = 30
        tb = 40
        pb = 50
)

var memoryMap = map[string]float64{
        "B":  float64(b),
        "kB": float64(b &lt;&lt; kb),
        "MB": float64(b &lt;&lt; mb),
        "GB": float64(b &lt;&lt; gb),
        "TB": float64(b &lt;&lt; tb),
        "PB": float64(b &lt;&lt; pb),
}

// Start - start gathering metrics for Memory usage
func (c *memMetric) start() <span class="cov8" title="1">{
        c.idx = 3
        c.typeMap = memoryMap

        old := runtime.MemProfileRate
        runtime.MemProfileRate = 4096 // set default memory rate

        c.writer = bytes.NewBuffer([]byte{})
        c.close = func() </span><span class="cov8" title="1">{
                if err := pprof.Lookup("heap").WriteTo(c.writer, 0); err != nil </span><span class="cov0" title="0">{
                        log.Error().Msgf("failed to write mem profile")
                }</span>

                <span class="cov8" title="1">runtime.MemProfileRate = old</span>
        }
}

func (c *memMetric) getDefault() string <span class="cov8" title="1">{
        return "B"
}</span>

// Stop - stop gathering metrics for Memory usage
func (c *memMetric) stop() <span class="cov8" title="1">{
        c.close()
}</span>

// getWriter returns the profile buffer
func (c *memMetric) getWriter() *bytes.Buffer <span class="cov8" title="1">{
        return c.writer
}</span>

// getIndex returns the memory sample index
func (c *memMetric) getIndex() int <span class="cov8" title="1">{
        return c.idx
}</span>

// getMap returns the map used to format total value
func (c *memMetric) getMap() map[string]float64 <span class="cov8" title="1">{
        return c.typeMap
}</span>
</pre>
		
		<pre class="file" id="file22" style="display: none">package metrics

import (
        "bytes"
        "fmt"
        "math"
        "strings"

        "github.com/google/pprof/profile"
        "github.com/rs/zerolog/log"
)

var (
        // Metric is the global metrics object
        Metric = &amp;Metrics{
                Disable: true,
        }
)

// Start - starts gathering metrics based on the type of metrics and writes metrics to string
// Stop - stops gathering metrics for the type of metrics specified
type metricType interface {
        start()
        stop()
        getWriter() *bytes.Buffer
        getIndex() int
        getMap() map[string]float64
        getDefault() string
}

// Metrics - structure to keep information relevant to the metrics calculation
// Disable - disables metric calculations
type Metrics struct {
        metric    metricType
        metricsID string
        location  string
        Disable   bool
        total     int64
        ci        bool
}

// InitializeMetrics - creates a new instance of a Metrics based on the type of metrics specified
func InitializeMetrics(metric string, ci bool) error <span class="cov5" title="7">{
        var err error
        switch strings.ToLower(metric) </span>{
        case "cpu":<span class="cov2" title="2">
                Metric.Disable = false
                Metric.metric = &amp;cpuMetric{}
                Metric.total = 0</span>
        case "mem":<span class="cov2" title="2">
                Metric.total = 0
                Metric.metric = &amp;memMetric{}
                Metric.Disable = false</span>
        case "":<span class="cov2" title="2">
                Metric.total = 0
                Metric.Disable = true</span>
        default:<span class="cov1" title="1">
                Metric.total = 0
                Metric.Disable = true
                err = fmt.Errorf("unknown metric: %s (available metrics: CPU, MEM)", metric)</span>
        }

        // Create temporary dir to keep pprof file
        <span class="cov5" title="7">if !Metric.Disable </span><span class="cov4" title="4">{
                Metric.metricsID = metric
                Metric.ci = ci
        }</span>

        <span class="cov5" title="7">return err</span>
}

// Start - starts gathering metrics for the location specified
func (m *Metrics) Start(location string) <span class="cov3" title="3">{
        if m.Disable </span><span class="cov1" title="1">{
                return
        }</span>

        <span class="cov2" title="2">log.Debug().Msgf("Started %s profiling for %s", m.metricsID, location)

        m.location = location
        m.metric.start()</span>
}

// Stop - stops gathering metrics and logs the result
func (m *Metrics) Stop() <span class="cov3" title="3">{
        if m.Disable </span><span class="cov1" title="1">{
                return
        }</span>
        <span class="cov2" title="2">log.Debug().Msgf("Stopped %s profiling for %s", m.metricsID, m.location)

        m.metric.stop()

        p, err := profile.Parse(m.metric.getWriter())
        if err != nil </span><span class="cov0" title="0">{
                log.Error().Msgf("failed to parse profile on %s: %s", m.location, err)
        }</span>

        <span class="cov2" title="2">if err := p.CheckValid(); err != nil </span><span class="cov0" title="0">{
                log.Error().Msgf("invalid profile on %s: %s", m.location, err)
        }</span>

        <span class="cov2" title="2">total := getTotal(p, m.metric.getIndex())
        log.Info().
                Msgf("Total %s usage for %s: %s", strings.ToUpper(m.metricsID),
                        m.location, m.formatTotal(total, m.metric.getMap(), m.metric.getDefault()))
        m.total = total</span>
}

// getTotal goes through the profile samples summing their values according to
// the type of profile
func getTotal(prof *profile.Profile, idx int) int64 <span class="cov2" title="2">{
        var total, diffTotal int64
        for _, sample := range prof.Sample </span><span class="cov9" title="37">{
                var v int64
                v = sample.Value[idx]
                if v &lt; 0 </span><span class="cov0" title="0">{
                        v = -v
                }</span>
                <span class="cov9" title="37">total += v
                if sample.DiffBaseSample() </span><span class="cov0" title="0">{
                        diffTotal += v
                }</span>
        }
        <span class="cov2" title="2">if diffTotal &gt; 0 </span><span class="cov0" title="0">{
                total = diffTotal
        }</span>

        <span class="cov2" title="2">return total</span>
}

// formatTotal parses total value into a human readable way
func (m *Metrics) formatTotal(b int64, typeMap map[string]float64, defaultMetric string) string <span class="cov6" title="11">{
        value := float64(b)
        var formatter float64
        var mesure string
        if m.ci </span><span class="cov1" title="1">{
                metric := value / typeMap[defaultMetric]
                if math.IsNaN(metric) </span><span class="cov0" title="0">{
                        metric = 0
                }</span>
                <span class="cov1" title="1">return fmt.Sprintf("%.f%s", metric, defaultMetric)</span>
        }
        <span class="cov6" title="10">for k, u := range typeMap </span><span class="cov10" title="55">{
                if u &gt;= formatter &amp;&amp; (value/u) &gt;= 1.0 </span><span class="cov7" title="20">{
                        formatter = u
                        mesure = k
                }</span>
        }

        <span class="cov6" title="10">metric := value / formatter
        if math.IsNaN(metric) </span><span class="cov2" title="2">{
                metric = 0
        }</span>

        <span class="cov6" title="10">return fmt.Sprintf("%.2f%s", metric, mesure)</span>
}
</pre>
		
		<pre class="file" id="file23" style="display: none">package sentry

import (
        "encoding/json"

        "github.com/Checkmarx/kics/v2/internal/console/flags"
        "github.com/Checkmarx/kics/v2/pkg/model"
        "github.com/getsentry/sentry-go"
        "github.com/rs/zerolog/log"
)

// Report is the struct containing necessary information to send to sentry
type Report struct {
        Location         string                 `json:"location"`
        Flags            map[string]interface{} `json:"flags"`
        FileName         string                 `json:"file_name"`
        Query            string                 `json:"query_name"`
        Platform         string                 `json:"platform"`
        Kind             model.FileKind         `json:"kind"`
        Metadata         map[string]interface{} `json:"query_metadata"`
        Message          string                 `json:"message"`
        Err              error                  `json:"error"`
        AdditionalValues map[string]interface{} `json:"additional_values"`
}

// ReportSentry creates a new issue with the necessary information to sentry
// and logs the issue
func ReportSentry(report *Report, shouldLog bool) <span class="cov10" title="186">{
        sentry.WithScope(func(scope *sentry.Scope) </span><span class="cov10" title="186">{
                report.Flags = flags.GetAllFlags()
                value := make(map[string]interface{})
                value["report"] = report
                scope.SetContext("Issue", value)
                sentry.CaptureException(report.Err)
        }</span>)

        <span class="cov10" title="186">if shouldLog </span><span class="cov10" title="186">{
                log.Err(report.Err).Msgf(report.Message)
                log.Debug().Msgf("Error Report: \n%+v\n", report.string())
        }</span>
}

func (r *Report) string() string <span class="cov10" title="186">{
        stringifyed, err := json.MarshalIndent(&amp;r, "", "  ")
        if err != nil </span><span class="cov0" title="0">{
                log.Err(err).Msgf("Failed to marshall sentry report")
        }</span>
        <span class="cov10" title="186">return string(stringifyed)</span>
}
</pre>
		
		<pre class="file" id="file24" style="display: none">package storage

import (
        "context"
        "fmt"
        "sync"

        "github.com/Checkmarx/kics/v2/pkg/model"
        "github.com/rs/zerolog/log"
)

var (
        memoryMu sync.Mutex
)

// MemoryStorage is scans' results representation
type MemoryStorage struct {
        vulnerabilities []model.Vulnerability
        allFiles        model.FileMetadatas
}

// SaveFile adds a new file metadata to files collection
func (m *MemoryStorage) SaveFile(_ context.Context, metadata *model.FileMetadata) error <span class="cov8" title="1">{
        m.allFiles = append(m.allFiles, *metadata)
        return nil
}</span>

// GetFiles returns a collection of files saved on MemoryStorage
func (m *MemoryStorage) GetFiles(_ context.Context, _ string) (model.FileMetadatas, error) <span class="cov8" title="1">{
        return m.allFiles, nil
}</span>

// SaveVulnerabilities adds a list of vulnerabilities to vulnerabilities collection
func (m *MemoryStorage) SaveVulnerabilities(_ context.Context, vulnerabilities []model.Vulnerability) error <span class="cov8" title="1">{
        defer memoryMu.Unlock()
        memoryMu.Lock()
        m.vulnerabilities = append(m.vulnerabilities, vulnerabilities...)
        return nil
}</span>

// GetVulnerabilities returns a collection of vulnerabilities saved on MemoryStorage
func (m *MemoryStorage) GetVulnerabilities(_ context.Context, _ string) ([]model.Vulnerability, error) <span class="cov8" title="1">{
        return m.getUniqueVulnerabilities(), nil
}</span>

func (m *MemoryStorage) getUniqueVulnerabilities() []model.Vulnerability <span class="cov8" title="1">{
        vulnDictionary := make(map[string]model.Vulnerability)
        for i := range m.vulnerabilities </span><span class="cov8" title="1">{
                key := fmt.Sprintf("%s:%s:%d:%s:%s:%s",
                        m.vulnerabilities[i].QueryID,
                        m.vulnerabilities[i].FileName,
                        m.vulnerabilities[i].Line,
                        m.vulnerabilities[i].SimilarityID,
                        m.vulnerabilities[i].SearchKey,
                        m.vulnerabilities[i].KeyActualValue,
                )
                vulnDictionary[key] = m.vulnerabilities[i]
        }</span>

        <span class="cov8" title="1">var uniqueVulnerabilities []model.Vulnerability
        for key := range vulnDictionary </span><span class="cov8" title="1">{
                uniqueVulnerabilities = append(uniqueVulnerabilities, vulnDictionary[key])
        }</span>
        <span class="cov8" title="1">if len(uniqueVulnerabilities) == 0 </span><span class="cov0" title="0">{
                return m.vulnerabilities
        }</span>
        <span class="cov8" title="1">return uniqueVulnerabilities</span>
}

// GetScanSummary is not supported by MemoryStorage
func (m *MemoryStorage) GetScanSummary(_ context.Context, _ []string) ([]model.SeveritySummary, error) <span class="cov8" title="1">{
        return nil, nil
}</span>

// NewMemoryStorage creates a new MemoryStorage empty and returns it
func NewMemoryStorage() *MemoryStorage <span class="cov8" title="1">{
        log.Debug().Msg("storage.NewMemoryStorage()")
        return &amp;MemoryStorage{
                allFiles:        make(model.FileMetadatas, 0),
                vulnerabilities: make([]model.Vulnerability, 0),
        }
}</span>
</pre>
		
		<pre class="file" id="file25" style="display: none">package tracker

import (
        "fmt"
        "sync"

        "github.com/Checkmarx/kics/v2/internal/constants"
        "github.com/Checkmarx/kics/v2/pkg/model"
)

// CITracker contains information of how many queries were loaded and executed
// and how many files were found and executed

var (
        trackerMu sync.Mutex
)

type CITracker struct {
        ExecutingQueries      int
        ExecutedQueries       int
        FoundFiles            int
        FailedSimilarityID    int
        FailedOldSimilarityID int
        LoadedQueries         int
        ParsedFiles           int
        ScanSecrets           int
        ScanPaths             int
        lines                 int
        FoundCountLines       int
        ParsedCountLines      int
        IgnoreCountLines      int
        Version               model.Version
        BagOfFilesParse       map[string]int
        BagOfFilesFound       map[string]int
        syncFileMutex         sync.Mutex
}

// NewTracker will create a new instance of a tracker with the number of lines to display in results output
// number of lines can not be smaller than 1
func NewTracker(previewLines int) (*CITracker, error) <span class="cov10" title="2">{
        if previewLines &lt; constants.MinimumPreviewLines || previewLines &gt; constants.MaximumPreviewLines </span><span class="cov1" title="1">{
                return &amp;CITracker{},
                        fmt.Errorf("output lines minimum is %v and maximum is %v", constants.MinimumPreviewLines, constants.MaximumPreviewLines)
        }</span>
        <span class="cov1" title="1">return &amp;CITracker{
                lines:           previewLines,
                BagOfFilesParse: make(map[string]int),
                BagOfFilesFound: make(map[string]int),
        }, nil</span>
}

// GetOutputLines returns the number of lines to display in results output
func (c *CITracker) GetOutputLines() int <span class="cov1" title="1">{
        return c.lines
}</span>

// TrackQueryLoad adds a loaded query
func (c *CITracker) TrackQueryLoad(queryAggregation int) <span class="cov1" title="1">{
        c.LoadedQueries += queryAggregation
}</span>

// TrackQueryExecuting adds a executing queries
func (c *CITracker) TrackQueryExecuting(queryAggregation int) <span class="cov1" title="1">{
        c.ExecutingQueries += queryAggregation
}</span>

// TrackQueryExecution adds a query executed
func (c *CITracker) TrackQueryExecution(queryAggregation int) <span class="cov1" title="1">{
        trackerMu.Lock()
        defer trackerMu.Unlock()
        c.ExecutedQueries += queryAggregation
}</span>

// TrackFileFound adds a found file to be scanned
func (c *CITracker) TrackFileFound(path string) <span class="cov1" title="1">{
        c.syncFileMutex.Lock()
        defer c.syncFileMutex.Unlock()
        count, value := c.BagOfFilesFound[path]
        if !value </span><span class="cov1" title="1">{
                c.BagOfFilesFound[path] = 1
                c.FoundFiles++
        }</span> else<span class="cov0" title="0"> {
                c.BagOfFilesFound[path] = count + 1
        }</span>
}

// TrackFileParse adds a successful parsed file to be scanned
func (c *CITracker) TrackFileParse(path string) <span class="cov1" title="1">{
        c.syncFileMutex.Lock()
        defer c.syncFileMutex.Unlock()
        count, value := c.BagOfFilesParse[path]
        if !value </span><span class="cov1" title="1">{
                c.BagOfFilesParse[path] = 1
                c.ParsedFiles++
        }</span> else<span class="cov0" title="0"> {
                c.BagOfFilesParse[path] = count + 1
        }</span>
}

// FailedDetectLine - queries that fail to detect line are counted as failed to execute queries
func (c *CITracker) FailedDetectLine() <span class="cov1" title="1">{
        c.ExecutedQueries--
}</span>

// FailedComputeSimilarityID - queries that failed to compute similarity ID
func (c *CITracker) FailedComputeSimilarityID() <span class="cov1" title="1">{
        c.FailedSimilarityID++
}</span>

// FailedComputeOldSimilarityID - queries that failed to compute old similarity ID
func (c *CITracker) FailedComputeOldSimilarityID() <span class="cov1" title="1">{
        c.FailedOldSimilarityID++
}</span>

// TrackScanSecret - add to secrets scanned
func (c *CITracker) TrackScanSecret() <span class="cov1" title="1">{
        c.ScanSecrets++
}</span>

// TrackScanPath - paths to preform scan
func (c *CITracker) TrackScanPath() <span class="cov1" title="1">{
        c.ScanPaths++
}</span>

// TrackVersion - information if current version is latest
func (c *CITracker) TrackVersion(retrievedVersion model.Version) <span class="cov1" title="1">{
        c.Version = retrievedVersion
}</span>

// TrackFileFoundCountLines - information about the lines of the scanned files
func (c *CITracker) TrackFileFoundCountLines(countLines int) <span class="cov1" title="1">{
        c.FoundCountLines += countLines
}</span>

// TrackFileParseCountLines - information about the lines of the parsed files
func (c *CITracker) TrackFileParseCountLines(countLines int) <span class="cov1" title="1">{
        c.ParsedCountLines += countLines
}</span>

// TrackFileIgnoreCountLines - information about the lines ignored of the parsed files
func (c *CITracker) TrackFileIgnoreCountLines(countLines int) <span class="cov1" title="1">{
        c.IgnoreCountLines += countLines
}</span>
</pre>
		
		<pre class="file" id="file26" style="display: none">package analyzer

import (
        "fmt"
        "os"
        "path/filepath"
        "regexp"
        "sort"
        "strings"
        "sync"

        "github.com/Checkmarx/kics/v2/internal/metrics"
        "github.com/Checkmarx/kics/v2/pkg/engine/provider"
        "github.com/Checkmarx/kics/v2/pkg/model"
        "github.com/Checkmarx/kics/v2/pkg/utils"
        "github.com/pkg/errors"
        "github.com/rs/zerolog/log"
        ignore "github.com/sabhiram/go-gitignore"

        yamlParser "gopkg.in/yaml.v3"
)

// move the openApi regex to public to be used on file.go
// openAPIRegex - Regex that finds OpenAPI defining property "openapi" or "swagger"
// openAPIRegexInfo - Regex that finds OpenAPI defining property "info"
// openAPIRegexPath - Regex that finds OpenAPI defining property "paths", "components", or "webhooks" (from 3.1.0)
// cloudRegex - Regex that finds CloudFormation defining property "Resources"
// k8sRegex - Regex that finds Kubernetes defining property "apiVersion"
// k8sRegexKind - Regex that finds Kubernetes defining property "kind"
// k8sRegexMetadata - Regex that finds Kubernetes defining property "metadata"
// k8sRegexSpec - Regex that finds Kubernetes defining property "spec"
var (
        OpenAPIRegex                                    = regexp.MustCompile(`("(openapi|swagger)"|(openapi|swagger))\s*:`)
        OpenAPIRegexInfo                                = regexp.MustCompile(`("info"|info)\s*:`)
        OpenAPIRegexPath                                = regexp.MustCompile(`("(paths|components|webhooks)"|(paths|components|webhooks))\s*:`)
        armRegexContentVersion                          = regexp.MustCompile(`"contentVersion"\s*:`)
        armRegexResources                               = regexp.MustCompile(`"resources"\s*:`)
        cloudRegex                                      = regexp.MustCompile(`("Resources"|Resources)\s*:`)
        k8sRegex                                        = regexp.MustCompile(`("apiVersion"|apiVersion)\s*:`)
        k8sRegexKind                                    = regexp.MustCompile(`("kind"|kind)\s*:`)
        tfPlanRegexPV                                   = regexp.MustCompile(`"planned_values"\s*:`)
        tfPlanRegexRC                                   = regexp.MustCompile(`"resource_changes"\s*:`)
        tfPlanRegexConf                                 = regexp.MustCompile(`"configuration"\s*:`)
        tfPlanRegexTV                                   = regexp.MustCompile(`"terraform_version"\s*:`)
        cdkTfRegexMetadata                              = regexp.MustCompile(`"metadata"\s*:`)
        cdkTfRegexStackName                             = regexp.MustCompile(`"stackName"\s*:`)
        cdkTfRegexTerraform                             = regexp.MustCompile(`"terraform"\s*:`)
        artifactsRegexKind                              = regexp.MustCompile(`("kind"|kind)\s*:`)
        artifactsRegexProperties                        = regexp.MustCompile(`("properties"|properties)\s*:`)
        artifactsRegexParametes                         = regexp.MustCompile(`("parameters"|parameters)\s*:`)
        policyAssignmentArtifactRegexPolicyDefinitionID = regexp.MustCompile(`("policyDefinitionId"|policyDefinitionId)\s*:`)
        roleAssignmentArtifactRegexPrincipalIds         = regexp.MustCompile(`("principalIds"|principalIds)\s*:`)
        roleAssignmentArtifactRegexRoleDefinitionID     = regexp.MustCompile(`("roleDefinitionId"|roleDefinitionId)\s*:`)
        templateArtifactRegexParametes                  = regexp.MustCompile(`("template"|template)\s*:`)
        blueprintpRegexTargetScope                      = regexp.MustCompile(`("targetScope"|targetScope)\s*:`)
        blueprintpRegexProperties                       = regexp.MustCompile(`("properties"|properties)\s*:`)
        buildahRegex                                    = regexp.MustCompile(`buildah\s*from\s*\w+`)
        dockerComposeServicesRegex                      = regexp.MustCompile(`services\s*:[\w\W]+(image|build)\s*:`)
        crossPlaneRegex                                 = regexp.MustCompile(`"?apiVersion"?\s*:\s*(\w+\.)+crossplane\.io/v\w+\s*`)
        knativeRegex                                    = regexp.MustCompile(`"?apiVersion"?\s*:\s*(\w+\.)+knative\.dev/v\w+\s*`)
        pulumiNameRegex                                 = regexp.MustCompile(`name\s*:`)
        pulumiRuntimeRegex                              = regexp.MustCompile(`runtime\s*:`)
        pulumiResourcesRegex                            = regexp.MustCompile(`resources\s*:`)
        serverlessServiceRegex                          = regexp.MustCompile(`service\s*:`)
        serverlessProviderRegex                         = regexp.MustCompile(`(^|\n)provider\s*:`)
        cicdOnRegex                                     = regexp.MustCompile(`\s*on:\s*`)
        cicdJobsRegex                                   = regexp.MustCompile(`\s*jobs:\s*`)
        cicdStepsRegex                                  = regexp.MustCompile(`\s*steps:\s*`)
        queryRegexPathsAnsible                          = regexp.MustCompile(fmt.Sprintf(`^.*?%s(?:group|host)_vars%s.*$`, regexp.QuoteMeta(string(os.PathSeparator)), regexp.QuoteMeta(string(os.PathSeparator)))) //nolint:lll
)

var (
        listKeywordsGoogleDeployment = []string{"resources"}
        armRegexTypes                = []string{"blueprint", "templateArtifact", "roleAssignmentArtifact", "policyAssignmentArtifact"}
        possibleFileTypes            = map[string]bool{
                ".yml":               true,
                ".yaml":              true,
                ".json":              true,
                ".dockerfile":        true,
                "Dockerfile":         true,
                "possibleDockerfile": true,
                ".debian":            true,
                ".ubi8":              true,
                ".tf":                true,
                "tfvars":             true,
                ".proto":             true,
                ".sh":                true,
                ".cfg":               true,
                ".conf":              true,
                ".ini":               true,
                ".bicep":             true,
        }
        supportedRegexes = map[string][]string{
                "azureresourcemanager": append(armRegexTypes, arm),
                "buildah":              {"buildah"},
                "cicd":                 {"cicd"},
                "cloudformation":       {"cloudformation"},
                "crossplane":           {"crossplane"},
                "dockercompose":        {"dockercompose"},
                "knative":              {"knative"},
                "kubernetes":           {"kubernetes"},
                "openapi":              {"openapi"},
                "terraform":            {"terraform", "cdkTf"},
                "pulumi":               {"pulumi"},
                "serverlessfw":         {"serverlessfw"},
        }
        listKeywordsAnsible = []string{"name", "gather_facts",
                "hosts", "tasks", "become", "with_items", "with_dict",
                "when", "become_pass", "become_exe", "become_flags"}
        playBooks               = "playbooks"
        ansibleHost             = []string{"all", "ungrouped"}
        listKeywordsAnsibleHots = []string{"hosts", "children"}
)

const (
        yml        = ".yml"
        yaml       = ".yaml"
        json       = ".json"
        sh         = ".sh"
        arm        = "azureresourcemanager"
        bicep      = "bicep"
        kubernetes = "kubernetes"
        terraform  = "terraform"
        gdm        = "googledeploymentmanager"
        ansible    = "ansible"
        grpc       = "grpc"
        dockerfile = "dockerfile"
        crossplane = "crossplane"
        knative    = "knative"
        sizeMb     = 1048576
)

type Parameters struct {
        Results     string
        Path        []string
        MaxFileSize int
}

// regexSlice is a struct to contain a slice of regex
type regexSlice struct {
        regex []*regexp.Regexp
}

type analyzerInfo struct {
        typesFlag        []string
        excludeTypesFlag []string
        filePath         string
}

// Analyzer keeps all the relevant info for the function Analyze
type Analyzer struct {
        Paths             []string
        Types             []string
        ExcludeTypes      []string
        Exc               []string
        GitIgnoreFileName string
        ExcludeGitIgnore  bool
        MaxFileSize       int
}

// types is a map that contains the regex by type
var types = map[string]regexSlice{
        "openapi": {
                regex: []*regexp.Regexp{
                        OpenAPIRegex,
                        OpenAPIRegexInfo,
                        OpenAPIRegexPath,
                },
        },
        "kubernetes": {
                regex: []*regexp.Regexp{
                        k8sRegex,
                        k8sRegexKind,
                },
        },
        "crossplane": {
                regex: []*regexp.Regexp{
                        crossPlaneRegex,
                        k8sRegexKind,
                },
        },
        "knative": {
                regex: []*regexp.Regexp{
                        knativeRegex,
                        k8sRegexKind,
                },
        },
        "cloudformation": {
                regex: []*regexp.Regexp{
                        cloudRegex,
                },
        },
        "azureresourcemanager": {
                []*regexp.Regexp{
                        armRegexContentVersion,
                        armRegexResources,
                },
        },
        "terraform": {
                []*regexp.Regexp{
                        tfPlanRegexConf,
                        tfPlanRegexPV,
                        tfPlanRegexRC,
                        tfPlanRegexTV,
                },
        },
        "cdkTf": {
                []*regexp.Regexp{
                        cdkTfRegexMetadata,
                        cdkTfRegexStackName,
                        cdkTfRegexTerraform,
                },
        },
        "policyAssignmentArtifact": {
                []*regexp.Regexp{
                        artifactsRegexKind,
                        artifactsRegexProperties,
                        artifactsRegexParametes,
                        policyAssignmentArtifactRegexPolicyDefinitionID,
                },
        },
        "roleAssignmentArtifact": {
                []*regexp.Regexp{
                        artifactsRegexKind,
                        artifactsRegexProperties,
                        roleAssignmentArtifactRegexPrincipalIds,
                        roleAssignmentArtifactRegexRoleDefinitionID,
                },
        },
        "templateArtifact": {
                []*regexp.Regexp{
                        artifactsRegexKind,
                        artifactsRegexProperties,
                        artifactsRegexParametes,
                        templateArtifactRegexParametes,
                },
        },
        "blueprint": {
                []*regexp.Regexp{
                        blueprintpRegexTargetScope,
                        blueprintpRegexProperties,
                },
        },
        "buildah": {
                []*regexp.Regexp{
                        buildahRegex,
                },
        },
        "dockercompose": {
                []*regexp.Regexp{
                        dockerComposeServicesRegex,
                },
        },
        "pulumi": {
                []*regexp.Regexp{
                        pulumiNameRegex,
                        pulumiRuntimeRegex,
                        pulumiResourcesRegex,
                },
        },
        "serverlessfw": {
                []*regexp.Regexp{
                        serverlessServiceRegex,
                        serverlessProviderRegex,
                },
        },
        "cicd": {
                []*regexp.Regexp{
                        cicdOnRegex,
                        cicdJobsRegex,
                        cicdStepsRegex,
                },
        },
}

var defaultConfigFiles = []string{"pnpm-lock.yaml"}

// Analyze will go through the slice paths given and determine what type of queries should be loaded
// should be loaded based on the extension of the file and the content
func Analyze(a *Analyzer) (model.AnalyzedPaths, error) <span class="cov4" title="27">{
        // start metrics for file analyzer
        metrics.Metric.Start("file_type_analyzer")
        returnAnalyzedPaths := model.AnalyzedPaths{
                Types:       make([]string, 0),
                Exc:         make([]string, 0),
                ExpectedLOC: 0,
        }

        var files []string
        var wg sync.WaitGroup
        // results is the channel shared by the workers that contains the types found
        results := make(chan string)
        locCount := make(chan int)
        ignoreFiles := make([]string, 0)
        projectConfigFiles := make([]string, 0)
        done := make(chan bool)
        hasGitIgnoreFile, gitIgnore := shouldConsiderGitIgnoreFile(a.Paths[0], a.GitIgnoreFileName, a.ExcludeGitIgnore)
        // get all the files inside the given paths
        for _, path := range a.Paths </span><span class="cov4" title="28">{
                if _, err := os.Stat(path); err != nil </span><span class="cov1" title="1">{
                        return returnAnalyzedPaths, errors.Wrap(err, "failed to analyze path")
                }</span>
                <span class="cov4" title="27">if err := filepath.Walk(path, func(path string, info os.FileInfo, err error) error </span><span class="cov7" title="239">{
                        if err != nil </span><span class="cov0" title="0">{
                                return err
                        }</span>

                        <span class="cov7" title="239">ext, errExt := utils.GetExtension(path)
                        if errExt == nil </span><span class="cov7" title="196">{
                                trimmedPath := strings.ReplaceAll(path, a.Paths[0], filepath.Base(a.Paths[0]))
                                ignoreFiles = a.checkIgnore(info.Size(), hasGitIgnoreFile, gitIgnore, path, trimmedPath, ignoreFiles)

                                if isConfigFile(path, defaultConfigFiles) </span><span class="cov2" title="5">{
                                        projectConfigFiles = append(projectConfigFiles, path)
                                        a.Exc = append(a.Exc, path)
                                }</span>

                                <span class="cov7" title="196">if _, ok := possibleFileTypes[ext]; ok &amp;&amp; !isExcludedFile(path, a.Exc) </span><span class="cov7" title="170">{
                                        files = append(files, path)
                                }</span>
                        }
                        <span class="cov7" title="239">return nil</span>
                }); err != nil <span class="cov0" title="0">{
                        log.Error().Msgf("failed to analyze path %s: %s", path, err)
                }</span>
        }

        // unwanted is the channel shared by the workers that contains the unwanted files that the parser will ignore
        <span class="cov4" title="26">unwanted := make(chan string, len(files))

        a.Types, a.ExcludeTypes = typeLower(a.Types, a.ExcludeTypes)

        // Start the workers
        for _, file := range files </span><span class="cov7" title="170">{
                wg.Add(1)
                // analyze the files concurrently
                a := &amp;analyzerInfo{
                        typesFlag:        a.Types,
                        excludeTypesFlag: a.ExcludeTypes,
                        filePath:         file,
                }
                go a.worker(results, unwanted, locCount, &amp;wg)
        }</span>

        <span class="cov4" title="26">go func() </span><span class="cov4" title="26">{
                // close channel results when the worker has finished writing into it
                defer func() </span><span class="cov4" title="26">{
                        close(unwanted)
                        close(results)
                        close(locCount)
                }</span>()
                <span class="cov4" title="26">wg.Wait()
                done &lt;- true</span>
        }()

        <span class="cov4" title="26">availableTypes, unwantedPaths, loc := computeValues(results, unwanted, locCount, done)
        multiPlatformTypeCheck(&amp;availableTypes)
        unwantedPaths = append(unwantedPaths, ignoreFiles...)
        unwantedPaths = append(unwantedPaths, projectConfigFiles...)
        returnAnalyzedPaths.Types = availableTypes
        returnAnalyzedPaths.Exc = unwantedPaths
        returnAnalyzedPaths.ExpectedLOC = loc
        // stop metrics for file analyzer
        metrics.Metric.Stop()
        return returnAnalyzedPaths, nil</span>
}

// worker determines the type of the file by ext (dockerfile and terraform)/content and
// writes the answer to the results channel
// if no types were found, the worker will write the path of the file in the unwanted channel
func (a *analyzerInfo) worker(results, unwanted chan&lt;- string, locCount chan&lt;- int, wg *sync.WaitGroup) <span class="cov7" title="170">{ //nolint: gocyclo
        defer wg.Done()

        ext, errExt := utils.GetExtension(a.filePath)
        if errExt == nil </span><span class="cov7" title="170">{
                linesCount, _ := utils.LineCounter(a.filePath)

                switch ext </span>{
                // Dockerfile (direct identification)
                case ".dockerfile", "Dockerfile":<span class="cov3" title="7">
                        if a.isAvailableType(dockerfile) </span><span class="cov3" title="6">{
                                results &lt;- dockerfile
                                locCount &lt;- linesCount
                        }</span>
                // Dockerfile (indirect identification)
                case "possibleDockerfile", ".ubi8", ".debian":<span class="cov1" title="2">
                        if a.isAvailableType(dockerfile) &amp;&amp; isDockerfile(a.filePath) </span><span class="cov0" title="0">{
                                results &lt;- dockerfile
                                locCount &lt;- linesCount
                        }</span> else<span class="cov1" title="2"> {
                                unwanted &lt;- a.filePath
                        }</span>
                // Terraform
                case ".tf", "tfvars":<span class="cov3" title="7">
                        if a.isAvailableType(terraform) </span><span class="cov3" title="6">{
                                results &lt;- terraform
                                locCount &lt;- linesCount
                        }</span>
                // Bicep
                case ".bicep":<span class="cov4" title="18">
                        if a.isAvailableType(bicep) </span><span class="cov4" title="18">{
                                results &lt;- bicep
                                locCount &lt;- linesCount
                        }</span>
                // GRPC
                case ".proto":<span class="cov0" title="0">
                        if a.isAvailableType(grpc) </span><span class="cov0" title="0">{
                                results &lt;- grpc
                                locCount &lt;- linesCount
                        }</span>
                // It could be Ansible Config or Ansible Inventory
                case ".cfg", ".conf", ".ini":<span class="cov4" title="18">
                        if a.isAvailableType(ansible) </span><span class="cov4" title="15">{
                                results &lt;- ansible
                                locCount &lt;- linesCount
                        }</span>
                /* It could be Ansible, Buildah, CICD, CloudFormation, Crossplane, OpenAPI, Azure Resource Manager
                Docker Compose, Knative, Kubernetes, Pulumi, ServerlessFW or Google Deployment Manager*/
                case yaml, yml, json, sh:<span class="cov6" title="118">
                        a.checkContent(results, unwanted, locCount, linesCount, ext)</span>
                }
        }
}

func isDockerfile(path string) bool <span class="cov1" title="2">{
        content, err := os.ReadFile(filepath.Clean(path))
        if err != nil </span><span class="cov0" title="0">{
                log.Error().Msgf("failed to analyze file: %s", err)
                return false
        }</span>

        <span class="cov1" title="2">regexes := []*regexp.Regexp{
                regexp.MustCompile(`\s*FROM\s*`),
                regexp.MustCompile(`\s*RUN\s*`),
        }

        check := true

        for _, regex := range regexes </span><span class="cov1" title="2">{
                if !regex.Match(content) </span><span class="cov1" title="2">{
                        check = false
                        break</span>
                }
        }

        <span class="cov1" title="2">return check</span>
}

// overrides k8s match when all regexs passes for azureresourcemanager key and extension is set to json
func needsOverride(check bool, returnType, key, ext string) bool <span class="cov9" title="1621">{
        if check &amp;&amp; returnType == kubernetes &amp;&amp; key == arm &amp;&amp; ext == json </span><span class="cov0" title="0">{
                return true
        }</span> else<span class="cov9" title="1621"> if check &amp;&amp; returnType == kubernetes &amp;&amp; (key == knative || key == crossplane) &amp;&amp; (ext == yaml || ext == yml) </span><span class="cov3" title="9">{
                return true
        }</span>
        <span class="cov9" title="1612">return false</span>
}

// checkContent will determine the file type by content when worker was unable to
// determine by ext, if no type was determined checkContent adds it to unwanted channel
func (a *analyzerInfo) checkContent(results, unwanted chan&lt;- string, locCount chan&lt;- int, linesCount int, ext string) <span class="cov6" title="118">{
        typesFlag := a.typesFlag
        excludeTypesFlag := a.excludeTypesFlag
        // get file content
        content, err := os.ReadFile(a.filePath)
        if err != nil </span><span class="cov0" title="0">{
                log.Error().Msgf("failed to analyze file: %s", err)
                return
        }</span>

        <span class="cov6" title="118">returnType := ""

        // Sort map so that CloudFormation (type that as less requireds) goes last
        keys := make([]string, 0, len(types))
        for k := range types </span><span class="cov10" title="2006">{
                keys = append(keys, k)
        }</span>

        <span class="cov6" title="118">if typesFlag[0] != "" </span><span class="cov4" title="19">{
                keys = getKeysFromTypesFlag(typesFlag)
        }</span> else<span class="cov6" title="99"> if excludeTypesFlag[0] != "" </span><span class="cov4" title="19">{
                keys = getKeysFromExcludeTypesFlag(excludeTypesFlag)
        }</span>

        <span class="cov6" title="118">sort.Sort(sort.Reverse(sort.StringSlice(keys)))

        for _, key := range keys </span><span class="cov9" title="1683">{
                check := true
                for _, typeRegex := range types[key].regex </span><span class="cov9" title="1947">{
                        if !typeRegex.Match(content) </span><span class="cov9" title="1603">{
                                check = false
                                break</span>
                        }
                }
                // If all regexs passed and there wasn't a type already assigned
                <span class="cov9" title="1683">if check &amp;&amp; returnType == "" </span><span class="cov5" title="62">{
                        returnType = key
                }</span> else<span class="cov9" title="1621"> if needsOverride(check, returnType, key, ext) </span><span class="cov3" title="9">{
                        returnType = key
                }</span>
        }
        <span class="cov6" title="118">returnType = checkReturnType(a.filePath, returnType, ext, content)
        if returnType != "" </span><span class="cov6" title="94">{
                if a.isAvailableType(returnType) </span><span class="cov6" title="90">{
                        results &lt;- returnType
                        locCount &lt;- linesCount
                        return
                }</span>
        }
        // No type was determined (ignore on parser)
        <span class="cov4" title="28">unwanted &lt;- a.filePath</span>
}

func checkReturnType(path, returnType, ext string, content []byte) string <span class="cov6" title="118">{
        if returnType != "" </span><span class="cov5" title="62">{
                if returnType == "cdkTf" </span><span class="cov0" title="0">{
                        return terraform
                }</span>
                <span class="cov5" title="62">if utils.Contains(returnType, armRegexTypes) </span><span class="cov0" title="0">{
                        return arm
                }</span>
        } else<span class="cov5" title="56"> if ext == yaml || ext == yml </span><span class="cov5" title="46">{
                if checkHelm(path) </span><span class="cov3" title="12">{
                        return kubernetes
                }</span>
                <span class="cov5" title="34">platform := checkYamlPlatform(content, path)
                if platform != "" </span><span class="cov4" title="20">{
                        return platform
                }</span>
        }
        <span class="cov6" title="86">return returnType</span>
}

func checkHelm(path string) bool <span class="cov5" title="46">{
        _, err := os.Stat(filepath.Join(filepath.Dir(path), "Chart.yaml"))
        if errors.Is(err, os.ErrNotExist) </span><span class="cov5" title="34">{
                return false
        }</span> else<span class="cov3" title="12"> if err != nil </span><span class="cov0" title="0">{
                log.Error().Msgf("failed to check helm: %s", err)
        }</span>

        <span class="cov3" title="12">return true</span>
}

func checkYamlPlatform(content []byte, path string) string <span class="cov5" title="34">{
        content = utils.DecryptAnsibleVault(content, os.Getenv("ANSIBLE_VAULT_PASSWORD_FILE"))

        var yamlContent model.Document
        if err := yamlParser.Unmarshal(content, &amp;yamlContent); err != nil </span><span class="cov1" title="1">{
                log.Warn().Msgf("failed to parse yaml file (%s): %s", path, err)
        }</span>
        // check if it is google deployment manager platform
        <span class="cov5" title="34">for _, keyword := range listKeywordsGoogleDeployment </span><span class="cov5" title="34">{
                if _, ok := yamlContent[keyword]; ok </span><span class="cov3" title="6">{
                        return gdm
                }</span>
        }

        // check if the file contains some keywords related with Ansible
        <span class="cov4" title="28">if checkForAnsible(yamlContent) </span><span class="cov3" title="9">{
                return ansible
        }</span>
        // check if the file contains some keywords related with Ansible Host
        <span class="cov4" title="19">if checkForAnsibleHost(yamlContent) </span><span class="cov2" title="3">{
                return ansible
        }</span>
        // add for yaml files contained at paths (group_vars, host_vars) related with ansible
        <span class="cov4" title="16">if checkForAnsibleByPaths(path) </span><span class="cov1" title="2">{
                return ansible
        }</span>
        <span class="cov4" title="14">return ""</span>
}

func checkForAnsibleByPaths(path string) bool <span class="cov4" title="16">{
        return queryRegexPathsAnsible.MatchString(path)
}</span>

func checkForAnsible(yamlContent model.Document) bool <span class="cov4" title="28">{
        isAnsible := false
        if play := yamlContent[playBooks]; play != nil </span><span class="cov3" title="9">{
                if listOfPlayBooks, ok := play.([]interface{}); ok </span><span class="cov3" title="9">{
                        for _, value := range listOfPlayBooks </span><span class="cov4" title="17">{
                                castingValue, ok := value.(map[string]interface{})
                                if ok </span><span class="cov4" title="17">{
                                        for _, keyword := range listKeywordsAnsible </span><span class="cov7" title="187">{
                                                if _, ok := castingValue[keyword]; ok </span><span class="cov5" title="44">{
                                                        isAnsible = true
                                                }</span>
                                        }
                                }
                        }
                }
        }
        <span class="cov4" title="28">return isAnsible</span>
}

func checkForAnsibleHost(yamlContent model.Document) bool <span class="cov4" title="19">{
        isAnsible := false
        for _, ansibleDefault := range ansibleHost </span><span class="cov5" title="38">{
                if hosts := yamlContent[ansibleDefault]; hosts != nil </span><span class="cov2" title="3">{
                        if listHosts, ok := hosts.(map[string]interface{}); ok </span><span class="cov2" title="3">{
                                for _, value := range listKeywordsAnsibleHots </span><span class="cov3" title="6">{
                                        if host := listHosts[value]; host != nil </span><span class="cov2" title="4">{
                                                isAnsible = true
                                        }</span>
                                }
                        }
                }
        }
        <span class="cov4" title="19">return isAnsible</span>
}

// computeValues computes expected Lines of Code to be scanned from locCount channel
// and creates the types and unwanted slices from the channels removing any duplicates
func computeValues(types, unwanted chan string, locCount chan int, done chan bool) (typesS, unwantedS []string, locTotal int) <span class="cov4" title="26">{
        var val int
        unwantedSlice := make([]string, 0)
        typeSlice := make([]string, 0)
        for </span><span class="cov7" title="326">{
                select </span>{
                case i := &lt;-locCount:<span class="cov6" title="135">
                        val += i</span>
                case i := &lt;-unwanted:<span class="cov5" title="30">
                        if !utils.Contains(i, unwantedSlice) </span><span class="cov5" title="30">{
                                unwantedSlice = append(unwantedSlice, i)
                        }</span>
                case i := &lt;-types:<span class="cov6" title="135">
                        if !utils.Contains(i, typeSlice) </span><span class="cov6" title="76">{
                                typeSlice = append(typeSlice, i)
                        }</span>
                case &lt;-done:<span class="cov4" title="26">
                        return typeSlice, unwantedSlice, val</span>
                }
        }
}

// getKeysFromTypesFlag gets all the regexes keys related to the types flag
func getKeysFromTypesFlag(typesFlag []string) []string <span class="cov4" title="19">{
        ks := make([]string, 0, len(types))
        for i := range typesFlag </span><span class="cov5" title="38">{
                t := typesFlag[i]

                if regexes, ok := supportedRegexes[t]; ok </span><span class="cov4" title="19">{
                        ks = append(ks, regexes...)
                }</span>
        }
        <span class="cov4" title="19">return ks</span>
}

// getKeysFromExcludeTypesFlag gets all the regexes keys related to the excluding unwanted types from flag
func getKeysFromExcludeTypesFlag(excludeTypesFlag []string) []string <span class="cov4" title="19">{
        ks := make([]string, 0, len(types))
        for k := range supportedRegexes </span><span class="cov7" title="228">{
                if !utils.Contains(k, excludeTypesFlag) </span><span class="cov7" title="209">{
                        if regexes, ok := supportedRegexes[k]; ok </span><span class="cov7" title="209">{
                                ks = append(ks, regexes...)
                        }</span>
                }
        }
        <span class="cov4" title="19">return ks</span>
}

// isExcludedFile verifies if the path is pointed in the --exclude-paths flag
func isExcludedFile(path string, exc []string) bool <span class="cov7" title="178">{
        for i := range exc </span><span class="cov7" title="208">{
                exclude, err := provider.GetExcludePaths(exc[i])
                if err != nil </span><span class="cov0" title="0">{
                        log.Err(err).Msg("failed to get exclude paths")
                }</span>
                <span class="cov7" title="208">for j := range exclude </span><span class="cov7" title="208">{
                        if exclude[j] == path </span><span class="cov3" title="8">{
                                log.Info().Msgf("Excluded file %s from analyzer", path)
                                return true
                        }</span>
                }
        }
        <span class="cov7" title="170">return false</span>
}

func isDeadSymlink(path string) bool <span class="cov7" title="194">{
        fileInfo, _ := os.Stat(path)
        return fileInfo == nil
}</span>

func isConfigFile(path string, exc []string) bool <span class="cov7" title="196">{
        for i := range exc </span><span class="cov7" title="196">{
                exclude, err := provider.GetExcludePaths(exc[i])
                if err != nil </span><span class="cov0" title="0">{
                        log.Err(err).Msg("failed to get exclude paths")
                }</span>
                <span class="cov7" title="196">for j := range exclude </span><span class="cov7" title="196">{
                        fileInfo, _ := os.Stat(path)
                        if fileInfo != nil &amp;&amp; fileInfo.IsDir() </span><span class="cov0" title="0">{
                                continue</span>
                        }

                        <span class="cov7" title="196">if len(path)-len(exclude[j]) &gt; 0 &amp;&amp; path[len(path)-len(exclude[j]):] == exclude[j] &amp;&amp; exclude[j] != "" </span><span class="cov2" title="5">{
                                log.Info().Msgf("Excluded file %s from analyzer", path)
                                return true
                        }</span>
                }
        }
        <span class="cov7" title="191">return false</span>
}

// shouldConsiderGitIgnoreFile verifies if the scan should exclude the files according to the .gitignore file
func shouldConsiderGitIgnoreFile(path, gitIgnore string, excludeGitIgnoreFile bool) (hasGitIgnoreFileRes bool,
        gitIgnoreRes *ignore.GitIgnore) <span class="cov4" title="27">{
        gitIgnorePath := filepath.ToSlash(filepath.Join(path, gitIgnore))
        _, err := os.Stat(gitIgnorePath)

        if !excludeGitIgnoreFile &amp;&amp; err == nil &amp;&amp; gitIgnore != "" </span><span class="cov1" title="1">{
                gitIgnore, _ := ignore.CompileIgnoreFile(gitIgnorePath)
                if gitIgnore != nil </span><span class="cov1" title="1">{
                        log.Info().Msgf(".gitignore file was found in '%s' and it will be used to automatically exclude paths", path)
                        return true, gitIgnore
                }</span>
        }
        <span class="cov4" title="26">return false, nil</span>
}

func multiPlatformTypeCheck(typesSelected *[]string) <span class="cov4" title="26">{
        if utils.Contains("serverlessfw", *typesSelected) &amp;&amp; !utils.Contains("cloudformation", *typesSelected) </span><span class="cov1" title="1">{
                *typesSelected = append(*typesSelected, "cloudformation")
        }</span>
        <span class="cov4" title="26">if utils.Contains("knative", *typesSelected) &amp;&amp; !utils.Contains("kubernetes", *typesSelected) </span><span class="cov1" title="1">{
                *typesSelected = append(*typesSelected, "kubernetes")
        }</span>
}

func (a *analyzerInfo) isAvailableType(typeName string) bool <span class="cov6" title="146">{
        // no flag is set
        if len(a.typesFlag) == 1 &amp;&amp; a.typesFlag[0] == "" &amp;&amp; len(a.excludeTypesFlag) == 1 &amp;&amp; a.excludeTypesFlag[0] == "" </span><span class="cov6" title="113">{
                return true
        }</span> else<span class="cov5" title="33"> if len(a.typesFlag) &gt; 1 || a.typesFlag[0] != "" </span><span class="cov3" title="11">{
                // type flag is set
                return utils.Contains(typeName, a.typesFlag)
        }</span> else<span class="cov4" title="22"> if len(a.excludeTypesFlag) &gt; 1 || a.excludeTypesFlag[0] != "" </span><span class="cov4" title="22">{
                // exclude type flag is set
                return !utils.Contains(typeName, a.excludeTypesFlag)
        }</span>
        // no valid behavior detected
        <span class="cov0" title="0">return false</span>
}

func (a *Analyzer) checkIgnore(fileSize int64, hasGitIgnoreFile bool,
        gitIgnore *ignore.GitIgnore,
        fullPath string, trimmedPath string, ignoreFiles []string) []string <span class="cov7" title="196">{
        exceededFileSize := a.MaxFileSize &gt;= 0 &amp;&amp; float64(fileSize)/float64(sizeMb) &gt; float64(a.MaxFileSize)

        if (hasGitIgnoreFile &amp;&amp; gitIgnore.MatchesPath(trimmedPath)) || isDeadSymlink(fullPath) || exceededFileSize </span><span class="cov2" title="3">{
                ignoreFiles = append(ignoreFiles, fullPath)
                a.Exc = append(a.Exc, fullPath)

                if exceededFileSize </span><span class="cov1" title="1">{
                        log.Error().Msgf("file %s exceeds maximum file size of %d Mb", fullPath, a.MaxFileSize)
                }</span>
        }
        <span class="cov7" title="196">return ignoreFiles</span>
}

func typeLower(types, exclTypes []string) (typesRes, exclTypesRes []string) <span class="cov4" title="26">{
        for i := range types </span><span class="cov4" title="27">{
                types[i] = strings.ToLower(types[i])
        }</span>

        <span class="cov4" title="26">for i := range exclTypes </span><span class="cov4" title="27">{
                exclTypes[i] = strings.ToLower(exclTypes[i])
        }</span>

        <span class="cov4" title="26">return types, exclTypes</span>
}
</pre>
		
		<pre class="file" id="file27" style="display: none">package engine

import (
        "fmt"
        "strings"

        build "github.com/Checkmarx/kics/v2/pkg/builder/model"
        commentParser "github.com/Checkmarx/kics/v2/pkg/builder/parser/comment"
        tagParser "github.com/Checkmarx/kics/v2/pkg/builder/parser/tag"
        "github.com/Checkmarx/kics/v2/pkg/model"
        "github.com/hashicorp/hcl/v2"
        "github.com/hashicorp/hcl/v2/hclsyntax"
        "github.com/rs/zerolog/log"
        "github.com/zclconf/go-cty/cty"
        ctyConvert "github.com/zclconf/go-cty/cty/convert"
)

const resourceLabelsCount = 2

// Engine contains the conditions of rules and comments positions
type Engine struct {
        commentParser *commentParser.Parser
        conditions    []build.Condition
}

// Run parses files and execute engine.Run
func Run(src []byte, filename string) ([]build.Rule, error) <span class="cov1" title="1">{
        cp, err := commentParser.NewParser(src, filename)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>

        <span class="cov1" title="1">file, diags := hclsyntax.ParseConfig(src, filename, hcl.Pos{Byte: 0, Line: 1, Column: 1})
        if diags != nil &amp;&amp; diags.HasErrors() </span><span class="cov0" title="0">{
                return nil, diags.Errs()[0]
        }</span>
        <span class="cov1" title="1">if file == nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("invalid parse result")
        }</span>

        <span class="cov1" title="1">e := &amp;Engine{
                commentParser: cp,
        }

        return e.Run(file.Body.(*hclsyntax.Body))</span>
}

// Run initializes rules for Engine and returns it
func (e *Engine) Run(body *hclsyntax.Body) ([]build.Rule, error) <span class="cov1" title="1">{
        e.conditions = make([]build.Condition, 0)
        if err := e.walkBody(body, []build.PathItem{}); err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>

        <span class="cov1" title="1">rules := make([]build.Rule, 0)
        conditionGroups := make(map[string][]build.Condition)
        for _, condition := range e.conditions </span><span class="cov1" title="1">{
                group, ok := condition.AttrAsString("group")
                if !ok </span><span class="cov1" title="1">{
                        rules = append(rules, build.Rule{
                                Conditions: []build.Condition{condition},
                        })
                        continue</span>
                }

                <span class="cov0" title="0">conditionGroups[group] = append(conditionGroups[group], condition)</span>
        }

        <span class="cov1" title="1">for _, conditionGroup := range conditionGroups </span><span class="cov0" title="0">{
                rules = append(rules, build.Rule{
                        Conditions: conditionGroup,
                })
        }</span>
        <span class="cov1" title="1">return rules, nil</span>
}

func (e *Engine) walkBody(body *hclsyntax.Body, walkHistory []build.PathItem) error <span class="cov5" title="3">{
        for _, attribute := range body.Attributes </span><span class="cov6" title="4">{
                if err := e.walkAttribute(attribute, walkHistory); err != nil </span><span class="cov0" title="0">{
                        return err
                }</span>
        }

        <span class="cov5" title="3">for _, block := range body.Blocks </span><span class="cov3" title="2">{
                if err := e.walkBlock(block, walkHistory); err != nil </span><span class="cov0" title="0">{
                        return err
                }</span>
        }

        <span class="cov5" title="3">return nil</span>
}

func (e *Engine) walkBlock(block *hclsyntax.Block, walkHistory []build.PathItem) error <span class="cov3" title="2">{
        if len(block.Labels) == resourceLabelsCount </span><span class="cov1" title="1">{
                walkHistory = append(walkHistory,
                        build.PathItem{Type: build.PathTypeResource, Name: block.Type},
                        build.PathItem{Type: build.PathTypeResourceType, Name: block.Labels[0]},
                        build.PathItem{Type: build.PathTypeResourceName, Name: block.Type},
                )
        }</span> else<span class="cov1" title="1"> {
                walkHistory = append(walkHistory, build.PathItem{Type: build.PathTypeDefault, Name: block.Type})
        }</span>

        <span class="cov3" title="2">e.checkComment(block.Range(), walkHistory, nil)

        return e.walkBody(block.Body, walkHistory)</span>
}

func (e *Engine) walkAttribute(attr *hclsyntax.Attribute, walkHistory []build.PathItem) error <span class="cov6" title="4">{
        walkHistory = append(walkHistory, build.PathItem{Type: build.PathTypeDefault, Name: attr.Name})

        switch exp := attr.Expr.(type) </span>{
        case *hclsyntax.TemplateExpr,
                *hclsyntax.TemplateWrapExpr,
                *hclsyntax.LiteralValueExpr,
                *hclsyntax.ScopeTraversalExpr:<span class="cov5" title="3">

                v, err := e.ExpToString(attr.Expr)
                if err != nil </span><span class="cov0" title="0">{
                        return err
                }</span>

                <span class="cov5" title="3">e.checkComment(attr.Range(), walkHistory, &amp;v)</span>
        case *hclsyntax.ObjectConsExpr:<span class="cov1" title="1">
                e.checkComment(attr.Range(), walkHistory, nil)

                for _, item := range exp.Items </span><span class="cov3" title="2">{
                        if err := e.walkConstantItem(item, walkHistory); err != nil </span><span class="cov0" title="0">{
                                return err
                        }</span>
                }
        default:<span class="cov0" title="0">
                e.checkComment(attr.Range(), walkHistory, nil)</span>
        }

        <span class="cov6" title="4">return nil</span>
}

// ExpToString converts an expression into a string
func (e *Engine) ExpToString(expr hclsyntax.Expression) (string, error) <span class="cov10" title="9">{
        switch t := expr.(type) </span>{
        case *hclsyntax.LiteralValueExpr:<span class="cov1" title="1">
                s, err := ctyConvert.Convert(t.Val, cty.String)
                if err != nil </span><span class="cov0" title="0">{
                        return "", err
                }</span>
                <span class="cov1" title="1">return s.AsString(), nil</span>
        case *hclsyntax.TemplateExpr:<span class="cov6" title="4">
                if t.IsStringLiteral() </span><span class="cov6" title="4">{
                        v, err := t.Value(nil)
                        if err != nil </span><span class="cov0" title="0">{
                                return "", err
                        }</span>
                        <span class="cov6" title="4">return v.AsString(), nil</span>
                }
                <span class="cov0" title="0">builderString, err := e.buildString(t.Parts)
                if err != nil </span><span class="cov0" title="0">{
                        return "", err
                }</span>

                <span class="cov0" title="0">return builderString, nil</span>
        case *hclsyntax.TemplateWrapExpr:<span class="cov0" title="0">
                return e.ExpToString(t.Wrapped)</span>
        case *hclsyntax.ObjectConsKeyExpr:<span class="cov3" title="2">
                return e.ExpToString(t.Wrapped)</span>
        case *hclsyntax.ScopeTraversalExpr:<span class="cov3" title="2">
                items := evaluateScopeTraversalExpr(t.Traversal)
                return strings.Join(items, "."), nil</span>
        }

        <span class="cov0" title="0">return "", fmt.Errorf("can't convert expression %T to string", expr)</span>
}

func (e *Engine) buildString(parts []hclsyntax.Expression) (string, error) <span class="cov1" title="1">{
        builder := &amp;strings.Builder{}

        for _, part := range parts </span><span class="cov0" title="0">{
                s, err := e.ExpToString(part)
                if err != nil </span><span class="cov0" title="0">{
                        return "", err
                }</span>
                <span class="cov0" title="0">builder.WriteString(s)</span>
        }

        <span class="cov1" title="1">s := builder.String()

        builder.Reset()
        builder = nil

        return s, nil</span>
}

func (e *Engine) walkConstantItem(item hclsyntax.ObjectConsItem, walkHistory []build.PathItem) error <span class="cov3" title="2">{
        k, err := e.ExpToString(item.KeyExpr)
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>

        <span class="cov3" title="2">walkHistory = append(walkHistory, build.PathItem{Type: build.PathTypeDefault, Name: k})

        v, err := e.ExpToString(item.ValueExpr)
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>

        <span class="cov3" title="2">e.checkComment(item.ValueExpr.Range(), walkHistory, &amp;v)

        return nil</span>
}

func (e *Engine) checkComment(rg hcl.Range, walkHistory []build.PathItem, actualValue *string) <span class="cov9" title="8">{
        leadComment, endLineComment := e.commentParser.ParseCommentsForNode(rg)
        if !leadComment.IsEmpty() </span><span class="cov1" title="1">{
                e.addRule(walkHistory, leadComment, actualValue)
        }</span>
        <span class="cov9" title="8">if !endLineComment.IsEmpty() </span><span class="cov1" title="1">{
                e.addRule(walkHistory, endLineComment, actualValue)
        }</span>
}

func (e *Engine) addRule(walkHistory []build.PathItem, comment commentParser.Comment, actualValue *string) <span class="cov3" title="2">{
        tags, err := tagParser.Parse(comment.Value(), model.AllIssueTypesAsString)
        if err != nil </span><span class="cov0" title="0">{
                log.Err(err).Msgf("Line %d: failed to parse comment '%s'", comment.Line(), comment.Value())
                return
        }</span>

        <span class="cov3" title="2">if len(tags) == 0 </span><span class="cov1" title="1">{
                return
        }</span>

        <span class="cov1" title="1">cp := make([]build.PathItem, len(walkHistory))
        copy(cp, walkHistory)

        for _, t := range tags </span><span class="cov1" title="1">{
                e.conditions = append(e.conditions, build.Condition{
                        Line:       comment.Line(),
                        IssueType:  model.IssueType(t.Name),
                        Path:       cp,
                        Value:      actualValue,
                        Attributes: t.Attributes,
                })
        }</span>
}

func evaluateScopeTraversalExpr(t hcl.Traversal) []string <span class="cov3" title="2">{
        items := make([]string, 0)
        for _, part := range t </span><span class="cov3" title="2">{
                switch tt := part.(type) </span>{
                case hcl.TraverseAttr:<span class="cov0" title="0">
                        items = append(items, tt.Name)</span>
                case hcl.TraverseRoot:<span class="cov3" title="2">
                        items = append(items, tt.Name)</span>
                case hcl.TraverseIndex:<span class="cov0" title="0">
                        switch tt.Key.Type() </span>{
                        case cty.Number:<span class="cov0" title="0">
                                items = append(items, tt.Key.AsBigFloat().String())</span>
                        case cty.String:<span class="cov0" title="0">
                                items = append(items, tt.Key.AsString())</span>
                        }
                }
        }
        <span class="cov3" title="2">return items</span>
}
</pre>
		
		<pre class="file" id="file28" style="display: none">package model

import "github.com/Checkmarx/kics/v2/pkg/model"

// PathItemType represents which type of path that item belongs on json representation
type PathItemType string

// Constants for kinds of PathItemTypes
const (
        PathTypeDefault      PathItemType = "DEFAULT"
        PathTypeResource     PathItemType = "RESOURCE"
        PathTypeResourceType PathItemType = "RESOURCE_TYPE"
        PathTypeResourceName PathItemType = "RESOURCE_NAME"
)

// PathItem represents json's element name and type
type PathItem struct {
        Name string
        Type PathItemType
}

// Condition represents a condition from a rule that should be checked
type Condition struct {
        Line int

        IssueType  model.IssueType
        Path       []PathItem
        Value      interface{}
        Attributes map[string]interface{}
}

// Rule represents a list of conditions to validate a rule
type Rule struct {
        Conditions []Condition
}

// Attr add some configurations to the condition to return the condition to be matched
func (c Condition) Attr(name string) (interface{}, bool) <span class="cov6" title="2">{
        v, ok := c.Attributes[name]
        if !ok </span><span class="cov1" title="1">{
                return nil, false
        }</span>

        <span class="cov1" title="1">return v, true</span>
}

// AttrAsString gets Attr and converts to string
func (c Condition) AttrAsString(name string) (string, bool) <span class="cov10" title="3">{
        v, ok := c.Attributes[name]
        if !ok </span><span class="cov1" title="1">{
                return "", false
        }</span>

        <span class="cov6" title="2">if vv, ok := v.(string); ok </span><span class="cov1" title="1">{
                return vv, true
        }</span>

        <span class="cov1" title="1">return "", false</span>
}
</pre>
		
		<pre class="file" id="file29" style="display: none">package comment

import (
        "github.com/hashicorp/hcl/v2"
        "github.com/hashicorp/hcl/v2/hclsyntax"
)

// Parser represents a list of code tokens
type Parser struct {
        tokens hclsyntax.Tokens
}

// NewParser parses the content of a file and return a parser with its tokens
func NewParser(src []byte, filename string) (*Parser, error) <span class="cov1" title="1">{
        tokens, diags := hclsyntax.LexConfig(src, filename, hcl.Pos{Line: 0, Column: 0})
        if diags != nil &amp;&amp; diags.HasErrors() </span><span class="cov0" title="0">{
                return nil, diags.Errs()[0]
        }</span>

        <span class="cov1" title="1">return &amp;Parser{
                tokens: tokens,
        }, nil</span>
}

// ParseCommentsForNode returns a comment in the range given in rg, if exists
func (p *Parser) ParseCommentsForNode(rg hcl.Range) (startComment, leadComment Comment) <span class="cov4" title="8">{
        start, end := p.rangePosition(rg)
        startLeadComment := p.leadCommentStarts(start)
        endLineComment := p.lineCommentEnds(end)

        return p.createCommentFromRange(startLeadComment, start), p.createCommentFromRange(end, endLineComment)
}</span>

func (p *Parser) rangePosition(rng hcl.Range) (start, end int) <span class="cov4" title="8">{
        for i := 0; ; i++ </span><span class="cov10" title="217">{
                if i &gt;= len(p.tokens) </span><span class="cov0" title="0">{
                        return len(p.tokens), len(p.tokens)
                }</span>

                <span class="cov10" title="217">if p.tokens[i].Range.Start.Byte &gt;= rng.Start.Byte </span><span class="cov4" title="8">{
                        start = i
                        break</span>
                }
        }

        <span class="cov4" title="8">for i := start; ; i++ </span><span class="cov8" title="103">{
                if i &gt;= len(p.tokens) </span><span class="cov0" title="0">{
                        return start, len(p.tokens)
                }</span>

                <span class="cov8" title="103">if p.tokens[i].Range.Start.Byte &gt;= rng.End.Byte </span><span class="cov4" title="8">{
                        end = i
                        break</span>
                }
        }

        <span class="cov4" title="8">return start, end</span>
}

func (p *Parser) leadCommentStarts(before int) (i int) <span class="cov4" title="8">{
        defer func() </span><span class="cov4" title="8">{
                if i != before &amp;&amp; i-1 &gt;= 0 &amp;&amp; p.tokens[i-1].Type != hclsyntax.TokenNewline </span><span class="cov0" title="0">{
                        i++
                }</span>
        }()

        <span class="cov4" title="8">for i = before - 1; i &gt;= 0; i-- </span><span class="cov4" title="9">{
                if p.tokens[i].Type != hclsyntax.TokenComment </span><span class="cov4" title="8">{
                        return i + 1
                }</span>
        }

        <span class="cov0" title="0">return 0</span>
}

func (p *Parser) lineCommentEnds(after int) int <span class="cov4" title="8">{
        for i := after; i &lt; len(p.tokens); i++ </span><span class="cov4" title="8">{
                tok := p.tokens[i]
                if tok.Type != hclsyntax.TokenComment </span><span class="cov4" title="7">{
                        return i
                }</span>

                <span class="cov1" title="1">if len(tok.Bytes) &gt; 0 &amp;&amp; tok.Bytes[len(tok.Bytes)-1] == '\n' </span><span class="cov1" title="1">{
                        return i + 1
                }</span>
        }
        <span class="cov0" title="0">return len(p.tokens)</span>
}

// Comment - struct with comment value and its position on file
type Comment struct {
        pos   hcl.Pos
        value string
}

// IsEmpty returns true if comment is empty, otherwise returns false
func (c Comment) IsEmpty() bool <span class="cov5" title="16">{
        return c.value == ""
}</span>

// Value returns comment value
func (c Comment) Value() string <span class="cov2" title="2">{
        return c.value
}</span>

// Line returns the line comment starts
func (c Comment) Line() int <span class="cov1" title="1">{
        return c.pos.Line + 1
}</span>

func (p *Parser) createCommentFromRange(start, end int) Comment <span class="cov5" title="16">{
        s := ""
        for i := start; i &lt; end; i++ </span><span class="cov2" title="2">{
                s += string(p.tokens[i].Bytes)
        }</span>

        <span class="cov5" title="16">return Comment{
                pos:   p.tokens[start].Range.Start,
                value: s,
        }</span>
}
</pre>
		
		<pre class="file" id="file30" style="display: none">package tag

import (
        "bytes"
        "errors"
        "fmt"
        "strconv"
        "strings"
        "text/scanner"
)

const (
        base      = 10
        bitSize64 = 64
)

// Tag contains the tag name reference and its attributes
type Tag struct {
        Name       string
        Attributes map[string]interface{}
}

// Parse tag from following structure
// name1:"expected=private,test=false" name2:"attr=1"
func Parse(s string, supportedNames []string) ([]Tag, error) <span class="cov7" title="15">{
        s = strings.TrimLeft(strings.TrimLeft(strings.TrimSpace(s), "/"), " ")
        var tags []Tag
        for _, si := range strings.Split(s, " ") </span><span class="cov7" title="18">{
                cleanSi := strings.TrimSpace(si)
                if cleanSi == "" </span><span class="cov1" title="1">{
                        continue</span>
                }

                <span class="cov7" title="17">for _, supportedName := range supportedNames </span><span class="cov8" title="22">{
                        if !strings.HasPrefix(cleanSi, supportedName) </span><span class="cov5" title="6">{
                                continue</span>
                        }

                        <span class="cov7" title="16">tag, err := parseTag(cleanSi, supportedName)
                        if err != nil </span><span class="cov5" title="6">{
                                return nil, err
                        }</span>

                        <span class="cov6" title="10">tags = append(tags, tag)</span>
                }
        }

        <span class="cov6" title="9">return tags, nil</span>
}

func parseTag(s, name string) (Tag, error) <span class="cov7" title="16">{
        t := Tag{
                Name:       name,
                Attributes: make(map[string]interface{}),
        }

        attributePart := strings.TrimPrefix(s, name)
        attributePart = strings.TrimPrefix(attributePart, ":")
        attributePart = strings.TrimPrefix(attributePart, "\"")
        attributePart = strings.TrimSuffix(attributePart, "\"")

        if attributePart == "" </span><span class="cov4" title="4">{
                return t, nil
        }</span>

        <span class="cov6" title="12">sc := &amp;scanner.Scanner{}
        sc.Mode = scanner.ScanIdents | scanner.ScanInts | scanner.ScanFloats | scanner.ScanStrings
        sc.Init(strings.NewReader(attributePart))

        for </span><span class="cov10" title="43">{
                tok := sc.Scan()
                switch tok </span>{
                case scanner.EOF:<span class="cov5" title="6">
                        return t, nil</span>
                case scanner.Ident:<span class="cov8" title="26">
                        ident := sc.TokenText()
                        switch sc.Peek() </span>{
                        case '=':<span class="cov8" title="19">
                                sc.Next()
                                value, err := parseValue(sc)
                                if err != nil </span><span class="cov4" title="4">{
                                        return Tag{}, err
                                }</span>
                                <span class="cov7" title="15">t.Attributes[ident] = value</span>
                        case '[':<span class="cov2" title="2">
                                sc.Next()
                                arg, err := parseArgs(sc)
                                if err != nil </span><span class="cov1" title="1">{
                                        return Tag{}, err
                                }</span>
                                <span class="cov1" title="1">t.Attributes[ident] = arg</span>
                        case ',':<span class="cov4" title="5">
                                sc.Next()
                                t.Attributes[ident] = nil</span>
                        case scanner.EOF:<span class="cov0" title="0">
                                t.Attributes[ident] = nil</span>
                        }
                case ',':<span class="cov6" title="10"></span>
                        // NOP
                default:<span class="cov1" title="1">
                        return Tag{}, fmt.Errorf("invalid token: %s", sc.TokenText())</span>
                }
        }
}

func parseArray(sc *scanner.Scanner) ([]interface{}, error) <span class="cov4" title="4">{
        var result []interface{}
        for </span><span class="cov7" title="13">{
                value, err := parseValue(sc)
                if err != nil </span><span class="cov0" title="0">{
                        return result, err
                }</span>
                <span class="cov7" title="13">result = append(result, value)
                next := sc.Next()
                if next == ']' </span><span class="cov3" title="3">{
                        return result, nil
                }</span>
                <span class="cov6" title="10">if next == ',' </span><span class="cov6" title="9">{
                        continue</span>
                }
                <span class="cov1" title="1">return result, fmt.Errorf(", expected but got %s", string(next))</span>
        }
}

func parseValue(sc *scanner.Scanner) (interface{}, error) <span class="cov9" title="34">{
        switch sc.Peek() </span>{
        case '\'':<span class="cov7" title="18">
                sc.Next()
                return parseString(sc)</span>
        case '*':<span class="cov1" title="1">
                r := sc.Next()
                return string(r), nil</span>
        case '&lt;', '&gt;':<span class="cov2" title="2">
                r := sc.Next()
                if sc.Peek() == '=' </span><span class="cov1" title="1">{
                        sc.Next()
                        return string(r) + "=", nil
                }</span>
                <span class="cov1" title="1">return string(r), nil</span>
        case '!':<span class="cov2" title="2">
                sc.Next()
                if sc.Peek() == '=' </span><span class="cov1" title="1">{
                        sc.Next()
                        return "!=", nil
                }</span>
                <span class="cov1" title="1">return nil, fmt.Errorf("invalid value: %s", sc.TokenText())</span>
        case '[':<span class="cov4" title="4">
                sc.Next()
                return parseArray(sc)</span>
        default:<span class="cov5" title="7">
                tok := sc.Scan()
                switch tok </span>{
                case scanner.Ident:<span class="cov4" title="5">
                        return checkType(sc.TokenText()), nil</span>
                case scanner.String, scanner.Int, scanner.Float:<span class="cov2" title="2">
                        if tok == scanner.String </span><span class="cov0" title="0">{
                                str := sc.TokenText()
                                return str[1 : len(str)-1], nil
                        }</span> else<span class="cov2" title="2"> if tok == scanner.Int </span><span class="cov1" title="1">{
                                return strconv.ParseInt(sc.TokenText(), base, bitSize64)
                        }</span> else<span class="cov1" title="1"> if tok == scanner.Float </span><span class="cov1" title="1">{
                                return strconv.ParseFloat(sc.TokenText(), bitSize64)
                        }</span>
                default:<span class="cov0" title="0">
                        return nil, fmt.Errorf("invalid value: %s", sc.TokenText())</span>
                }
        }
        <span class="cov0" title="0">return nil, errors.New("invalid value")</span>
}

func parseArgs(sc *scanner.Scanner) (map[string]interface{}, error) <span class="cov2" title="2">{
        result := map[string]interface{}{}
        for </span><span class="cov3" title="3">{
                tok := sc.Scan()
                if tok != scanner.Ident </span><span class="cov0" title="0">{
                        return result, fmt.Errorf("invalid attribute name: %s", sc.TokenText())
                }</span>
                <span class="cov3" title="3">name := sc.TokenText()
                eq := sc.Next()
                if eq != '=' </span><span class="cov1" title="1">{
                        return result, fmt.Errorf("= expected but got %s", string(eq))
                }</span>
                <span class="cov2" title="2">value, err := parseValue(sc)
                if err != nil </span><span class="cov0" title="0">{
                        return result, err
                }</span>
                <span class="cov2" title="2">result[name] = value
                next := sc.Next()
                if next == ']' </span><span class="cov1" title="1">{
                        return result, nil
                }</span>
                <span class="cov1" title="1">if next == ',' </span><span class="cov1" title="1">{
                        continue</span>
                }
                <span class="cov0" title="0">return result, fmt.Errorf(") or , expected but got %s", string(next))</span>
        }
}

func parseString(sc *scanner.Scanner) (string, error) <span class="cov7" title="18">{
        var buf bytes.Buffer
        ch := sc.Next()
        for ch != '\'' </span><span class="cov8" title="26">{
                if ch == '\n' || ch == '\r' || ch &lt; 0 </span><span class="cov1" title="1">{
                        return "", errors.New("unterminated string")
                }</span>
                <span class="cov8" title="25">if ch == '\\' </span><span class="cov6" title="12">{
                        s, err := parseEscape(sc)
                        if err != nil </span><span class="cov1" title="1">{
                                return "", err
                        }</span>
                        <span class="cov6" title="11">buf.WriteString(s)</span>
                } else<span class="cov7" title="13"> {
                        buf.WriteRune(ch)
                }</span>
                <span class="cov8" title="24">ch = sc.Next()</span>
        }
        <span class="cov7" title="16">return buf.String(), nil</span>
}

func parseEscape(sc *scanner.Scanner) (string, error) <span class="cov6" title="12">{
        ch := sc.Next()
        switch ch </span>{
        case 'a':<span class="cov1" title="1">
                return "\a", nil</span>
        case 'b':<span class="cov1" title="1">
                return "\b", nil</span>
        case 'f':<span class="cov1" title="1">
                return "\f", nil</span>
        case 'n':<span class="cov1" title="1">
                return "\n", nil</span>
        case 'r':<span class="cov1" title="1">
                return "\r", nil</span>
        case 't':<span class="cov1" title="1">
                return "\t", nil</span>
        case 'v':<span class="cov1" title="1">
                return "\v", nil</span>
        case '\\':<span class="cov1" title="1">
                return "\\", nil</span>
        case '"':<span class="cov2" title="2">
                return "\"", nil</span>
        case '\'':<span class="cov1" title="1">
                return "'", nil</span>
        }
        <span class="cov1" title="1">return "", fmt.Errorf("invalid escape sequence: %s", string(ch))</span>
}

func checkType(s string) interface{} <span class="cov4" title="5">{
        switch s </span>{
        case "true", "TRUE":<span class="cov1" title="1">
                return true</span>
        case "false", "FALSE":<span class="cov1" title="1">
                return false</span>
        default:<span class="cov3" title="3">
                if i, err := strconv.ParseInt(s, base, bitSize64); err == nil </span><span class="cov0" title="0">{
                        return i
                }</span>
                <span class="cov3" title="3">if f, err := strconv.ParseFloat(s, bitSize64); err == nil </span><span class="cov0" title="0">{
                        return f
                }</span>

                <span class="cov3" title="3">return s</span>
        }
}
</pre>
		
		<pre class="file" id="file31" style="display: none">package writer

import (
        "bytes"
        "fmt"
        "html/template"
        "strconv"
        "strings"

        build "github.com/Checkmarx/kics/v2/pkg/builder/model"
        "github.com/Checkmarx/kics/v2/pkg/model"
        "github.com/pkg/errors"
        "github.com/rs/zerolog/log"
)

// RegoWriter represents the template for a Rego rule
type RegoWriter struct {
        tmpl *template.Template
}

// Block represents a json block of a file for scan
type Block struct {
        Name string
        All  bool
        List []string
}

// RegoRule contains a block to be scanned and a rule to be applied
type RegoRule struct {
        Block Block
        build.Rule
}

const (
        stringValue = "\"%s\""
        prec        = 6
        bitSize32   = 32
        bitSize64   = 64
)

// NewRegoWriter initializes a default RegoWriter using builder template
func NewRegoWriter() (*RegoWriter, error) <span class="cov1" title="1">{
        tmpl, err := template.New("template.gorego").
                Funcs(template.FuncMap{
                        "condition": condition,
                        "regoValue": regoValueToString,
                        "lastCondition": func(r RegoRule) build.Condition </span><span class="cov1" title="1">{
                                return r.Conditions[len(r.Conditions)-1]
                        }</span>,
                        "unescape": func(v string) template.HTML <span class="cov1" title="1">{
                                return template.HTML(v) //nolint:gosec
                        }</span>,
                        "innerKey": func(r RegoRule) template.HTML <span class="cov2" title="2">{
                                condition := r.Conditions[len(r.Conditions)-1]
                                return template.HTML(conditionKey(r.Block, condition, false, true)) //nolint:gosec
                        }</span>,
                        "searchKey": func(r RegoRule) template.HTML <span class="cov1" title="1">{
                                format := "%%s[%%s].%s"
                                condition := r.Conditions[len(r.Conditions)-1]
                                var vars []string

                                if v, ok := condition.Attr("resource"); ok &amp;&amp; v == "*" </span><span class="cov1" title="1">{
                                        vars = append(vars, "blockType")
                                }</span> else<span class="cov0" title="0"> {
                                        vars = append(vars, "blockTypes[blockIndex]")
                                }</span>
                                <span class="cov1" title="1">vars = append(vars, "name")
                                if _, ok := condition.Attr("any_key"); ok </span><span class="cov1" title="1">{
                                        format += ".%%s"
                                        vars = append(vars, "key")
                                }</span>
                                <span class="cov1" title="1">format = fmt.Sprintf(format, conditionKey(r.Block, condition, false, true))

                                return template.HTML(fmt.Sprintf("sprintf(\"%s\", [%s])", format, strings.Join(vars, ", ")))</span> //nolint
                        },
                }).
                ParseFiles("./pkg/builder/writer/template.gorego")
        <span class="cov1" title="1">if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>

        <span class="cov1" title="1">return &amp;RegoWriter{tmpl: tmpl}, nil</span>
}

// Render starts RegoWriter rules list passed as parameter
func (w *RegoWriter) Render(rules []build.Rule) ([]byte, error) <span class="cov1" title="1">{
        wr := bytes.NewBuffer(nil)

        if err := w.tmpl.Execute(wr, format(rules)); err != nil </span><span class="cov0" title="0">{
                return nil, errors.Wrap(err, "failed to render")
        }</span>

        <span class="cov1" title="1">return wr.Bytes(), nil</span>
}

func condition(r Block, c build.Condition) string <span class="cov5" title="6">{
        key := conditionKey(r, c, true, false)

        if c.IssueType == model.IssueTypeRedundantAttribute </span><span class="cov1" title="1">{
                return key
        }</span>
        <span class="cov4" title="5">if c.IssueType == model.IssueTypeMissingAttribute </span><span class="cov1" title="1">{
                return fmt.Sprintf("not %s", key)
        }</span>

        <span class="cov4" title="4">if _, ok := c.Attr("upper"); ok </span><span class="cov1" title="1">{
                key = fmt.Sprintf("upper(%s)", key)
        }</span>
        <span class="cov4" title="4">if _, ok := c.Attr("lower"); ok </span><span class="cov1" title="1">{
                key = fmt.Sprintf("lower(%s)", key)
        }</span>

        <span class="cov4" title="4">if reg, ok := c.Attr("regex"); ok </span><span class="cov1" title="1">{
                return fmt.Sprintf("re_match(%q, %s)", reg, key)
        }</span>

        <span class="cov3" title="3">condition := "=="
        if v, ok := c.AttrAsString("condition"); ok </span><span class="cov1" title="1">{
                condition = v
        }</span>

        <span class="cov3" title="3">if value, ok := c.AttrAsString("val"); ok </span><span class="cov1" title="1">{
                return fmt.Sprintf("%s %s %s", key, condition, regoValueToString(value))
        }</span>

        <span class="cov2" title="2">return fmt.Sprintf("%s %s %s", key, condition, regoValueToString(c.Value))</span>
}

func regoValueToString(i interface{}) string <span class="cov7" title="15">{
        switch v := i.(type) </span>{
        case bool:<span class="cov2" title="2">
                if v </span><span class="cov1" title="1">{
                        return "true"
                }</span>
                <span class="cov1" title="1">return "false"</span>
        case int64:<span class="cov1" title="1">
                return strconv.Itoa(int(v))</span>
        case int32:<span class="cov1" title="1">
                return strconv.Itoa(int(v))</span>
        case int:<span class="cov1" title="1">
                return strconv.Itoa(v)</span>
        case float64:<span class="cov1" title="1">
                return strconv.FormatFloat(v, 'f', prec, bitSize64)</span>
        case float32:<span class="cov1" title="1">
                return strconv.FormatFloat(float64(v), 'f', prec, bitSize32)</span>
        case string:<span class="cov4" title="4">
                return fmt.Sprintf(stringValue, v)</span>
        case *string:<span class="cov2" title="2">
                if v == nil </span><span class="cov1" title="1">{
                        return "\"\""
                }</span>
                <span class="cov1" title="1">return fmt.Sprintf(stringValue, *v)</span>
        case []string:<span class="cov1" title="1">
                sts := make([]string, 0, len(v))
                for _, vi := range v </span><span class="cov3" title="3">{
                        sts = append(sts, fmt.Sprintf(stringValue, vi))
                }</span>

                <span class="cov1" title="1">return fmt.Sprintf("{%s}", strings.Join(sts, ", "))</span>
        default:<span class="cov1" title="1">
                log.Warn().Msgf("Can't convert value, %T to string", i)
                return ""</span>
        }
}

func conditionKey(block Block, c build.Condition, withBlockPrefix, pathOnly bool) string <span class="cov6" title="10">{
        key := ""
        if withBlockPrefix </span><span class="cov5" title="7">{
                key = "block"
        }</span>
        <span class="cov6" title="10">for i, pathItem := range c.Path </span><span class="cov10" title="50">{
                switch pathItem.Type </span>{
                case build.PathTypeResourceType:<span class="cov6" title="10">
                        if pathOnly </span><span class="cov3" title="3">{
                                continue</span>
                        } else<span class="cov5" title="7"> if block.All </span><span class="cov5" title="7">{
                                key += "[blockType]"
                        }</span> else<span class="cov0" title="0"> {
                                key += "[blockTypes[blockIndex]]"
                        }</span>
                case build.PathTypeResourceName:<span class="cov6" title="10">
                        if !pathOnly </span><span class="cov5" title="7">{
                                key += "[name]"
                        }</span>
                case build.PathTypeDefault:<span class="cov7" title="20">
                        key = buildDefaultType(c, i, pathOnly, pathItem, key)</span>
                }
        }

        <span class="cov6" title="10">return key</span>
}

func buildDefaultType(c build.Condition, i int, pathOnly bool, pathItem build.PathItem, key string) string <span class="cov7" title="20">{
        if _, ok := c.Attr("any_key"); ok &amp;&amp; i == len(c.Path)-1 </span><span class="cov6" title="10">{
                if !pathOnly </span><span class="cov5" title="7">{
                        key += "[key]"
                }</span>
                <span class="cov6" title="10">return key</span>
        }

        <span class="cov6" title="10">if key != "" </span><span class="cov5" title="7">{
                key += "."
        }</span>

        <span class="cov6" title="10">key += pathItem.Name
        return key</span>
}

func format(rules []build.Rule) []RegoRule <span class="cov2" title="2">{
        res := make([]RegoRule, len(rules))
        for i, r := range rules </span><span class="cov2" title="2">{
                res[i] = RegoRule{
                        Rule:  r,
                        Block: createBlock(r),
                }
        }</span>

        <span class="cov2" title="2">return res</span>
}

func createBlock(rule build.Rule) Block <span class="cov3" title="3">{
        result := Block{}
        result = resultName(rule, result)

        resources := make(map[string]struct{}, len(rule.Conditions))
        for _, condition := range rule.Conditions </span><span class="cov3" title="3">{
                if len(condition.Path) == 0 </span><span class="cov0" title="0">{
                        continue</span>
                }

                <span class="cov3" title="3">v, ok := condition.Attr("resource")
                if !ok </span><span class="cov0" title="0">{
                        for _, pathItem := range condition.Path </span><span class="cov0" title="0">{
                                if pathItem.Type == build.PathTypeResourceType </span><span class="cov0" title="0">{
                                        resources[pathItem.Name] = struct{}{}
                                }</span>
                        }

                        <span class="cov0" title="0">continue</span>
                }
                <span class="cov3" title="3">resources, result = switchFunction(v, result, resources)</span>
        }

        <span class="cov3" title="3">result.List = make([]string, 0, len(resources))
        for resource := range resources </span><span class="cov3" title="3">{
                result.List = append(result.List, resource)
        }</span>

        <span class="cov3" title="3">return result</span>
}

func switchFunction(v interface{}, result Block, resources map[string]struct{}) (map[string]struct{}, Block) <span class="cov4" title="5">{
        switch vv := v.(type) </span>{
        case string:<span class="cov4" title="4">
                if vv == "*" </span><span class="cov4" title="4">{
                        result.All = true
                }</span>
                <span class="cov4" title="4">resources[vv] = struct{}{}</span>
        case []string:<span class="cov1" title="1">
                for _, vi := range vv </span><span class="cov2" title="2">{
                        resources[vi] = struct{}{}
                }</span>
        case []interface{}:<span class="cov0" title="0">
                for _, vi := range vv </span><span class="cov0" title="0">{
                        if vvi, ok := vi.(string); ok </span><span class="cov0" title="0">{
                                resources[vvi] = struct{}{}
                        }</span>
                }
        }
        <span class="cov4" title="5">return resources, result</span>
}

func resultName(rule build.Rule, result Block) Block <span class="cov4" title="4">{
        for _, pathItem := range rule.Conditions[len(rule.Conditions)-1].Path </span><span class="cov4" title="4">{
                if pathItem.Type == build.PathTypeResource </span><span class="cov4" title="4">{
                        result.Name = pathItem.Name
                        break</span>
                }
        }
        <span class="cov4" title="4">return result</span>
}
</pre>
		
		<pre class="file" id="file32" style="display: none">package descriptions

import (
        "bytes"
        "encoding/base64"
        "encoding/json"
        "fmt"
        "io"
        "net/http"
        "os"
        "time"

        "github.com/Checkmarx/kics/v2/internal/constants"
        descModel "github.com/Checkmarx/kics/v2/pkg/descriptions/model"
        "github.com/Checkmarx/kics/v2/pkg/model"
        "github.com/rs/zerolog/log"
)

var (
        // ***************************************************
        // *  HARDCODED authKey is NOT FOR SECURITY PURPOSES *
        // ***************************************************
        authKey = []rune{67, 101, 110, 116, 101, 114, 95, 102, 111, 114, 95, 73, 110, 116, 101, 114, 110, 101,
                116, 95, 83, 101, 99, 117, 114, 105, 116, 121, 95, 80, 114, 111, 112, 114, 105, 101, 116, 97, 114, 121,
                95, 67, 111, 110, 116, 101, 110, 116, 95, 99, 105, 115, 101, 99, 117, 114, 105, 116, 121, 46, 111, 114, 103}

        tr = &amp;http.Transport{
                Proxy:              http.ProxyFromEnvironment,
                MaxIdleConns:       10,
                IdleConnTimeout:    30 * time.Second,
                DisableCompression: true,
        }
        // HTTPRequestClient - http client to use for requests
        HTTPRequestClient HTTPClient = &amp;http.Client{
                Transport: tr,
                Timeout:   20 * time.Second,
        }
)

// HTTPClient - http client to use for requests
type HTTPClient interface {
        Do(req *http.Request) (*http.Response, error)
}

// HTTPDescription - HTTP client interface to use for requesting descriptions
type HTTPDescription interface {
        CheckConnection() error
        RequestDescriptions(descriptionIDs []string) (map[string]descModel.CISDescriptions, error)
        CheckLatestVersion(version string) (model.Version, error)
}

// Client - client for making descriptions requests
type Client struct {
}

// CheckConnection - checks if the endpoint is reachable
func (c *Client) CheckConnection() error <span class="cov7" title="3">{
        baseURL, err := getBaseURL()
        if err != nil </span><span class="cov1" title="1">{
                return err
        }</span>

        <span class="cov4" title="2">endpointURL := fmt.Sprintf("%s/api/", baseURL)
        req, err := http.NewRequest(http.MethodGet, endpointURL, http.NoBody) //nolint
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>

        <span class="cov4" title="2">resp, err := doRequest(req)
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>
        <span class="cov4" title="2">defer func() </span><span class="cov4" title="2">{
                if closeErr := resp.Body.Close(); closeErr != nil </span><span class="cov0" title="0">{
                        log.Err(closeErr).Msg("Error closing file")
                }</span>
        }()
        <span class="cov4" title="2">return err</span>
}

// CheckLatestVersion - Check if using KICS latest version from endpoint
func (c *Client) CheckLatestVersion(version string) (model.Version, error) <span class="cov1" title="1">{
        baseURL, err := getBaseURL()
        if err != nil </span><span class="cov0" title="0">{
                return model.Version{}, err
        }</span>
        <span class="cov1" title="1">endpointURL := fmt.Sprintf("%s/api/%s", baseURL, "version")

        versionRequest := descModel.VersionRequest{
                Version: version,
        }

        requestBody, err := json.Marshal(versionRequest)
        if err != nil </span><span class="cov0" title="0">{
                return model.Version{}, err
        }</span>

        <span class="cov1" title="1">req, err := http.NewRequest(http.MethodPost, endpointURL, bytes.NewReader(requestBody)) //nolint
        if err != nil </span><span class="cov0" title="0">{
                return model.Version{}, err
        }</span>
        <span class="cov1" title="1">req.Header.Add("Content-Type", "application/json")
        req.Header.Add("Authorization", fmt.Sprintf("Basic %s", base64.StdEncoding.EncodeToString([]byte(getBasicAuth()))))

        resp, err := doRequest(req)
        if err != nil </span><span class="cov0" title="0">{
                return model.Version{}, err
        }</span>
        <span class="cov1" title="1">defer func() </span><span class="cov1" title="1">{
                if closeErr := resp.Body.Close(); closeErr != nil </span><span class="cov0" title="0">{
                        log.Err(closeErr).Msg("Error closing file")
                }</span>
        }()

        <span class="cov1" title="1">b, err := io.ReadAll(resp.Body)
        if err != nil </span><span class="cov0" title="0">{
                return model.Version{}, err
        }</span>

        <span class="cov1" title="1">var VersionResponse model.Version
        err = json.Unmarshal(b, &amp;VersionResponse)
        if err != nil </span><span class="cov0" title="0">{
                return model.Version{}, err
        }</span>

        <span class="cov1" title="1">return VersionResponse, nil</span>
}

// RequestDescriptions - gets descriptions from endpoint
func (c *Client) RequestDescriptions(descriptionIDs []string) (map[string]descModel.CISDescriptions, error) <span class="cov1" title="1">{
        baseURL, err := getBaseURL()
        if err != nil </span><span class="cov0" title="0">{
                log.Debug().Msg("Unable to get baseURL")
                return nil, err
        }</span>

        <span class="cov1" title="1">endpointURL := fmt.Sprintf("%s/api/%s", baseURL, "descriptions")

        descriptionRequest := descModel.DescriptionRequest{
                Version:        constants.Version,
                DescriptionIDs: descriptionIDs,
        }

        requestBody, err := json.Marshal(descriptionRequest)
        if err != nil </span><span class="cov0" title="0">{
                log.Err(err).Msg("Unable to marshal request body")
                return nil, err
        }</span>

        <span class="cov1" title="1">req, err := http.NewRequest(http.MethodPost, endpointURL, bytes.NewReader(requestBody)) //nolint
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov1" title="1">req.Header.Add("Content-Type", "application/json")
        req.Header.Add("Authorization", fmt.Sprintf("Basic %s", base64.StdEncoding.EncodeToString([]byte(getBasicAuth()))))

        log.Debug().Msgf("HTTP POST to descriptions endpoint")
        startTime := time.Now()
        resp, err := doRequest(req)
        if err != nil </span><span class="cov0" title="0">{
                log.Err(err).Msgf("Unable to POST to descriptions endpoint")
                return nil, err
        }</span>
        <span class="cov1" title="1">defer func() </span><span class="cov1" title="1">{
                if closeErr := resp.Body.Close(); closeErr != nil </span><span class="cov0" title="0">{
                        log.Err(closeErr).Msg("Error closing file")
                }</span>
        }()
        <span class="cov1" title="1">endTime := time.Since(startTime)
        log.Debug().Msgf("HTTP Status: %d %s %v", resp.StatusCode, http.StatusText(resp.StatusCode), endTime)

        b, err := io.ReadAll(resp.Body)
        if err != nil </span><span class="cov0" title="0">{
                log.Err(err).Msg("Unable to read response body")
                return nil, err
        }</span>

        <span class="cov1" title="1">var getDescriptionsResponse descModel.DescriptionResponse
        err = json.Unmarshal(b, &amp;getDescriptionsResponse)
        if err != nil </span><span class="cov0" title="0">{
                log.Err(err).Msg("Unable to unmarshal response body")
                return nil, err
        }</span>

        <span class="cov1" title="1">return getDescriptionsResponse.Descriptions, nil</span>
}

// doRequest - make HTTP request
func doRequest(request *http.Request) (*http.Response, error) <span class="cov10" title="5">{
        return HTTPRequestClient.Do(request)
}</span>

func getBaseURL() (string, error) <span class="cov10" title="5">{
        var rtnBaseURL string
        urlFromEnv := os.Getenv("KICS_DESCRIPTIONS_ENDPOINT")
        if constants.BaseURL == "" &amp;&amp; urlFromEnv == "" </span><span class="cov1" title="1">{
                return "", fmt.Errorf("the BaseURL or KICS_DESCRIPTIONS_ENDPOINT environment variable not set")
        }</span>

        <span class="cov8" title="4">if urlFromEnv != "" </span><span class="cov8" title="4">{
                rtnBaseURL = urlFromEnv
        }</span> else<span class="cov0" title="0"> {
                rtnBaseURL = constants.BaseURL
        }</span>
        <span class="cov8" title="4">return rtnBaseURL, nil</span>
}

func getBasicAuth() string <span class="cov4" title="2">{
        auth := os.Getenv("KICS_BASIC_AUTH_PASS")
        if auth == "" </span><span class="cov4" title="2">{
                auth = string(authKey)
        }</span>
        <span class="cov4" title="2">return auth</span>
}
</pre>
		
		<pre class="file" id="file33" style="display: none">package descriptions

import (
        "fmt"

        "github.com/Checkmarx/kics/v2/pkg/model"
)

var (
        descClient HTTPDescription = &amp;Client{}
)

// RequestAndOverrideDescriptions - Requests descriptions and override default descriptions
func RequestAndOverrideDescriptions(summary *model.Summary) error <span class="cov8" title="1">{
        descriptionIDs := make([]string, 0)
        for idx := range summary.Queries </span><span class="cov8" title="1">{
                descriptionIDs = append(descriptionIDs, summary.Queries[idx].DescriptionID)
        }</span>

        <span class="cov8" title="1">if err := descClient.CheckConnection(); err != nil </span><span class="cov0" title="0">{
                return err
        }</span>

        <span class="cov8" title="1">descriptionMap, err := descClient.RequestDescriptions(descriptionIDs)
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>

        <span class="cov8" title="1">for idx := range summary.Queries </span><span class="cov8" title="1">{
                if descriptionMap[summary.Queries[idx].DescriptionID].DescriptionID == "" &amp;&amp;
                        descriptionMap[summary.Queries[idx].DescriptionID].RationaleText == "" </span><span class="cov0" title="0">{
                        continue</span>
                }
                <span class="cov8" title="1">descriptionID := summary.Queries[idx].DescriptionID

                summary.Queries[idx].CISDescriptionID = descriptionMap[descriptionID].DescriptionID
                summary.Queries[idx].CISDescriptionTitle = descriptionMap[descriptionID].DescriptionTitle
                summary.Queries[idx].CISDescriptionText = descriptionMap[descriptionID].DescriptionText
                summary.Queries[idx].CISRationaleText = descriptionMap[descriptionID].RationaleText
                summary.Queries[idx].CISBenchmarkName = descriptionMap[descriptionID].BenchmarkName
                summary.Queries[idx].CISBenchmarkVersion = descriptionMap[descriptionID].BenchmarkVersion

                summary.Queries[idx].CISDescriptionIDFormatted = fmt.Sprintf(
                        "Security - %s v%s - Rule %s",
                        descriptionMap[descriptionID].BenchmarkName,
                        descriptionMap[descriptionID].BenchmarkVersion,
                        descriptionMap[descriptionID].DescriptionID,
                )
                summary.Queries[idx].CISDescriptionTextFormatted = fmt.Sprintf(
                        "%s\n%s",
                        descriptionMap[descriptionID].DescriptionText,
                        descriptionMap[descriptionID].RationaleText,
                )</span>
        }
        <span class="cov8" title="1">return nil</span>
}
</pre>
		
		<pre class="file" id="file34" style="display: none">package mockclient

import (
        "net/http"

        "github.com/Checkmarx/kics/v2/pkg/descriptions/model"
        genModel "github.com/Checkmarx/kics/v2/pkg/model"
)

// MockHTTPClient - the mock http client
type MockHTTPClient struct {
        DoFunc func(req *http.Request) (*http.Response, error)
}

// Do - mock clients do function
func (m *MockHTTPClient) Do(req *http.Request) (*http.Response, error) <span class="cov10" title="5">{
        return GetDoFunc(req)
}</span>

// MockDescriptionsClient - the mock descriptions client
type MockDescriptionsClient struct {
        RequestDescriptionsFunc func(descriptionIDs []string) (map[string]model.CISDescriptions, error)
}

// RequestDescriptions - mock descriptions client request descriptions function
func (m *MockDescriptionsClient) RequestDescriptions(descriptionIDs []string) (map[string]model.CISDescriptions, error) <span class="cov1" title="1">{
        return GetDescriptions(descriptionIDs)
}</span>

// CheckConnection - mock descriptions client check connection function
func (m *MockDescriptionsClient) CheckConnection() error <span class="cov8" title="4">{
        return CheckConnection()
}</span>

// CheckLatestVersion - mock client request version function
func (m *MockDescriptionsClient) CheckLatestVersion(version string) (genModel.Version, error) <span class="cov4" title="2">{
        return CheckVersion(version)
}</span>

var (
        // GetDoFunc - mock client's `Do` func
        GetDoFunc func(req *http.Request) (*http.Response, error)
        // CheckConnection - mock client's `CheckConnection` func
        CheckConnection func() error
        // GetDescriptions - mock client's `RequestDescriptions` func
        GetDescriptions func(descriptionIDs []string) (map[string]model.CISDescriptions, error)
        // CheckVersion mock client's `CheckLatestVersion` func
        CheckVersion func(version string) (genModel.Version, error)
)

// MockRequestBody - mock request body
type MockRequestBody struct {
        Descriptions []string `json:"descriptions"`
}

// MockResponseBody - mock response body
type MockResponseBody struct {
        Descriptions map[string]string `json:"descriptions"`
}
</pre>
		
		<pre class="file" id="file35" style="display: none">package descriptions

import (
        "github.com/Checkmarx/kics/v2/internal/constants"
        "github.com/Checkmarx/kics/v2/internal/tracker"
        "github.com/Checkmarx/kics/v2/pkg/model"
)

// CheckVersion - checks if using the latest version and saves that information in the tracker
func CheckVersion(t *tracker.CITracker) <span class="cov10" title="3">{
        baseVersionInfo := model.Version{
                Latest: true,
        }

        if err := descClient.CheckConnection(); err != nil </span><span class="cov1" title="1">{
                t.TrackVersion(baseVersionInfo)
                return
        }</span>

        <span class="cov6" title="2">versionInfo, err := descClient.CheckLatestVersion(constants.Version)
        if err != nil </span><span class="cov1" title="1">{
                t.TrackVersion(baseVersionInfo)
                return
        }</span>

        <span class="cov1" title="1">t.TrackVersion(versionInfo)</span>
}
</pre>
		
		<pre class="file" id="file36" style="display: none">package detector

import (
        "strconv"
        "strings"

        "github.com/Checkmarx/kics/v2/pkg/model"
        "github.com/rs/zerolog"
)

const (
        undetectedVulnerabilityLine = -1
)

type defaultDetectLine struct {
}

// DetectLine searches vulnerability line if kindDetectLine is not in detectors
func (d defaultDetectLine) DetectLine(file *model.FileMetadata, searchKey string,
        outputLines int, logwithfields *zerolog.Logger) model.VulnerabilityLines <span class="cov6" title="3">{
        detector := &amp;DefaultDetectLineResponse{
                CurrentLine:     0,
                IsBreak:         false,
                FoundAtLeastOne: false,
                ResolvedFile:    file.FilePath,
                ResolvedFiles:   d.prepareResolvedFiles(file.ResolvedFiles),
        }

        var extractedString [][]string
        extractedString = GetBracketValues(searchKey, extractedString, "")
        sanitizedSubstring := searchKey
        for idx, str := range extractedString </span><span class="cov6" title="3">{
                sanitizedSubstring = strings.Replace(sanitizedSubstring, str[0], `{{`+strconv.Itoa(idx)+`}}`, -1)
        }</span>

        <span class="cov6" title="3">lines := *file.LinesOriginalData
        splitSanitized := strings.Split(sanitizedSubstring, ".")
        for index, split := range splitSanitized </span><span class="cov10" title="6">{
                if strings.Contains(split, "$ref") </span><span class="cov0" title="0">{
                        splitSanitized[index] = strings.Join(splitSanitized[index:], ".")
                        splitSanitized = splitSanitized[:index+1]
                        break</span>
                }
        }

        <span class="cov6" title="3">for _, key := range splitSanitized </span><span class="cov9" title="5">{
                substr1, substr2 := GenerateSubstrings(key, extractedString)

                // BICEP-specific tweaks in order to make bicep files compatible with ARM queries
                if file.Kind == "BICEP" </span><span class="cov0" title="0">{
                        substr1 = strings.ReplaceAll(substr1, "resources", "resource")
                        substr1 = strings.ReplaceAll(substr1, "parameters", "param")
                        substr1 = strings.ReplaceAll(substr1, "variables", "variable")
                }</span>

                <span class="cov9" title="5">detector, lines = detector.DetectCurrentLine(substr1, substr2, 0, lines)

                if detector.IsBreak </span><span class="cov1" title="1">{
                        break</span>
                }
        }

        <span class="cov6" title="3">if detector.FoundAtLeastOne </span><span class="cov4" title="2">{
                return model.VulnerabilityLines{
                        Line:         detector.CurrentLine + 1,
                        VulnLines:    GetAdjacentVulnLines(detector.CurrentLine, outputLines, lines),
                        ResolvedFile: detector.ResolvedFile,
                }
        }</span>

        <span class="cov1" title="1">var filePathSplit = strings.Split(file.FilePath, "/")
        logwithfields.Warn().Msgf("Failed to detect line associated with identified result in file %s\n", filePathSplit[len(filePathSplit)-1])

        return model.VulnerabilityLines{
                Line:         undetectedVulnerabilityLine,
                VulnLines:    &amp;[]model.CodeLine{},
                ResolvedFile: detector.ResolvedFile,
        }</span>
}

func (d defaultDetectLine) prepareResolvedFiles(resFiles map[string]model.ResolvedFile) map[string]model.ResolvedFileSplit <span class="cov7" title="4">{
        resolvedFiles := make(map[string]model.ResolvedFileSplit)
        for f, res := range resFiles </span><span class="cov1" title="1">{
                resolvedFiles[f] = model.ResolvedFileSplit{
                        Path:  res.Path,
                        Lines: *res.LinesContent,
                }
        }</span>
        <span class="cov7" title="4">return resolvedFiles</span>
}
</pre>
		
		<pre class="file" id="file37" style="display: none">package detector

import (
        "github.com/Checkmarx/kics/v2/pkg/model"
        "github.com/rs/zerolog"
)

type kindDetectLine interface {
        DetectLine(file *model.FileMetadata, searchKey string, outputLines int, logWithFields *zerolog.Logger) model.VulnerabilityLines
}

// DetectLine is a struct that associates a kindDetectLine to its FileKind
type DetectLine struct {
        detectors       map[model.FileKind]kindDetectLine
        outputLines     int
        logWithFields   *zerolog.Logger
        defaultDetector kindDetectLine
}

// NewDetectLine creates a new DetectLine's reference
func NewDetectLine(outputLines int) *DetectLine <span class="cov10" title="7">{
        return &amp;DetectLine{
                detectors:       make(map[model.FileKind]kindDetectLine),
                logWithFields:   &amp;zerolog.Logger{},
                outputLines:     outputLines,
                defaultDetector: defaultDetectLine{},
        }
}</span>

// SetupLogs will change the logger feild to be used in kindDetectLine DetectLine method
func (d *DetectLine) SetupLogs(logger *zerolog.Logger) <span class="cov1" title="1">{
        d.logWithFields = logger
}</span>

// Add adds a new kindDetectLine to the caller and returns it
func (d *DetectLine) Add(detector kindDetectLine, kind model.FileKind) *DetectLine <span class="cov6" title="3">{
        d.detectors[kind] = detector
        return d
}</span>

// DetectLine will use the correct kindDetectLine according to the files kind
// if file kind is not in detectors default detect line is called
func (d *DetectLine) DetectLine(file *model.FileMetadata, searchKey string, logWithFields *zerolog.Logger) model.VulnerabilityLines <span class="cov4" title="2">{
        if det, ok := d.detectors[file.Kind]; ok </span><span class="cov1" title="1">{
                return det.DetectLine(file, searchKey, d.outputLines, logWithFields)
        }</span>
        <span class="cov1" title="1">return d.defaultDetector.DetectLine(file, searchKey, d.outputLines, logWithFields)</span>
}

// GetAdjacent finds and returns the lines adjacent to the line containing the vulnerability
func (d *DetectLine) GetAdjacent(file *model.FileMetadata, line int) model.VulnerabilityLines <span class="cov4" title="2">{
        return model.VulnerabilityLines{
                Line:         line,
                VulnLines:    GetAdjacentVulnLines(line-1, d.outputLines, *file.LinesOriginalData),
                ResolvedFile: file.FilePath,
        }
}</span>
</pre>
		
		<pre class="file" id="file38" style="display: none">package docker

import (
        "regexp"
        "strconv"
        "strings"

        "github.com/Checkmarx/kics/v2/pkg/detector"
        "github.com/Checkmarx/kics/v2/pkg/model"
        "github.com/rs/zerolog"
)

// DetectKindLine defines a kindDetectLine type
type DetectKindLine struct {
}

const (
        undetectedVulnerabilityLine = -1
)

var (
        nameRegexDockerFileML = regexp.MustCompile(`.+\s+\\$`)
        commentRegex          = regexp.MustCompile(`^\s*#.*`)
        splitRegex            = regexp.MustCompile(`\s\\`)
)

// DetectLine searches vulnerability line in docker files
func (d DetectKindLine) DetectLine(file *model.FileMetadata, searchKey string,
        outputLines int, logwithfields *zerolog.Logger) model.VulnerabilityLines <span class="cov3" title="3">{
        det := &amp;detector.DefaultDetectLineResponse{
                CurrentLine:     0,
                IsBreak:         false,
                FoundAtLeastOne: false,
                ResolvedFile:    file.FilePath,
                ResolvedFiles:   make(map[string]model.ResolvedFileSplit),
        }

        var extractedString [][]string
        extractedString = detector.GetBracketValues(searchKey, extractedString, "")
        sKey := searchKey
        for idx, str := range extractedString </span><span class="cov4" title="5">{
                sKey = strings.Replace(sKey, str[0], `{{`+strconv.Itoa(idx)+`}}`, -1)
        }</span>

        <span class="cov3" title="3">unchangedText := make([]string, len(*file.LinesOriginalData))
        copy(unchangedText, *file.LinesOriginalData)

        for _, key := range strings.Split(sKey, ".") </span><span class="cov4" title="6">{
                substr1, substr2 := detector.GenerateSubstrings(key, extractedString)

                det, _ = det.DetectCurrentLine(substr1, substr2, 0, prepareDockerFileLines(*file.LinesOriginalData))

                if det.IsBreak </span><span class="cov0" title="0">{
                        break</span>
                }
        }

        <span class="cov3" title="3">if det.FoundAtLeastOne </span><span class="cov3" title="3">{
                return model.VulnerabilityLines{
                        Line:         det.CurrentLine + 1,
                        VulnLines:    detector.GetAdjacentVulnLines(det.CurrentLine, outputLines, unchangedText),
                        ResolvedFile: file.FilePath,
                }
        }</span>

        <span class="cov0" title="0">logwithfields.Warn().Msgf("Failed to detect Docker line, query response %s", sKey)

        return model.VulnerabilityLines{
                Line:         undetectedVulnerabilityLine,
                VulnLines:    &amp;[]model.CodeLine{},
                ResolvedFile: file.FilePath,
        }</span>
}

func prepareDockerFileLines(text []string) []string <span class="cov4" title="6">{
        for idx, key := range text </span><span class="cov9" title="74">{
                if !commentRegex.MatchString(key) </span><span class="cov9" title="74">{
                        text[idx] = multiLineSpliter(text, key, idx)
                }</span>
        }
        <span class="cov4" title="6">return text</span>
}

func multiLineSpliter(textSplit []string, key string, idx int) string <span class="cov10" title="85">{
        if nameRegexDockerFileML.MatchString(key) </span><span class="cov5" title="11">{
                i := idx + 1
                if i &gt;= len(textSplit) </span><span class="cov0" title="0">{
                        return textSplit[idx]
                }</span>
                <span class="cov5" title="11">for textSplit[i] == "" </span><span class="cov5" title="8">{
                        i++
                        if i &gt;= len(textSplit) </span><span class="cov0" title="0">{
                                return textSplit[idx]
                        }</span>
                }
                <span class="cov5" title="11">if commentRegex.MatchString(textSplit[i]) </span><span class="cov0" title="0">{
                        textSplit[i] += " \\"
                }</span>
                <span class="cov5" title="11">textSplit[idx] = splitRegex.ReplaceAllLiteralString(textSplit[idx], " "+textSplit[i])
                textSplit[i] = ""
                textSplit[idx] = multiLineSpliter(textSplit, textSplit[idx], idx)</span>
        }
        <span class="cov10" title="85">return textSplit[idx]</span>
}
</pre>
		
		<pre class="file" id="file39" style="display: none">package helm

import (
        "fmt"
        "sort"
        "strconv"
        "strings"

        "github.com/Checkmarx/kics/v2/pkg/detector"
        "github.com/Checkmarx/kics/v2/pkg/model"
        "github.com/agnivade/levenshtein"
        "github.com/rs/zerolog"
)

// DetectKindLine defines a kindDetectLine type
type DetectKindLine struct {
}

type detectCurlLine struct {
        foundRes   bool
        lineRes    int
        breakRes   bool
        lastUnique dupHistory
}

// dupHistory keeps the history of uniques
type dupHistory struct {
        unique         bool
        lastUniqueLine int
}

const (
        undetectedVulnerabilityLine = -1
)

// DetectLine is used to detect line on the helm template,
// it looks only at the keys of the template and will make use of the auxiliary added
// lines (ex: "# KICS_HELM_ID_")
func (d DetectKindLine) DetectLine(file *model.FileMetadata, searchKey string,
        outputLines int, logWithFields *zerolog.Logger) model.VulnerabilityLines <span class="cov2" title="3">{
        searchKey = fmt.Sprintf("%s.%s", strings.TrimRight(strings.TrimLeft(file.HelmID, "# "), ":"), searchKey)

        lines := make([]string, len(*file.LinesOriginalData))
        copy(lines, *file.LinesOriginalData)

        curLineRes := detectCurlLine{
                foundRes: false,
                lineRes:  0,
                breakRes: false,
        }
        var extractedString [][]string
        extractedString = detector.GetBracketValues(searchKey, extractedString, "")
        sanitizedSubstring := searchKey
        for idx, str := range extractedString </span><span class="cov3" title="6">{
                sanitizedSubstring = strings.Replace(sanitizedSubstring, str[0], `{{`+strconv.Itoa(idx)+`}}`, -1)
        }</span>

        <span class="cov2" title="3">helmID, err := strconv.Atoi(strings.TrimSuffix(strings.TrimPrefix(file.HelmID, "# KICS_HELM_ID_"), ":"))
        if err != nil </span><span class="cov0" title="0">{
                helmID = -1
        }</span>

        // Since we are only looking at keys we can ignore the second value passed through '=' and '[]'
        <span class="cov2" title="3">for _, key := range strings.Split(sanitizedSubstring, ".") </span><span class="cov5" title="18">{
                substr1, _ := detector.GenerateSubstrings(key, extractedString)
                curLineRes = curLineRes.detectCurrentLine(lines, fmt.Sprintf("%s:", substr1), "", true, file.IDInfo, helmID)

                if curLineRes.breakRes </span><span class="cov0" title="0">{
                        break</span>
                }
        }

        // Look at dupHistory to see if the last element was duplicate, if so
        // change the line to the last unique key
        <span class="cov2" title="3">if !curLineRes.lastUnique.unique </span><span class="cov1" title="1">{
                curLineRes.lineRes = curLineRes.lastUnique.lastUniqueLine
        }</span>

        <span class="cov2" title="3">if curLineRes.foundRes </span><span class="cov2" title="3">{
                lineRemove := make(map[int]int)
                count := 0
                for i, line := range lines </span><span class="cov7" title="74">{ // Remove auxiliary lines
                        if strings.Contains(line, "# KICS_HELM_ID_") </span><span class="cov3" title="4">{
                                count++
                                lineRemove[i] = count
                                lines = append(lines[:i], lines[i+1:]...)
                        }</span>
                }
                // Update found line
                <span class="cov2" title="3">curLineRes.lineRes = removeLines(curLineRes.lineRes, lineRemove)
                return model.VulnerabilityLines{
                        Line:                  curLineRes.lineRes + 1,
                        VulnLines:             detector.GetAdjacentVulnLines(curLineRes.lineRes, outputLines, lines),
                        LineWithVulnerability: strings.Split(lines[curLineRes.lineRes], ": ")[0],
                        ResolvedFile:          file.FilePath,
                }</span>
        }

        <span class="cov0" title="0">var filePathSplit = strings.Split(file.FilePath, "/")
        logWithFields.Warn().Msgf("Failed to detect line associated with identified result in file %s\n", filePathSplit[len(filePathSplit)-1])

        return model.VulnerabilityLines{
                Line:         undetectedVulnerabilityLine,
                VulnLines:    &amp;[]model.CodeLine{},
                ResolvedFile: file.FilePath,
        }</span>
}

// removeLines is used to update the vulnerability line after removing the "# KICS_HELM_ID_"
func removeLines(current int, lineRemove map[int]int) int <span class="cov2" title="3">{
        orderByKey := make([]int, len(lineRemove))
        i := 0
        for k := range lineRemove </span><span class="cov3" title="4">{
                orderByKey[i] = k
                i++
        }</span>
        <span class="cov2" title="3">remove := 0
        sort.Ints(orderByKey)
        for _, k := range orderByKey </span><span class="cov3" title="4">{
                if current &gt; k </span><span class="cov3" title="4">{
                        remove = lineRemove[k]
                }</span> else<span class="cov0" title="0"> {
                        break</span>
                }
        }
        <span class="cov2" title="3">current -= remove
        return current</span>
}

func (d detectCurlLine) detectCurrentLine(lines []string, str1,
        str2 string, byKey bool, idInfo map[int]interface{}, id int) detectCurlLine <span class="cov5" title="18">{
        distances := make(map[int]int)
        for i := d.lineRes; i &lt; len(lines); i++ </span><span class="cov10" title="311">{
                if str1 != "" &amp;&amp; str2 != "" </span><span class="cov0" title="0">{
                        if strings.Contains(lines[i], str1) &amp;&amp; strings.Contains(lines[i], str2) </span><span class="cov0" title="0">{
                                distances[i] = levenshtein.ComputeDistance(detector.ExtractLineFragment(lines[i], str2, byKey), str2)
                        }</span>
                } else<span class="cov10" title="311"> if str1 != "" </span><span class="cov10" title="311">{
                        if strings.Contains(lines[i], str1) </span><span class="cov5" title="23">{
                                distances[i] = levenshtein.ComputeDistance(
                                        detector.ExtractLineFragment(strings.TrimSpace(lines[i]), str1, byKey), str1)
                        }</span>
                }
        }

        <span class="cov5" title="18">lastSingle := d.lastUnique.lastUniqueLine

        if len(distances) == 0 </span><span class="cov0" title="0">{
                return detectCurlLine{
                        foundRes: d.foundRes,
                        lineRes:  d.lineRes,
                        breakRes: true,
                        lastUnique: dupHistory{
                                lastUniqueLine: lastSingle,
                                unique:         d.lastUnique.unique,
                        },
                }
        }</span>

        <span class="cov5" title="18">lineResponse := detector.SelectLineWithMinimumDistance(distances, d.lineRes)
        // if lineResponse is unique
        unique := detectLastSingle(lineResponse, distances, idInfo, id)
        if unique </span><span class="cov5" title="17">{
                lastSingle = lineResponse
        }</span>

        <span class="cov5" title="18">return detectCurlLine{
                foundRes: true,
                lineRes:  lineResponse,
                breakRes: false,
                lastUnique: dupHistory{
                        unique:         unique,
                        lastUniqueLine: lastSingle,
                },
        }</span>
}

// detectLastSingle checks if the line is unique or a duplicate
func detectLastSingle(line int, dis map[int]int, idInfo map[int]interface{}, id int) bool <span class="cov5" title="18">{
        if idInfo == nil </span><span class="cov4" title="12">{
                return true
        }</span>
        <span class="cov3" title="6">for key, value := range dis </span><span class="cov4" title="9">{
                if value == dis[line] &amp;&amp; key != line </span><span class="cov1" title="1">{
                        // check if we are only looking at original data equivalent to the vulnerability
                        if ok := idInfo[id].(map[int]int)[key]; ok != 0 </span><span class="cov1" title="1">{
                                return false
                        }</span>
                }
        }
        <span class="cov3" title="5">return true</span>
}
</pre>
		
		<pre class="file" id="file40" style="display: none">package detector

import (
        "fmt"
        "regexp"
        "strconv"
        "strings"

        "github.com/agnivade/levenshtein"

        "github.com/Checkmarx/kics/v2/internal/constants"
        "github.com/Checkmarx/kics/v2/pkg/model"
        "github.com/rs/zerolog/log"
)

var (
        nameRegex       = regexp.MustCompile(`^([A-Za-z\d-_]+)\[([A-Za-z\d-_{}]+)]$`)
        nameRegexDocker = regexp.MustCompile(`{{(.*?)}}`)
)

const (
        namePartsLength  = 3
        valuePartsLength = 2
)

// DefaultDetectLineResponse is the default response for struct DetectLine
type DefaultDetectLineResponse struct {
        CurrentLine     int
        IsBreak         bool
        FoundAtLeastOne bool
        ResolvedFile    string
        ResolvedFiles   map[string]model.ResolvedFileSplit
}

// GetBracketValues gets values inside "{{ }}" ignoring any "{{" or "}}" inside
func GetBracketValues(expr string, list [][]string, restOfString string) [][]string <span class="cov7" title="21">{
        var tempList []string
        firstOpen := strings.Index(expr, "{{")
        firstClose := strings.Index(expr, "}}")
        for firstOpen &gt; firstClose &amp;&amp; firstClose != -1 </span><span class="cov1" title="1">{
                firstClose = strings.Index(expr[firstOpen:], "}}") + firstOpen
        }</span>
        // in case we have '}}}' we need to advance one position to get the close
        <span class="cov7" title="21">for firstClose+2 &lt; len(expr) &amp;&amp; string(expr[firstClose+2]) == `}` &amp;&amp; firstClose != -1 </span><span class="cov1" title="1">{
                firstClose++
        }</span>

        <span class="cov7" title="21">switch t := firstClose - firstOpen; t &gt;= 0 </span>{
        case true:<span class="cov7" title="18">
                if t == 0 &amp;&amp; expr != "" </span><span class="cov5" title="8">{
                        tempList = append(tempList, fmt.Sprintf("{{%s}}", expr), expr)
                        list = append(list, tempList)
                }</span>
                <span class="cov7" title="18">if t == 0 &amp;&amp; restOfString == "" </span><span class="cov5" title="9">{
                        return list // if there is no more string to read from return value of list
                }</span>
                <span class="cov5" title="9">if t &gt; 0 &amp;&amp; firstOpen+2 &lt;= firstClose </span><span class="cov5" title="8">{
                        list = GetBracketValues(expr[firstOpen+2:firstClose], list, expr[firstClose+2:])
                }</span> else<span class="cov1" title="1"> {
                        list = GetBracketValues(restOfString, list, "") // recursive call to the rest of the string
                }</span>
        case false:<span class="cov3" title="3">
                nextClose := strings.Index(restOfString, "}}")
                tempNextClose := nextClose + 2
                if tempNextClose == len(restOfString) </span><span class="cov2" title="2">{
                        tempNextClose = nextClose
                }</span>
                <span class="cov3" title="3">tempList = append(tempList, fmt.Sprintf("{{%s}}%s}}", expr, restOfString[:tempNextClose]),
                        fmt.Sprintf("%s}}%s", expr, restOfString[:tempNextClose]))
                list = append(list, tempList)
                list = GetBracketValues(restOfString[nextClose+2:], list, "")</span> // recursive call to the rest of the string
        }

        <span class="cov6" title="12">return list</span>
}

// GenerateSubstrings returns the substrings used for line searching depending on search key
// '.' is new line
// '=' is value in the same line
// '[]' is in the same line
func GenerateSubstrings(key string, extractedString [][]string) (substr1Res, substr2Res string) <span class="cov4" title="5">{
        var substr1, substr2 string
        if parts := nameRegex.FindStringSubmatch(key); len(parts) == namePartsLength </span><span class="cov2" title="2">{
                substr1, substr2 = getKeyWithCurlyBrackets(key, extractedString, parts)
        }</span> else<span class="cov3" title="3"> if parts := strings.Split(key, "="); len(parts) == valuePartsLength </span><span class="cov1" title="1">{
                substr1, substr2 = getKeyWithCurlyBrackets(key, extractedString, parts)
        }</span> else<span class="cov2" title="2"> {
                parts := []string{key, ""}
                substr1, substr2 = getKeyWithCurlyBrackets(key, extractedString, parts)
        }</span>
        <span class="cov4" title="5">return substr1, substr2</span>
}

func getKeyWithCurlyBrackets(key string, extractedString [][]string, parts []string) (substr1Res, substr2Res string) <span class="cov4" title="5">{
        var substr1, substr2 string
        extractedPart := nameRegexDocker.FindStringSubmatch(key)
        if len(extractedPart) == valuePartsLength </span><span class="cov1" title="1">{
                for idx, key := range parts </span><span class="cov2" title="2">{
                        if extractedPart[0] == key </span><span class="cov1" title="1">{
                                switch idx </span>{
                                case len(parts) - 2:<span class="cov0" title="0">
                                        i, err := strconv.Atoi(extractedPart[1])
                                        if err != nil </span><span class="cov0" title="0">{
                                                log.Error().Msgf("failed to extract curly brackets substring")
                                        }</span>
                                        <span class="cov0" title="0">if len(extractedString) &gt; i </span><span class="cov0" title="0">{
                                                if extractedString[i][1] != "" </span><span class="cov0" title="0">{
                                                        substr1 = extractedString[i][1]
                                                }</span>
                                        }
                                case len(parts) - 1:<span class="cov1" title="1">
                                        i, err := strconv.Atoi(extractedPart[1])
                                        if err != nil </span><span class="cov0" title="0">{
                                                log.Error().Msgf("failed to extract curly brackets substring")
                                        }</span>
                                        <span class="cov1" title="1">if len(extractedString) &gt; i </span><span class="cov1" title="1">{
                                                if extractedString[i][1] != "" </span><span class="cov1" title="1">{
                                                        substr2 = extractedString[i][1]
                                                }</span>
                                        }
                                }
                        } else<span class="cov1" title="1"> {
                                substr1 = generateSubstr(substr1, parts, valuePartsLength)
                                substr2 = generateSubstr(substr2, parts, 1)
                        }</span>
                }
        } else<span class="cov4" title="4"> {
                substr1 = parts[len(parts)-2]
                substr2 = parts[len(parts)-1]
        }</span>

        <span class="cov4" title="5">return substr1, substr2</span>
}

func generateSubstr(substr string, parts []string, length int) string <span class="cov2" title="2">{
        if substr == "" </span><span class="cov2" title="2">{
                substr = parts[len(parts)-length]
        }</span>
        <span class="cov2" title="2">return substr</span>
}

// GetAdjacentVulnLines is used to get the lines adjacent to the line that contains the vulnerability
// adj is the amount of lines wanted
func GetAdjacentVulnLines(idx, adj int, lines []string) *[]model.CodeLine <span class="cov6" title="11">{
        var endPos int
        var startPos int
        if adj &lt;= len(lines) </span><span class="cov6" title="10">{
                endPos = idx + adj/2 + 1 // if adj lines passes the number of lines in file
                if len(lines) &lt; endPos </span><span class="cov1" title="1">{
                        endPos = len(lines)
                }</span>
                <span class="cov6" title="10">startAdj := adj
                if adj%2 == 0 </span><span class="cov2" title="2">{
                        startAdj--
                }</span>

                <span class="cov6" title="10">startPos = idx - startAdj/2 // if adj lines passes the first line in the file
                if startPos &lt; 0 </span><span class="cov3" title="3">{
                        startPos = 0
                }</span>
        } else<span class="cov1" title="1"> { // in case adj is bigger than number of lines in file
                adj = len(lines)
                endPos = len(lines)
                startPos = 0
        }</span>

        <span class="cov6" title="11">switch idx </span>{
        case 0:<span class="cov4" title="4">
                // case vulnerability is the first line of the file
                return createVulnLines(1, lines[:adj])</span>
        case len(lines) - 1:<span class="cov3" title="3">
                // case vulnerability is the last line of the file
                return createVulnLines(len(lines)-adj+1, lines[len(lines)-adj:])</span>
        default:<span class="cov4" title="4">
                // case vulnerability is in the middle of the file
                return createVulnLines(startPos+1, lines[startPos:endPos])</span>
        }
}

// createVulnLines is the function that will  generate the array that contains the lines numbers
// used to alter the color of the line that contains the vulnerability
func createVulnLines(startPos int, lines []string) *[]model.CodeLine <span class="cov6" title="11">{
        vulns := make([]model.CodeLine, len(lines))
        for idx, line := range lines </span><span class="cov8" title="30">{
                vulns[idx] = model.CodeLine{
                        Line:     line,
                        Position: startPos,
                }
                startPos++
        }</span>
        <span class="cov6" title="11">return &amp;vulns</span>
}

// SelectLineWithMinimumDistance will search a map of levenshtein distances to find the minimum distance
func SelectLineWithMinimumDistance(distances map[int]int, startingFrom int) int <span class="cov5" title="8">{
        minDistance, lineOfMinDistance := constants.MaxInteger, startingFrom
        for line, distance := range distances </span><span class="cov6" title="12">{
                if distance &lt; minDistance || distance == minDistance &amp;&amp; line &lt; lineOfMinDistance </span><span class="cov6" title="10">{
                        minDistance = distance
                        lineOfMinDistance = line
                }</span>
        }

        <span class="cov5" title="8">return lineOfMinDistance</span>
}

// ExtractLineFragment will prepare substr for line detection
func ExtractLineFragment(line, substr string, key bool) string <span class="cov5" title="9">{
        // If detecting line by keys only
        idx := strings.Index(line, ":")
        if key &amp;&amp; idx &gt;= 0 </span><span class="cov0" title="0">{
                return line[:idx]
        }</span>
        <span class="cov5" title="9">start := strings.Index(line, substr)
        end := start + len(substr)

        for start &gt;= 0 </span><span class="cov7" title="19">{
                if line[start] == ' ' </span><span class="cov4" title="5">{
                        break</span>
                }

                <span class="cov6" title="14">start--</span>
        }

        <span class="cov5" title="9">for end &lt; len(line) </span><span class="cov7" title="15">{
                if line[end] == ' ' </span><span class="cov5" title="8">{
                        break</span>
                }

                <span class="cov5" title="7">end++</span>
        }

        <span class="cov5" title="9">return removeExtras(line, start, end)</span>
}

func removeExtras(result string, start, end int) string <span class="cov5" title="9">{
        // workaround for selecting yaml keys
        if result[end-1] == ':' </span><span class="cov2" title="2">{
                end--
        }</span>

        <span class="cov5" title="9">if result[end-1] == '"' </span><span class="cov5" title="7">{
                end--
        }</span>

        <span class="cov5" title="9">if result[start+1] == '"' </span><span class="cov5" title="7">{
                start++
        }</span>

        <span class="cov5" title="9">return result[start+1 : end]</span>
}

// DetectCurrentLine uses levenshtein distance to find the most accurate line for the vulnerability
func (d *DefaultDetectLineResponse) DetectCurrentLine(str1, str2 string, recurseCount int,
        lines []string) (det *DefaultDetectLineResponse, l []string) <span class="cov4" title="6">{
        distances := make(map[int]int)

        for i := d.CurrentLine; i &lt; len(lines); i++ </span><span class="cov10" title="57">{
                distances = checkLine(str1, str2, distances, lines[i], i)
        }</span>

        <span class="cov4" title="6">if len(distances) == 0 </span><span class="cov1" title="1">{
                d.IsBreak = true
                return d, lines
        }</span>

        <span class="cov4" title="5">d.CurrentLine = SelectLineWithMinimumDistance(distances, d.CurrentLine)
        d.IsBreak = false
        d.FoundAtLeastOne = true

        return d, lines</span>
}

func checkLine(str1, str2 string, distances map[int]int, line string, i int) map[int]int <span class="cov10" title="57">{
        regex := regexp.MustCompile(`^\s+`)
        line = regex.ReplaceAllString(line, "")
        if str1 != "" &amp;&amp; str2 != "" &amp;&amp; strings.Contains(line, str1) </span><span class="cov4" title="4">{
                restLine := line[strings.Index(line, str1)+len(str1):]
                if strings.Contains(restLine, str2) </span><span class="cov3" title="3">{
                        distances[i] = levenshtein.ComputeDistance(ExtractLineFragment(line, str1, false), str1)
                        distances[i] += levenshtein.ComputeDistance(ExtractLineFragment(restLine, str2, false), str2)
                }</span>
        } else<span class="cov9" title="53"> if str1 != "" &amp;&amp; strings.Contains(line, str1) </span><span class="cov3" title="3">{
                distances[i] = levenshtein.ComputeDistance(ExtractLineFragment(line, str1, false), str1)
        }</span>

        <span class="cov10" title="57">return distances</span>
}
</pre>
		
		<pre class="file" id="file41" style="display: none">package detector

import (
        "encoding/json"
        "strconv"
        "strings"

        "github.com/Checkmarx/kics/v2/pkg/model"
        "github.com/tidwall/gjson"
)

// searchLineDetector is the struct used to get the line from the payload with lines information
// content - payload with line information
// resolvedPath - string created from pathComponents, used to create gjson paths
// resolvedArrayPath - string created from pathComponents containing an array used to create gjson paths
// targetObj - key of the interface{}, we want the line from
type searchLineDetector struct {
        content           []byte
        resolvedPath      string
        resolvedArrayPath string
        targetObj         string
}

// GetLineBySearchLine makes use of the gjson pkg to find the line of a key in the original file
// with it's path given by a slice of strings
func GetLineBySearchLine(pathComponents []string, file *model.FileMetadata) (int, error) <span class="cov6" title="5">{
        content, err := json.Marshal(file.LineInfoDocument)
        if err != nil </span><span class="cov0" title="0">{
                return -1, err
        }</span>

        <span class="cov6" title="5">detector := &amp;searchLineDetector{
                content: content,
        }

        return detector.preparePath(pathComponents), nil</span>
}

// preparePath resolves the path components and retrives important information
// for the creation of the paths to search
func (d *searchLineDetector) preparePath(pathItems []string) int <span class="cov6" title="5">{
        if len(pathItems) == 0 </span><span class="cov0" title="0">{
                return 1
        }</span>
        // Escaping '.' in path components so it doesn't conflict with gjson pkg
        <span class="cov6" title="5">objPath := strings.ReplaceAll(pathItems[0], ".", "\\.")
        ArrPath := strings.ReplaceAll(pathItems[0], ".", "\\.")

        obj := pathItems[len(pathItems)-1]

        arrayObject := ""

        // Iterate reversely through the path components and get the key of the last array in the path
        // needed for cases where the fields in the array are &lt;"key": "value"&gt; type and not &lt;object&gt;
        foundArrayIdx := false
        for i := len(pathItems) - 1; i &gt;= 0; i-- </span><span class="cov10" title="14">{
                if _, err := strconv.Atoi(pathItems[i]); err == nil </span><span class="cov4" title="3">{
                        foundArrayIdx = true
                        continue</span>
                }
                <span class="cov9" title="11">if foundArrayIdx </span><span class="cov4" title="3">{
                        arrayObject = pathItems[i]
                        break</span>
                }
        }

        <span class="cov6" title="5">if arrayObject == objPath </span><span class="cov3" title="2">{
                ArrPath = "_kics_lines._kics_" + arrayObject + "._kics_arr"
        }</span>

        <span class="cov6" title="5">var treatedPathItems []string
        if len(pathItems) &gt; 1 </span><span class="cov6" title="5">{
                treatedPathItems = pathItems[1 : len(pathItems)-1]
        }</span>

        // Create a string based on the path components so it can be later transformed in a gjson path
        <span class="cov6" title="5">for _, pathItem := range treatedPathItems </span><span class="cov6" title="5">{
                // In case of an array present
                if pathItem == arrayObject </span><span class="cov1" title="1">{
                        ArrPath += "._kics_lines._kics_" + strings.ReplaceAll(pathItem, ".", "\\.") + "._kics_arr"
                }</span> else<span class="cov5" title="4"> {
                        ArrPath += "." + strings.ReplaceAll(pathItem, ".", "\\.")
                }</span>
                <span class="cov6" title="5">objPath += "." + strings.ReplaceAll(pathItem, ".", "\\.")</span>
        }

        <span class="cov6" title="5">d.resolvedPath = objPath
        d.resolvedArrayPath = ArrPath
        d.targetObj = obj

        return d.getResult()</span>
}

// getResult creates the paths to be used by gjson pkg to find the line in the content
func (d *searchLineDetector) getResult() int <span class="cov6" title="5">{
        pathObjects := []string{
                d.resolvedPath + "._kics_lines._kics_" + d.targetObj + "._kics_line",
                d.resolvedPath + "." + d.targetObj + "._kics_lines._kics__default._kics_line",
                d.resolvedArrayPath + "." + d.targetObj + "._kics__default._kics_line",
                d.resolvedArrayPath + "._kics_" + d.targetObj + "._kics_line",
        }

        result := -1
        // run gjson pkg
        for _, pathItem := range pathObjects </span><span class="cov8" title="10">{
                if tmpResult := gjson.GetBytes(d.content, pathItem); int(tmpResult.Int()) &gt; 0 </span><span class="cov6" title="5">{
                        result = int(tmpResult.Int())
                        break</span>
                }
        }
        <span class="cov6" title="5">return result</span>
}
</pre>
		
		<pre class="file" id="file42" style="display: none">package engine

import (
        "bytes"
        "context"
        "encoding/json"
        "fmt"

        "runtime"
        "strings"
        "sync"
        "time"

        "github.com/Checkmarx/kics/v2/internal/metrics"
        sentryReport "github.com/Checkmarx/kics/v2/internal/sentry"
        "github.com/Checkmarx/kics/v2/pkg/detector"
        "github.com/Checkmarx/kics/v2/pkg/detector/docker"
        "github.com/Checkmarx/kics/v2/pkg/detector/helm"
        "github.com/Checkmarx/kics/v2/pkg/engine/source"
        "github.com/Checkmarx/kics/v2/pkg/model"
        "github.com/open-policy-agent/opa/ast"
        "github.com/open-policy-agent/opa/cover"
        "github.com/open-policy-agent/opa/rego"
        "github.com/open-policy-agent/opa/storage/inmem"
        "github.com/open-policy-agent/opa/topdown"
        "github.com/open-policy-agent/opa/util"
        "github.com/pkg/errors"
        "github.com/rs/zerolog/log"
)

// Default values for inspector
const (
        UndetectedVulnerabilityLine = -1
        DefaultQueryID              = "Undefined"
        DefaultQueryName            = "Anonymous"
        DefaultExperimental         = false
        DefaultQueryDescription     = "Undefined"
        DefaultQueryDescriptionID   = "Undefined"
        DefaultQueryURI             = "https://github.com/Checkmarx/kics/"
        DefaultIssueType            = model.IssueTypeIncorrectValue

        regoQuery = `result = data.Cx.CxPolicy`
)

// ErrNoResult - error representing when a query didn't return a result
var ErrNoResult = errors.New("query: not result")

// ErrInvalidResult - error representing invalid result
var ErrInvalidResult = errors.New("query: invalid result format")

// QueryLoader is responsible for loading the queries for the inspector
type QueryLoader struct {
        commonLibrary     source.RegoLibraries
        platformLibraries map[string]source.RegoLibraries
        querySum          int
        QueriesMetadata   []model.QueryMetadata
}

// VulnerabilityBuilder represents a function that will build a vulnerability
type VulnerabilityBuilder func(ctx *QueryContext, tracker Tracker, v interface{},
        detector *detector.DetectLine, useOldSeverities bool, kicsComputeNewSimID bool) (*model.Vulnerability, error)

// PreparedQuery includes the opaQuery and its metadata
type PreparedQuery struct {
        OpaQuery rego.PreparedEvalQuery
        Metadata model.QueryMetadata
}

// Inspector represents a list of compiled queries, a builder for vulnerabilities, an information tracker
// a flag to enable coverage and the coverage report if it is enabled
type Inspector struct {
        QueryLoader    *QueryLoader
        vb             VulnerabilityBuilder
        tracker        Tracker
        failedQueries  map[string]error
        excludeResults map[string]bool
        detector       *detector.DetectLine

        enableCoverageReport bool
        coverageReport       cover.Report
        queryExecTimeout     time.Duration
        useOldSeverities     bool
        numWorkers           int
        kicsComputeNewSimID  bool
}

// QueryContext contains the context where the query is executed, which scan it belongs, basic information of query,
// the query compiled and its payload
type QueryContext struct {
        Ctx           context.Context
        scanID        string
        Files         map[string]model.FileMetadata
        Query         *PreparedQuery
        payload       *ast.Value
        BaseScanPaths []string
}

var (
        unsafeRegoFunctions = map[string]struct{}{
                "http.send":   {},
                "opa.runtime": {},
        }
)

func adjustNumWorkers(workers int) int <span class="cov4" title="5">{
        // for the case in which the end user decides to use num workers as "auto-detected"
        // we will set the number of workers to the number of CPUs available based on GOMAXPROCS value
        if workers == 0 </span><span class="cov0" title="0">{
                return runtime.GOMAXPROCS(-1)
        }</span>
        <span class="cov4" title="5">return workers</span>
}

// NewInspector initializes a inspector, compiling and loading queries for scan and its tracker
func NewInspector(
        ctx context.Context,
        queriesSource source.QueriesSource,
        vb VulnerabilityBuilder,
        tracker Tracker,
        queryParameters *source.QueryInspectorParameters,
        excludeResults map[string]bool,
        queryTimeout int,
        useOldSeverities bool,
        needsLog bool,
        numWorkers int,
        kicsComputeNewSimID bool) (*Inspector, error) <span class="cov4" title="5">{
        log.Debug().Msg("engine.NewInspector()")

        metrics.Metric.Start("get_queries")
        queries, err := queriesSource.GetQueries(queryParameters)
        if err != nil </span><span class="cov0" title="0">{
                return nil, errors.Wrap(err, "failed to get queries")
        }</span>

        <span class="cov4" title="5">commonLibrary, err := queriesSource.GetQueryLibrary("common")
        if err != nil </span><span class="cov0" title="0">{
                sentryReport.ReportSentry(&amp;sentryReport.Report{
                        Message:  fmt.Sprintf("Inspector failed to get library for %s platform", "common"),
                        Err:      err,
                        Location: "func NewInspector()",
                        Platform: "common",
                }, true)
                return nil, errors.Wrap(err, "failed to get library")
        }</span>
        <span class="cov4" title="5">platformLibraries := getPlatformLibraries(queriesSource, queries)

        queryLoader := prepareQueries(queries, commonLibrary, platformLibraries, tracker)

        failedQueries := make(map[string]error)

        metrics.Metric.Stop()

        if needsLog </span><span class="cov4" title="5">{
                log.Info().
                        Msgf("Inspector initialized, number of queries=%d", queryLoader.querySum)
        }</span>

        <span class="cov4" title="5">lineDetector := detector.NewDetectLine(tracker.GetOutputLines()).
                Add(helm.DetectKindLine{}, model.KindHELM).
                Add(docker.DetectKindLine{}, model.KindDOCKER).
                Add(docker.DetectKindLine{}, model.KindBUILDAH)

        queryExecTimeout := time.Duration(queryTimeout) * time.Second

        if needsLog </span><span class="cov4" title="5">{
                log.Info().Msgf("Query execution timeout=%v", queryExecTimeout)
        }</span>

        <span class="cov4" title="5">return &amp;Inspector{
                QueryLoader:         &amp;queryLoader,
                vb:                  vb,
                tracker:             tracker,
                failedQueries:       failedQueries,
                excludeResults:      excludeResults,
                detector:            lineDetector,
                queryExecTimeout:    queryExecTimeout,
                useOldSeverities:    useOldSeverities,
                numWorkers:          adjustNumWorkers(numWorkers),
                kicsComputeNewSimID: kicsComputeNewSimID,
        }, nil</span>
}

func getPlatformLibraries(queriesSource source.QueriesSource, queries []model.QueryMetadata) map[string]source.RegoLibraries <span class="cov4" title="5">{
        supportedPlatforms := make(map[string]string)
        for _, query := range queries </span><span class="cov9" title="42">{
                supportedPlatforms[query.Platform] = ""
        }</span>
        <span class="cov4" title="5">platformLibraries := make(map[string]source.RegoLibraries)
        for platform := range supportedPlatforms </span><span class="cov7" title="15">{
                platformLibrary, errLoadingPlatformLib := queriesSource.GetQueryLibrary(platform)
                if errLoadingPlatformLib != nil </span><span class="cov2" title="2">{
                        sentryReport.ReportSentry(&amp;sentryReport.Report{
                                Message:  fmt.Sprintf("Inspector failed to get library for %s platform", platform),
                                Err:      errLoadingPlatformLib,
                                Location: "func getPlatformLibraries()",
                                Platform: platform,
                        }, true)
                        continue</span>
                }
                <span class="cov7" title="13">platformLibraries[platform] = platformLibrary</span>
        }
        <span class="cov4" title="5">return platformLibraries</span>
}

type InspectionJob struct {
        queryID int
}

type QueryResult struct {
        vulnerabilities []model.Vulnerability
        err             error
        queryID         int
}

// This function creates an inspection task and sends it to the jobs channel
func (c *Inspector) createInspectionJobs(jobs chan&lt;- InspectionJob, queries []model.QueryMetadata) <span class="cov2" title="2">{
        defer close(jobs)
        for i := range queries </span><span class="cov2" title="2">{
                jobs &lt;- InspectionJob{queryID: i}
        }</span>
}

// This function performs an inspection job and sends the result to the results channel
func (c *Inspector) performInspection(ctx context.Context, scanID string, files model.FileMetadatas,
        astPayload ast.Value, baseScanPaths []string, currentQuery chan&lt;- int64,
        jobs &lt;-chan InspectionJob, results chan&lt;- QueryResult, queries []model.QueryMetadata) <span class="cov2" title="2">{
        for job := range jobs </span><span class="cov2" title="2">{
                currentQuery &lt;- 1

                queryOpa, err := c.QueryLoader.LoadQuery(ctx, &amp;queries[job.queryID])
                if err != nil </span><span class="cov0" title="0">{
                        continue</span>
                }

                <span class="cov2" title="2">log.Debug().Msgf("Starting to run query %s", queries[job.queryID].Query)
                queryStartTime := time.Now()

                query := &amp;PreparedQuery{
                        OpaQuery: *queryOpa,
                        Metadata: queries[job.queryID],
                }

                queryContext := &amp;QueryContext{
                        Ctx:           ctx,
                        scanID:        scanID,
                        Files:         files.ToMap(),
                        Query:         query,
                        payload:       &amp;astPayload,
                        BaseScanPaths: baseScanPaths,
                }

                vuls, err := c.doRun(queryContext)
                if err == nil </span><span class="cov2" title="2">{
                        log.Debug().Msgf("Finished to run query %s after %v", queries[job.queryID].Query, time.Since(queryStartTime))
                        c.tracker.TrackQueryExecution(query.Metadata.Aggregation)
                }</span>
                <span class="cov2" title="2">results &lt;- QueryResult{vulnerabilities: vuls, err: err, queryID: job.queryID}</span>
        }
}

func (c *Inspector) Inspect(
        ctx context.Context,
        scanID string,
        files model.FileMetadatas,
        baseScanPaths []string,
        platforms []string,
        currentQuery chan&lt;- int64) ([]model.Vulnerability, error) <span class="cov2" title="2">{
        log.Debug().Msg("engine.Inspect()")
        combinedFiles := files.Combine(false)

        var vulnerabilities []model.Vulnerability
        vulnerabilities = make([]model.Vulnerability, 0)
        var p interface{}

        payload, err := json.Marshal(combinedFiles)
        if err != nil </span><span class="cov0" title="0">{
                return vulnerabilities, err
        }</span>

        <span class="cov2" title="2">err = util.UnmarshalJSON(payload, &amp;p)
        if err != nil </span><span class="cov0" title="0">{
                return vulnerabilities, err
        }</span>

        <span class="cov2" title="2">astPayload, err := ast.InterfaceToValue(p)
        if err != nil </span><span class="cov0" title="0">{
                return vulnerabilities, err
        }</span>

        <span class="cov2" title="2">queries := c.getQueriesByPlat(platforms)

        // Create a channel to collect the results
        results := make(chan QueryResult, len(queries))

        // Create a channel for inspection jobs
        jobs := make(chan InspectionJob, len(queries))

        var wg sync.WaitGroup

        // Start a goroutine for each worker
        for w := 0; w &lt; c.numWorkers; w++ </span><span class="cov2" title="2">{
                wg.Add(1)

                go func() </span><span class="cov2" title="2">{
                        // Decrement the counter when the goroutine completes
                        defer wg.Done()
                        c.performInspection(ctx, scanID, files, astPayload, baseScanPaths, currentQuery, jobs, results, queries)
                }</span>()
        }
        // Start a goroutine to create inspection jobs
        <span class="cov2" title="2">go c.createInspectionJobs(jobs, queries)

        go func() </span><span class="cov2" title="2">{
                // Wait for all jobs to finish
                wg.Wait()
                // Then close the results channel
                close(results)
        }</span>()

        // Collect all the results
        <span class="cov2" title="2">for result := range results </span><span class="cov2" title="2">{
                if result.err != nil </span><span class="cov0" title="0">{
                        fmt.Println()
                        sentryReport.ReportSentry(&amp;sentryReport.Report{
                                Message:  fmt.Sprintf("Inspector. query executed with error, query=%s", queries[result.queryID].Query),
                                Err:      result.err,
                                Location: "func Inspect()",
                                Platform: queries[result.queryID].Platform,
                                Metadata: queries[result.queryID].Metadata,
                                Query:    queries[result.queryID].Query,
                        }, true)

                        c.failedQueries[queries[result.queryID].Query] = result.err

                        continue</span>
                }
                <span class="cov2" title="2">vulnerabilities = append(vulnerabilities, result.vulnerabilities...)</span>
        }
        <span class="cov2" title="2">return vulnerabilities, nil</span>
}

// LenQueriesByPlat returns the number of queries by platforms
func (c *Inspector) LenQueriesByPlat(platforms []string) int <span class="cov2" title="2">{
        count := 0
        for _, query := range c.QueryLoader.QueriesMetadata </span><span class="cov8" title="21">{
                if contains(platforms, query.Platform) </span><span class="cov4" title="5">{
                        c.tracker.TrackQueryExecuting(query.Aggregation)
                        count++
                }</span>
        }
        <span class="cov2" title="2">return count</span>
}

func (c *Inspector) getQueriesByPlat(platforms []string) []model.QueryMetadata <span class="cov2" title="2">{
        queries := make([]model.QueryMetadata, 0)
        for _, query := range c.QueryLoader.QueriesMetadata </span><span class="cov2" title="2">{
                if contains(platforms, query.Platform) </span><span class="cov2" title="2">{
                        queries = append(queries, query)
                }</span>
        }
        <span class="cov2" title="2">return queries</span>
}

// EnableCoverageReport enables the flag to create a coverage report
func (c *Inspector) EnableCoverageReport() <span class="cov1" title="1">{
        c.enableCoverageReport = true
}</span>

// GetCoverageReport returns the scan coverage report
func (c *Inspector) GetCoverageReport() cover.Report <span class="cov1" title="1">{
        return c.coverageReport
}</span>

// GetFailedQueries returns a map of failed queries and the associated error
func (c *Inspector) GetFailedQueries() map[string]error <span class="cov1" title="1">{
        return c.failedQueries
}</span>

func (c *Inspector) doRun(ctx *QueryContext) (vulns []model.Vulnerability, err error) <span class="cov2" title="2">{
        timeoutCtx, cancel := context.WithTimeout(ctx.Ctx, c.queryExecTimeout)
        defer cancel()
        defer func() </span><span class="cov2" title="2">{
                if r := recover(); r != nil </span><span class="cov0" title="0">{
                        errMessage := fmt.Sprintf("Recovered from panic during query '%s' run. ", ctx.Query.Metadata.Query)
                        err = fmt.Errorf("panic: %v", r)
                        fmt.Println()
                        log.Err(err).Msg(errMessage)
                }</span>
        }()
        <span class="cov2" title="2">options := []rego.EvalOption{rego.EvalParsedInput(*ctx.payload)}

        var cov *cover.Cover
        if c.enableCoverageReport </span><span class="cov2" title="2">{
                cov = cover.New()
                options = append(options, rego.EvalQueryTracer(cov))
        }</span>

        <span class="cov2" title="2">results, err := ctx.Query.OpaQuery.Eval(timeoutCtx, options...)
        ctx.payload = nil
        if err != nil </span><span class="cov0" title="0">{
                if topdown.IsCancel(err) </span><span class="cov0" title="0">{
                        return nil, errors.Wrap(err, "query executing timeout exited")
                }</span>

                <span class="cov0" title="0">return nil, errors.Wrap(err, "failed to evaluate query")</span>
        }
        <span class="cov2" title="2">if c.enableCoverageReport &amp;&amp; cov != nil </span><span class="cov2" title="2">{
                module, parseErr := ast.ParseModule(ctx.Query.Metadata.Query, ctx.Query.Metadata.Content)
                if parseErr != nil </span><span class="cov0" title="0">{
                        return nil, errors.Wrap(parseErr, "failed to parse coverage module")
                }</span>

                <span class="cov2" title="2">c.coverageReport = cov.Report(map[string]*ast.Module{
                        ctx.Query.Metadata.Query: module,
                })</span>
        }

        <span class="cov2" title="2">log.Trace().
                Str("scanID", ctx.scanID).
                Msgf("Inspector executed with result %+v, query=%s", results, ctx.Query.Metadata.Query)

        timeoutCtxToDecode, cancelDecode := context.WithTimeout(ctx.Ctx, c.queryExecTimeout)
        defer cancelDecode()
        return c.DecodeQueryResults(ctx, timeoutCtxToDecode, results)</span>
}

// DecodeQueryResults decodes the results into []model.Vulnerability
func (c *Inspector) DecodeQueryResults(
        ctx *QueryContext,
        ctxTimeout context.Context,
        results rego.ResultSet) ([]model.Vulnerability, error) <span class="cov3" title="3">{
        if len(results) == 0 </span><span class="cov0" title="0">{
                return nil, ErrNoResult
        }</span>

        <span class="cov3" title="3">result := results[0].Bindings

        queryResult, ok := result["result"]
        if !ok </span><span class="cov0" title="0">{
                return nil, ErrNoResult
        }</span>

        <span class="cov3" title="3">queryResultItems, ok := queryResult.([]interface{})
        if !ok </span><span class="cov0" title="0">{
                return nil, ErrInvalidResult
        }</span>

        <span class="cov3" title="3">vulnerabilities := make([]model.Vulnerability, 0, len(queryResultItems))
        failedDetectLine := false
        timeOut := false
        for _, queryResultItem := range queryResultItems </span><span class="cov3" title="3">{
                select </span>{
                case &lt;-ctxTimeout.Done():<span class="cov1" title="1">
                        timeOut = true
                        break</span>
                default:<span class="cov2" title="2">
                        vulnerability, aux := getVulnerabilitiesFromQuery(ctx, c, queryResultItem)
                        if aux </span><span class="cov0" title="0">{
                                failedDetectLine = aux
                        }</span>
                        <span class="cov2" title="2">if vulnerability != nil &amp;&amp; !aux </span><span class="cov1" title="1">{
                                vulnerabilities = append(vulnerabilities, *vulnerability)
                        }</span>
                }
        }

        <span class="cov3" title="3">if timeOut </span><span class="cov1" title="1">{
                fmt.Println()
                log.Err(ctxTimeout.Err()).Msgf(
                        "Timeout processing the results of the query: %s %s",
                        ctx.Query.Metadata.Platform,
                        ctx.Query.Metadata.Query)
        }</span>

        <span class="cov3" title="3">if failedDetectLine </span><span class="cov0" title="0">{
                c.tracker.FailedDetectLine()
        }</span>

        <span class="cov3" title="3">return vulnerabilities, nil</span>
}

func getVulnerabilitiesFromQuery(ctx *QueryContext, c *Inspector, queryResultItem interface{}) (*model.Vulnerability, bool) <span class="cov2" title="2">{
        vulnerability, err := c.vb(ctx, c.tracker, queryResultItem, c.detector, c.useOldSeverities, c.kicsComputeNewSimID)
        if err != nil &amp;&amp; err.Error() == ErrNoResult.Error() </span><span class="cov0" title="0">{
                // Ignoring bad results
                return nil, false
        }</span>
        <span class="cov2" title="2">if err != nil </span><span class="cov0" title="0">{
                sentryReport.ReportSentry(&amp;sentryReport.Report{
                        Message:  fmt.Sprintf("Inspector can't save vulnerability, query=%s", ctx.Query.Metadata.Query),
                        Err:      err,
                        Location: "func decodeQueryResults()",
                        Platform: ctx.Query.Metadata.Platform,
                        Metadata: ctx.Query.Metadata.Metadata,
                        Query:    ctx.Query.Metadata.Query,
                }, true)

                if _, ok := c.failedQueries[ctx.Query.Metadata.Query]; !ok </span><span class="cov0" title="0">{
                        c.failedQueries[ctx.Query.Metadata.Query] = err
                }</span>

                <span class="cov0" title="0">return nil, false</span>
        }
        <span class="cov2" title="2">file := ctx.Files[vulnerability.FileID]
        if ShouldSkipVulnerability(file.Commands, vulnerability.QueryID) </span><span class="cov0" title="0">{
                log.Debug().Msgf("Skipping vulnerability in file %s for query '%s':%s", file.FilePath, vulnerability.QueryName, vulnerability.QueryID)
                return nil, false
        }</span>

        <span class="cov2" title="2">if vulnerability.Line == UndetectedVulnerabilityLine </span><span class="cov0" title="0">{
                return nil, true
        }</span>

        <span class="cov2" title="2">if _, ok := c.excludeResults[vulnerability.SimilarityID]; ok </span><span class="cov1" title="1">{
                log.Debug().
                        Msgf("Excluding result SimilarityID: %s", vulnerability.SimilarityID)
                return nil, false
        }</span> else<span class="cov1" title="1"> if checkComment(vulnerability.Line, file.LinesIgnore) </span><span class="cov0" title="0">{
                log.Debug().
                        Msgf("Excluding result Comment: %s", vulnerability.SimilarityID)
                return nil, false
        }</span>

        <span class="cov1" title="1">return vulnerability, false</span>
}

// checkComment checks if the vulnerability should be skipped from comment
func checkComment(line int, ignoreLines []int) bool <span class="cov3" title="3">{
        for _, ignoreLine := range ignoreLines </span><span class="cov6" title="9">{
                if line == ignoreLine </span><span class="cov1" title="1">{
                        return true
                }</span>
        }
        <span class="cov2" title="2">return false</span>
}

// contains is a simple method to check if a slice
// contains an entry
func contains(s []string, e string) bool <span class="cov8" title="27">{
        if e == "common" </span><span class="cov2" title="2">{
                return true
        }</span>
        <span class="cov8" title="25">if e == "k8s" </span><span class="cov1" title="1">{
                e = "kubernetes"
        }</span>
        <span class="cov8" title="25">for _, a := range s </span><span class="cov8" title="26">{
                if strings.EqualFold(a, e) </span><span class="cov5" title="8">{
                        return true
                }</span>
        }
        <span class="cov7" title="17">return false</span>
}

func isDisabled(queries, queryID string, output bool) bool <span class="cov4" title="4">{
        for _, query := range strings.Split(queries, ",") </span><span class="cov4" title="4">{
                if strings.EqualFold(query, queryID) </span><span class="cov2" title="2">{
                        return output
                }</span>
        }

        <span class="cov2" title="2">return !output</span>
}

// ShouldSkipVulnerability verifies if the vulnerability in question should be ignored through comment commands
func ShouldSkipVulnerability(command model.CommentsCommands, queryID string) bool <span class="cov5" title="7">{
        if queries, ok := command["enable"]; ok </span><span class="cov2" title="2">{
                return isDisabled(queries, queryID, false)
        }</span>
        <span class="cov4" title="5">if queries, ok := command["disable"]; ok </span><span class="cov2" title="2">{
                return isDisabled(queries, queryID, true)
        }</span>
        <span class="cov3" title="3">return false</span>
}

func prepareQueries(queries []model.QueryMetadata, commonLibrary source.RegoLibraries,
        platformLibraries map[string]source.RegoLibraries, tracker Tracker) QueryLoader <span class="cov5" title="6">{
        // track queries loaded
        sum := 0
        for _, metadata := range queries </span><span class="cov10" title="43">{
                tracker.TrackQueryLoad(metadata.Aggregation)
                sum += metadata.Aggregation
        }</span>
        <span class="cov5" title="6">return QueryLoader{
                commonLibrary:     commonLibrary,
                platformLibraries: platformLibraries,
                querySum:          sum,
                QueriesMetadata:   queries,
        }</span>
}

// LoadQuery loads the query into memory so it can be freed when not used anymore
func (q QueryLoader) LoadQuery(ctx context.Context, query *model.QueryMetadata) (*rego.PreparedEvalQuery, error) <span class="cov2" title="2">{
        opaQuery := rego.PreparedEvalQuery{}

        platformGeneralQuery, ok := q.platformLibraries[query.Platform]
        if !ok </span><span class="cov0" title="0">{
                return nil, errors.New("failed to get platform library")
        }</span>

        <span class="cov2" title="2">select </span>{
        case &lt;-ctx.Done():<span class="cov0" title="0">
                return nil, ctx.Err()</span>
        default:<span class="cov2" title="2">
                mergedInputData, err := source.MergeInputData(platformGeneralQuery.LibraryInputData, query.InputData)
                if err != nil </span><span class="cov0" title="0">{
                        log.Debug().Msgf("Could not merge %s library input data", query.Platform)
                }</span>
                <span class="cov2" title="2">mergedInputData, err = source.MergeInputData(q.commonLibrary.LibraryInputData, mergedInputData)
                if err != nil </span><span class="cov0" title="0">{
                        log.Debug().Msg("Could not merge common library input data")
                }</span>
                <span class="cov2" title="2">store := inmem.NewFromReader(bytes.NewBufferString(mergedInputData))
                opaQuery, err = rego.New(
                        rego.Query(regoQuery),
                        rego.Module("Common", q.commonLibrary.LibraryCode),
                        rego.Module("Generic", platformGeneralQuery.LibraryCode),
                        rego.Module(query.Query, query.Content),
                        rego.Store(store),
                        rego.UnsafeBuiltins(unsafeRegoFunctions),
                ).PrepareForEval(ctx)

                if err != nil </span><span class="cov0" title="0">{
                        sentryReport.ReportSentry(&amp;sentryReport.Report{
                                Message:  fmt.Sprintf("Inspector failed to prepare query for evaluation, query=%s", query.Query),
                                Err:      err,
                                Location: "func NewInspector()",
                                Query:    query.Query,
                                Metadata: query.Metadata,
                                Platform: query.Platform,
                        }, true)

                        return nil, err
                }</span>

                <span class="cov2" title="2">return &amp;opaQuery, nil</span>
        }
}
</pre>
		
		<pre class="file" id="file43" style="display: none">// Code generated by MockGen. DO NOT EDIT.
// Source: ./pkg/engine/source/source.go

// Package mock is a generated GoMock package.
package mock

import (
        reflect "reflect"

        source "github.com/Checkmarx/kics/v2/pkg/engine/source"
        model "github.com/Checkmarx/kics/v2/pkg/model"
        gomock "github.com/golang/mock/gomock"
)

// MockQueriesSource is a mock of QueriesSource interface.
type MockQueriesSource struct {
        ctrl     *gomock.Controller
        recorder *MockQueriesSourceMockRecorder
}

// MockQueriesSourceMockRecorder is the mock recorder for MockQueriesSource.
type MockQueriesSourceMockRecorder struct {
        mock *MockQueriesSource
}

// NewMockQueriesSource creates a new mock instance.
func NewMockQueriesSource(ctrl *gomock.Controller) *MockQueriesSource <span class="cov8" title="5118">{
        mock := &amp;MockQueriesSource{ctrl: ctrl}
        mock.recorder = &amp;MockQueriesSourceMockRecorder{mock}
        return mock
}</span>

// EXPECT returns an object that allows the caller to indicate expected use.
func (m *MockQueriesSource) EXPECT() *MockQueriesSourceMockRecorder <span class="cov10" title="15354">{
        return m.recorder
}</span>

// GetQueries mocks base method.
func (m *MockQueriesSource) GetQueries(querySelection *source.QueryInspectorParameters) ([]model.QueryMetadata, error) <span class="cov8" title="5118">{
        m.ctrl.T.Helper()
        ret := m.ctrl.Call(m, "GetQueries", querySelection)
        ret0, _ := ret[0].([]model.QueryMetadata)
        ret1, _ := ret[1].(error)
        return ret0, ret1
}</span>

// GetQueries indicates an expected call of GetQueries.
func (mr *MockQueriesSourceMockRecorder) GetQueries(querySelection interface{}) *gomock.Call <span class="cov8" title="5118">{
        mr.mock.ctrl.T.Helper()
        return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "GetQueries", reflect.TypeOf((*MockQueriesSource)(nil).GetQueries), querySelection)
}</span>

// GetQueryLibrary mocks base method.
func (m *MockQueriesSource) GetQueryLibrary(platform string) (source.RegoLibraries, error) <span class="cov9" title="10236">{
        m.ctrl.T.Helper()
        ret := m.ctrl.Call(m, "GetQueryLibrary", platform)
        ret0, _ := ret[0].(source.RegoLibraries)
        ret1, _ := ret[1].(error)
        return ret0, ret1
}</span>

// GetQueryLibrary indicates an expected call of GetQueryLibrary.
func (mr *MockQueriesSourceMockRecorder) GetQueryLibrary(platform interface{}) *gomock.Call <span class="cov9" title="10236">{
        mr.mock.ctrl.T.Helper()
        return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "GetQueryLibrary", reflect.TypeOf((*MockQueriesSource)(nil).GetQueryLibrary), platform)
}</span>
</pre>
		
		<pre class="file" id="file44" style="display: none">package provider

import (
        "context"
        "errors"
        "io/fs"
        "os"
        "os/signal"
        "path/filepath"
        "sync"

        "github.com/alexmullins/zip"

        "github.com/Checkmarx/kics/v2/pkg/kuberneter"
        "github.com/Checkmarx/kics/v2/pkg/model"
        "github.com/Checkmarx/kics/v2/pkg/utils"
        "github.com/rs/zerolog/log"

        "github.com/hashicorp/go-getter"
)

const (
        channelLength = 2
)

// ExtractedPath is a struct that contains the paths, temporary paths to remove
// and extraction map path of the sources
// Path is the slice of paths to scan
// ExtractionMap is a map that correlates the temporary path to the given path
// RemoveTmp is the slice containing temporary paths to be removed
type ExtractedPath struct {
        Path          []string
        ExtractionMap map[string]model.ExtractedPathObject
}

type getterStruct struct {
        ctx         context.Context
        cancel      context.CancelFunc
        mode        getter.ClientMode
        pwd         string
        opts        []getter.ClientOption
        destination string
        source      string
}

// GetKuberneterSources uses Kubernetes API to download runtime resources
// After Downloaded files kics scan the files as normal local files
func GetKuberneterSources(ctx context.Context, source []string, destinationPath string) (ExtractedPath, error) <span class="cov0" title="0">{
        extrStruct := ExtractedPath{
                Path:          []string{},
                ExtractionMap: make(map[string]model.ExtractedPathObject),
        }

        for _, path := range source </span><span class="cov0" title="0">{
                exportedPath, err := kuberneter.Import(ctx, path, destinationPath)
                if err != nil </span><span class="cov0" title="0">{
                        log.Error().Msgf("failed to import %s: %s", path, err)
                }</span>

                <span class="cov0" title="0">extrStruct.ExtractionMap[exportedPath] = model.ExtractedPathObject{
                        Path:      exportedPath,
                        LocalPath: true,
                }

                extrStruct.Path = append(extrStruct.Path, exportedPath)</span>
        }

        <span class="cov0" title="0">return extrStruct, nil</span>
}

// GetSources goes through the source slice, and determines the of source type (ex: zip, git, local).
// It than extracts the files to be scanned. If the source given is not local, a temp dir
// will be created where the files will be stored.
func GetSources(source []string) (ExtractedPath, error) <span class="cov10" title="6">{
        extrStruct := ExtractedPath{
                Path:          []string{},
                ExtractionMap: make(map[string]model.ExtractedPathObject),
        }
        for _, path := range source </span><span class="cov10" title="6">{
                destination := filepath.Join(os.TempDir(), "kics-extract-"+utils.NextRandom())

                mode := getter.ClientModeAny

                pwd, err := os.Getwd()
                if err != nil </span><span class="cov0" title="0">{
                        log.Fatal().Msgf("Error getting wd: %s", err)
                }</span>

                <span class="cov10" title="6">opts := []getter.ClientOption{}

                opts = append(opts, getter.WithInsecure())

                ctx, cancel := context.WithCancel(context.Background())

                goGetter := getterStruct{
                        ctx:         ctx,
                        cancel:      cancel,
                        mode:        mode,
                        pwd:         pwd,
                        opts:        opts,
                        destination: destination,
                        source:      path,
                }

                getterDst, err := getPaths(&amp;goGetter)
                if err != nil </span><span class="cov6" title="3">{
                        if ignoreDamagedFiles(path) </span><span class="cov1" title="1">{
                                continue</span>
                        }
                        <span class="cov4" title="2">log.Error().Msgf("%s", err)
                        return ExtractedPath{}, err</span>
                }
                <span class="cov6" title="3">tempDst, local := checkSymLink(getterDst, path)

                extrStruct.ExtractionMap[getterDst] = model.ExtractedPathObject{
                        Path:      path,
                        LocalPath: local,
                }

                extrStruct.Path = append(extrStruct.Path, tempDst)</span>
        }

        <span class="cov7" title="4">return extrStruct, nil</span>
}

func getPaths(g *getterStruct) (string, error) <span class="cov10" title="6">{
        if isEncrypted(g.source) </span><span class="cov1" title="1">{
                err := errors.New("zip encrypted files are not supported")
                log.Err(err)
                return "", err
        }</span>

        // Build the client
        <span class="cov9" title="5">client := &amp;getter.Client{
                Ctx:     g.ctx,
                Src:     g.source,
                Dst:     g.destination,
                Pwd:     g.pwd,
                Mode:    g.mode,
                Options: g.opts,
        }

        wg := sync.WaitGroup{}
        wg.Add(1)
        errChan := make(chan error, channelLength)
        go func() </span><span class="cov9" title="5">{
                defer wg.Done()
                defer g.cancel()
                if err := client.Get(); err != nil </span><span class="cov4" title="2">{
                        errChan &lt;- err
                }</span>
        }()

        <span class="cov9" title="5">c := make(chan os.Signal, channelLength)
        signal.Notify(c, os.Interrupt)

        select </span>{
        case &lt;-c:<span class="cov0" title="0">
                signal.Reset(os.Interrupt)
                g.cancel()
                wg.Wait()</span>
        case &lt;-g.ctx.Done():<span class="cov6" title="3">
                wg.Wait()</span>
        case err := &lt;-errChan:<span class="cov4" title="2">
                wg.Wait()
                return "", err</span>
        }

        <span class="cov6" title="3">return g.destination, nil</span>
}

// check if the dst is a symbolic link
func checkSymLink(getterDst, pathFile string) (string, bool) <span class="cov6" title="3">{
        var local bool
        _, err := os.Stat(pathFile)
        if err == nil </span><span class="cov6" title="3">{ // check if file exist locally
                local = true
        }</span>

        <span class="cov6" title="3">info, err := os.Lstat(getterDst)
        if err != nil </span><span class="cov0" title="0">{
                log.Error().Msgf("failed lstat for %s: %v", getterDst, err)
        }</span>

        <span class="cov6" title="3">fileInfo := getFileInfo(info, getterDst, pathFile)

        if info.Mode()&amp;os.ModeSymlink != 0 </span><span class="cov4" title="2">{ // if it's a symbolic Link
                path, err := os.Readlink(getterDst) // get location of symbolic Link
                if err != nil </span><span class="cov0" title="0">{
                        log.Error().Msgf("failed Readlink for %s: %v", getterDst, err)
                }</span>
                <span class="cov4" title="2">getterDst = path</span> // change path to local path
        } else<span class="cov1" title="1"> if !fileInfo.IsDir() </span><span class="cov0" title="0">{ // symbolic links are not created for single files
                if local </span><span class="cov0" title="0">{ // check if file exist locally
                        getterDst = pathFile
                }</span>
        }
        <span class="cov6" title="3">return getterDst, local</span>
}

func getFileInfo(info fs.FileInfo, dst, pathFile string) fs.FileInfo <span class="cov6" title="3">{
        var extension = filepath.Ext(pathFile)
        var path string
        if extension == "" </span><span class="cov4" title="2">{
                path = filepath.Join(dst, filepath.Base(pathFile[0:len(pathFile)-len(extension)])) // for single file
        }</span> else<span class="cov1" title="1"> {
                path = filepath.Join(dst, filepath.Base(pathFile)) // for directories
        }</span>
        <span class="cov6" title="3">fileInfo, err := os.Lstat(path)
        if err != nil </span><span class="cov6" title="3">{
                fileInfo = info
        }</span>
        <span class="cov6" title="3">return fileInfo</span>
}

func isEncrypted(sourceFile string) bool <span class="cov10" title="6">{
        if filepath.Ext(sourceFile) != ".zip" </span><span class="cov7" title="4">{
                return false
        }</span>
        <span class="cov4" title="2">zipFile, err := zip.OpenReader(sourceFile)
        if err != nil </span><span class="cov0" title="0">{
                log.Error().Msgf("failed to open %s: %v", sourceFile, err)
                return false
        }</span>
        <span class="cov4" title="2">defer zipFile.Close()
        for _, file := range zipFile.File </span><span class="cov6" title="3">{
                if file.IsEncrypted() </span><span class="cov1" title="1">{
                        log.Error().Msgf("file %s is encrypted", sourceFile)
                        return true
                }</span>
        }
        <span class="cov1" title="1">return false</span>
}
</pre>
		
		<pre class="file" id="file45" style="display: none">package provider

import (
        "context"
        "fmt"
        ioFs "io/fs"
        "os"
        "path/filepath"
        "regexp"
        "strings"
        "sync"
        "syscall"

        sentryReport "github.com/Checkmarx/kics/v2/internal/sentry"
        "github.com/Checkmarx/kics/v2/pkg/model"
        "github.com/Checkmarx/kics/v2/pkg/utils"
        "github.com/pkg/errors"
        "github.com/rs/zerolog/log"
        "github.com/yargevad/filepathx"
)

// FileSystemSourceProvider provides a path to be scanned
// and a list of files which will not be scanned
type FileSystemSourceProvider struct {
        paths    []string
        excludes map[string][]os.FileInfo
        mu       sync.RWMutex
}

var (
        queryRegexExcludeTerraCache = regexp.MustCompile(fmt.Sprintf(`^(.*?%s)?\.terra.*`, regexp.QuoteMeta(string(os.PathSeparator))))
        // ErrNotSupportedFile - error representing when a file format is not supported by KICS
        ErrNotSupportedFile = errors.New("invalid file format")
)

// NewFileSystemSourceProvider initializes a FileSystemSourceProvider with path and files that will be ignored
func NewFileSystemSourceProvider(paths, excludes []string) (*FileSystemSourceProvider, error) <span class="cov2" title="5">{
        log.Debug().Msgf("provider.NewFileSystemSourceProvider()")
        ex := make(map[string][]os.FileInfo, len(excludes))
        osPaths := make([]string, len(paths))
        for idx, path := range paths </span><span class="cov2" title="7">{
                osPaths[idx] = filepath.FromSlash(path)
        }</span>
        <span class="cov2" title="5">fs := &amp;FileSystemSourceProvider{
                paths:    osPaths,
                excludes: ex,
        }
        for _, exclude := range excludes </span><span class="cov1" title="2">{
                excludePaths, err := GetExcludePaths(exclude)
                if err != nil </span><span class="cov0" title="0">{
                        return nil, err
                }</span>
                <span class="cov1" title="2">if err := fs.AddExcluded(excludePaths); err != nil </span><span class="cov0" title="0">{
                        return nil, err
                }</span>
        }

        <span class="cov2" title="5">return fs, nil</span>
}

// AddExcluded add new excluded files to the File System Source Provider
func (s *FileSystemSourceProvider) AddExcluded(excludePaths []string) error <span class="cov3" title="18">{
        for _, excludePath := range excludePaths </span><span class="cov3" title="17">{
                info, err := os.Stat(excludePath)
                if err != nil </span><span class="cov3" title="16">{
                        if os.IsNotExist(err) </span><span class="cov3" title="15">{
                                continue</span>
                        }
                        <span class="cov1" title="1">if sysErr, ok := err.(*ioFs.PathError); ok </span><span class="cov1" title="1">{
                                log.Warn().Msgf("Failed getting file info for file '%s', Skipping due to: %s, Error number: %d",
                                        excludePath, sysErr, sysErr.Err.(syscall.Errno))
                                continue</span>
                        }
                        <span class="cov0" title="0">return errors.Wrap(err, "failed to open excluded file")</span>
                }
                <span class="cov1" title="1">s.mu.Lock()
                if _, ok := s.excludes[info.Name()]; !ok </span><span class="cov1" title="1">{
                        s.excludes[info.Name()] = make([]os.FileInfo, 0)
                }</span>
                <span class="cov1" title="1">s.excludes[info.Name()] = append(s.excludes[info.Name()], info)
                s.mu.Unlock()</span>
        }
        <span class="cov3" title="18">return nil</span>
}

// GetExcludePaths gets all the files that should be excluded
func GetExcludePaths(pathExpressions string) ([]string, error) <span class="cov2" title="4">{
        if strings.ContainsAny(pathExpressions, "*?[") </span><span class="cov1" title="2">{
                info, err := filepathx.Glob(pathExpressions)
                if err != nil </span><span class="cov0" title="0">{
                        log.Error().Msgf("failed to get exclude path %s: %s", pathExpressions, err)
                        return []string{pathExpressions}, nil
                }</span>
                <span class="cov1" title="2">return info, nil</span>
        }
        <span class="cov1" title="2">return []string{pathExpressions}, nil</span>
}

// GetBasePaths returns base path of FileSystemSourceProvider
func (s *FileSystemSourceProvider) GetBasePaths() []string <span class="cov1" title="2">{
        return s.paths
}</span>

// ignoreDamagedFiles checks whether we should ignore a damaged file from a scan or not.
func ignoreDamagedFiles(path string) bool <span class="cov1" title="3">{
        shouldIgnoreFile := false
        fileInfo, err := os.Lstat(path)
        if err != nil </span><span class="cov1" title="1">{
                log.Warn().Msgf("Failed getting the file info for file '%s'", path)
                return shouldIgnoreFile
        }</span>
        <span class="cov1" title="2">log.Info().Msgf("No mode type bits are set( is a regular file ) for file '%s' : %t ", path, fileInfo.Mode().IsRegular())

        if fileInfo.Mode()&amp;os.ModeSymlink == os.ModeSymlink </span><span class="cov1" title="1">{
                log.Warn().Msgf("File '%s' is a symbolic link - but seems not to be accessible", path)
                shouldIgnoreFile = true
        }</span>

        <span class="cov1" title="2">return shouldIgnoreFile</span>
}

// GetSources tries to open file or directory and execute sink function on it
func (s *FileSystemSourceProvider) GetSources(ctx context.Context,
        extensions model.Extensions, sink Sink, resolverSink ResolverSink) error <span class="cov2" title="7">{
        for _, scanPath := range s.paths </span><span class="cov2" title="7">{
                resolved := false
                fileInfo, err := os.Stat(scanPath)
                if err != nil </span><span class="cov1" title="3">{
                        return errors.Wrap(err, "failed to open path")
                }</span>

                <span class="cov2" title="4">if !fileInfo.IsDir() </span><span class="cov1" title="1">{
                        c, openFileErr := openScanFile(scanPath, extensions)
                        if openFileErr != nil </span><span class="cov0" title="0">{
                                if openFileErr == ErrNotSupportedFile || ignoreDamagedFiles(scanPath) </span><span class="cov0" title="0">{
                                        continue</span>
                                }
                                <span class="cov0" title="0">return openFileErr</span>
                        }
                        <span class="cov1" title="1">if sinkErr := sink(ctx, scanPath, c); sinkErr != nil </span><span class="cov0" title="0">{
                                return sinkErr
                        }</span>
                        <span class="cov1" title="1">continue</span>
                }

                <span class="cov1" title="3">err = s.walkDir(ctx, scanPath, resolved, sink, resolverSink, extensions)
                if err != nil </span><span class="cov0" title="0">{
                        return errors.Wrap(err, "failed to walk directory")
                }</span>
                <span class="cov1" title="3">continue</span>
        }
        <span class="cov2" title="4">return nil</span>
}

func (s *FileSystemSourceProvider) walkDir(ctx context.Context, scanPath string, resolved bool,
        sink Sink, resolverSink ResolverSink, extensions model.Extensions) error <span class="cov1" title="3">{
        return filepath.Walk(scanPath, func(path string, info os.FileInfo, err error) error </span><span class="cov9" title="31913">{
                if err != nil </span><span class="cov0" title="0">{
                        return err
                }</span>

                <span class="cov9" title="31913">if shouldSkip, skipFolder := s.checkConditions(info, extensions, path, resolved); shouldSkip </span><span class="cov9" title="31572">{
                        return skipFolder
                }</span>

                // ------------------ Helm resolver --------------------------------
                <span class="cov6" title="341">if info.IsDir() </span><span class="cov1" title="1">{
                        excluded, errRes := resolverSink(ctx, strings.ReplaceAll(path, "\\", "/"))
                        if errRes != nil </span><span class="cov0" title="0">{
                                sentryReport.ReportSentry(&amp;sentryReport.Report{
                                        Message:  fmt.Sprintf("Filesystem files provider couldn't Resolve Directory, file=%s", info.Name()),
                                        Err:      errRes,
                                        Location: "func walkDir()",
                                        FileName: info.Name(),
                                }, true)
                                return nil
                        }</span>
                        <span class="cov1" title="1">if errAdd := s.AddExcluded(excluded); errAdd != nil </span><span class="cov0" title="0">{
                                log.Err(errAdd).Msgf("Filesystem files provider couldn't exclude rendered Chart files, Chart=%s", info.Name())
                        }</span>
                        <span class="cov1" title="1">resolved = true
                        return nil</span>
                }
                // -----------------------------------------------------------------

                <span class="cov6" title="340">c, err := os.Open(filepath.Clean(path))
                if err != nil </span><span class="cov0" title="0">{
                        if ignoreDamagedFiles(filepath.Clean(path)) </span><span class="cov0" title="0">{
                                return nil
                        }</span>
                        <span class="cov0" title="0">return errors.Wrap(err, "failed to open file")</span>
                }
                <span class="cov6" title="340">defer closeFile(c, info)

                err = sink(ctx, strings.ReplaceAll(path, "\\", "/"), c)
                if err != nil </span><span class="cov5" title="170">{
                        sentryReport.ReportSentry(&amp;sentryReport.Report{
                                Message:  fmt.Sprintf("Filesystem files provider couldn't parse file, file=%s", info.Name()),
                                Err:      err,
                                Location: "func walkDir()",
                                FileName: info.Name(),
                        }, true)
                }</span>
                <span class="cov6" title="340">return nil</span>
        })
}

func openScanFile(scanPath string, extensions model.Extensions) (*os.File, error) <span class="cov1" title="1">{
        ext, _ := utils.GetExtension(scanPath)

        if !extensions.Include(ext) </span><span class="cov0" title="0">{
                return nil, ErrNotSupportedFile
        }</span>

        <span class="cov1" title="1">c, errOpenFile := os.Open(scanPath)
        if errOpenFile != nil </span><span class="cov0" title="0">{
                return nil, errors.Wrap(errOpenFile, "failed to open path")
        }</span>
        <span class="cov1" title="1">return c, nil</span>
}

func closeFile(file *os.File, info os.FileInfo) <span class="cov6" title="340">{
        if err := file.Close(); err != nil </span><span class="cov0" title="0">{
                sentryReport.ReportSentry(&amp;sentryReport.Report{
                        Message:  fmt.Sprintf("Filesystem couldn't close file, file=%s", info.Name()),
                        Err:      err,
                        Location: "func closeFile()",
                        FileName: info.Name(),
                }, true)
        }</span>
}

func (s *FileSystemSourceProvider) checkConditions(info os.FileInfo, extensions model.Extensions,
        path string, resolved bool) (bool, error) <span class="cov10" title="31932">{
        s.mu.RLock()
        defer s.mu.RUnlock()

        if info.IsDir() </span><span class="cov8" title="6940">{
                // exclude terraform cache folders
                if queryRegexExcludeTerraCache.MatchString(path) </span><span class="cov3" title="13">{
                        log.Info().Msgf("Directory ignored: %s", path)

                        err := s.AddExcluded([]string{info.Name()})
                        if err != nil </span><span class="cov0" title="0">{
                                return true, err
                        }</span>
                        <span class="cov3" title="13">return true, filepath.SkipDir</span>
                }
                <span class="cov8" title="6927">if f, ok := s.excludes[info.Name()]; ok &amp;&amp; containsFile(f, info) </span><span class="cov1" title="1">{
                        log.Info().Msgf("Directory ignored: %s", path)
                        return true, filepath.SkipDir
                }</span>
                <span class="cov8" title="6926">_, err := os.Stat(filepath.Join(path, "Chart.yaml"))
                if err != nil || resolved </span><span class="cov8" title="6923">{
                        return true, nil
                }</span>
                <span class="cov1" title="3">return false, nil</span>
        }

        <span class="cov9" title="24992">if f, ok := s.excludes[info.Name()]; ok &amp;&amp; containsFile(f, info) </span><span class="cov0" title="0">{
                log.Trace().Msgf("File ignored: %s", path)
                return true, nil
        }</span>
        <span class="cov9" title="24992">ext, _ := utils.GetExtension(path)
        if !extensions.Include(ext) </span><span class="cov9" title="24652">{
                log.Trace().Msgf("File ignored: %s", path)
                return true, nil
        }</span>
        <span class="cov6" title="340">return false, nil</span>
}

func containsFile(fileList []os.FileInfo, target os.FileInfo) bool <span class="cov1" title="1">{
        for _, file := range fileList </span><span class="cov1" title="1">{
                if os.SameFile(file, target) </span><span class="cov1" title="1">{
                        return true
                }</span>
        }
        <span class="cov0" title="0">return false</span>
}
</pre>
		
		<pre class="file" id="file46" style="display: none">package secrets

import (
        "context"
        _ "embed" // Embed KICS regex rules
        "encoding/json"
        "fmt"
        "math"
        "regexp"
        "strings"
        "sync"
        "time"

        "github.com/Checkmarx/kics/v2/assets"
        "github.com/Checkmarx/kics/v2/pkg/detector"
        "github.com/Checkmarx/kics/v2/pkg/detector/docker"
        "github.com/Checkmarx/kics/v2/pkg/detector/helm"
        engine "github.com/Checkmarx/kics/v2/pkg/engine"
        "github.com/Checkmarx/kics/v2/pkg/engine/similarity"
        "github.com/Checkmarx/kics/v2/pkg/engine/source"
        "github.com/Checkmarx/kics/v2/pkg/model"
        "github.com/rs/zerolog/log"
)

const (
        Base64Chars = "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/="
        HexChars    = "1234567890abcdefABCDEF"
)

var (
        SecretsQueryMetadata map[string]string
)

// SecretTracker is Struct created to keep track of the secrets found in the inspector
// it used for masking all the secrets in the vulnerability preview in the different report formats
type SecretTracker struct {
        ResolvedFilePath string
        Line             int
        OriginalContent  string
        MaskedContent    string
}

type Inspector struct {
        ctx                   context.Context
        tracker               engine.Tracker
        detector              *detector.DetectLine
        excludeResults        map[string]bool
        regexQueries          []RegexQuery
        allowRules            []AllowRule
        vulnerabilities       []model.Vulnerability
        queryExecutionTimeout time.Duration
        foundLines            []int
        mu                    sync.RWMutex
        SecretTracker         []SecretTracker
}

type Entropy struct {
        Group int     `json:"group"`
        Min   float64 `json:"min"`
        Max   float64 `json:"max"`
}

type MultilineResult struct {
        DetectLineGroup int `json:"detectLineGroup"`
}

type AllowRule struct {
        Description string `json:"description"`
        RegexStr    string `json:"regex"`
        Regex       *regexp.Regexp
}

type RegexQuery struct {
        ID          string          `json:"id"`
        Name        string          `json:"name"`
        Multiline   MultilineResult `json:"multiline"`
        RegexStr    string          `json:"regex"`
        SpecialMask string          `json:"specialMask"`
        Entropies   []Entropy       `json:"entropies"`
        AllowRules  []AllowRule     `json:"allowRules"`
        Regex       *regexp.Regexp
}

type RegexRuleStruct struct {
        Rules      []RegexQuery `json:"rules"`
        AllowRules []AllowRule  `json:"allowRules"`
}

type RuleMatch struct {
        File     string
        RuleName string
        Matches  []string
        Line     int
        Entropy  float64
}

type lineVulneInfo struct {
        lineContent string
        lineNumber  int
        groups      []string
}

func NewInspector(
        ctx context.Context,
        excludeResults map[string]bool,
        tracker engine.Tracker,
        queryFilter *source.QueryInspectorParameters,
        disableSecretsQuery bool,
        executionTimeout int,
        regexRulesContent string,
        isCustomSecretsRegexes bool,
) (*Inspector, error) <span class="cov3" title="13">{
        passwordsAndSecretsQueryID, err := getPasswordsAndSecretsQueryID()
        if err != nil </span><span class="cov1" title="1">{
                return nil, err
        }</span>
        <span class="cov3" title="12">excludeSecretsQuery := isValueInArray(passwordsAndSecretsQueryID, queryFilter.ExcludeQueries.ByIDs)
        if disableSecretsQuery || excludeSecretsQuery &amp;&amp; !isCustomSecretsRegexes </span><span class="cov1" title="1">{
                return &amp;Inspector{
                        ctx:                   ctx,
                        tracker:               tracker,
                        excludeResults:        excludeResults,
                        regexQueries:          make([]RegexQuery, 0),
                        allowRules:            make([]AllowRule, 0),
                        vulnerabilities:       make([]model.Vulnerability, 0),
                        queryExecutionTimeout: time.Duration(executionTimeout) * time.Second,
                        SecretTracker:         make([]SecretTracker, 0),
                }, nil
        }</span>

        <span class="cov3" title="11">lineDetector := detector.NewDetectLine(tracker.GetOutputLines()).
                Add(helm.DetectKindLine{}, model.KindHELM).
                Add(docker.DetectKindLine{}, model.KindDOCKER)

        err = json.Unmarshal([]byte(assets.SecretsQueryMetadataJSON), &amp;SecretsQueryMetadata)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov3" title="11">queryExecutionTimeout := time.Duration(executionTimeout) * time.Second

        var allRegexQueries RegexRuleStruct
        err = json.Unmarshal([]byte(regexRulesContent), &amp;allRegexQueries)
        if err != nil </span><span class="cov1" title="1">{
                return nil, err
        }</span>

        <span class="cov3" title="10">if isCustomSecretsRegexes </span><span class="cov0" title="0">{
                err = validateCustomSecretsQueriesID(allRegexQueries.Rules)
                if err != nil </span><span class="cov0" title="0">{
                        return nil, err
                }</span>
        }

        <span class="cov3" title="10">regexQueries, err := compileRegexQueries(queryFilter, allRegexQueries.Rules, isCustomSecretsRegexes, passwordsAndSecretsQueryID)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>

        <span class="cov3" title="10">allowRules, err := CompileRegex(allRegexQueries.AllowRules)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>

        <span class="cov3" title="10">return &amp;Inspector{
                ctx:                   ctx,
                detector:              lineDetector,
                excludeResults:        excludeResults,
                tracker:               tracker,
                regexQueries:          regexQueries,
                allowRules:            allowRules,
                vulnerabilities:       make([]model.Vulnerability, 0),
                queryExecutionTimeout: queryExecutionTimeout,
                foundLines:            make([]int, 0),
        }, nil</span>
}

func (c *Inspector) inspectQuery(ctx context.Context, basePaths []string,
        files model.FileMetadatas, i int) ([]model.Vulnerability, error) <span class="cov7" title="288">{
        timeoutCtx, cancel := context.WithTimeout(ctx, c.queryExecutionTimeout)
        defer cancel()

        cleanFiles := cleanFiles(files)

        for idx := range cleanFiles </span><span class="cov7" title="288">{
                if _, ok := cleanFiles[idx].Commands["ignore"]; !ok </span><span class="cov7" title="252">{
                        select </span>{
                        case &lt;-timeoutCtx.Done():<span class="cov0" title="0">
                                return c.vulnerabilities, timeoutCtx.Err()</span>
                        default:<span class="cov7" title="252">
                                c.checkContent(i, idx, basePaths, cleanFiles)</span>
                        }
                }
        }
        <span class="cov7" title="288">return c.vulnerabilities, nil</span>
}

// Inspect inspects the source code for passwords &amp; secrets and returns the list of vulnerabilities
func (c *Inspector) Inspect(ctx context.Context, basePaths []string,
        files model.FileMetadatas, currentQuery chan&lt;- int64) ([]model.Vulnerability, error) <span class="cov3" title="8">{
        for i := range c.regexQueries </span><span class="cov7" title="288">{
                currentQuery &lt;- 1

                vulns, err := c.inspectQuery(ctx, basePaths, files, i)

                if err != nil </span><span class="cov0" title="0">{
                        return vulns, err
                }</span>
        }
        <span class="cov3" title="8">return c.vulnerabilities, nil</span>
}

func compileRegexQueries(
        queryFilter *source.QueryInspectorParameters,
        allRegexQueries []RegexQuery,
        isCustom bool,
        passwordsAndSecretsQueryID string,
) ([]RegexQuery, error) <span class="cov4" title="15">{
        var regexQueries []RegexQuery
        var includeSpecificSecretQuery bool

        allSecretsQueryAndCustom := false

        includeAllSecretsQuery := isValueInArray(passwordsAndSecretsQueryID, queryFilter.IncludeQueries.ByIDs)

        if includeAllSecretsQuery &amp;&amp; isCustom </span><span class="cov0" title="0">{ // merge case
                var kicsRegexQueries RegexRuleStruct
                err := json.Unmarshal([]byte(assets.SecretsQueryRegexRulesJSON), &amp;kicsRegexQueries)
                if err != nil </span><span class="cov0" title="0">{
                        return nil, err
                }</span>
                <span class="cov0" title="0">allSecretsQueryAndCustom = true
                regexQueries = kicsRegexQueries.Rules</span>
        }

        <span class="cov4" title="15">for i := range allRegexQueries </span><span class="cov7" title="300">{
                includeSpecificSecretQuery = isValueInArray(allRegexQueries[i].ID, queryFilter.IncludeQueries.ByIDs)
                if len(queryFilter.IncludeQueries.ByIDs) &gt; 0 &amp;&amp; !allSecretsQueryAndCustom </span><span class="cov2" title="3">{
                        if includeAllSecretsQuery || includeSpecificSecretQuery </span><span class="cov1" title="1">{
                                regexQueries = append(regexQueries, allRegexQueries[i])
                        }</span>
                } else<span class="cov7" title="297"> {
                        if !shouldExecuteQuery(
                                allRegexQueries[i].ID,
                                allRegexQueries[i].ID,
                                SecretsQueryMetadata["category"],
                                SecretsQueryMetadata["severity"],
                                queryFilter.ExcludeQueries.ByIDs,
                        ) </span><span class="cov1" title="1">{
                                continue</span>
                        }
                        <span class="cov7" title="296">if !shouldExecuteQuery(
                                SecretsQueryMetadata["category"],
                                allRegexQueries[i].ID,
                                SecretsQueryMetadata["category"],
                                SecretsQueryMetadata["severity"],
                                queryFilter.ExcludeQueries.ByCategories,
                        ) </span><span class="cov0" title="0">{
                                continue</span>
                        }
                        <span class="cov7" title="296">if !shouldExecuteQuery(
                                SecretsQueryMetadata["severity"],
                                allRegexQueries[i].ID,
                                SecretsQueryMetadata["category"],
                                SecretsQueryMetadata["severity"],
                                queryFilter.ExcludeQueries.BySeverities,
                        ) </span><span class="cov0" title="0">{
                                continue</span>
                        }
                        <span class="cov7" title="296">regexQueries = append(regexQueries, allRegexQueries[i])</span>
                }
        }
        <span class="cov4" title="15">for i := range regexQueries </span><span class="cov7" title="297">{
                compiledRegexp, err := regexp.Compile(regexQueries[i].RegexStr)
                if err != nil </span><span class="cov0" title="0">{
                        return regexQueries, err
                }</span>
                <span class="cov7" title="297">regexQueries[i].Regex = compiledRegexp
                for j := range regexQueries[i].AllowRules </span><span class="cov7" title="208">{
                        regexQueries[i].AllowRules[j].Regex = regexp.MustCompile(regexQueries[i].AllowRules[j].RegexStr)
                }</span>
        }
        <span class="cov4" title="15">return regexQueries, nil</span>
}

// CompileRegex compiles the regex allow rules
func CompileRegex(allowRules []AllowRule) ([]AllowRule, error) <span class="cov3" title="10">{
        for j := range allowRules </span><span class="cov5" title="80">{
                compiledRegex, err := regexp.Compile(allowRules[j].RegexStr)
                if err != nil </span><span class="cov0" title="0">{
                        return nil, err
                }</span>
                <span class="cov5" title="80">allowRules[j].Regex = compiledRegex</span>
        }
        <span class="cov3" title="10">return allowRules, nil</span>
}

func (c *Inspector) GetQueriesLength() int <span class="cov3" title="8">{
        return len(c.regexQueries)
}</span>

func isValueInArray(value string, array []string) bool <span class="cov8" title="1216">{
        for i := range array </span><span class="cov3" title="7">{
                if strings.EqualFold(value, array[i]) </span><span class="cov1" title="2">{
                        return true
                }</span>
        }
        <span class="cov8" title="1214">return false</span>
}

func (c *Inspector) isSecret(s string, query *RegexQuery) (isSecretRet bool, groups [][]string) <span class="cov10" title="2980">{
        if IsAllowRule(s, query, append(query.AllowRules, c.allowRules...)) </span><span class="cov0" title="0">{
                return false, [][]string{}
        }</span>

        <span class="cov10" title="2980">groups = query.Regex.FindAllStringSubmatch(s, -1)

        for _, group := range groups </span><span class="cov3" title="6">{
                splitedText := strings.Split(s, "\n")
                max := -1
                for i, splited := range splitedText </span><span class="cov4" title="21">{
                        if len(groups) &lt; query.Multiline.DetectLineGroup </span><span class="cov4" title="16">{
                                if strings.Contains(splited, group[query.Multiline.DetectLineGroup]) &amp;&amp; i &gt; max </span><span class="cov0" title="0">{
                                        max = i
                                }</span>
                        }
                }
                <span class="cov3" title="6">if max == -1 </span><span class="cov3" title="6">{
                        continue</span>
                }
                <span class="cov0" title="0">secret, newGroups := c.isSecret(strings.Join(append(splitedText[:max], splitedText[max+1:]...), "\n"), query)
                if !secret </span><span class="cov0" title="0">{
                        continue</span>
                }
                <span class="cov0" title="0">groups = append(groups, newGroups...)</span>
        }

        <span class="cov10" title="2980">if len(groups) &gt; 0 </span><span class="cov3" title="6">{
                return true, groups
        }</span>
        <span class="cov9" title="2974">return false, [][]string{}</span>
}

// IsAllowRule check if string matches any of the allow rules for the secret queries
func IsAllowRule(s string, query *RegexQuery, allowRules []AllowRule) bool <span class="cov10" title="2980">{
        regexMatch := query.Regex.FindStringIndex(s)
        if regexMatch != nil </span><span class="cov3" title="6">{
                allowRuleMatches := AllowRuleMatches(s, append(query.AllowRules, allowRules...))

                for _, allowMatch := range allowRuleMatches </span><span class="cov0" title="0">{
                        allowStart, allowEnd := allowMatch[0], allowMatch[1]
                        regexStart, regexEnd := regexMatch[0], regexMatch[1]

                        if (allowStart &lt;= regexEnd &amp;&amp; allowStart &gt;= regexStart) || (regexStart &lt;= allowEnd &amp;&amp; regexStart &gt;= allowStart) </span><span class="cov0" title="0">{
                                return true
                        }</span>
                }
        }

        <span class="cov10" title="2980">return false</span>
}

// AllowRuleMatches return all the allow rules matches for the secret queries
func AllowRuleMatches(s string, allowRules []AllowRule) [][]int <span class="cov3" title="6">{
        allowRuleMatches := [][]int{}
        for i := range allowRules </span><span class="cov6" title="138">{
                allowRuleMatches = append(allowRuleMatches, allowRules[i].Regex.FindAllStringIndex(s, -1)...)
        }</span>
        <span class="cov3" title="6">return allowRuleMatches</span>
}

func (c *Inspector) checkFileContent(query *RegexQuery, basePaths []string, file *model.FileMetadata) <span class="cov4" title="35">{
        isSecret, groups := c.isSecret(file.OriginalData, query)
        if !isSecret </span><span class="cov4" title="34">{
                return
        }</span>

        <span class="cov1" title="1">lineVulns := c.secretsDetectLine(query, file, groups)

        for _, lineVuln := range lineVulns </span><span class="cov1" title="1">{
                if len(query.Entropies) == 0 </span><span class="cov0" title="0">{
                        c.addVulnerability(
                                basePaths,
                                file,
                                query,
                                lineVuln.lineNumber,
                                lineVuln.lineContent,
                        )
                }</span>

                <span class="cov1" title="1">if len(lineVuln.groups) &gt; 0 </span><span class="cov1" title="1">{
                        for _, entropy := range query.Entropies </span><span class="cov1" title="1">{
                                // if matched group does not exist continue
                                if len(lineVuln.groups) &lt;= entropy.Group </span><span class="cov0" title="0">{
                                        return
                                }</span>
                                <span class="cov1" title="1">isMatch, entropyFloat := CheckEntropyInterval(
                                        entropy,
                                        lineVuln.groups[entropy.Group],
                                )
                                log.Debug().Msgf("match: %v :: %v", isMatch, fmt.Sprint(entropyFloat))

                                if isMatch </span><span class="cov1" title="1">{
                                        c.addVulnerability(
                                                basePaths,
                                                file,
                                                query,
                                                lineVuln.lineNumber,
                                                lineVuln.lineContent,
                                        )
                                }</span>
                        }
                }
        }
}

func (c *Inspector) secretsDetectLine(query *RegexQuery, file *model.FileMetadata, vulnGroups [][]string) []lineVulneInfo <span class="cov1" title="1">{
        content := file.OriginalData
        lines := *file.LinesOriginalData
        lineVulneInfoSlice := make([]lineVulneInfo, 0)
        realLineUpdater := 0
        for _, groups := range vulnGroups </span><span class="cov1" title="1">{
                lineVulneInfoObject := lineVulneInfo{
                        lineNumber:  -1,
                        lineContent: "-",
                        groups:      groups,
                }

                if len(groups) &lt;= query.Multiline.DetectLineGroup </span><span class="cov0" title="0">{
                        log.Warn().Msgf("Unable to detect line in file %v Multiline group not found: %v", file.FilePath, query.Multiline.DetectLineGroup)
                        lineVulneInfoSlice = append(lineVulneInfoSlice, lineVulneInfoObject)
                        continue</span>
                }

                <span class="cov1" title="1">contentMatchRemoved := strings.Replace(content, groups[query.Multiline.DetectLineGroup], "", 1)

                text := strings.ReplaceAll(contentMatchRemoved, "\r", "")
                contentMatchRemovedLines := strings.Split(text, "\n")
                for i := 0; i &lt; len(lines); i++ </span><span class="cov3" title="7">{
                        if lines[i] != contentMatchRemovedLines[i] </span><span class="cov1" title="1">{
                                lineVulneInfoObject.lineNumber = i + realLineUpdater
                                lineVulneInfoObject.lineContent = lines[i]
                                break</span>
                        }
                }

                <span class="cov1" title="1">realLineUpdater += len(lines) - len(contentMatchRemovedLines)
                content = contentMatchRemoved
                lines = contentMatchRemovedLines

                lineVulneInfoSlice = append(lineVulneInfoSlice, lineVulneInfoObject)</span>
        }

        <span class="cov1" title="1">return lineVulneInfoSlice</span>
}

func (c *Inspector) checkLineByLine(wg *sync.WaitGroup, query *RegexQuery,
        basePaths []string, file *model.FileMetadata, lineNumber int, currentLine string) <span class="cov9" title="2945">{
        defer wg.Done()
        isSecret, groups := c.isSecret(currentLine, query)
        if !isSecret </span><span class="cov9" title="2940">{
                return
        }</span>

        <span class="cov2" title="5">if len(query.Entropies) == 0 </span><span class="cov2" title="4">{
                c.addVulnerability(
                        basePaths,
                        file,
                        query,
                        lineNumber,
                        currentLine,
                )
        }</span>

        <span class="cov2" title="5">for i := range query.Entropies </span><span class="cov1" title="1">{
                entropy := query.Entropies[i]

                // if matched group does not exist continue
                if len(groups[0]) &lt;= entropy.Group </span><span class="cov0" title="0">{
                        return
                }</span>

                <span class="cov1" title="1">isMatch, entropyFloat := CheckEntropyInterval(
                        entropy,
                        groups[0][entropy.Group],
                )
                log.Debug().Msgf("match: %v :: %v", isMatch, fmt.Sprint(entropyFloat))

                if isMatch </span><span class="cov1" title="1">{
                        c.addVulnerability(
                                basePaths,
                                file,
                                query,
                                lineNumber,
                                currentLine,
                        )
                }</span>
        }
}

func (c *Inspector) addVulnerability(basePaths []string, file *model.FileMetadata, query *RegexQuery, lineNumber int, issueLine string) <span class="cov3" title="6">{
        if engine.ShouldSkipVulnerability(file.Commands, query.ID) </span><span class="cov1" title="1">{
                log.Debug().Msgf("Skipping vulnerability in file %s for query '%s':%s", file.FilePath, query.Name, query.ID)
                return
        }</span>
        <span class="cov2" title="5">simID, err := similarity.ComputeSimilarityID(
                basePaths,
                file.FilePath,
                query.ID,
                fmt.Sprintf("%d", lineNumber),
                "",
        )
        if err != nil </span><span class="cov0" title="0">{
                log.Error().Msg("unable to compute similarity ID")
        }</span>

        <span class="cov2" title="5">c.mu.Lock()
        if _, ok := c.excludeResults[engine.PtrStringToString(simID)]; !ok </span><span class="cov2" title="5">{
                linesVuln := c.detector.GetAdjacent(file, lineNumber+1)
                if !ignoreLine(linesVuln.Line, file.LinesIgnore) </span><span class="cov2" title="3">{
                        vuln := model.Vulnerability{
                                QueryID:          query.ID,
                                QueryName:        SecretsQueryMetadata["queryName"] + " - " + query.Name,
                                SimilarityID:     engine.PtrStringToString(simID),
                                FileID:           file.ID,
                                FileName:         file.FilePath,
                                Line:             linesVuln.Line,
                                VulnLines:        hideSecret(&amp;linesVuln, issueLine, query, &amp;c.SecretTracker),
                                IssueType:        "RedundantAttribute",
                                Platform:         SecretsQueryMetadata["platform"],
                                CWE:              SecretsQueryMetadata["cwe"],
                                Severity:         model.SeverityHigh,
                                QueryURI:         SecretsQueryMetadata["descriptionUrl"],
                                Category:         SecretsQueryMetadata["category"],
                                Description:      SecretsQueryMetadata["descriptionText"],
                                DescriptionID:    SecretsQueryMetadata["descriptionID"],
                                KeyExpectedValue: "Hardcoded secret key should not appear in source",
                                KeyActualValue:   "Hardcoded secret key appears in source",
                                CloudProvider:    SecretsQueryMetadata["cloudProvider"],
                        }
                        c.vulnerabilities = append(c.vulnerabilities, vuln)
                }</span>
        }
        <span class="cov2" title="5">c.mu.Unlock()</span>
}

// CheckEntropyInterval - verifies if a given token's entropy is within expected bounds
func CheckEntropyInterval(entropy Entropy, token string) (isEntropyInInterval bool, entropyLevel float64) <span class="cov3" title="8">{
        base64Entropy := calculateEntropy(token, Base64Chars)
        hexEntropy := calculateEntropy(token, HexChars)
        highestEntropy := math.Max(base64Entropy, hexEntropy)
        if insideInterval(entropy, base64Entropy) || insideInterval(entropy, hexEntropy) </span><span class="cov2" title="5">{
                return true, highestEntropy
        }</span>
        <span class="cov2" title="3">return false, highestEntropy</span>
}

func insideInterval(entropy Entropy, floatEntropy float64) bool <span class="cov3" title="12">{
        return floatEntropy &gt;= entropy.Min &amp;&amp; floatEntropy &lt;= entropy.Max
}</span>

// calculateEntropy - calculates the entropy of a string based on the Shannon formula
func calculateEntropy(token, charSet string) float64 <span class="cov4" title="16">{
        if token == "" </span><span class="cov2" title="4">{
                return 0
        }</span>
        <span class="cov3" title="12">charMap := map[rune]float64{}
        for _, char := range token </span><span class="cov9" title="1234">{
                if strings.Contains(charSet, string(char)) </span><span class="cov8" title="909">{
                        charMap[char]++
                }</span>
        }

        <span class="cov3" title="12">var freq float64
        length := float64(len(token))
        for _, count := range charMap </span><span class="cov6" title="191">{
                freq += count * math.Log2(count)
        }</span>

        <span class="cov3" title="12">return math.Log2(length) - freq/length</span>
}

func shouldExecuteQuery(filterTarget, id, category, severity string, filter []string) bool <span class="cov8" title="889">{
        if isValueInArray(filterTarget, filter) </span><span class="cov1" title="1">{
                log.Debug().
                        Msgf("Excluding query ID: %s category: %s severity: %s",
                                id,
                                category,
                                severity)
                return false
        }</span>
        <span class="cov8" title="888">return true</span>
}

func getPasswordsAndSecretsQueryID() (string, error) <span class="cov3" title="13">{
        var metadata = make(map[string]string)
        err := json.Unmarshal([]byte(assets.SecretsQueryMetadataJSON), &amp;metadata)
        if err != nil </span><span class="cov1" title="1">{
                return "", err
        }</span>
        <span class="cov3" title="12">return metadata["id"], nil</span>
}

func validateCustomSecretsQueriesID(allRegexQueries []RegexQuery) error <span class="cov0" title="0">{
        for i := range allRegexQueries </span><span class="cov0" title="0">{
                re := regexp.MustCompile(`^[0-9a-fA-F]{8}\b-[0-9a-fA-F]{4}\b-[0-9a-fA-F]{4}\b-[0-9a-fA-F]{4}\b-[0-9a-fA-F]{12}$`)
                if !(re.MatchString(allRegexQueries[i].ID)) </span><span class="cov0" title="0">{
                        return fmt.Errorf("the query %s defines an invalid query ID (%s)", allRegexQueries[i].Name, allRegexQueries[i].ID)
                }</span>
        }
        <span class="cov0" title="0">return nil</span>
}

func (c *Inspector) checkContent(i, idx int, basePaths []string, files model.FileMetadatas) <span class="cov7" title="252">{
        // lines ignore can have the lines from the resolved files
        // since inspector secrets only looks to original data, the lines ignore should be replaced
        files[idx].LinesIgnore = model.GetIgnoreLines(&amp;files[idx])

        wg := &amp;sync.WaitGroup{}
        // check file content line by line
        if c.regexQueries[i].Multiline == (MultilineResult{}) </span><span class="cov7" title="217">{
                lines := (&amp;files[idx]).LinesOriginalData
                for lineNumber, currentLine := range *lines </span><span class="cov9" title="2945">{
                        wg.Add(1)
                        go c.checkLineByLine(wg, &amp;c.regexQueries[i], basePaths, &amp;files[idx], lineNumber, currentLine)
                }</span>
                <span class="cov7" title="217">wg.Wait()
                return</span>
        }

        // check file content as a whole
        <span class="cov4" title="35">c.checkFileContent(&amp;c.regexQueries[i], basePaths, &amp;files[idx])</span>
}

func ignoreLine(lineNumber int, linesIgnore []int) bool <span class="cov2" title="5">{
        for _, ignoreLine := range linesIgnore </span><span class="cov2" title="3">{
                if lineNumber == ignoreLine </span><span class="cov1" title="2">{
                        return true
                }</span>
        }
        <span class="cov2" title="3">return false</span>
}

// cleanFiles keeps one file per filePath
func cleanFiles(files model.FileMetadatas) model.FileMetadatas <span class="cov7" title="288">{
        keys := make(map[string]bool)

        cleanFiles := model.FileMetadatas{}

        for i := range files </span><span class="cov7" title="288">{
                filePath := files[i].FilePath
                if _, value := keys[filePath]; !value </span><span class="cov7" title="288">{
                        keys[filePath] = true
                        cleanFiles = append(cleanFiles, files[i])
                }</span>
        }

        <span class="cov7" title="288">return cleanFiles</span>
}

func hideSecret(linesVuln *model.VulnerabilityLines,
        issueLine string,
        query *RegexQuery,
        secretTracker *[]SecretTracker) *[]model.CodeLine <span class="cov2" title="3">{
        for idx := range *linesVuln.VulnLines </span><span class="cov1" title="2">{
                if query.SpecialMask == "all" &amp;&amp; idx != 0 </span><span class="cov0" title="0">{
                        addToSecretTracker(secretTracker, linesVuln.ResolvedFile, linesVuln.Line, (*linesVuln.VulnLines)[idx].Line, "&lt;SECRET-MASKED-ON-PURPOSE&gt;")
                        (*linesVuln.VulnLines)[idx].Line = "&lt;SECRET-MASKED-ON-PURPOSE&gt;"
                        continue</span>
                }

                <span class="cov1" title="2">if (*linesVuln.VulnLines)[idx].Line == issueLine </span><span class="cov1" title="2">{
                        regex := query.RegexStr

                        if query.SpecialMask != "" </span><span class="cov1" title="2">{
                                regex = "(.*)" + query.SpecialMask // get key
                        }</span>

                        <span class="cov1" title="2">var re = regexp.MustCompile(regex)
                        match := re.FindString(issueLine)

                        if query.SpecialMask != "" </span><span class="cov1" title="2">{
                                match = issueLine[len(match):] // get value
                        }</span>

                        <span class="cov1" title="2">if match != "" </span><span class="cov1" title="2">{
                                originalCntAux := (*linesVuln.VulnLines)[idx].Line
                                (*linesVuln.VulnLines)[idx].Line = strings.Replace(issueLine, match, "&lt;SECRET-MASKED-ON-PURPOSE&gt;", 1)
                                addToSecretTracker(secretTracker, linesVuln.ResolvedFile, linesVuln.Line, originalCntAux, (*linesVuln.VulnLines)[idx].Line)
                        }</span> else<span class="cov0" title="0"> {
                                addToSecretTracker(secretTracker,
                                        linesVuln.ResolvedFile,
                                        linesVuln.Line,
                                        (*linesVuln.VulnLines)[idx].Line,
                                        "&lt;SECRET-MASKED-ON-PURPOSE&gt;")
                                (*linesVuln.VulnLines)[idx].Line = "&lt;SECRET-MASKED-ON-PURPOSE&gt;"
                        }</span>
                }
        }
        <span class="cov2" title="3">return linesVuln.VulnLines</span>
}

func addToSecretTracker(secretTracker *[]SecretTracker, path string, line int, originalCnt, maskedCnt string) <span class="cov1" title="2">{
        *secretTracker = append(*secretTracker, SecretTracker{
                ResolvedFilePath: path,
                Line:             line,
                OriginalContent:  originalCnt,
                MaskedContent:    maskedCnt,
        })
}</span>
</pre>
		
		<pre class="file" id="file47" style="display: none">package similarity

import (
        "crypto/sha256"
        "encoding/hex"
        "path/filepath"
        "strings"

        "github.com/rs/zerolog/log"
)

// ComputeSimilarityID This function receives four string parameters and computes a sha256 hash
func ComputeSimilarityID(basePaths []string, filePath, queryID, searchKey, searchValue string) (*string, error) <span class="cov9" title="18">{
        basePath := ""
        for _, path := range basePaths </span><span class="cov9" title="18">{
                if strings.Contains(filepath.ToSlash(filePath), filepath.ToSlash(path)) </span><span class="cov8" title="14">{
                        basePath = filepath.ToSlash(path)
                        break</span>
                }
        }
        <span class="cov9" title="18">standardizedPath, err := standardizeToRelativePath(basePath, filePath)
        if err != nil </span><span class="cov0" title="0">{
                log.Debug().Msgf("Error while standardizing path: %s", err)
        }</span>

        <span class="cov9" title="18">var stringNode = standardizedPath + queryID + searchKey + searchValue

        hashSum := sha256.Sum256([]byte(stringNode))

        similarity := hex.EncodeToString(hashSum[:])
        return &amp;similarity, nil</span>
}

func standardizeToRelativePath(basePath, path string) (string, error) <span class="cov10" title="22">{
        cleanPath := filepath.Clean(path)
        standardPath := filepath.ToSlash(cleanPath)
        basePath = filepath.ToSlash(basePath)
        relativeStandardPath, err := filepath.Rel(basePath, standardPath)
        if err != nil </span><span class="cov1" title="1">{
                return "", err
        }</span>
        <span class="cov9" title="21">return filepath.ToSlash(relativeStandardPath), nil</span>
}
</pre>
		
		<pre class="file" id="file48" style="display: none">package source

import (
        "encoding/json"
        "fmt"
        "os"
        "path"
        "path/filepath"
        "sort"
        "strings"

        "github.com/Checkmarx/kics/v2/assets"
        "github.com/Checkmarx/kics/v2/internal/constants"
        sentryReport "github.com/Checkmarx/kics/v2/internal/sentry"
        "github.com/Checkmarx/kics/v2/pkg/model"
        "github.com/pkg/errors"
        "github.com/rs/zerolog/log"
)

// FilesystemSource this type defines a struct with a path to a filesystem source of queries
// Source is the path to the queries
// Types are the types given by the flag --type for query selection mechanism
type FilesystemSource struct {
        Source              []string
        Types               []string
        CloudProviders      []string
        Library             string
        ExperimentalQueries bool
}

const (
        // QueryFileName The default query file name
        QueryFileName = "query.rego"
        // MetadataFileName The default metadata file name
        MetadataFileName = "metadata.json"
        // LibrariesDefaultBasePath the path to rego libraries
        LibrariesDefaultBasePath = "./assets/libraries"

        emptyInputData = "{}"

        common = "Common"

        kicsDefault = "default"
)

// NewFilesystemSource initializes a NewFilesystemSource with source to queries and types of queries to load
func NewFilesystemSource(source, types, cloudProviders []string, libraryPath string, experimentalQueries bool) *FilesystemSource <span class="cov7" title="19">{
        log.Debug().Msg("source.NewFilesystemSource()")

        if len(types) == 0 </span><span class="cov0" title="0">{
                types = []string{""}
        }</span>

        <span class="cov7" title="19">if len(cloudProviders) == 0 </span><span class="cov0" title="0">{
                cloudProviders = []string{""}
        }</span>

        <span class="cov7" title="19">for s := range source </span><span class="cov7" title="20">{
                source[s] = filepath.FromSlash(source[s])
        }</span>

        <span class="cov7" title="19">return &amp;FilesystemSource{
                Source:              source,
                Types:               types,
                CloudProviders:      cloudProviders,
                Library:             filepath.FromSlash(libraryPath),
                ExperimentalQueries: experimentalQueries,
        }</span>
}

// ListSupportedPlatforms returns a list of supported platforms
func ListSupportedPlatforms() []string <span class="cov1" title="1">{
        keys := make([]string, len(constants.AvailablePlatforms))
        i := 0
        for k := range constants.AvailablePlatforms </span><span class="cov7" title="17">{
                keys[i] = k
                i++
        }</span>
        <span class="cov1" title="1">sort.Strings(keys)
        return keys</span>
}

// ListSupportedCloudProviders returns a list of supported cloud providers
func ListSupportedCloudProviders() []string <span class="cov1" title="1">{
        return []string{"alicloud", "aws", "azure", "gcp", "nifcloud", "tencentcloud"}
}</span>

func getLibraryInDir(platform, libraryDirPath string) string <span class="cov2" title="2">{
        var libraryFilePath string
        err := filepath.Walk(libraryDirPath, func(path string, info os.FileInfo, err error) error </span><span class="cov8" title="38">{
                if err != nil </span><span class="cov0" title="0">{
                        return err
                }</span>
                <span class="cov8" title="38">if strings.EqualFold(filepath.Base(path), platform+".rego") </span><span class="cov1" title="1">{ // try to find the library file &lt;platform&gt;.rego
                        libraryFilePath = path
                }</span>
                <span class="cov8" title="38">return nil</span>
        })
        <span class="cov2" title="2">if err != nil </span><span class="cov0" title="0">{
                log.Error().Msgf("Failed to analyze path %s: %s", libraryDirPath, err)
        }</span>
        <span class="cov2" title="2">return libraryFilePath</span>
}

func isDefaultLibrary(libraryPath string) bool <span class="cov5" title="8">{
        return filepath.FromSlash(libraryPath) == filepath.FromSlash(LibrariesDefaultBasePath)
}</span>

// GetPathToCustomLibrary - returns the libraries path for a given platform
func GetPathToCustomLibrary(platform, libraryPathFlag string) string <span class="cov5" title="8">{
        libraryFilePath := kicsDefault

        if !isDefaultLibrary(libraryPathFlag) </span><span class="cov0" title="0">{
                log.Debug().Msgf("Trying to load custom libraries from %s", libraryPathFlag)

                library := getLibraryInDir(platform, libraryPathFlag)
                // found a library named according to the platform
                if library != "" </span><span class="cov0" title="0">{
                        libraryFilePath = library
                }</span>
        }

        <span class="cov5" title="8">return libraryFilePath</span>
}

// GetQueryLibrary returns the library.rego for the platform passed in the argument
func (s *FilesystemSource) GetQueryLibrary(platform string) (RegoLibraries, error) <span class="cov5" title="8">{
        library := GetPathToCustomLibrary(platform, s.Library)
        customLibraryCode := ""
        customLibraryData := emptyInputData

        if library == "" </span><span class="cov0" title="0">{
                return RegoLibraries{}, errors.New("unable to get libraries path")
        }</span>

        <span class="cov5" title="8">if library != kicsDefault </span><span class="cov0" title="0">{
                byteContent, err := os.ReadFile(library)
                if err != nil </span><span class="cov0" title="0">{
                        return RegoLibraries{}, err
                }</span>
                <span class="cov0" title="0">customLibraryCode = string(byteContent)
                customLibraryData, err = readInputData(strings.TrimSuffix(library, filepath.Ext(library)) + ".json")
                if err != nil </span><span class="cov0" title="0">{
                        log.Debug().Msg(err.Error())
                }</span>
        } else<span class="cov5" title="8"> {
                log.Debug().Msgf("Custom library %s not provided. Loading embedded library instead", platform)
        }</span>
        // getting embedded library
        <span class="cov5" title="8">embeddedLibraryCode, errGettingEmbeddedLibrary := assets.GetEmbeddedLibrary(strings.ToLower(platform))
        if errGettingEmbeddedLibrary != nil </span><span class="cov1" title="1">{
                return RegoLibraries{}, errGettingEmbeddedLibrary
        }</span>

        <span class="cov5" title="7">mergedLibraryCode, errMergeLibs := mergeLibraries(customLibraryCode, embeddedLibraryCode)
        if errMergeLibs != nil </span><span class="cov0" title="0">{
                return RegoLibraries{}, errMergeLibs
        }</span>

        <span class="cov5" title="7">embeddedLibraryData, errGettingEmbeddedLibraryCode := assets.GetEmbeddedLibraryData(strings.ToLower(platform))
        if errGettingEmbeddedLibraryCode != nil </span><span class="cov4" title="6">{
                log.Debug().Msgf("Could not open embedded library data for %s platform", platform)
                embeddedLibraryData = emptyInputData
        }</span>
        <span class="cov5" title="7">mergedLibraryData, errMergingLibraryData := MergeInputData(embeddedLibraryData, customLibraryData)
        if errMergingLibraryData != nil </span><span class="cov0" title="0">{
                log.Debug().Msgf("Could not merge library data for %s platform", platform)
        }</span>

        <span class="cov5" title="7">regoLibrary := RegoLibraries{
                LibraryCode:      mergedLibraryCode,
                LibraryInputData: mergedLibraryData,
        }
        return regoLibrary, nil</span>
}

// CheckType checks if the queries have the type passed as an argument in '--type' flag to be loaded
func (s *FilesystemSource) CheckType(queryPlatform interface{}) bool <span class="cov5" title="10">{
        if queryPlatform.(string) == common </span><span class="cov0" title="0">{
                return true
        }</span>
        <span class="cov5" title="10">if s.Types[0] != "" </span><span class="cov0" title="0">{
                for _, t := range s.Types </span><span class="cov0" title="0">{
                        if strings.EqualFold(t, queryPlatform.(string)) </span><span class="cov0" title="0">{
                                return true
                        }</span>
                }
                <span class="cov0" title="0">return false</span>
        }
        <span class="cov5" title="10">return true</span>
}

// CheckCloudProvider checks if the queries have the cloud provider passed as an argument in '--cloud-provider' flag to be loaded
func (s *FilesystemSource) CheckCloudProvider(cloudProvider interface{}) bool <span class="cov5" title="10">{
        if cloudProvider != nil </span><span class="cov2" title="2">{
                if strings.EqualFold(cloudProvider.(string), common) </span><span class="cov0" title="0">{
                        return true
                }</span>
                <span class="cov2" title="2">if s.CloudProviders[0] != "" </span><span class="cov0" title="0">{
                        return strings.Contains(strings.ToUpper(strings.Join(s.CloudProviders, ",")), strings.ToUpper(cloudProvider.(string)))
                }</span>
        }

        <span class="cov5" title="10">if s.CloudProviders[0] == "" </span><span class="cov5" title="10">{
                return true
        }</span>

        <span class="cov0" title="0">return false</span>
}

func checkQueryInclude(id interface{}, includedQueries []string) bool <span class="cov2" title="2">{
        queryMetadataKey, ok := id.(string)
        if !ok </span><span class="cov0" title="0">{
                log.Warn().
                        Msgf("Can't cast query metadata key = %v", id)
                return false
        }</span>
        <span class="cov2" title="2">for _, includedQuery := range includedQueries </span><span class="cov2" title="2">{
                if queryMetadataKey == includedQuery </span><span class="cov1" title="1">{
                        return true
                }</span>
        }
        <span class="cov1" title="1">return false</span>
}

func checkQueryExcludeField(id interface{}, excludeQueries []string) bool <span class="cov7" title="21">{
        queryMetadataKey, ok := id.(string)
        if !ok </span><span class="cov0" title="0">{
                log.Warn().
                        Msgf("Can't cast query metadata key = %v", id)
                return false
        }</span>
        <span class="cov7" title="21">for _, excludedQuery := range excludeQueries </span><span class="cov3" title="4">{
                if strings.EqualFold(queryMetadataKey, excludedQuery) </span><span class="cov3" title="3">{
                        return true
                }</span>
        }
        <span class="cov7" title="18">return false</span>
}

func checkQueryExclude(metadata map[string]interface{}, queryParameters *QueryInspectorParameters) bool <span class="cov5" title="8">{
        return checkQueryExcludeField(metadata["id"], queryParameters.ExcludeQueries.ByIDs) ||
                checkQueryExcludeField(metadata["category"], queryParameters.ExcludeQueries.ByCategories) ||
                checkQueryExcludeField(metadata["severity"], queryParameters.ExcludeQueries.BySeverities) ||
                (!queryParameters.BomQueries &amp;&amp; metadata["severity"] == model.SeverityTrace)
}</span>

// GetQueries walks a given filesource path returns all queries found in an array of
// QueryMetadata struct
func (s *FilesystemSource) GetQueries(queryParameters *QueryInspectorParameters) ([]model.QueryMetadata, error) <span class="cov6" title="11">{
        queryDirs, err := s.iterateSources()
        if err != nil </span><span class="cov3" title="3">{
                return nil, err
        }</span>

        <span class="cov5" title="8">queries := s.iterateQueryDirs(queryDirs, queryParameters)

        return queries, nil</span>
}

func (s *FilesystemSource) iterateSources() ([]string, error) <span class="cov6" title="11">{
        queryDirs := make([]string, 0)

        for _, source := range s.Source </span><span class="cov6" title="12">{
                err := filepath.Walk(source,
                        func(p string, f os.FileInfo, err error) error </span><span class="cov10" title="68">{
                                if err != nil </span><span class="cov3" title="3">{
                                        return err
                                }</span>

                                <span class="cov9" title="65">if f.IsDir() || f.Name() != QueryFileName </span><span class="cov9" title="55">{
                                        return nil
                                }</span>

                                <span class="cov5" title="10">querypathDir := filepath.Dir(p)

                                if err == nil </span><span class="cov5" title="10">{
                                        queryDirs = append(queryDirs, querypathDir)
                                }</span> else<span class="cov0" title="0"> if err != nil </span><span class="cov0" title="0">{
                                        return errors.Wrap(err, "Failed to get query relative path")
                                }</span>

                                <span class="cov5" title="10">return nil</span>
                        })
                <span class="cov6" title="12">if err != nil </span><span class="cov3" title="3">{
                        return nil, errors.Wrap(err, "failed to get query Source")
                }</span>
        }

        <span class="cov5" title="8">return queryDirs, nil</span>
}

// iterateQueryDirs iterates all query directories and reads the respective queries
func (s *FilesystemSource) iterateQueryDirs(queryDirs []string, queryParameters *QueryInspectorParameters) []model.QueryMetadata <span class="cov5" title="8">{
        queries := make([]model.QueryMetadata, 0, len(queryDirs))

        for _, queryDir := range queryDirs </span><span class="cov5" title="10">{
                query, errRQ := ReadQuery(queryDir)
                if errRQ != nil </span><span class="cov0" title="0">{
                        sentryReport.ReportSentry(&amp;sentryReport.Report{
                                Message:  fmt.Sprintf("Query provider failed to read query, query=%s", path.Base(queryDir)),
                                Err:      errRQ,
                                Location: "func GetQueries()",
                                FileName: path.Base(queryDir),
                        }, true)
                        continue</span>
                }

                <span class="cov5" title="10">if query.Experimental &amp;&amp; !queryParameters.ExperimentalQueries </span><span class="cov0" title="0">{
                        continue</span>
                }

                <span class="cov5" title="10">if !s.CheckType(query.Metadata["platform"]) </span><span class="cov0" title="0">{
                        continue</span>
                }

                <span class="cov5" title="10">if !s.CheckCloudProvider(query.Metadata["cloudProvider"]) </span><span class="cov0" title="0">{
                        continue</span>
                }

                <span class="cov5" title="10">customInputData, readInputErr := readInputData(filepath.Join(queryParameters.InputDataPath, query.Metadata["id"].(string)+".json"))
                if readInputErr != nil </span><span class="cov0" title="0">{
                        log.Err(errRQ).
                                Msgf("failed to read input data, query=%s", path.Base(queryDir))
                        continue</span>
                }

                <span class="cov5" title="10">inputData, mergeError := MergeInputData(query.InputData, customInputData)
                if mergeError != nil </span><span class="cov0" title="0">{
                        log.Err(mergeError).
                                Msgf("failed to merge input data, query=%s", path.Base(queryDir))
                        continue</span>
                }
                <span class="cov5" title="10">query.InputData = inputData

                if len(queryParameters.IncludeQueries.ByIDs) &gt; 0 </span><span class="cov2" title="2">{
                        if checkQueryInclude(query.Metadata["id"], queryParameters.IncludeQueries.ByIDs) </span><span class="cov1" title="1">{
                                queries = append(queries, query)
                        }</span>
                } else<span class="cov5" title="8"> {
                        if checkQueryExclude(query.Metadata, queryParameters) </span><span class="cov3" title="3">{
                                log.Debug().
                                        Msgf("Excluding query ID: %s category: %s severity: %s", query.Metadata["id"], query.Metadata["category"], query.Metadata["severity"])
                                continue</span>
                        }

                        <span class="cov4" title="5">queries = append(queries, query)</span>
                }
        }
        <span class="cov5" title="8">return queries</span>
}

// validateMetadata prevents panics when KICS queries metadata fields are missing
func validateMetadata(metadata map[string]interface{}) (exist bool, field string) <span class="cov6" title="13">{
        fields := []string{
                "id",
                "platform",
        }
        for _, field = range fields </span><span class="cov7" title="25">{
                if _, exist = metadata[field]; !exist </span><span class="cov2" title="2">{
                        return
                }</span>
        }
        <span class="cov6" title="11">return</span>
}

// ReadQuery reads query's files for a given path and returns a QueryMetadata struct with it's
// content
func ReadQuery(queryDir string) (model.QueryMetadata, error) <span class="cov5" title="10">{
        queryContent, err := os.ReadFile(filepath.Clean(path.Join(queryDir, QueryFileName)))
        if err != nil </span><span class="cov0" title="0">{
                return model.QueryMetadata{}, errors.Wrapf(err, "failed to read query %s", path.Base(queryDir))
        }</span>

        <span class="cov5" title="10">metadata, err := ReadMetadata(queryDir)
        if err != nil </span><span class="cov0" title="0">{
                return model.QueryMetadata{}, errors.Wrapf(err, "failed to read query %s", path.Base(queryDir))
        }</span>

        <span class="cov5" title="10">if valid, missingField := validateMetadata(metadata); !valid </span><span class="cov0" title="0">{
                return model.QueryMetadata{}, fmt.Errorf("failed to read metadata field: %s", missingField)
        }</span>

        <span class="cov5" title="10">platform := getPlatform(metadata["platform"].(string))

        inputData, errInputData := readInputData(filepath.Join(queryDir, "data.json"))
        if errInputData != nil </span><span class="cov0" title="0">{
                log.Err(errInputData).
                        Msgf("Query provider failed to read input data, query=%s", path.Base(queryDir))
        }</span>

        <span class="cov5" title="10">aggregation := 1
        if agg, ok := metadata["aggregation"]; ok </span><span class="cov0" title="0">{
                aggregation = int(agg.(float64))
        }</span>

        <span class="cov5" title="10">experimental := getExperimental(metadata["experimental"])

        return model.QueryMetadata{
                Query:        path.Base(filepath.ToSlash(queryDir)),
                Content:      string(queryContent),
                Metadata:     metadata,
                Platform:     platform,
                InputData:    inputData,
                Aggregation:  aggregation,
                Experimental: experimental,
        }, nil</span>
}

// ReadMetadata read query's metadata file inside the query directory
func ReadMetadata(queryDir string) (map[string]interface{}, error) <span class="cov6" title="12">{
        f, err := os.Open(filepath.Clean(path.Join(queryDir, MetadataFileName)))
        if err != nil </span><span class="cov1" title="1">{
                sentryReport.ReportSentry(&amp;sentryReport.Report{
                        Message:  fmt.Sprintf("Queries provider can't read metadata, query=%s", path.Base(queryDir)),
                        Err:      err,
                        Location: "func ReadMetadata()",
                        FileName: path.Base(queryDir),
                }, true)

                return nil, err
        }</span>
        <span class="cov6" title="11">defer func() </span><span class="cov6" title="11">{
                if err := f.Close(); err != nil </span><span class="cov0" title="0">{
                        log.Err(err).
                                Msgf("Queries provider can't close file, file=%s", filepath.Clean(path.Join(queryDir, MetadataFileName)))
                }</span>
        }()

        <span class="cov6" title="11">var metadata map[string]interface{}
        if err := json.NewDecoder(f).Decode(&amp;metadata); err != nil </span><span class="cov0" title="0">{
                sentryReport.ReportSentry(&amp;sentryReport.Report{
                        Message:  fmt.Sprintf("Queries provider can't unmarshal metadata, query=%s", path.Base(queryDir)),
                        Err:      err,
                        Location: "func ReadMetadata()",
                        FileName: path.Base(queryDir),
                }, true)

                return nil, err
        }</span>

        <span class="cov6" title="11">return metadata, nil</span>
}

type supportedPlatforms map[string]string

var supPlatforms = &amp;supportedPlatforms{
        "Ansible":                 "ansible",
        "CloudFormation":          "cloudFormation",
        "Common":                  "common",
        "Crossplane":              "crossplane",
        "Dockerfile":              "dockerfile",
        "DockerCompose":           "dockerCompose",
        "Knative":                 "knative",
        "Kubernetes":              "k8s",
        "OpenAPI":                 "openAPI",
        "Terraform":               "terraform",
        "AzureResourceManager":    "azureResourceManager",
        "GRPC":                    "grpc",
        "GoogleDeploymentManager": "googleDeploymentManager",
        "Buildah":                 "buildah",
        "Pulumi":                  "pulumi",
        "ServerlessFW":            "serverlessFW",
        "CICD":                    "cicd",
}

func getPlatform(metadataPlatform string) string <span class="cov7" title="20">{
        if p, ok := (*supPlatforms)[metadataPlatform]; ok </span><span class="cov7" title="19">{
                return p
        }</span>
        <span class="cov1" title="1">return "unknown"</span>
}

func getExperimental(experimental interface{}) bool <span class="cov5" title="10">{
        readExperimental, _ := experimental.(string)
        if readExperimental == "true" </span><span class="cov2" title="2">{
                return true
        }</span> else<span class="cov5" title="8"> {
                return false
        }</span>
}

func readInputData(inputDataPath string) (string, error) <span class="cov7" title="21">{
        inputData, err := os.ReadFile(filepath.Clean(inputDataPath))
        if err != nil </span><span class="cov7" title="20">{
                if os.IsNotExist(err) </span><span class="cov7" title="20">{
                        return emptyInputData, nil
                }</span>
                <span class="cov0" title="0">return emptyInputData, errors.Wrapf(err, "failed to read query input data %s", path.Base(inputDataPath))</span>
        }
        <span class="cov1" title="1">return string(inputData), nil</span>
}
</pre>
		
		<pre class="file" id="file49" style="display: none">// Package source (go:generate go run -mod=mod github.com/golang/mock/mockgen -package mock -source=./$GOFILE -destination=../mock/$GOFILE)
package source

import (
        "encoding/json"
        "strings"

        "github.com/Checkmarx/kics/v2/pkg/model"
        "github.com/open-policy-agent/opa/ast"
        "github.com/pkg/errors"
        "github.com/rs/zerolog/log"
)

// QueryInspectorParameters is a struct that represents the optionn to select queries to be executed
type QueryInspectorParameters struct {
        IncludeQueries      IncludeQueries
        ExcludeQueries      ExcludeQueries
        ExperimentalQueries bool
        InputDataPath       string
        BomQueries          bool
}

// ExcludeQueries is a struct that represents the option to exclude queries by ids or by categories
type ExcludeQueries struct {
        ByIDs        []string
        ByCategories []string
        BySeverities []string
}

// IncludeQueries is a struct that represents the option to include queries by ID taking precedence over exclusion
type IncludeQueries struct {
        ByIDs []string
}

// RegoLibraries is a struct that contains the library code and its input data
type RegoLibraries struct {
        LibraryCode      string
        LibraryInputData string
}

// QueriesSource wraps an interface that contains basic methods: GetQueries and GetQueryLibrary
// GetQueries gets all queries from a QueryMetadata list
// GetQueryLibrary gets a library of rego functions given a plataform's name
type QueriesSource interface {
        GetQueries(querySelection *QueryInspectorParameters) ([]model.QueryMetadata, error)
        GetQueryLibrary(platform string) (RegoLibraries, error)
}

// mergeLibraries return custom library and embedded library merged, overwriting embedded library functions, if necessary
func mergeLibraries(customLib, embeddedLib string) (string, error) <span class="cov7" title="13">{
        if customLib == "" </span><span class="cov6" title="8">{
                return embeddedLib, nil
        }</span>
        <span class="cov4" title="5">statements, _, err := ast.NewParser().WithReader(strings.NewReader(customLib)).Parse()
        if err != nil </span><span class="cov1" title="1">{
                log.Err(err).Msg("Could not parse custom library")
                return "", err
        }</span>
        <span class="cov4" title="4">headers := make(map[string]string)
        variables := make(map[string]string)
        for _, st := range statements </span><span class="cov4" title="4">{
                if rule, ok := st.(*ast.Rule); ok </span><span class="cov4" title="4">{
                        headers[string(rule.Head.Name)] = ""
                }</span>
                <span class="cov4" title="4">if regoPackage, ok := st.(ast.Body); ok </span><span class="cov0" title="0">{
                        variableSet := regoPackage.Vars(ast.SafetyCheckVisitorParams)
                        for variable := range variableSet </span><span class="cov0" title="0">{
                                variables[variable.String()] = ""
                        }</span>
                }
        }
        <span class="cov4" title="4">statements, _, err = ast.NewParser().WithReader(strings.NewReader(embeddedLib)).Parse()
        if err != nil </span><span class="cov1" title="1">{
                log.Err(err).Msg("Could not parse default library")
                return "", err
        }</span>
        <span class="cov3" title="3">for _, st := range statements </span><span class="cov4" title="4">{
                if rule, ok := st.(*ast.Rule); ok </span><span class="cov4" title="4">{
                        if _, remove := headers[string(rule.Head.Name)]; remove </span><span class="cov2" title="2">{
                                embeddedLib = strings.Replace(embeddedLib, string(rule.Location.Text), "", 1)
                        }</span>
                        <span class="cov4" title="4">continue</span>
                }
                <span class="cov0" title="0">if regoPackage, ok := st.(*ast.Package); ok </span><span class="cov0" title="0">{
                        firstHalf := strings.Join(strings.Split(embeddedLib, "\n")[:regoPackage.Location.Row-1], "\n")
                        secondHalf := strings.Join(strings.Split(embeddedLib, "\n")[regoPackage.Location.Row+1:], "\n")
                        embeddedLib = firstHalf + "\n" + secondHalf
                        continue</span>
                }
                <span class="cov0" title="0">if body, ok := st.(ast.Body); ok </span><span class="cov0" title="0">{
                        variableSet := body.Vars(ast.SafetyCheckVisitorParams)
                        for variable := range variableSet </span><span class="cov0" title="0">{
                                if _, remove := variables[variable.String()]; remove </span><span class="cov0" title="0">{
                                        embeddedLib = strings.Replace(embeddedLib, string(body.Loc().Text), "", 1)
                                        break</span>
                                }
                        }
                }
        }
        <span class="cov3" title="3">customLib += "\n" + embeddedLib

        return customLib, nil</span>
}

// MergeInputData merges KICS input data with custom input data user defined
func MergeInputData(defaultInputData, customInputData string) (string, error) <span class="cov8" title="18">{
        if checkEmptyInputdata(customInputData) &amp;&amp; checkEmptyInputdata(defaultInputData) </span><span class="cov7" title="16">{
                return emptyInputData, nil
        }</span>
        <span class="cov2" title="2">if checkEmptyInputdata(defaultInputData) </span><span class="cov0" title="0">{
                return customInputData, nil
        }</span>
        <span class="cov2" title="2">if checkEmptyInputdata(customInputData) </span><span class="cov1" title="1">{
                return defaultInputData, nil
        }</span>

        <span class="cov1" title="1">dataJSON := map[string]interface{}{}
        customDataJSON := map[string]interface{}{}
        if unmarshalError := json.Unmarshal([]byte(defaultInputData), &amp;dataJSON); unmarshalError != nil </span><span class="cov0" title="0">{
                return "", errors.Wrapf(unmarshalError, "failed to merge query input data")
        }</span>
        <span class="cov1" title="1">if unmarshalError := json.Unmarshal([]byte(customInputData), &amp;customDataJSON); unmarshalError != nil </span><span class="cov0" title="0">{
                return "", errors.Wrapf(unmarshalError, "failed to merge query input data")
        }</span>

        <span class="cov1" title="1">for key, value := range customDataJSON </span><span class="cov2" title="2">{
                dataJSON[key] = value
        }</span>
        <span class="cov1" title="1">mergedJSON, mergeErr := json.Marshal(dataJSON)
        if mergeErr != nil </span><span class="cov0" title="0">{
                return "", errors.Wrapf(mergeErr, "failed to merge query input data")
        }</span>
        <span class="cov1" title="1">return string(mergedJSON), nil</span>
}

func checkEmptyInputdata(inputData string) bool <span class="cov10" title="39">{
        return inputData == emptyInputData || inputData == ""
}</span>
</pre>
		
		<pre class="file" id="file50" style="display: none">package engine

import (
        "encoding/json"
        "strings"

        dec "github.com/Checkmarx/kics/v2/pkg/detector"
        "github.com/Checkmarx/kics/v2/pkg/engine/similarity"
        "github.com/Checkmarx/kics/v2/pkg/model"
        "github.com/pkg/errors"
        "github.com/rs/zerolog"
        "github.com/rs/zerolog/log"
)

const (
        formatFloat64   = 64
        searchKeyMinLen = 3
)

func modifyVulSearchKeyReference(doc interface{}, originalSearchKey string, stringVulList []string) (string, bool) <span class="cov10" title="9">{
        for index, vulSplit := range stringVulList </span><span class="cov10" title="9">{
                switch docTyped := doc.(type) </span>{
                case map[string]interface{}:<span class="cov10" title="9">
                        if strings.HasPrefix(vulSplit, "{{") &amp;&amp; strings.HasSuffix(vulSplit, "}}") </span><span class="cov0" title="0">{
                                vulSplit = vulSplit[2 : len(vulSplit)-2]
                        }</span>
                        <span class="cov10" title="9">if vulSplitEqual := strings.Split(vulSplit, "="); len(vulSplitEqual) != 1 </span><span class="cov0" title="0">{
                                vulSplit = vulSplitEqual[0]
                        }</span>
                        <span class="cov10" title="9">newDoc, foundEntry := docTyped[vulSplit]
                        if metadataRefDoc, ok := docTyped["RefMetadata"]; ok &amp;&amp; foundEntry &amp;&amp; index &lt; len(stringVulList) </span><span class="cov0" title="0">{
                                newSearchKey := strings.Join(stringVulList[:index], ".") + ".$ref=" + (metadataRefDoc.(map[string]interface{})["$ref"].(string))
                                return newSearchKey, true
                        }</span> else<span class="cov10" title="9"> if foundEntry </span><span class="cov0" title="0">{
                                doc = newDoc
                        }</span> else<span class="cov10" title="9"> {
                                return originalSearchKey, false
                        }</span>
                case []interface{}:<span class="cov0" title="0">
                        for _, listDoc := range docTyped </span><span class="cov0" title="0">{
                                if newSearchKey, modified := modifyVulSearchKeyReference(listDoc, originalSearchKey, stringVulList[index:]); modified </span><span class="cov0" title="0">{
                                        return strings.Join(stringVulList[:index], ".") + "." + newSearchKey, true
                                }</span>
                        }
                        <span class="cov0" title="0">return originalSearchKey, false</span>
                default:<span class="cov0" title="0">
                        if index != len(stringVulList)-1 </span><span class="cov0" title="0">{
                                return originalSearchKey, false
                        }</span>
                }
        }
        <span class="cov0" title="0">return originalSearchKey, false</span>
}

// DefaultVulnerabilityBuilder defines a vulnerability builder to execute default actions of scan
var DefaultVulnerabilityBuilder = func(ctx *QueryContext,
        tracker Tracker,
        v interface{},
        detector *dec.DetectLine,
        useOldSeverities bool,
        kicsComputeNewSimID bool) (*model.Vulnerability, error) <span class="cov10" title="9">{
        vObj, ok := v.(map[string]interface{})
        if !ok </span><span class="cov0" title="0">{
                return &amp;model.Vulnerability{}, ErrInvalidResult
        }</span>

        <span class="cov10" title="9">vObj = mergeWithMetadata(vObj, ctx.Query.Metadata.Metadata)

        var err error
        var output []byte

        output, err = json.Marshal(vObj)
        if err != nil </span><span class="cov0" title="0">{
                return &amp;model.Vulnerability{}, errors.Wrap(err, "failed to marshall query output")
        }</span>

        <span class="cov10" title="9">var fileID *string

        fileID, err = mapKeyToString(vObj, "documentId", false)
        if err != nil </span><span class="cov0" title="0">{
                return &amp;model.Vulnerability{}, errors.Wrap(err, "failed to recognize file id")
        }</span>

        <span class="cov10" title="9">file, ok := ctx.Files[*fileID]
        if !ok </span><span class="cov0" title="0">{
                return &amp;model.Vulnerability{}, errors.New("failed to find file from query response")
        }</span>

        <span class="cov10" title="9">logWithFields := log.With().
                Str("scanID", ctx.scanID).
                Str("fileName", file.FilePath).
                Str("queryName", ctx.Query.Metadata.Query).
                Logger()

        detector.SetupLogs(&amp;logWithFields)

        linesVulne := model.VulnerabilityLines{
                Line:      -1,
                VulnLines: &amp;[]model.CodeLine{},
        }

        similarityIDLineInfo := ""
        searchKey := ""
        if s, ok := vObj["searchKey"]; ok </span><span class="cov10" title="9">{
                searchKey = s.(string)
                similarityIDLineInfo = searchKey
                intDoc := file.LineInfoDocument
                vulsSplit := strings.Split(searchKey, ".")

                if file.Kind == model.KindINI </span><span class="cov0" title="0">{
                        vulsSplit, searchKey = sanitizeINIKey(vulsSplit)
                }</span>

                <span class="cov10" title="9">if strings.Contains(vulsSplit[len(vulsSplit)-1], "RefMetadata") </span><span class="cov0" title="0">{
                        return &amp;model.Vulnerability{}, ErrNoResult
                }</span>

                // modify the search key in cases where it should be referencing a ref instead of part of the resolved object
                <span class="cov10" title="9">searchKey, _ = modifyVulSearchKeyReference(intDoc, searchKey, vulsSplit)
                vObj["searchKey"] = searchKey
                linesVulne = detector.DetectLine(&amp;file, searchKey, &amp;logWithFields)</span>
        } else<span class="cov0" title="0"> {
                logWithFields.Error().Msg("Saving result. failed to detect line")
        }</span>

        <span class="cov10" title="9">lineNumber := 0
        var similarityIDLineInfoOld = similarityIDLineInfo
        if file.Kind != model.KindHELM &amp;&amp; len(file.ResolvedFiles) == 0 </span><span class="cov10" title="9">{
                searchLineCalc := &amp;searchLineCalculator{
                        lineNr:               -1,
                        vObj:                 vObj,
                        file:                 file,
                        detector:             detector,
                        similarityIDLineInfo: similarityIDLineInfo,
                        linesVulne:           linesVulne,
                }
                // calculate search Line if possible (default uses values of search key)
                lineNumber, similarityIDLineInfoOld, linesVulne = calculeSearchLine(searchLineCalc)
        }</span>

        <span class="cov10" title="9">if linesVulne.Line == -1 </span><span class="cov10" title="9">{
                logWithFields.Warn().Msgf("Failed to detect line, query response %s", searchKey)
                linesVulne.Line = 1
        }</span>

        <span class="cov10" title="9">searchValue := ""
        if s, ok := vObj["searchValue"]; ok </span><span class="cov0" title="0">{
                searchValue = s.(string)
        }</span>

        <span class="cov10" title="9">overrideKey := ""
        if s, ok := vObj["overrideKey"]; ok </span><span class="cov5" title="3">{
                overrideKey = s.(string)
        }</span>

        <span class="cov10" title="9">queryID := getStringFromMap("id", DefaultQueryID, overrideKey, vObj, &amp;logWithFields)

        severity := getResolvedSeverity(vObj, &amp;logWithFields, overrideKey, useOldSeverities)

        issueType := DefaultIssueType
        if v := mustMapKeyToString(vObj, "issueType"); v != nil </span><span class="cov10" title="9">{
                issueType = model.IssueType(*v)
        }</span>

        <span class="cov10" title="9">similarityID, oldSimilarityID := generateSimilaritiesID(ctx, linesVulne.ResolvedFile, queryID, similarityIDLineInfo, searchValue,
                searchKey, similarityIDLineInfoOld, kicsComputeNewSimID, &amp;logWithFields, tracker)

        return &amp;model.Vulnerability{
                ID:               0,
                SimilarityID:     PtrStringToString(similarityID),
                OldSimilarityID:  PtrStringToString(oldSimilarityID),
                ScanID:           ctx.scanID,
                FileID:           file.ID,
                FileName:         linesVulne.ResolvedFile,
                QueryName:        getStringFromMap("queryName", DefaultQueryName, overrideKey, vObj, &amp;logWithFields),
                QueryID:          queryID,
                Experimental:     getBoolFromMap("experimental", DefaultExperimental, overrideKey, vObj, &amp;logWithFields),
                QueryURI:         getStringFromMap("descriptionUrl", DefaultQueryURI, overrideKey, vObj, &amp;logWithFields),
                Category:         getStringFromMap("category", "", overrideKey, vObj, &amp;logWithFields),
                Description:      getStringFromMap("descriptionText", "", overrideKey, vObj, &amp;logWithFields),
                DescriptionID:    getStringFromMap("descriptionID", DefaultQueryDescriptionID, overrideKey, vObj, &amp;logWithFields),
                Severity:         severity,
                Platform:         getStringFromMap("platform", "", overrideKey, vObj, &amp;logWithFields),
                CWE:              getStringFromMap("cwe", "", overrideKey, vObj, &amp;logWithFields),
                Line:             linesVulne.Line,
                VulnLines:        linesVulne.VulnLines,
                ResourceType:     PtrStringToString(mustMapKeyToString(vObj, "resourceType")),
                ResourceName:     PtrStringToString(mustMapKeyToString(vObj, "resourceName")),
                IssueType:        issueType,
                SearchKey:        searchKey,
                SearchLine:       lineNumber,
                SearchValue:      searchValue,
                KeyExpectedValue: PtrStringToString(mustMapKeyToString(vObj, "keyExpectedValue")),
                KeyActualValue:   PtrStringToString(mustMapKeyToString(vObj, "keyActualValue")),
                Value:            mustMapKeyToString(vObj, "value"),
                Output:           string(output),
                CloudProvider:    getCloudProvider(overrideKey, vObj, &amp;logWithFields),
                Remediation:      PtrStringToString(mustMapKeyToString(vObj, "remediation")),
                RemediationType:  PtrStringToString(mustMapKeyToString(vObj, "remediationType")),
        }, nil</span>
}

// &lt;editor-fold desc="similarity id"&gt;
func generateSimilaritiesID(ctx *QueryContext,
        resolvedFile, queryID, similarityIDLineInfo, searchValue, searchKey, similarityIDLineInfoOld string,
        kicsComputeNewSimID bool,
        logWithFields *zerolog.Logger,
        tracker Tracker) (similarityID, oldSimilarityID *string) <span class="cov10" title="9">{
        if kicsComputeNewSimID </span><span class="cov8" title="7">{
                similarityID, err := buildSimilarityID(ctx, resolvedFile, queryID, similarityIDLineInfo, searchValue)
                if err != nil </span><span class="cov0" title="0">{
                        logWithFields.Err(err).Send()
                        tracker.FailedComputeSimilarityID()
                }</span>

                <span class="cov8" title="7">oldSimilarityID, err = oldBuildSimilarityID(ctx, resolvedFile, queryID, searchKey, similarityIDLineInfoOld, searchValue)
                if err != nil </span><span class="cov0" title="0">{
                        logWithFields.Err(err).Send()
                        tracker.FailedComputeOldSimilarityID()
                }</span>
                <span class="cov8" title="7">return similarityID, oldSimilarityID</span>
        } else<span class="cov3" title="2"> {
                similarityID, err := oldBuildSimilarityID(ctx, resolvedFile, queryID, searchKey, similarityIDLineInfoOld, searchValue)
                if err != nil </span><span class="cov0" title="0">{
                        logWithFields.Err(err).Send()
                        tracker.FailedComputeSimilarityID()
                }</span>
                <span class="cov3" title="2">return similarityID, oldSimilarityID</span>
        }
}

func buildSimilarityID(
        ctx *QueryContext,
        resolvedFile,
        queryID,
        searchKey,
        searchValue string) (*string, error) <span class="cov8" title="7">{
        return similarity.ComputeSimilarityID(ctx.BaseScanPaths, resolvedFile, queryID, searchKey, searchValue)
}</span>

// &lt;editor-fold desc="old similarity id"&gt;
func oldBuildSimilarityID(
        ctx *QueryContext,
        resolvedFile,
        queryID,
        searchKey,
        similarityIDLineInfo,
        searchValue string) (*string, error) <span class="cov10" title="9">{
        if checkMinified(ctx, resolvedFile) </span><span class="cov0" title="0">{
                return similarity.ComputeSimilarityID(ctx.BaseScanPaths, resolvedFile, queryID, searchKey, searchValue)
        }</span> else<span class="cov10" title="9"> {
                return similarity.ComputeSimilarityID(ctx.BaseScanPaths, resolvedFile, queryID, similarityIDLineInfo, searchValue)
        }</span>
}

func checkMinified(ctx *QueryContext, resolvedFile string) bool <span class="cov10" title="9">{
        for i := range ctx.Files </span><span class="cov10" title="9">{
                if ctx.Files[i].FilePath == resolvedFile </span><span class="cov10" title="9">{
                        return ctx.Files[i].IsMinified
                }</span>
        }
        <span class="cov0" title="0">return false</span>
}

// &lt;/editor-fold&gt;
// &lt;/editor-fold&gt;

func getCloudProvider(overrideKey string, vObj map[string]interface{}, logWithFields *zerolog.Logger) string <span class="cov10" title="9">{
        cloudProvider := ""
        if _, ok := vObj["cloudProvider"]; ok </span><span class="cov1" title="1">{
                cloudProvider = getStringFromMap("cloudProvider", "", overrideKey, vObj, logWithFields)
        }</span>
        <span class="cov10" title="9">return cloudProvider</span>
}

// calculate search Line if possible (default uses values of search key)
func calculeSearchLine(searchLineCalc *searchLineCalculator) (lineNumber int,
        similarityIDLineInfo string, linesVulne model.VulnerabilityLines) <span class="cov10" title="9">{
        searchLineCalc.calculate()
        lineNumber = searchLineCalc.lineNr
        similarityIDLineInfo = searchLineCalc.similarityIDLineInfo
        linesVulne = searchLineCalc.linesVulne

        return lineNumber, similarityIDLineInfo, linesVulne
}</span>

func getResolvedSeverity(vObj map[string]interface{}, logWithFields *zerolog.Logger,
        overrideKey string, useOldSeverities bool) model.Severity <span class="cov10" title="9">{
        var severity model.Severity = model.SeverityInfo
        s, err := mapKeyToString(vObj, "severity", false)

        if err == nil </span><span class="cov8" title="7">{
                sev := getSeverity(strings.ToUpper(*s))
                if sev == "" </span><span class="cov0" title="0">{
                        logWithFields.Warn().Str("severity", *s).Msg("Saving result. invalid severity constant value")
                }</span> else<span class="cov8" title="7"> {
                        severity = sev
                        overrideValue := tryOverride(overrideKey, "severity", vObj)
                        if overrideValue != nil </span><span class="cov3" title="2">{
                                sev = getSeverity(strings.ToUpper(*overrideValue))
                                if sev != "" </span><span class="cov3" title="2">{
                                        severity = sev
                                }</span>
                        } else<span class="cov7" title="5"> if useOldSeverities </span><span class="cov1" title="1">{
                                oldS, errOld := mapKeyToString(vObj, "oldSeverity", false)
                                if errOld == nil </span><span class="cov1" title="1">{
                                        oldSev := getSeverity(strings.ToUpper(*oldS))
                                        severity = oldSev
                                }</span>
                        }
                }
        } else<span class="cov3" title="2"> {
                logWithFields.Info().Msg("Saving result. failed to detect severity")
        }</span>

        <span class="cov10" title="9">return severity</span>
}

// sanitizeINIKey removes useless searchkey elements like "all" and "children"
func sanitizeINIKey(vulsSplit []string) (vulsRefact []string, searchKey string) <span class="cov6" title="4">{
        length := len(vulsSplit)
        vulsRefact = vulsSplit
        if length &gt;= searchKeyMinLen </span><span class="cov5" title="3">{
                vulsRefact = []string{"[" + vulsSplit[2] + "]"}

                if length &gt;= searchKeyMinLen+2 </span><span class="cov1" title="1">{
                        vulsRefact = append(vulsRefact, vulsSplit[4])

                        if length &gt;= searchKeyMinLen+4 </span><span class="cov0" title="0">{
                                vulsRefact = append(vulsRefact, vulsSplit[6])
                        }</span>
                }
        }
        <span class="cov6" title="4">return vulsRefact, strings.Join(vulsRefact, ".")</span>
}
</pre>
		
		<pre class="file" id="file51" style="display: none">package engine

import (
        "encoding/json"
        "fmt"
        "strconv"

        dec "github.com/Checkmarx/kics/v2/pkg/detector"
        "github.com/Checkmarx/kics/v2/pkg/model"
        "github.com/Checkmarx/kics/v2/pkg/utils"
        "github.com/rs/zerolog"
        "github.com/rs/zerolog/log"
)

type searchLineCalculator struct {
        lineNr               int
        vObj                 map[string]interface{}
        file                 model.FileMetadata
        detector             *dec.DetectLine
        similarityIDLineInfo string
        linesVulne           model.VulnerabilityLines
}

func (s *searchLineCalculator) calculate() <span class="cov5" title="11">{
        if searchLine, ok := s.vObj["searchLine"]; ok </span><span class="cov1" title="1">{
                line := make([]string, 0, len(searchLine.([]interface{})))
                for _, strElement := range searchLine.([]interface{}) </span><span class="cov2" title="3">{
                        line = append(line, strElement.(string))
                }</span>
                <span class="cov1" title="1">var err error
                s.lineNr, err = dec.GetLineBySearchLine(line, &amp;s.file)
                if err != nil </span><span class="cov0" title="0">{
                        log.Error().Msgf("failed to get line information from searchLine, using searchKey")
                }</span>
                <span class="cov1" title="1">if s.lineNr &gt;= 0 </span><span class="cov1" title="1">{
                        s.similarityIDLineInfo = strconv.Itoa(s.lineNr)
                        s.linesVulne = s.detector.GetAdjacent(&amp;s.file, s.lineNr)
                }</span>
        }
}
func mergeWithMetadata(base, additional map[string]interface{}) map[string]interface{} <span class="cov5" title="11">{
        for k, v := range additional </span><span class="cov7" title="44">{
                if _, ok := base[k]; ok </span><span class="cov1" title="1">{
                        continue</span>
                }
                <span class="cov7" title="43">base[k] = v</span>
        }
        <span class="cov5" title="11">return base</span>
}
func mustMapKeyToString(m map[string]interface{}, key string) *string <span class="cov8" title="73">{
        res, err := mapKeyToString(m, key, true)
        excludedFields := []string{"value", "resourceName", "resourceType", "remediation", "remediationType"}
        if err != nil &amp;&amp; !utils.Contains(key, excludedFields) </span><span class="cov5" title="14">{
                log.Warn().
                        Str("reason", err.Error()).
                        Msgf("Failed to get key %s in map", key)
        }</span>
        <span class="cov8" title="73">return res</span>
}
func mapKeyToString(m map[string]interface{}, key string, allowNil bool) (*string, error) <span class="cov10" title="187">{
        v, ok := m[key]
        if !ok </span><span class="cov9" title="144">{
                return nil, fmt.Errorf("key '%s' not found in map", key)
        }</span>
        <span class="cov7" title="43">switch vv := v.(type) </span>{
        case json.Number:<span class="cov0" title="0">
                return stringToPtrString(vv.String()), nil</span>
        case string:<span class="cov7" title="38">
                return stringToPtrString(vv), nil</span>
        case int, int32, int64:<span class="cov2" title="2">
                return stringToPtrString(fmt.Sprintf("%d", vv)), nil</span>
        case float32:<span class="cov0" title="0">
                return stringToPtrString(strconv.FormatFloat(float64(vv), 'f', -1, formatFloat64)), nil</span>
        case float64:<span class="cov1" title="1">
                return stringToPtrString(strconv.FormatFloat(vv, 'f', -1, formatFloat64)), nil</span>
        case nil:<span class="cov1" title="1">
                if allowNil </span><span class="cov0" title="0">{
                        return nil, nil
                }</span>
                <span class="cov1" title="1">return stringToPtrString("null"), nil</span>
        case bool:<span class="cov1" title="1">
                return stringToPtrString(fmt.Sprintf("%v", vv)), nil</span>
        }
        <span class="cov0" title="0">log.Debug().
                Msg("Detecting line. can't format item to string")
        if allowNil </span><span class="cov0" title="0">{
                return nil, nil
        }</span>
        <span class="cov0" title="0">return stringToPtrString(""), nil</span>
}
func stringToPtrString(v string) *string <span class="cov7" title="43">{
        return &amp;v
}</span>

// PtrStringToString - converts a pointer to string to a string
func PtrStringToString(v *string) string <span class="cov8" title="74">{
        if v == nil </span><span class="cov7" title="53">{
                return ""
        }</span>
        <span class="cov6" title="21">return *v</span>
}
func tryOverride(overrideKey, vulnParam string, vObj map[string]interface{}) *string <span class="cov5" title="11">{
        if overrideKey != "" </span><span class="cov3" title="4">{
                if override, ok := vObj["override"].(map[string]interface{}); ok </span><span class="cov3" title="4">{
                        if overrideObject, ok := override[overrideKey].(map[string]interface{}); ok </span><span class="cov3" title="4">{
                                if _, ok := overrideObject[vulnParam]; ok </span><span class="cov2" title="3">{
                                        overrideValue, err := mapKeyToString(overrideObject, vulnParam, true)
                                        if err != nil </span><span class="cov0" title="0">{
                                                return nil
                                        }</span> else<span class="cov2" title="3"> if overrideValue != nil </span><span class="cov2" title="3">{
                                                return overrideValue
                                        }</span>
                                }
                        }
                }
        }
        <span class="cov4" title="8">return nil</span>
}
func getStringFromMap(vulnParam, defaultParam, overrideKey string, vObj map[string]interface{}, logWithFields *zerolog.Logger) string <span class="cov8" title="73">{
        ts, err := mapKeyToString(vObj, vulnParam, false)
        if err != nil </span><span class="cov8" title="69">{
                logWithFields.Err(err).
                        Msgf("Saving result. failed to detect %s", vulnParam)
                return defaultParam
        }</span>
        <span class="cov3" title="4">overrideValue := tryOverride(overrideKey, vulnParam, vObj)
        if overrideValue != nil </span><span class="cov1" title="1">{
                ts = overrideValue
        }</span>
        <span class="cov3" title="4">return *ts</span>
}
func getBoolFromMap(
        vulnParam string,
        defaultParam bool,
        overrideKey string,
        vObj map[string]interface{},
        logWithFields *zerolog.Logger) bool <span class="cov4" title="9">{
        ts, err := mapKeyToString(vObj, vulnParam, false)
        if err != nil </span><span class="cov4" title="9">{
                return defaultParam
        }</span>
        <span class="cov0" title="0">overrideValue := tryOverride(overrideKey, vulnParam, vObj)
        if overrideValue != nil </span><span class="cov0" title="0">{
                ts = overrideValue
        }</span>
        <span class="cov0" title="0">res, err := strconv.ParseBool(*ts)
        if err != nil </span><span class="cov0" title="0">{
                logWithFields.Err(err).
                        Msgf("Saving result. failed to detect %s", vulnParam)
                return defaultParam
        }</span>
        <span class="cov0" title="0">return res</span>
}
func getSeverity(severity string) model.Severity <span class="cov4" title="10">{
        for _, si := range model.AllSeverities </span><span class="cov7" title="40">{
                if severity == string(si) </span><span class="cov4" title="10">{
                        return si
                }</span>
        }
        <span class="cov0" title="0">return ""</span>
}
</pre>
		
		<pre class="file" id="file52" style="display: none">package kics

import (
        "bytes"
        "context"
        "encoding/json"
        "fmt"
        "regexp"
        "sort"

        sentryReport "github.com/Checkmarx/kics/v2/internal/sentry"
        "github.com/Checkmarx/kics/v2/pkg/minified"
        "github.com/Checkmarx/kics/v2/pkg/model"
        "github.com/Checkmarx/kics/v2/pkg/utils"
        "github.com/google/uuid"
        "github.com/rs/zerolog/log"
)

func (s *Service) resolverSink(
        ctx context.Context,
        filename, scanID string,
        openAPIResolveReferences bool,
        maxResolverDepth int) ([]string, error) <span class="cov10" title="3">{
        kind := s.Resolver.GetType(filename)
        if kind == model.KindCOMMON </span><span class="cov1" title="1">{
                return []string{}, nil
        }</span>
        <span class="cov6" title="2">resFiles, err := s.Resolver.Resolve(filename, kind)
        if err != nil </span><span class="cov1" title="1">{
                log.Err(err).Msgf("failed to render file content")
                return []string{}, err
        }</span>

        <span class="cov1" title="1">for _, rfile := range resFiles.File </span><span class="cov10" title="3">{
                s.Tracker.TrackFileFound(rfile.FileName)

                isMinified := minified.IsMinified(rfile.FileName, rfile.Content)
                documents, err := s.Parser.Parse(rfile.FileName, rfile.Content, openAPIResolveReferences, isMinified, maxResolverDepth)
                if err != nil </span><span class="cov0" title="0">{
                        if documents.Kind == "break" </span><span class="cov0" title="0">{
                                return []string{}, nil
                        }</span>
                        <span class="cov0" title="0">log.Err(err).Msgf("failed to parse file content")
                        return []string{}, nil</span>
                }

                <span class="cov10" title="3">if kind == model.KindHELM </span><span class="cov10" title="3">{
                        ignoreList, errorIL := s.getOriginalIgnoreLines(
                                rfile.FileName, rfile.OriginalData,
                                openAPIResolveReferences, isMinified, maxResolverDepth)
                        if errorIL == nil </span><span class="cov6" title="2">{
                                documents.IgnoreLines = ignoreList

                                // Need to ignore #KICS_HELM_ID Line
                                documents.CountLines = bytes.Count(rfile.OriginalData, []byte{'\n'})
                        }</span>
                } else<span class="cov0" title="0"> {
                        documents.CountLines = bytes.Count(rfile.OriginalData, []byte{'\n'}) + 1
                }</span>

                <span class="cov10" title="3">fileCommands := s.Parser.CommentsCommands(rfile.FileName, rfile.OriginalData)

                for _, document := range documents.Docs </span><span class="cov10" title="3">{
                        _, err = json.Marshal(document)
                        if err != nil </span><span class="cov0" title="0">{
                                sentryReport.ReportSentry(&amp;sentryReport.Report{
                                        Message:  fmt.Sprintf("failed to marshal content in file: %s", rfile.FileName),
                                        Err:      err,
                                        Location: "func resolverSink()",
                                        FileName: rfile.FileName,
                                        Kind:     kind,
                                }, true)
                                continue</span>
                        }

                        <span class="cov10" title="3">if len(documents.IgnoreLines) &gt; 0 </span><span class="cov1" title="1">{
                                sort.Ints(documents.IgnoreLines)
                        }</span>

                        <span class="cov10" title="3">file := model.FileMetadata{
                                ID:                uuid.New().String(),
                                ScanID:            scanID,
                                Document:          PrepareScanDocument(document, kind),
                                OriginalData:      string(rfile.OriginalData),
                                LineInfoDocument:  document,
                                Kind:              kind,
                                FilePath:          rfile.FileName,
                                Content:           string(rfile.Content),
                                HelmID:            rfile.SplitID,
                                Commands:          fileCommands,
                                IDInfo:            rfile.IDInfo,
                                LinesIgnore:       documents.IgnoreLines,
                                ResolvedFiles:     documents.ResolvedFiles,
                                LinesOriginalData: utils.SplitLines(string(rfile.OriginalData)),
                                IsMinified:        documents.IsMinified,
                        }
                        s.saveToFile(ctx, &amp;file)</span>
                }
                <span class="cov10" title="3">s.Tracker.TrackFileParse(rfile.FileName)
                s.Tracker.TrackFileFoundCountLines(documents.CountLines)
                s.Tracker.TrackFileParseCountLines(documents.CountLines - len(documents.IgnoreLines))
                s.Tracker.TrackFileIgnoreCountLines(len(documents.IgnoreLines))</span>
        }
        <span class="cov1" title="1">return resFiles.Excluded, nil</span>
}

func (s *Service) getOriginalIgnoreLines(filename string,
        originalFile []uint8,
        openAPIResolveReferences, isMinified bool,
        maxResolverDepth int) (ignoreLines []int, err error) <span class="cov10" title="3">{
        refactor := regexp.MustCompile(`.*\n?.*KICS_HELM_ID.+\n`).ReplaceAll(originalFile, []uint8{})
        refactor = regexp.MustCompile(`{{-\s*(.*?)\s*}}`).ReplaceAll(refactor, []uint8{})

        documentsOriginal, err := s.Parser.Parse(filename, refactor, openAPIResolveReferences, isMinified, maxResolverDepth)
        if err == nil </span><span class="cov6" title="2">{
                ignoreLines = documentsOriginal.IgnoreLines
        }</span>
        <span class="cov10" title="3">return</span>
}
</pre>
		
		<pre class="file" id="file53" style="display: none">package kics

import (
        "bytes"
        "context"
        "encoding/json"
        "io"
        "sync"

        "github.com/Checkmarx/kics/v2/pkg/engine"
        "github.com/Checkmarx/kics/v2/pkg/engine/provider"
        "github.com/Checkmarx/kics/v2/pkg/engine/secrets"
        "github.com/Checkmarx/kics/v2/pkg/minified"
        "github.com/Checkmarx/kics/v2/pkg/model"
        "github.com/Checkmarx/kics/v2/pkg/parser"
        "github.com/Checkmarx/kics/v2/pkg/resolver"

        "github.com/Checkmarx/kics/v2/pkg/utils"
        "github.com/pkg/errors"
        "github.com/rs/zerolog/log"
)

const (
        mbConst = 1048576
)

// Storage is the interface that wraps following basic methods: SaveFile, SaveVulnerability, GetVulnerability and GetScanSummary
// SaveFile should append metadata to a file
// SaveVulnerabilities should append vulnerabilities list to current storage
// GetVulnerabilities should returns all vulnerabilities associated to a scan ID
// GetScanSummary should return a list of summaries based on their scan IDs
type Storage interface {
        SaveFile(ctx context.Context, metadata *model.FileMetadata) error
        SaveVulnerabilities(ctx context.Context, vulnerabilities []model.Vulnerability) error
        GetVulnerabilities(ctx context.Context, scanID string) ([]model.Vulnerability, error)
        GetScanSummary(ctx context.Context, scanIDs []string) ([]model.SeveritySummary, error)
}

// Tracker is the interface that wraps the basic methods: TrackFileFound and TrackFileParse
// TrackFileFound should increment the number of files to be scanned
// TrackFileParse should increment the number of files parsed successfully to be scanned
type Tracker interface {
        TrackFileFound(path string)
        TrackFileParse(path string)
        TrackFileFoundCountLines(countLines int)
        TrackFileParseCountLines(countLines int)
        TrackFileIgnoreCountLines(countLines int)
}

// Service is a struct that contains a SourceProvider to receive sources, a storage to save and retrieve scanning informations
// a parser to parse and provide files in format that KICS understand, a inspector that runs the scanning and a tracker to
// update scanning numbers
type Service struct {
        SourceProvider   provider.SourceProvider
        Storage          Storage
        Parser           *parser.Parser
        Inspector        *engine.Inspector
        SecretsInspector *secrets.Inspector
        Tracker          Tracker
        Resolver         *resolver.Resolver
        files            model.FileMetadatas
        MaxFileSize      int
}

// PrepareSources will prepare the sources to be scanned
func (s *Service) PrepareSources(ctx context.Context,
        scanID string,
        openAPIResolveReferences bool,
        maxResolverDepth int,
        wg *sync.WaitGroup, errCh chan&lt;- error) <span class="cov0" title="0">{
        defer wg.Done()
        // CxSAST query under review
        data := make([]byte, mbConst)
        if err := s.SourceProvider.GetSources(
                ctx,
                s.Parser.SupportedExtensions(),
                func(ctx context.Context, filename string, rc io.ReadCloser) error </span><span class="cov0" title="0">{
                        return s.sink(ctx, filename, scanID, rc, data, openAPIResolveReferences, maxResolverDepth)
                }</span>,
                func(ctx context.Context, filename string) ([]string, error) <span class="cov0" title="0">{ // Sink used for resolver files and templates
                        return s.resolverSink(ctx, filename, scanID, openAPIResolveReferences, maxResolverDepth)
                }</span>,
        ); err != nil <span class="cov0" title="0">{
                errCh &lt;- errors.Wrap(err, "failed to read sources")
        }</span>
}

// StartScan executes scan over the context, using the scanID as reference
func (s *Service) StartScan(
        ctx context.Context,
        scanID string,
        errCh chan&lt;- error,
        wg *sync.WaitGroup,
        currentQuery chan&lt;- int64) <span class="cov3" title="4">{
        log.Debug().Msg("service.StartScan()")
        defer wg.Done()

        secretsVulnerabilities, err := s.SecretsInspector.Inspect(
                ctx,
                s.SourceProvider.GetBasePaths(),
                s.files,
                currentQuery,
        )
        if err != nil </span><span class="cov0" title="0">{
                errCh &lt;- errors.Wrap(err, "failed to inspect secrets")
        }</span>

        <span class="cov3" title="4">vulnerabilities, err := s.Inspector.Inspect(
                ctx,
                scanID,
                s.files,
                s.SourceProvider.GetBasePaths(),
                s.Parser.Platform,
                currentQuery,
        )
        if err != nil </span><span class="cov0" title="0">{
                errCh &lt;- errors.Wrap(err, "failed to inspect files")
        }</span>
        <span class="cov3" title="4">vulnerabilities = append(vulnerabilities, secretsVulnerabilities...)

        updateMaskedSecrets(&amp;vulnerabilities, s.SecretsInspector.SecretTracker)

        err = s.Storage.SaveVulnerabilities(ctx, vulnerabilities)
        if err != nil </span><span class="cov0" title="0">{
                errCh &lt;- errors.Wrap(err, "failed to save vulnerabilities")
        }</span>
}

// Content keeps the content of the file and the number of lines
type Content struct {
        Content    *[]byte
        CountLines int
        IsMinified bool
}

/*
getContent will read the passed file 1MB at a time
to prevent resource exhaustion and return its content
*/
func getContent(rc io.Reader, data []byte, maxSizeMB int, filename string) (*Content, error) <span class="cov0" title="0">{
        var content []byte
        countLines := 0

        c := &amp;Content{
                Content:    &amp;[]byte{},
                CountLines: 0,
        }

        for </span><span class="cov0" title="0">{
                if maxSizeMB &lt; 0 </span><span class="cov0" title="0">{
                        return c, errors.New("file size limit exceeded")
                }</span>
                <span class="cov0" title="0">data = data[:cap(data)]
                n, err := rc.Read(data)
                if err != nil </span><span class="cov0" title="0">{
                        if err == io.EOF </span><span class="cov0" title="0">{
                                break</span>
                        }
                        <span class="cov0" title="0">return c, err</span>
                }
                <span class="cov0" title="0">countLines += bytes.Count(data[:n], []byte{'\n'}) + 1
                content = append(content, data[:n]...)
                maxSizeMB--</span>
        }
        <span class="cov0" title="0">c.Content = &amp;content
        c.CountLines = countLines

        c.IsMinified = minified.IsMinified(filename, content)
        return c, nil</span>
}

// GetVulnerabilities returns a list of scan detected vulnerabilities
func (s *Service) GetVulnerabilities(ctx context.Context, scanID string) ([]model.Vulnerability, error) <span class="cov3" title="4">{
        return s.Storage.GetVulnerabilities(ctx, scanID)
}</span>

// GetScanSummary returns how many vulnerabilities of each severity was found
func (s *Service) GetScanSummary(ctx context.Context, scanIDs []string) ([]model.SeveritySummary, error) <span class="cov3" title="4">{
        return s.Storage.GetScanSummary(ctx, scanIDs)
}</span>

func (s *Service) saveToFile(ctx context.Context, file *model.FileMetadata) <span class="cov3" title="3">{
        err := s.Storage.SaveFile(ctx, file)
        if err == nil </span><span class="cov3" title="3">{
                s.files = append(s.files, *file)
        }</span>
}

// PrepareScanDocument removes _kics_lines from payload and parses json filters
func PrepareScanDocument(body map[string]interface{}, kind model.FileKind) map[string]interface{} <span class="cov3" title="4">{
        var bodyMap map[string]interface{}
        j, err := json.Marshal(body)
        if err != nil </span><span class="cov0" title="0">{
                log.Error().Msgf("failed to remove kics line information")
                return body
        }</span>
        <span class="cov3" title="4">if err := json.Unmarshal(j, &amp;bodyMap); err != nil </span><span class="cov0" title="0">{
                log.Error().Msgf("failed to remove kics line information: '%s'", err)
                return body
        }</span>
        <span class="cov3" title="4">prepareScanDocumentRoot(bodyMap, kind)
        return bodyMap</span>
}

func prepareScanDocumentRoot(body interface{}, kind model.FileKind) <span class="cov8" title="37">{
        switch bodyType := body.(type) </span>{
        case map[string]interface{}:<span class="cov8" title="37">
                prepareScanDocumentValue(bodyType, kind)</span>
        case []interface{}:<span class="cov0" title="0">
                for _, indx := range bodyType </span><span class="cov0" title="0">{
                        prepareScanDocumentRoot(indx, kind)
                }</span>
        }
}

func prepareScanDocumentValue(bodyType map[string]interface{}, kind model.FileKind) <span class="cov8" title="37">{
        delete(bodyType, "_kics_lines")
        for key, v := range bodyType </span><span class="cov10" title="93">{
                switch value := v.(type) </span>{
                case map[string]interface{}:<span class="cov7" title="27">
                        prepareScanDocumentRoot(value, kind)</span>
                case []interface{}:<span class="cov4" title="6">
                        for _, indx := range value </span><span class="cov4" title="6">{
                                prepareScanDocumentRoot(indx, kind)
                        }</span>
                case string:<span class="cov8" title="56">
                        if field, ok := lines[kind]; ok &amp;&amp; utils.Contains(key, field) </span><span class="cov1" title="1">{
                                bodyType[key] = resolveJSONFilter(value)
                        }</span>
                }
        }
}

func updateMaskedSecrets(vulnerabilities *[]model.Vulnerability, maskedSecretsTracked []secrets.SecretTracker) <span class="cov3" title="4">{
        for idx := range *vulnerabilities </span><span class="cov0" title="0">{
                for _, secretT := range maskedSecretsTracked </span><span class="cov0" title="0">{
                        updateMaskedSecretLine(&amp;(*vulnerabilities)[idx], secretT)
                }</span>
        }
}

func updateMaskedSecretLine(vulnerability *model.Vulnerability, secretT secrets.SecretTracker) <span class="cov0" title="0">{
        if vulnerability.FileName == secretT.ResolvedFilePath </span><span class="cov0" title="0">{
                for vlidx := range *vulnerability.VulnLines </span><span class="cov0" title="0">{
                        if (*vulnerability.VulnLines)[vlidx].Position == secretT.Line </span><span class="cov0" title="0">{
                                (*vulnerability.VulnLines)[vlidx].Line = secretT.MaskedContent
                        }</span>
                }
        }
}
</pre>
		
		<pre class="file" id="file54" style="display: none">package kics

import (
        "context"
        "encoding/json"
        "fmt"
        "io"
        "regexp"
        "sort"

        sentryReport "github.com/Checkmarx/kics/v2/internal/sentry"
        "github.com/Checkmarx/kics/v2/pkg/model"
        "github.com/Checkmarx/kics/v2/pkg/parser/jsonfilter/parser"
        "github.com/Checkmarx/kics/v2/pkg/utils"
        "github.com/antlr4-go/antlr/v4"
        "github.com/google/uuid"
        "github.com/pkg/errors"
        "github.com/rs/zerolog/log"
)

var (
        lines = map[model.FileKind][]string{
                "TF":   {"pattern"},
                "JSON": {"FilterPattern"},
                "YAML": {"filter_pattern", "FilterPattern"},
        }
)

func (s *Service) sink(ctx context.Context, filename, scanID string,
        rc io.Reader, data []byte,
        openAPIResolveReferences bool,
        maxResolverDepth int) error <span class="cov0" title="0">{
        s.Tracker.TrackFileFound(filename)
        log.Debug().Msgf("Starting to process file %s", filename)

        c, err := getContent(rc, data, s.MaxFileSize, filename)

        *c.Content = resolveCRLFFile(*c.Content)
        content := c.Content

        s.Tracker.TrackFileFoundCountLines(c.CountLines)

        if err != nil </span><span class="cov0" title="0">{
                return errors.Wrapf(err, "failed to get file content: %s", filename)
        }</span>
        <span class="cov0" title="0">documents, err := s.Parser.Parse(filename, *content, openAPIResolveReferences, c.IsMinified, maxResolverDepth)
        if err != nil </span><span class="cov0" title="0">{
                log.Err(err).Msgf("failed to parse file content: %s", filename)
                return nil
        }</span>

        <span class="cov0" title="0">linesResolved := 0
        for _, ref := range documents.ResolvedFiles </span><span class="cov0" title="0">{
                if ref.Path != filename </span><span class="cov0" title="0">{
                        linesResolved += len(*ref.LinesContent)
                }</span>
        }
        <span class="cov0" title="0">s.Tracker.TrackFileFoundCountLines(linesResolved)

        fileCommands := s.Parser.CommentsCommands(filename, *content)

        for _, document := range documents.Docs </span><span class="cov0" title="0">{
                _, err = json.Marshal(document)
                if err != nil </span><span class="cov0" title="0">{
                        sentryReport.ReportSentry(&amp;sentryReport.Report{
                                Message:  fmt.Sprintf("failed to marshal content in file: %s", filename),
                                Err:      err,
                                Location: "func sink()",
                                FileName: filename,
                                Kind:     documents.Kind,
                        }, true)
                        continue</span>
                }

                <span class="cov0" title="0">if len(documents.IgnoreLines) &gt; 0 </span><span class="cov0" title="0">{
                        sort.Ints(documents.IgnoreLines)
                }</span>

                <span class="cov0" title="0">file := model.FileMetadata{
                        ID:                uuid.New().String(),
                        ScanID:            scanID,
                        Document:          PrepareScanDocument(document, documents.Kind),
                        LineInfoDocument:  document,
                        OriginalData:      documents.Content,
                        Kind:              documents.Kind,
                        FilePath:          filename,
                        Commands:          fileCommands,
                        LinesIgnore:       documents.IgnoreLines,
                        ResolvedFiles:     documents.ResolvedFiles,
                        LinesOriginalData: utils.SplitLines(documents.Content),
                        IsMinified:        documents.IsMinified,
                }

                s.saveToFile(ctx, &amp;file)</span>
        }
        <span class="cov0" title="0">s.Tracker.TrackFileParse(filename)
        log.Debug().Msgf("Finished to process file %s", filename)

        s.Tracker.TrackFileParseCountLines(documents.CountLines - len(documents.IgnoreLines))
        s.Tracker.TrackFileIgnoreCountLines(len(documents.IgnoreLines))

        return errors.Wrap(err, "failed to save file content")</span>
}

func resolveCRLFFile(fileContent []byte) []byte <span class="cov8" title="1">{
        regex := regexp.MustCompile(`\r\n`)
        contentSTR := regex.ReplaceAllString(string(fileContent), "\n")
        return []byte(contentSTR)
}</span>

func resolveJSONFilter(jsonFilter string) string <span class="cov8" title="1">{
        is := antlr.NewInputStream(jsonFilter)

        // lexer build
        lexer := parser.NewJSONFilterLexer(is)
        lexer.RemoveErrorListeners()
        stream := antlr.NewCommonTokenStream(lexer, antlr.TokenDefaultChannel)
        errorListener := parser.NewCustomErrorListener()
        lexer.RemoveErrorListeners()
        lexer.AddErrorListener(errorListener)

        // parser build
        p := parser.NewJSONFilterParser(stream)
        p.RemoveErrorListeners()
        p.AddErrorListener(errorListener)
        p.BuildParseTrees = true
        tree := p.Awsjsonfilter()

        // parse
        visitor := parser.NewJSONFilterPrinterVisitor()
        if errorListener.HasErrors() </span><span class="cov0" title="0">{
                return jsonFilter
        }</span>

        <span class="cov8" title="1">parsed := visitor.VisitAll(tree)

        parsedByte, err := json.Marshal(parsed)
        if err != nil </span><span class="cov0" title="0">{
                return jsonFilter
        }</span>

        <span class="cov8" title="1">return string(parsedByte)</span>
}
</pre>
		
		<pre class="file" id="file55" style="display: none">/*
Package kuberneter implements calls to the Kubernetes API in order to scan the runtime information of the resources
*/
package kuberneter

import (
        "os"

        b64 "encoding/base64"

        "github.com/pkg/errors"
        "github.com/rs/zerolog/log"
        "k8s.io/client-go/rest"
        "k8s.io/client-go/tools/clientcmd"
        "sigs.k8s.io/controller-runtime/pkg/client"
)

// K8sConfig saves the config for k8s auth
type K8sConfig struct {
        Config *rest.Config
}

func getK8sClient() (client.Client, error) <span class="cov9" title="6">{
        // authentication through k8s config file
        if os.Getenv("K8S_CONFIG_FILE") != "" </span><span class="cov4" title="2">{
                config, err := clientcmd.BuildConfigFromFlags("", os.Getenv("K8S_CONFIG_FILE"))

                if err != nil </span><span class="cov1" title="1">{
                        log.Error().Msgf("failed to get k8s client through k8s config file: %s", err)
                        return nil, err
                }</span>

                <span class="cov1" title="1">log.Info().Msg("auth to k8s API through k8s config file")

                config.QPS = 100
                config.Burst = 100

                return client.New(config, client.Options{})</span>
        }

        <span class="cov7" title="4">c := &amp;K8sConfig{
                Config: &amp;rest.Config{
                        QPS:   100,
                        Burst: 100,
                },
        }

        // authentication through k8s service account token or k8s client certificate
        if os.Getenv("K8S_HOST") != "" &amp;&amp; c.hasCertificateAuthority() </span><span class="cov4" title="2">{
                c.Config.Host = os.Getenv("K8S_HOST")

                // authentication through k8s service account token
                if c.hasServiceAccountToken() </span><span class="cov1" title="1">{
                        log.Info().Msg("auth to k8s API through k8s service account token")
                        return client.New(c.Config, client.Options{})
                }</span>

                // authentication through k8s client certificate
                <span class="cov1" title="1">if c.hasClientCertificate() </span><span class="cov1" title="1">{
                        log.Info().Msg("auth to k8s API through k8s client certificate")
                        return client.New(c.Config, client.Options{})
                }</span>
        }

        <span class="cov4" title="2">log.Error().Msg("failed to get k8s client. check the k8s cluster auth information")
        return nil, errors.New("failed to get k8s client")</span>
}

func (c *K8sConfig) hasCertificateAuthority() bool <span class="cov9" title="6">{
        if os.Getenv("K8S_CA_FILE") != "" </span><span class="cov6" title="3">{
                c.Config.TLSClientConfig.CAFile = os.Getenv("K8S_CA_FILE")
                return true
        }</span>

        <span class="cov6" title="3">if os.Getenv("K8S_CA_DATA") != "" </span><span class="cov4" title="2">{
                caDataDecoded, err := b64.StdEncoding.DecodeString(os.Getenv("K8S_CA_DATA"))
                if err != nil </span><span class="cov1" title="1">{
                        log.Error().Msgf("failed to decode K8S_CA_DATA: %s", err)
                        return false
                }</span>
                <span class="cov1" title="1">c.Config.TLSClientConfig.CAData = caDataDecoded
                return true</span>
        }

        <span class="cov1" title="1">return false</span>
}

func (c *K8sConfig) hasServiceAccountToken() bool <span class="cov8" title="5">{
        if os.Getenv("K8S_SA_TOKEN_FILE") != "" </span><span class="cov1" title="1">{
                c.Config.BearerTokenFile = os.Getenv("K8S_SA_TOKEN_FILE")
                return true
        }</span>

        <span class="cov7" title="4">if os.Getenv("K8S_SA_TOKEN_DATA") != "" </span><span class="cov4" title="2">{
                c.Config.BearerToken = os.Getenv("K8S_SA_TOKEN_DATA")
                return true
        }</span>

        <span class="cov4" title="2">return false</span>
}

func (c *K8sConfig) hasClientCertificate() bool <span class="cov10" title="7">{
        hasCert := false

        if os.Getenv("K8S_CERT_FILE") != "" </span><span class="cov7" title="4">{
                c.Config.TLSClientConfig.CertFile = os.Getenv("K8S_CERT_FILE")
                hasCert = true
        }</span>

        <span class="cov10" title="7">if os.Getenv("K8S_CERT_DATA") != "" </span><span class="cov4" title="2">{
                certDataDecoded, err := b64.StdEncoding.DecodeString(os.Getenv("K8S_CERT_DATA"))
                if err != nil </span><span class="cov1" title="1">{
                        log.Error().Msgf("failed to decode K8S_CERT_DATA: %s", err)
                        return false
                }</span>
                <span class="cov1" title="1">c.Config.TLSClientConfig.CertData = certDataDecoded
                hasCert = true</span>
        }

        <span class="cov9" title="6">if hasCert </span><span class="cov8" title="5">{
                if os.Getenv("K8S_KEY_FILE") != "" </span><span class="cov6" title="3">{
                        c.Config.TLSClientConfig.KeyFile = os.Getenv("K8S_KEY_FILE")
                        return true
                }</span>

                <span class="cov4" title="2">if os.Getenv("K8S_KEY_DATA") != "" </span><span class="cov4" title="2">{
                        keyDataDecoded, err := b64.StdEncoding.DecodeString(os.Getenv("K8S_KEY_DATA"))
                        if err != nil </span><span class="cov1" title="1">{
                                log.Error().Msgf("failed to decode K8S_KEY_DATA: %s", err)
                                return false
                        }</span>
                        <span class="cov1" title="1">c.Config.TLSClientConfig.KeyData = keyDataDecoded
                        return true</span>
                }
        }

        <span class="cov1" title="1">return false</span>
}
</pre>
		
		<pre class="file" id="file56" style="display: none">/*
Package kuberneter implements calls to the Kubernetes API in order to scan the runtime information of the resources
*/
package kuberneter

import (
        "context"
        "os"
        "path/filepath"
        "strings"
        "sync"

        "github.com/pkg/errors"
        "github.com/rs/zerolog/log"
        "k8s.io/apimachinery/pkg/api/meta"
        "sigs.k8s.io/controller-runtime/pkg/client"
)

type k8sAPICall struct {
        client          client.Client
        options         *K8sAPIOptions
        ctx             *context.Context
        destinationPath string
}

type supportedKinds map[string]map[string]interface{}

var getK8sClientFunc = getK8sClient // for testing purposes

// Import imports the k8s cluster resources into the destination using kuberneter path
func Import(ctx context.Context, kuberneterPath, destinationPath string) (string, error) <span class="cov10" title="2">{
        log.Info().Msg("importing k8s cluster resources")

        supportedKinds := buildSupportedKinds()
        defer func() </span><span class="cov10" title="2">{ supportedKinds = nil }</span>()

        // extract k8s API options
        <span class="cov10" title="2">k8sAPIOptions, err := extractK8sAPIOptions(kuberneterPath, supportedKinds)
        if err != nil </span><span class="cov1" title="1">{
                return "", err
        }</span>

        // get the k8s client
        <span class="cov1" title="1">c, err := getK8sClientFunc()
        if err != nil </span><span class="cov0" title="0">{
                return "", err
        }</span>

        // create folder to save k8s resources
        <span class="cov1" title="1">destination, err := getDestinationFolder(destinationPath)
        if err != nil </span><span class="cov0" title="0">{
                return "", err
        }</span>

        <span class="cov1" title="1">if c == nil </span><span class="cov1" title="1">{
                return destination, errors.New("failed to get client")
        }</span>

        <span class="cov0" title="0">info := &amp;k8sAPICall{
                client:          c,
                options:         k8sAPIOptions,
                ctx:             &amp;ctx,
                destinationPath: destination,
        }

        // list and save k8s resources
        for i := range k8sAPIOptions.Namespaces </span><span class="cov0" title="0">{
                info.listK8sResources(i, supportedKinds)
        }</span>

        <span class="cov0" title="0">return destination, nil</span>
}

func (info *k8sAPICall) listK8sResources(idx int, supKinds *supportedKinds) <span class="cov0" title="0">{
        var wg sync.WaitGroup
        for apiVersion := range *supKinds </span><span class="cov0" title="0">{
                kinds := (*supKinds)[apiVersion]

                if isTarget(apiVersion, info.options.APIVersions) </span><span class="cov0" title="0">{
                        wg.Add(1)
                        go info.listKinds(apiVersion, kinds, info.options.Namespaces[idx], &amp;wg)
                }</span>
        }
        <span class="cov0" title="0">wg.Wait()</span>
}

func (info *k8sAPICall) listKinds(apiVersion string, kinds map[string]interface{}, namespace string, wg *sync.WaitGroup) <span class="cov0" title="0">{
        defer wg.Done()
        sb := &amp;strings.Builder{}

        apiVersionFolder := filepath.Join(info.destinationPath, apiVersion)

        if err := os.MkdirAll(apiVersionFolder, os.ModePerm); err != nil </span><span class="cov0" title="0">{
                log.Error().Msgf("unable to create folder %s: %s", apiVersionFolder, err)
                return
        }</span>

        <span class="cov0" title="0">for kind := range kinds </span><span class="cov0" title="0">{
                kindList := kinds[kind]

                if !isTarget(kind, info.options.Kinds) </span><span class="cov0" title="0">{
                        continue</span>
                }

                <span class="cov0" title="0">if _, ok := kindList.(client.ObjectList); !ok </span><span class="cov0" title="0">{
                        continue</span>
                }

                <span class="cov0" title="0">resource := kindList.(client.ObjectList)
                err := info.client.List(*info.ctx, resource, client.InNamespace(namespace))
                if err != nil </span><span class="cov0" title="0">{
                        log.Info().Msgf("failed to list %s: %s", apiVersion, err)
                }</span>

                <span class="cov0" title="0">objList, err := meta.ExtractList(resource)
                if err != nil </span><span class="cov0" title="0">{
                        log.Info().Msgf("failed to extract list: %s", err)
                }</span>

                <span class="cov0" title="0">log.Info().Msgf("KICS found %d %s(s) in %s from %s", len(objList), kind, getNamespace(namespace), apiVersion)

                for i := range objList </span><span class="cov0" title="0">{
                        item := objList[i]
                        sb = info.getResource(item, apiVersion, kind, sb)
                }</span>

                <span class="cov0" title="0">if sb.String() != "" </span><span class="cov0" title="0">{
                        info.saveK8sResources(kind, sb.String(), apiVersionFolder)
                }</span>
                <span class="cov0" title="0">sb.Reset()</span>
        }
}
</pre>
		
		<pre class="file" id="file57" style="display: none">package kuberneter

import (
        "fmt"
        "os"
        "path/filepath"
        "strings"
        "time"

        "github.com/Checkmarx/kics/v2/pkg/utils"
        "github.com/pkg/errors"
        "github.com/rs/zerolog/log"
        appsv1 "k8s.io/api/apps/v1"
        appsv1beta1 "k8s.io/api/apps/v1beta1"
        appsv1beta2 "k8s.io/api/apps/v1beta2"
        batchv1 "k8s.io/api/batch/v1"
        batchv1beta1 "k8s.io/api/batch/v1beta1"
        corev1 "k8s.io/api/core/v1"
        networkingv1 "k8s.io/api/networking/v1"
        networkingv1beta1 "k8s.io/api/networking/v1beta1"
        policyv1 "k8s.io/api/policy/v1"
        policyv1beta1 "k8s.io/api/policy/v1beta1"
        rbacv1 "k8s.io/api/rbac/v1"
        rbacv1alpha1 "k8s.io/api/rbac/v1alpha1"
        rbacv1beta1 "k8s.io/api/rbac/v1beta1"
        "k8s.io/apimachinery/pkg/runtime"
        "k8s.io/apimachinery/pkg/runtime/serializer/json"
        "k8s.io/client-go/kubernetes/scheme"
)

// K8sAPIOptions saves all the necessary information to list the resources
type K8sAPIOptions struct {
        Namespaces  []string
        APIVersions []string
        Kinds       []string
}

const kuberneterPathLength = 3

func (info *k8sAPICall) saveK8sResources(kind, k8sResourcesContent, apiVersionFolder string) <span class="cov0" title="0">{
        file := filepath.Join(apiVersionFolder, kind+"s"+".yaml")

        f, err := os.OpenFile(filepath.Clean(file), os.O_WRONLY|os.O_CREATE|os.O_TRUNC, os.ModePerm)

        if err != nil </span><span class="cov0" title="0">{
                log.Error().Msgf("failed to open file '%s': %s", file, err)
        }</span>

        <span class="cov0" title="0">if _, err = f.WriteString(k8sResourcesContent); err != nil </span><span class="cov0" title="0">{
                log.Error().Msgf("failed to write file '%s': %s", file, err)
        }</span>

        <span class="cov0" title="0">err = f.Close()
        if err != nil </span><span class="cov0" title="0">{
                log.Err(err).Msgf("failed to close file: %s", file)
        }</span>
}

func (info *k8sAPICall) getResource(o runtime.Object, apiVersion, kind string, sb *strings.Builder) *strings.Builder <span class="cov0" title="0">{
        e := json.NewYAMLSerializer(json.DefaultMetaFactory, scheme.Scheme, scheme.Scheme)

        begin := fmt.Sprintf("\n---\napiVersion: %s\nkind: %s\n", getAPIVersion(apiVersion), kind)

        if _, err := sb.WriteString(begin); err != nil </span><span class="cov0" title="0">{
                log.Err(err).Msg("failed to write")
        }</span>

        <span class="cov0" title="0">if err := e.Encode(o, sb); err != nil </span><span class="cov0" title="0">{
                log.Err(err).Msg("failed to encode")
        }</span>

        <span class="cov0" title="0">return sb</span>
}

func extractK8sAPIOptions(path string, supportedKinds *supportedKinds) (*K8sAPIOptions, error) <span class="cov4" title="7">{
        pathInfo := strings.Split(path, ":")
        if len(pathInfo) != kuberneterPathLength </span><span class="cov2" title="2">{
                return &amp;K8sAPIOptions{}, errors.New("wrong kuberneter path syntax")
        }</span>

        <span class="cov3" title="5">k8sAPIOptions := &amp;K8sAPIOptions{
                Namespaces:  strings.Split(pathInfo[0], "+"),
                APIVersions: strings.Split(pathInfo[1], "+"),
                Kinds:       strings.Split(pathInfo[2], "+"),
        }

        supAPIVersions, supKinds := getSupportedOptions(supportedKinds)

        for i := range k8sAPIOptions.APIVersions </span><span class="cov4" title="6">{
                if !utils.Contains(k8sAPIOptions.APIVersions[i], *supAPIVersions) </span><span class="cov1" title="1">{
                        return &amp;K8sAPIOptions{}, errors.New("wrong apiVersion: " + k8sAPIOptions.APIVersions[i])
                }</span>
        }

        <span class="cov3" title="4">for i := range k8sAPIOptions.Kinds </span><span class="cov3" title="5">{
                if !utils.Contains(k8sAPIOptions.Kinds[i], *supKinds) </span><span class="cov1" title="1">{
                        return &amp;K8sAPIOptions{}, errors.New("wrong kind: " + k8sAPIOptions.Kinds[i])
                }</span>
        }

        <span class="cov2" title="3">if k8sAPIOptions.Namespaces[0] == "*" </span><span class="cov2" title="2">{
                k8sAPIOptions.Namespaces[0] = ""
        }</span>

        <span class="cov2" title="3">return k8sAPIOptions, nil</span>
}

func getNamespace(namespace string) string <span class="cov2" title="2">{
        if namespace == "" </span><span class="cov1" title="1">{
                return "all namespaces"
        }</span>

        <span class="cov1" title="1">return fmt.Sprintf("the namespace %s", namespace)</span>
}

func buildSupportedKinds() *supportedKinds <span class="cov2" title="3">{
        supportedKinds := &amp;supportedKinds{
                "apps/v1": {
                        "DaemonSet":   &amp;appsv1.DaemonSetList{},
                        "Deployment":  &amp;appsv1.DeploymentList{},
                        "ReplicaSet":  &amp;appsv1.ReplicaSetList{},
                        "StatefulSet": &amp;appsv1.StatefulSetList{},
                },
                "core/v1": {
                        "LimitRange":            &amp;corev1.LimitRangeList{},
                        "Pod":                   &amp;corev1.PodList{},
                        "PersistentVolume":      &amp;corev1.PersistentVolumeList{},
                        "PersistentVolumeClaim": &amp;corev1.PersistentVolumeClaimList{},
                        "ReplicationController": &amp;corev1.ReplicationControllerList{},
                        "ResourceQuota":         &amp;corev1.ResourceQuotaList{},
                        "Secret":                &amp;corev1.SecretList{},
                        "ServiceAccount":        &amp;corev1.ServiceAccountList{},
                        "Service":               &amp;corev1.ServiceList{},
                },
                "batch/v1": {
                        "CronJob": &amp;batchv1.CronJobList{},
                        "Job":     &amp;batchv1.JobList{},
                },
                "networking.k8s.io/v1": {
                        "IngressClass":  &amp;networkingv1.IngressClassList{},
                        "Ingress":       &amp;networkingv1.IngressList{},
                        "NetworkPolicy": &amp;networkingv1.NetworkPolicyList{},
                },
                "policy/v1": {
                        "PodDisruptionBudget": &amp;policyv1.PodDisruptionBudgetList{},
                },
                "rbac.authorization.k8s.io/v1": {
                        "ClusterRoleBinding": &amp;rbacv1.ClusterRoleBindingList{},
                        "ClusterRole":        &amp;rbacv1.ClusterRoleList{},
                        "RoleBinding":        &amp;rbacv1.RoleBindingList{},
                        "Role":               &amp;rbacv1.RoleList{},
                },
                "apps/v1beta1": {
                        "Deployment":  &amp;appsv1beta1.DeploymentList{},
                        "StatefulSet": &amp;appsv1beta1.StatefulSetList{},
                },
                "apps/v1beta2": {
                        "DaemonSet":   &amp;appsv1beta2.DaemonSetList{},
                        "Deployment":  &amp;appsv1beta2.DeploymentList{},
                        "ReplicaSet":  &amp;appsv1beta2.ReplicaSetList{},
                        "StatefulSet": &amp;appsv1beta2.StatefulSet{},
                },
                "batch/v1beta1": {
                        "CronJob": &amp;batchv1beta1.CronJobList{},
                },
                "networking.k8s.io/v1beta1": {
                        "IngressClass": &amp;networkingv1beta1.IngressClassList{},
                        "Ingress":      &amp;networkingv1beta1.IngressList{},
                },
                "policy/v1beta1": {
                        "PodDisruptionBudget": &amp;policyv1beta1.PodDisruptionBudgetList{},
                },
                "rbac.authorization.k8s.io/v1alpha1": {
                        "ClusterRoleBinding": &amp;rbacv1alpha1.ClusterRoleBindingList{},
                        "ClusterRole":        &amp;rbacv1alpha1.ClusterRoleList{},
                        "RoleBinding":        &amp;rbacv1alpha1.RoleBindingList{},
                        "Role":               &amp;rbacv1alpha1.RoleList{},
                },
                "rbac.authorization.k8s.io/v1beta1": {
                        "ClusterRoleBinding": &amp;rbacv1beta1.ClusterRoleBindingList{},
                        "ClusterRole":        &amp;rbacv1beta1.ClusterRoleList{},
                        "RoleBinding":        &amp;rbacv1beta1.RoleBindingList{},
                        "Role":               &amp;rbacv1beta1.RoleList{},
                },
        }

        return supportedKinds
}</span>

func isTarget(target string, targetOptions []string) bool <span class="cov2" title="3">{
        if targetOptions[0] == "*" || utils.Contains(target, targetOptions) </span><span class="cov2" title="2">{
                return true
        }</span>
        <span class="cov1" title="1">return false</span>
}

func getDestinationFolder(destinationPath string) (string, error) <span class="cov1" title="1">{
        var err error
        if destinationPath == "" </span><span class="cov1" title="1">{
                destinationPath, err = os.Getwd()
                if err != nil </span><span class="cov0" title="0">{
                        return "", errors.Wrap(err, "failed to get working directory")
                }</span>
        }
        <span class="cov1" title="1">destFolderName := fmt.Sprintf("kics-extract-kuberneter-%s", time.Now().Format("01-02-2006"))
        destination := filepath.Join(destinationPath, destFolderName)

        if err := os.MkdirAll(destination, os.ModePerm); err != nil </span><span class="cov0" title="0">{
                return "", err
        }</span>

        <span class="cov1" title="1">return destination, nil</span>
}

func getAPIVersion(apiVersion string) string <span class="cov2" title="2">{
        if apiVersion == "core/v1" </span><span class="cov1" title="1">{
                return "v1"
        }</span>
        <span class="cov1" title="1">return apiVersion</span>
}

func getSupportedOptions(supportedKinds *supportedKinds) (v, k *[]string) <span class="cov3" title="5">{
        supportedAPIVersions := make([]string, 0)
        supKinds := make([]string, 0)

        for apiVersion := range *supportedKinds </span><span class="cov8" title="65">{
                supportedAPIVersions = append(supportedAPIVersions, apiVersion)
                for kind := range (*supportedKinds)[apiVersion] </span><span class="cov10" title="205">{
                        supKinds = append(supKinds, kind)
                }</span>
        }

        <span class="cov3" title="5">supportedAPIVersions = append(supportedAPIVersions, "*")
        supKinds = append(supKinds, "*")

        return &amp;supportedAPIVersions, &amp;supKinds</span>
}
</pre>
		
		<pre class="file" id="file58" style="display: none">package minified

import (
        "regexp"
        "strings"
)

func IsMinified(filename string, content []byte) bool <span class="cov10" title="4">{
        if strings.HasSuffix(filename, ".json") </span><span class="cov8" title="3">{
                return isMinifiedJSON(string(content))
        }</span>
        <span class="cov1" title="1">return false</span>
}

func isMinifiedJSON(content string) bool <span class="cov8" title="3">{
        // Define a regular expression to match common minification patterns
        minifiedPattern := regexp.MustCompile(`\s+`)

        // Count the number of non-whitespace characters
        nonWhitespaceCount := len(minifiedPattern.ReplaceAllString(content, ""))

        // 80% of non-whitespace characters
        minifiedThreshold := 0.8

        return float64(nonWhitespaceCount)/float64(len(content)) &gt; minifiedThreshold
}</span>
</pre>
		
		<pre class="file" id="file59" style="display: none">package model

import (
        "reflect"
        "strings"
        "sync"

        "gopkg.in/yaml.v3"
)

// comment is a struct that holds the comment
type comment string

// Ignore is a struct that holds the lines to ignore
type Ignore struct {
        // Lines is the lines to ignore
        Lines []int
}

var (
        // NewIgnore is the ignore struct
        NewIgnore = &amp;Ignore{}
        memoryMu  sync.Mutex
)

// build builds the ignore struct
func (i *Ignore) build(lines []int) <span class="cov7" title="31">{
        defer memoryMu.Unlock()
        memoryMu.Lock()
        i.Lines = append(i.Lines, lines...)
}</span>

// GetLines returns the lines to ignore
func (i *Ignore) GetLines() []int <span class="cov4" title="8">{
        return RemoveDuplicates(i.Lines)
}</span>

// Reset resets the ignore struct
func (i *Ignore) Reset() <span class="cov4" title="8">{
        i.Lines = make([]int, 0)
}</span>

// ignoreCommentsYAML sets the lines to ignore for a yaml file
func ignoreCommentsYAML(node *yaml.Node) <span class="cov7" title="31">{
        linesIgnore := make([]int, 0)
        if node.HeadComment != "" </span><span class="cov1" title="1">{
                // Squence Node - Head Comment comes in root node
                linesIgnore = append(linesIgnore, processCommentYAML((*comment)(&amp;node.HeadComment), 0, node, node.Kind, false)...)
                NewIgnore.build(linesIgnore)
                return
        }</span>
        // check if comment is in the content
        <span class="cov7" title="30">for i, content := range node.Content </span><span class="cov10" title="113">{
                if content.FootComment != "" &amp;&amp; i+2 &lt; len(node.Content) </span><span class="cov0" title="0">{
                        linesIgnore = append(linesIgnore, processCommentYAML((*comment)(&amp;content.FootComment), i+2, node, node.Kind, true)...)
                }</span>
                <span class="cov10" title="113">if content.HeadComment == "" </span><span class="cov9" title="106">{
                        continue</span>
                }
                <span class="cov4" title="7">linesIgnore = append(linesIgnore, processCommentYAML((*comment)(&amp;content.HeadComment), i, node, node.Kind, false)...)</span>
        }

        <span class="cov7" title="30">NewIgnore.build(linesIgnore)</span>
}

// processCommentYAML returns the lines to ignore
func processCommentYAML(comment *comment, position int, content *yaml.Node, kind yaml.Kind, isFooter bool) (linesIgnore []int) <span class="cov4" title="8">{
        linesIgnore = make([]int, 0)
        switch com := (*comment).value(); com </span>{
        case IgnoreLine:<span class="cov2" title="2">
                linesIgnore = append(linesIgnore, processLine(kind, content, position)...)</span>
        case IgnoreBlock:<span class="cov3" title="4">
                linesIgnore = append(linesIgnore, processBlock(kind, content.Content, position)...)</span>
        default:<span class="cov2" title="2">
                linesIgnore = append(linesIgnore, processRegularLine(string(*comment), content, position, isFooter)...)</span>
        }

        <span class="cov4" title="8">return</span>
}

func getSeqLastLine(content *yaml.Node) int <span class="cov0" title="0">{
        if len(content.Content) == 0 </span><span class="cov0" title="0">{
                return content.Line
        }</span>

        <span class="cov0" title="0">return content.Content[len(content.Content)-1].Line</span>
}

func getFootComments(comment string, content *yaml.Node, position, commentsNumber int) (linesIgnore []int) <span class="cov0" title="0">{
        for </span><span class="cov0" title="0">{ // get the right position where the comment is a foot comment
                if content.Content[position].FootComment == comment </span><span class="cov0" title="0">{
                        break</span>
                }
                <span class="cov0" title="0">position--</span>
        }

        <span class="cov0" title="0">line := content.Content[position].Line

        if content.Content[position+1].Kind == yaml.SequenceNode </span><span class="cov0" title="0">{
                // get the last line of the sequence through the sequence after the content that has the comment as a foot comment
                // example:
                // - proto: tcp  // content.Content[position]
                //   ports:      // content.Content[position+1]
                //     - 80
                //     - 443    //  last line of the sequence
                //   # public ALB 80 + 443 must be access able from everywhere
                line = getSeqLastLine(content.Content[position+1])
        }</span>

        <span class="cov0" title="0">for i := 1; i &lt;= commentsNumber; i++ </span><span class="cov0" title="0">{
                linesIgnore = append(linesIgnore, line+i)
        }</span>

        <span class="cov0" title="0">return</span>
}

func processRegularLine(comment string, content *yaml.Node, position int, isFooter bool) (linesIgnore []int) <span class="cov2" title="2">{
        linesIgnore = make([]int, 0)

        if len(content.Content) == 0 </span><span class="cov0" title="0">{
                return linesIgnore
        }</span>

        <span class="cov2" title="2">line := content.Content[position].Line
        commentsNumber := strings.Count(comment, "\n") + 1 // number of comments (coverage of nested comments)

        if isFooter </span><span class="cov0" title="0">{ // comment is a foot comment
                return getFootComments(comment, content, position, commentsNumber)
        }</span>

        // comment is not a foot comment

        <span class="cov2" title="2">if KICSCommentRgxpYaml.MatchString(comment) </span><span class="cov0" title="0">{
                // has kics-scan ignore at the end of the comment
                linesIgnore = append(linesIgnore, line)
        }</span>

        <span class="cov2" title="2">for i := 1; i &lt;= commentsNumber; i++ </span><span class="cov3" title="4">{
                linesIgnore = append(linesIgnore, line-i)
        }</span>

        <span class="cov2" title="2">return linesIgnore</span>
}

// processLine returns the lines to ignore for a line
func processLine(kind yaml.Kind, content *yaml.Node, position int) (linesIgnore []int) <span class="cov2" title="2">{
        linesIgnore = make([]int, 0)
        var nodeToIgnore *yaml.Node
        if kind == yaml.ScalarNode </span><span class="cov0" title="0">{
                nodeToIgnore = content
        }</span> else<span class="cov2" title="2"> {
                nodeToIgnore = content.Content[position]
        }</span>

        <span class="cov2" title="2">linesIgnore = append(linesIgnore, nodeToIgnore.Line-1, nodeToIgnore.Line)
        return</span>
}

// processBlock returns the lines to ignore for a block
func processBlock(kind yaml.Kind, content []*yaml.Node, position int) (linesIgnore []int) <span class="cov3" title="4">{
        linesIgnore = make([]int, 0)
        var contentToIgnore []*yaml.Node
        if kind == yaml.SequenceNode </span><span class="cov0" title="0">{
                contentToIgnore = content[position].Content
        }</span> else<span class="cov3" title="4"> if position == 0 </span><span class="cov2" title="2">{
                contentToIgnore = content
        }</span> else<span class="cov2" title="2"> {
                contentToIgnore = content[position+1].Content
        }</span>

        <span class="cov3" title="4">linesIgnore = append(linesIgnore, content[position].Line, content[position].Line-1)
        linesIgnore = append(linesIgnore, Range(contentToIgnore[0].Line,
                getNodeLastLine(contentToIgnore[len(contentToIgnore)-1]))...)
        return</span>
}

// getNodeLastLine returns the last line of a node
func getNodeLastLine(node *yaml.Node) (lastLine int) <span class="cov7" title="34">{
        lastLine = node.Line
        if len(node.Content) &gt; 0 </span><span class="cov4" title="8">{
                for _, content := range node.Content </span><span class="cov7" title="30">{
                        if content.Line &gt; lastLine </span><span class="cov5" title="13">{
                                lastLine = content.Line
                        }</span>
                        <span class="cov7" title="30">if lineContent := getNodeLastLine(content); lineContent &gt; lastLine </span><span class="cov4" title="5">{
                                lastLine = lineContent
                        }</span>
                }
        } else<span class="cov7" title="26"> if reflect.TypeOf(node.Value).Kind() == reflect.String </span><span class="cov7" title="26">{
                lastLine += strings.Count(node.Value, "\n")
        }</span>

        <span class="cov7" title="34">return</span>
}

// value returns the value of the comment
func (c *comment) value() (value CommentCommand) <span class="cov5" title="10">{
        comment := strings.ToLower(string(*c))
        if isHelm(comment) </span><span class="cov2" title="2">{
                res := KICSGetContentCommentRgxp.FindString(comment)
                if res != "" </span><span class="cov1" title="1">{
                        comment = res
                }</span>
        }
        // check if we are working with kics command
        <span class="cov5" title="10">if KICSCommentRgxp.MatchString(comment) </span><span class="cov4" title="8">{
                comment = KICSCommentRgxp.ReplaceAllString(comment, "")
                comment = strings.Trim(comment, "\n")
                commands := strings.Split(strings.Trim(comment, "\r"), " ")
                value = ProcessCommands(commands)
                return
        }</span>
        <span class="cov2" title="2">return CommentCommand(comment)</span>
}

func isHelm(comment string) bool <span class="cov5" title="10">{
        return strings.Contains(comment, "helm")
}</span>
</pre>
		
		<pre class="file" id="file60" style="display: none">package model

// RemoveDuplicates removes duplicate lines from a slice of lines.
func RemoveDuplicates(lines []int) []int <span class="cov6" title="9">{
        seen := make(map[int]bool)
        var result []int
        for _, line := range lines </span><span class="cov10" title="47">{
                if !seen[line] </span><span class="cov9" title="44">{
                        result = append(result, line)
                        seen[line] = true
                }</span>
        }
        <span class="cov6" title="9">return result</span>
}

// ProcessCommands processes a slice of commands.
func ProcessCommands(commands []string) CommentCommand <span class="cov6" title="11">{
        for _, command := range commands </span><span class="cov6" title="12">{
                switch com := CommentCommand(command); com </span>{
                case IgnoreLine:<span class="cov3" title="3">
                        return IgnoreLine</span>
                case IgnoreBlock:<span class="cov5" title="6">
                        return IgnoreBlock</span>
                default:<span class="cov3" title="3">
                        continue</span>
                }
        }

        <span class="cov2" title="2">return CommentCommand(commands[0])</span>
}

// Range returns a slice of lines between the start and end line numbers.
func Range(start, end int) (lines []int) <span class="cov5" title="6">{
        lines = make([]int, end-start+1)
        for i := range lines </span><span class="cov9" title="31">{
                lines[i] = start + i
        }</span>
        <span class="cov5" title="6">return</span>
}
</pre>
		
		<pre class="file" id="file61" style="display: none">package model

import (
        "regexp"
        "sort"
        "strings"

        "github.com/rs/zerolog/log"
)

// Constants to describe what kind of file refers
const (
        KindTerraform FileKind = "TF"
        KindBICEP     FileKind = "BICEP"
        KindJSON      FileKind = "JSON"
        KindYAML      FileKind = "YAML"
        KindYML       FileKind = "YML"
        KindDOCKER    FileKind = "DOCKERFILE"
        KindPROTO     FileKind = "PROTO"
        KindCOMMON    FileKind = "*"
        KindHELM      FileKind = "HELM"
        KindBUILDAH   FileKind = "SH"
        KindCFG       FileKind = "CFG"
        KindINI       FileKind = "INI"
)

// Constants to describe commands given from comments
const (
        IgnoreLine    CommentCommand = "ignore-line"
        IgnoreBlock   CommentCommand = "ignore-block"
        IgnoreComment CommentCommand = "ignore-comment"
)

// Constants to describe vulnerability's severity
const (
        SeverityCritical = "CRITICAL"
        SeverityHigh     = "HIGH"
        SeverityMedium   = "MEDIUM"
        SeverityLow      = "LOW"
        SeverityInfo     = "INFO"
        SeverityTrace    = "TRACE"
)

// Constants to describe issue's type
const (
        IssueTypeMissingAttribute   IssueType = "MissingAttribute"
        IssueTypeRedundantAttribute IssueType = "RedundantAttribute"
        IssueTypeIncorrectValue     IssueType = "IncorrectValue"
)

// Arrays to group all constants of one type
var (
        AllSeverities = []Severity{
                SeverityCritical,
                SeverityHigh,
                SeverityMedium,
                SeverityLow,
                SeverityInfo,
                SeverityTrace,
        }

        AllIssueTypesAsString = []string{
                string(IssueTypeMissingAttribute),
                string(IssueTypeRedundantAttribute),
                string(IssueTypeIncorrectValue),
        }
)

var (
        // KICSCommentRgxp is the regexp to identify if a comment is a KICS comment
        KICSCommentRgxp = regexp.MustCompile(`(^|\n)((/{2})|#|;)*\s*kics-scan\s*`)
        // KICSGetContentCommentRgxp to gets the kics comment on the hel case
        KICSGetContentCommentRgxp = regexp.MustCompile(`(^|\n)((/{2})|#|;)*\s*kics-scan([^\n]*)\n`)
        // KICSCommentRgxpYaml is the regexp to identify if the comment has KICS comment at the end of the comment in YAML
        KICSCommentRgxpYaml = regexp.MustCompile(`((/{2})|#)*\s*kics-scan\s*(ignore-line|ignore-block)\s*\n*$`)
)

// Version - is the model for the version response
type Version struct {
        Latest           bool   `json:"is_latest"`
        LatestVersionTag string `json:"latest_version"`
}

// VulnerabilityLines is the representation of the found line for issue
type VulnerabilityLines struct {
        Line                  int
        VulnLines             *[]CodeLine
        LineWithVulnerability string
        ResolvedFile          string
}

// CommentCommand represents a command given from a comment
type CommentCommand string

// FileKind is the extension of a file
type FileKind string

// Severity of the vulnerability
type Severity string

// IssueType is the issue's type string representation
type IssueType string

// CodeLine is the lines containing and adjacent to the vulnerability line with their respective positions
type CodeLine struct {
        Position int
        Line     string
}

// ExtractedPathObject is the struct that contains the path location of extracted source
// and a boolean to check if it is a local source
type ExtractedPathObject struct {
        Path      string
        LocalPath bool
}

// CommentsCommands list of commands on a file that will be parsed
type CommentsCommands map[string]string

// FileMetadata is a representation of basic information and content of a file
type FileMetadata struct {
        ID                string `db:"id"`
        ScanID            string `db:"scan_id"`
        Document          Document
        LineInfoDocument  map[string]interface{}
        OriginalData      string   `db:"orig_data"`
        Kind              FileKind `db:"kind"`
        FilePath          string   `db:"file_path"`
        Content           string
        HelmID            string
        IDInfo            map[int]interface{}
        Commands          CommentsCommands
        LinesIgnore       []int
        ResolvedFiles     map[string]ResolvedFile
        LinesOriginalData *[]string
        IsMinified        bool
}

// QueryMetadata is a representation of general information about a query
type QueryMetadata struct {
        InputData string
        Query     string
        Content   string
        Metadata  map[string]interface{}
        Platform  string
        CWE       string
        // special field for generic queries
        // represents how many queries are aggregated into a single rego file
        Aggregation  int
        Experimental bool
}

// Vulnerability is a representation of a detected vulnerability in scanned files
// after running a query
type Vulnerability struct {
        ID               int         `json:"id"`
        ScanID           string      `db:"scan_id" json:"-"`
        SimilarityID     string      `db:"similarity_id" json:"similarityID"`
        OldSimilarityID  string      `db:"old_similarity_id" json:"oldSimilarityID"`
        FileID           string      `db:"file_id" json:"-"`
        FileName         string      `db:"file_name" json:"fileName"`
        QueryID          string      `db:"query_id" json:"queryID"`
        QueryName        string      `db:"query_name" json:"queryName"`
        QueryURI         string      `json:"-"`
        Category         string      `json:"category"`
        Experimental     bool        `json:"experimental"`
        Description      string      `json:"description"`
        DescriptionID    string      `json:"descriptionID"`
        Platform         string      `db:"platform" json:"platform"`
        CWE              string      `db:"cwe" json:"cwe"`
        Severity         Severity    `json:"severity"`
        Line             int         `json:"line"`
        VulnLines        *[]CodeLine `json:"vulnLines"`
        ResourceType     string      `db:"resource_type" json:"resourceType"`
        ResourceName     string      `db:"resource_name" json:"resourceName"`
        IssueType        IssueType   `db:"issue_type" json:"issueType"`
        SearchKey        string      `db:"search_key" json:"searchKey"`
        SearchLine       int         `db:"search_line" json:"searchLine"`
        SearchValue      string      `db:"search_value" json:"searchValue"`
        KeyExpectedValue string      `db:"key_expected_value" json:"expectedValue"`
        KeyActualValue   string      `db:"key_actual_value" json:"actualValue"`
        Value            *string     `db:"value" json:"value"`
        Output           string      `json:"-"`
        CloudProvider    string      `json:"cloud_provider"`
        Remediation      string      `db:"remediation" json:"remediation"`
        RemediationType  string      `db:"remediation_type" json:"remediation_type"`
}

// QueryConfig is a struct that contains the fileKind and platform of the rego query
type QueryConfig struct {
        FileKind []FileKind
        Platform string
}

// ResolvedFiles keeps the information of all file/template resolved
type ResolvedFiles struct {
        File     []ResolvedHelm
        Excluded []string
}

// ResolvedHelm keeps the information of a file/template resolved
type ResolvedHelm struct {
        FileName     string
        Content      []byte
        OriginalData []byte
        SplitID      string
        IDInfo       map[int]interface{}
}

// Extensions represents a list of supported extensions
type Extensions map[string]struct{}

// Include returns true if an extension is included in supported extensions listed
// otherwise returns false
func (e Extensions) Include(ext string) bool <span class="cov1" title="1">{
        _, b := e[ext]

        return b
}</span>

// LineObject is the struct that will hold line information for each key
type LineObject struct {
        Line int                      `json:"_kics_line"`
        Arr  []map[string]*LineObject `json:"_kics_arr,omitempty"`
}

// MatchedFilesRegex returns the regex rule to identify if an extension is supported or not
func (e Extensions) MatchedFilesRegex() string <span class="cov10" title="4">{
        if len(e) == 0 </span><span class="cov5" title="2">{
                return "NO_MATCHED_FILES"
        }</span>

        <span class="cov5" title="2">var parts []string
        for ext := range e </span><span class="cov8" title="3">{
                parts = append(parts, "\\"+ext)
        }</span>

        <span class="cov5" title="2">sort.Strings(parts)

        return "(.*)(" + strings.Join(parts, "|") + ")$"</span>
}

// FileMetadatas is a slice of FileMetadata
type FileMetadatas []FileMetadata

// ToMap creates a map of FileMetadatas, which the key is the FileMedata ID and the value is the FileMetadata
func (m FileMetadatas) ToMap() map[string]FileMetadata <span class="cov1" title="1">{
        c := make(map[string]FileMetadata, len(m))
        for i := 0; i &lt; len(m); i++ </span><span class="cov1" title="1">{
                c[m[i].ID] = m[i]
        }</span>
        <span class="cov1" title="1">return c</span>
}

// Documents
type Documents struct {
        Documents []Document `json:"document"`
}

// Document
type Document map[string]interface{}

// Combine merge documents from FileMetadatas using the ID as reference for Document ID and FileName as reference for file
func (m FileMetadatas) Combine(lineInfo bool) Documents <span class="cov8" title="3">{
        documents := Documents{Documents: make([]Document, 0, len(m))}
        for i := 0; i &lt; len(m); i++ </span><span class="cov8" title="3">{
                _, ignore := m[i].Commands["ignore"]
                if len(m[i].Document) == 0 </span><span class="cov1" title="1">{
                        continue</span>
                }
                <span class="cov5" title="2">if ignore </span><span class="cov1" title="1">{
                        log.Debug().Msgf("Ignoring file %s", m[i].FilePath)
                        continue</span>
                }
                <span class="cov1" title="1">if lineInfo </span><span class="cov0" title="0">{
                        m[i].LineInfoDocument["id"] = m[i].ID
                        m[i].LineInfoDocument["file"] = m[i].FilePath
                        documents.Documents = append(documents.Documents, m[i].LineInfoDocument)
                }</span> else<span class="cov1" title="1"> {
                        m[i].Document["id"] = m[i].ID
                        m[i].Document["file"] = m[i].FilePath
                        documents.Documents = append(documents.Documents, m[i].Document)
                }</span>
        }
        <span class="cov8" title="3">return documents</span>
}

// AnalyzedPaths is a slice of types and excluded files obtained from the Analyzer
type AnalyzedPaths struct {
        Types       []string
        Exc         []string
        ExpectedLOC int
}

// ResolvedFileSplit is a struct that contains the information of a resolved file, the path and the lines of the file
type ResolvedFileSplit struct {
        Path  string
        Lines []string
}

// ResolvedFile is a struct that contains the information of a resolved file, the path and the content in bytes of the file
type ResolvedFile struct {
        Path         string
        Content      []byte
        LinesContent *[]string
}
</pre>
		
		<pre class="file" id="file62" style="display: none">package model

import (
        json "encoding/json"
        "errors"
        "path/filepath"
        "strconv"

        "github.com/Checkmarx/kics/v2/pkg/utils"
        "github.com/rs/zerolog/log"
        "gopkg.in/yaml.v3"
)

// UnmarshalYAML is a custom yaml parser that places line information in the payload
func (m *Document) UnmarshalYAML(value *yaml.Node) error <span class="cov3" title="3">{
        dpc := unmarshal(value)
        if mapDcp, ok := dpc.(map[string]interface{}); ok </span><span class="cov3" title="3">{
                // set line information for root level objects
                mapDcp["_kics_lines"] = getLines(value, 0)

                // place the payload in the Document struct
                tmp, _ := json.Marshal(mapDcp)
                _ = json.Unmarshal(tmp, m)
                return nil
        }</span>
        <span class="cov0" title="0">return errors.New("failed to parse yaml content")</span>
}

// GetIgnoreLines get the lines to ignore in the KICS results
// lines ignore can have the lines from the resolved files
// since inspector secrets only looks to original data, the lines ignore should be replaced in yaml cases
func GetIgnoreLines(file *FileMetadata) []int <span class="cov1" title="1">{
        ignoreLines := file.LinesIgnore

        if utils.Contains(filepath.Ext(file.FilePath), []string{".yml", ".yaml"}) </span><span class="cov1" title="1">{
                NewIgnore.Reset()
                var node yaml.Node

                if err := yaml.Unmarshal([]byte(file.OriginalData), &amp;node); err != nil </span><span class="cov0" title="0">{
                        log.Info().Msgf("failed to unmarshal file: %s", err)
                        return ignoreLines
                }</span>

                <span class="cov1" title="1">if node.Kind == 1 &amp;&amp; len(node.Content) == 1 </span><span class="cov1" title="1">{
                        _ = unmarshal(node.Content[0])
                        ignoreLines = NewIgnore.GetLines()
                }</span>
        }

        <span class="cov1" title="1">return ignoreLines</span>
}

/*
        YAML Node TYPES

        SequenceNode -&gt; array
        ScalarNode -&gt; generic (except for arrays, objects and maps)
        MappingNode -&gt; map

*/
// unmarshal is the function that will parse the yaml elements and call the functions needed
// to place their line information in the payload
func unmarshal(val *yaml.Node) interface{} <span class="cov8" title="24">{
        tmp := make(map[string]interface{})
        ignoreCommentsYAML(val)

        // if Yaml Node is an Array than we are working with ansible
        // which need to be placed inside "playbooks"
        if val.Kind == yaml.SequenceNode </span><span class="cov2" title="2">{
                contentArray := make([]interface{}, 0)
                for _, contentEntry := range val.Content </span><span class="cov3" title="3">{
                        contentArray = append(contentArray, unmarshal(contentEntry))
                }</span>
                <span class="cov2" title="2">tmp["playbooks"] = contentArray</span>
        } else<span class="cov8" title="22"> if val.Kind == yaml.ScalarNode </span><span class="cov4" title="4">{
                // resolve Scalar Node
                return scalarNodeResolver(val)
        }</span> else<span class="cov7" title="18"> {
                // iterate two by two, since first iteration is the key and the second is the value
                for i := 0; i &lt; len(val.Content); i += 2 </span><span class="cov10" title="44">{
                        if val.Content[i].Kind == yaml.ScalarNode </span><span class="cov10" title="44">{
                                switch val.Content[i+1].Kind </span>{
                                case yaml.ScalarNode:<span class="cov9" title="32">
                                        tmp[val.Content[i].Value] = scalarNodeResolver(val.Content[i+1])</span>
                                // in case value iteration is a map
                                case yaml.MappingNode:<span class="cov5" title="8">
                                        // unmarshall map value and get its line information
                                        tt := unmarshal(val.Content[i+1]).(map[string]interface{})
                                        tt["_kics_lines"] = getLines(val.Content[i+1], val.Content[i].Line)
                                        tmp[val.Content[i].Value] = tt</span>
                                // in case value iteration is an array
                                case yaml.SequenceNode:<span class="cov4" title="4">
                                        contentArray := make([]interface{}, 0)
                                        // unmarshall each iteration of the array
                                        for _, contentEntry := range val.Content[i+1].Content </span><span class="cov6" title="9">{
                                                contentArray = append(contentArray, unmarshal(contentEntry))
                                        }</span>
                                        <span class="cov4" title="4">tmp[val.Content[i].Value] = contentArray</span>
                                case yaml.AliasNode:<span class="cov0" title="0">
                                        if tt, ok := unmarshal(val.Content[i+1].Alias).(map[string]interface{}); ok </span><span class="cov0" title="0">{
                                                tt["_kics_lines"] = getLines(val.Content[i+1], val.Content[i].Line)
                                                utils.MergeMaps(tmp, tt)
                                        }</span>
                                        <span class="cov0" title="0">if v, ok := unmarshal(val.Content[i+1].Alias).(string); ok </span><span class="cov0" title="0">{
                                                tmp[val.Content[i].Value] = v
                                        }</span>
                                }
                        }
                }
        }
        <span class="cov8" title="20">return tmp</span>
}

// getLines creates the map containing the line information for the yaml Node
// def is the line to be used as "_kics__default"
func getLines(val *yaml.Node, def int) map[string]*LineObject <span class="cov7" title="18">{
        lineMap := make(map[string]*LineObject)

        // line information map
        lineMap["_kics__default"] = &amp;LineObject{
                Line: def,
                Arr:  []map[string]*LineObject{},
        }

        // if yaml Node is an Array use func getSeqLines
        if val.Kind == yaml.SequenceNode </span><span class="cov1" title="1">{
                return getSeqLines(val, def)
        }</span>

        // iterate two by two, since first iteration is the key and the second is the value
        <span class="cov7" title="17">for i := 0; i &lt; len(val.Content); i += 2 </span><span class="cov9" title="32">{
                lineArr := make([]map[string]*LineObject, 0)
                // in case the value iteration is an array call getLines for each iteration of the array
                if val.Content[i+1].Kind == yaml.SequenceNode </span><span class="cov2" title="2">{
                        for _, contentEntry := range val.Content[i+1].Content </span><span class="cov4" title="5">{
                                defaultLine := val.Content[i].Line
                                if contentEntry.Kind == yaml.ScalarNode </span><span class="cov3" title="3">{
                                        defaultLine = contentEntry.Line
                                }</span> else<span class="cov2" title="2"> if contentEntry.Kind == yaml.MappingNode &amp;&amp; len(contentEntry.Content) &gt; 0 </span><span class="cov2" title="2">{
                                        defaultLine = contentEntry.Content[0].Line
                                }</span>
                                <span class="cov4" title="5">lineArr = append(lineArr, getLines(contentEntry, defaultLine))</span>
                        }
                }

                // line information map of each key of the yaml Node
                <span class="cov9" title="32">lineMap["_kics_"+val.Content[i].Value] = &amp;LineObject{
                        Line: val.Content[i].Line,
                        Arr:  lineArr,
                }</span>
        }

        <span class="cov7" title="17">return lineMap</span>
}

// getSeqLines iterates through the elements of an Array
// creating a map with each iteration lines information
func getSeqLines(val *yaml.Node, def int) map[string]*LineObject <span class="cov1" title="1">{
        lineMap := make(map[string]*LineObject)
        lineArr := make([]map[string]*LineObject, 0)

        // get line information slice of every element in the array
        for _, cont := range val.Content </span><span class="cov2" title="2">{
                lineArr = append(lineArr, getLines(cont, cont.Line))
        }</span>

        // create line information of array with its line and elements line information
        <span class="cov1" title="1">lineMap["_kics__default"] = &amp;LineObject{
                Line: def,
                Arr:  lineArr,
        }
        return lineMap</span>
}

// scalarNodeResolver transforms a ScalarNode value in its correct type
func scalarNodeResolver(val *yaml.Node) interface{} <span class="cov9" title="36">{
        var transformed interface{} = val.Value
        switch val.Tag </span>{
        case "!!bool":<span class="cov1" title="1">
                transformed = transformBoolScalarNode(val.Value)</span>
        case "!!int":<span class="cov1" title="1">
                v, err := strconv.Atoi(val.Value)
                if err != nil </span><span class="cov0" title="0">{
                        log.Error().Msgf("failed to convert integer in yaml parser")
                        return val.Value
                }</span>
                <span class="cov1" title="1">transformed = v</span>
        case "!!null":<span class="cov1" title="1">
                transformed = nil</span>
        }

        <span class="cov9" title="36">return transformed</span>
}

// transformBoolScalarNode transforms a string value to its boolean representation
func transformBoolScalarNode(value string) bool <span class="cov1" title="1">{
        switch value </span>{
        case "true", "True":<span class="cov0" title="0">
                return true</span>
        default:<span class="cov1" title="1">
                return false</span>
        }
}
</pre>
		
		<pre class="file" id="file63" style="display: none">package model

import (
        "os"
        "path/filepath"
        "regexp"
        "sort"
        "strings"
        "time"

        "github.com/rs/zerolog/log"
)

// SeveritySummary contains scans' result numbers, how many vulnerabilities of each severity was detected
type SeveritySummary struct {
        ScanID            string           `json:"scan_id"`
        SeverityCounters  map[Severity]int `json:"severity_counters"`
        TotalCounter      int              `json:"total_counter"`
        TotalBOMResources int              `json:"total_bom_resources"`
}

// VulnerableFile contains information of a vulnerable file and where the vulnerability was found
type VulnerableFile struct {
        FileName         string      `json:"file_name"`
        SimilarityID     string      `json:"similarity_id"`
        OldSimilarityID  string      `json:"old_similarity_id,omitempty"`
        Line             int         `json:"line"`
        VulnLines        *[]CodeLine `json:"-"`
        ResourceType     string      `json:"resource_type,omitempty"`
        ResourceName     string      `json:"resource_name,omitempty"`
        IssueType        IssueType   `json:"issue_type"`
        SearchKey        string      `json:"search_key"`
        SearchLine       int         `json:"search_line"`
        SearchValue      string      `json:"search_value"`
        KeyExpectedValue string      `json:"expected_value"`
        KeyActualValue   string      `json:"actual_value"`
        Value            *string     `json:"value,omitempty"`
        Remediation      string      `json:"remediation,omitempty"`
        RemediationType  string      `json:"remediation_type,omitempty"`
}

// QueryResult contains a query that tested positive ID, name, severity and a list of files that tested vulnerable
type QueryResult struct {
        QueryName                   string           `json:"query_name"`
        QueryID                     string           `json:"query_id"`
        QueryURI                    string           `json:"query_url"`
        Severity                    Severity         `json:"severity"`
        Platform                    string           `json:"platform"`
        CWE                         string           `json:"cwe,omitempty"`
        CloudProvider               string           `json:"cloud_provider,omitempty"`
        Category                    string           `json:"category"`
        Experimental                bool             `json:"experimental"`
        Description                 string           `json:"description"`
        DescriptionID               string           `json:"description_id"`
        CISDescriptionIDFormatted   string           `json:"cis_description_id,omitempty"`
        CISDescriptionTitle         string           `json:"cis_description_title,omitempty"`
        CISDescriptionTextFormatted string           `json:"cis_description_text,omitempty"`
        CISDescriptionID            string           `json:"cis_description_id_raw,omitempty"`
        CISDescriptionText          string           `json:"cis_description_text_raw,omitempty"`
        CISRationaleText            string           `json:"cis_description_rationale,omitempty"`
        CISBenchmarkName            string           `json:"cis_benchmark_name,omitempty"`
        CISBenchmarkVersion         string           `json:"cis_benchmark_version,omitempty"`
        Files                       []VulnerableFile `json:"files"`
}

// QueryResultSlice is a slice of QueryResult
type QueryResultSlice []QueryResult

// Counters hold information about how many files were scanned, parsed, failed to be scaned, the total of queries
// and how many queries failed to execute
type Counters struct {
        ScannedFiles           int `json:"files_scanned"`
        ScannedFilesLines      int `json:"lines_scanned"`
        ParsedFiles            int `json:"files_parsed"`
        ParsedFilesLines       int `json:"lines_parsed"`
        IgnoredFilesLines      int `json:"lines_ignored"`
        FailedToScanFiles      int `json:"files_failed_to_scan"`
        TotalQueries           int `json:"queries_total"`
        FailedToExecuteQueries int `json:"queries_failed_to_execute"`
        FailedSimilarityID     int `json:"queries_failed_to_compute_similarity_id"`
}

// Times represents an object that contains the start and end time of the scan
type Times struct {
        Start time.Time `json:"start"`
        End   time.Time `json:"end"`
}

// VersionResponse - is the model for the version response
type VersionResponse struct {
        Latest           bool   `json:"is_latest"`
        LatestVersionTag string `json:"latest_version"`
}

// Summary is a report of a single scan
type Summary struct {
        Version       string  `json:"kics_version,omitempty"`
        LatestVersion Version `json:"-"`
        Counters
        SeveritySummary
        Times
        ScannedPaths []string          `json:"paths"`
        Queries      QueryResultSlice  `json:"queries"`
        Bom          QueryResultSlice  `json:"bill_of_materials,omitempty"`
        FilePaths    map[string]string `json:"-"`
}

// PathParameters - structure wraps the required fields for temporary path translation
type PathParameters struct {
        ScannedPaths      []string
        PathExtractionMap map[string]ExtractedPathObject
}

var (
        queryRegex   = regexp.MustCompile(`\?([\w-]+(=[\w-]*)?(&amp;[\w-]+(=[\w-]*)?)*)?`)
        urlAuthRegex = regexp.MustCompile(`((ssh|https?)://)(\S+(:\S*)?@).*`)
)

const authGroupPosition = 3

func getRelativePath(basePath, filePath string) string <span class="cov7" title="4">{
        var returnPath string
        relativePath, err := filepath.Rel(basePath, filePath)
        if err != nil </span><span class="cov5" title="3">{
                returnPath = filePath
        }</span> else<span class="cov1" title="1"> {
                returnPath = relativePath
        }</span>
        <span class="cov7" title="4">return returnPath</span>
}

func replaceIfTemporaryPath(filePath string, pathExtractionMap map[string]ExtractedPathObject) string <span class="cov7" title="4">{
        prettyPath := filePath
        for key, val := range pathExtractionMap </span><span class="cov5" title="3">{
                if strings.Contains(filePath, key) </span><span class="cov4" title="2">{
                        splittedPath := strings.Split(filePath, key)
                        if !val.LocalPath </span><span class="cov4" title="2">{
                                // remove authentication information from the URL
                                sanitizedURL := removeURLCredentials(val.Path)
                                // remove query parameters '?key=value&amp;key2=value'
                                return filepath.FromSlash(queryRegex.ReplaceAllString(sanitizedURL, "") + splittedPath[1])
                        }</span>
                        <span class="cov0" title="0">prettyPath = filepath.FromSlash(filepath.Base(val.Path) + splittedPath[1])</span>
                } else<span class="cov1" title="1"> {
                        prettyPath = filePath
                }</span>
        }
        <span class="cov4" title="2">return prettyPath</span>
}

func removeAllURLCredentials(pathExtractionMap map[string]ExtractedPathObject) []string <span class="cov7" title="4">{
        sanitizedScannedPaths := make([]string, 0)
        for _, val := range pathExtractionMap </span><span class="cov5" title="3">{
                if !val.LocalPath </span><span class="cov4" title="2">{
                        sanitizedURL := removeURLCredentials(val.Path)
                        sanitizedScannedPaths = append(sanitizedScannedPaths, sanitizedURL)
                }</span> else<span class="cov1" title="1"> {
                        sanitizedScannedPaths = append(sanitizedScannedPaths, val.Path)
                }</span>
        }
        <span class="cov7" title="4">return sanitizedScannedPaths</span>
}

func removeURLCredentials(url string) string <span class="cov10" title="8">{
        authGroup := ""
        groups := urlAuthRegex.FindStringSubmatch(url)
        // credentials are present in the URL
        if len(groups) &gt; authGroupPosition </span><span class="cov7" title="5">{
                authGroup = groups[authGroupPosition]
        }</span>
        <span class="cov10" title="8">return strings.Replace(url, authGroup, "", 1)</span>
}

func resolvePath(filePath string, pathExtractionMap map[string]ExtractedPathObject) string <span class="cov7" title="4">{
        var returnPath string
        returnPath = replaceIfTemporaryPath(filepath.FromSlash(filePath), pathExtractionMap)
        pwd, err := os.Getwd()
        if err != nil </span><span class="cov0" title="0">{
                log.Error().Msgf("Unable to get current working dir %s", err)
                return returnPath
        }</span>
        <span class="cov7" title="4">returnPath = getRelativePath(pwd, returnPath)
        return returnPath</span>
}

// CreateSummary creates a report for a single scan, based on its scanID
func CreateSummary(counters Counters, vulnerabilities []Vulnerability,
        scanID string, pathExtractionMap map[string]ExtractedPathObject, version Version) Summary <span class="cov4" title="2">{
        log.Debug().Msg("model.CreateSummary()")
        q := make(map[string]QueryResult, len(vulnerabilities))
        severitySummary := SeveritySummary{
                ScanID: scanID,
        }
        filePaths := make(map[string]string)

        for i := range vulnerabilities </span><span class="cov1" title="1">{
                item := vulnerabilities[i]
                if _, ok := q[item.QueryID]; !ok </span><span class="cov1" title="1">{
                        q[item.QueryID] = QueryResult{
                                QueryName:     item.QueryName,
                                QueryID:       item.QueryID,
                                Severity:      item.Severity,
                                QueryURI:      item.QueryURI,
                                Platform:      item.Platform,
                                CWE:           item.CWE,
                                Experimental:  item.Experimental,
                                CloudProvider: strings.ToUpper(item.CloudProvider),
                                Category:      item.Category,
                                Description:   item.Description,
                                DescriptionID: item.DescriptionID,
                        }
                }</span>

                <span class="cov1" title="1">resolvedPath := resolvePath(item.FileName, pathExtractionMap)

                qItem := q[item.QueryID]
                qItem.Files = append(qItem.Files, VulnerableFile{
                        FileName:         resolvedPath,
                        SimilarityID:     item.SimilarityID,
                        OldSimilarityID:  item.OldSimilarityID,
                        Line:             item.Line,
                        VulnLines:        item.VulnLines,
                        ResourceType:     item.ResourceType,
                        ResourceName:     item.ResourceName,
                        IssueType:        item.IssueType,
                        SearchKey:        item.SearchKey,
                        SearchValue:      item.SearchValue,
                        SearchLine:       item.SearchLine,
                        KeyExpectedValue: item.KeyExpectedValue,
                        KeyActualValue:   item.KeyActualValue,
                        Value:            item.Value,
                        Remediation:      item.Remediation,
                        RemediationType:  item.RemediationType,
                })

                filePaths[resolvedPath] = item.FileName

                q[item.QueryID] = qItem</span>
        }

        <span class="cov4" title="2">queries := make([]QueryResult, 0, len(q))
        sevs := map[Severity]int{SeverityTrace: 0, SeverityInfo: 0, SeverityLow: 0, SeverityMedium: 0, SeverityHigh: 0, SeverityCritical: 0}
        for idx := range q </span><span class="cov1" title="1">{
                sevs[q[idx].Severity] += len(q[idx].Files)

                if q[idx].Severity == SeverityTrace </span><span class="cov0" title="0">{
                        continue</span>
                }
                <span class="cov1" title="1">queries = append(queries, q[idx])

                severitySummary.TotalCounter += len(q[idx].Files)</span>
        }

        <span class="cov4" title="2">severityOrder := map[Severity]int{
                SeverityTrace:    5,
                SeverityInfo:     4,
                SeverityLow:      3,
                SeverityMedium:   2,
                SeverityHigh:     1,
                SeverityCritical: 0,
        }
        sort.Slice(queries, func(i, j int) bool </span><span class="cov0" title="0">{
                if severityOrder[queries[i].Severity] == severityOrder[queries[j].Severity] </span><span class="cov0" title="0">{
                        return queries[i].QueryName &lt; queries[j].QueryName
                }</span>
                <span class="cov0" title="0">return severityOrder[queries[i].Severity] &lt; severityOrder[queries[j].Severity]</span>
        })

        <span class="cov4" title="2">materials := make([]QueryResult, 0, len(q))
        for idx := range q </span><span class="cov1" title="1">{
                if q[idx].Severity == SeverityTrace </span><span class="cov0" title="0">{
                        materials = append(materials, q[idx])
                        severitySummary.TotalBOMResources += len(q[idx].Files)
                }</span>
        }

        <span class="cov4" title="2">severitySummary.SeverityCounters = sevs

        return Summary{
                Bom:             materials,
                Counters:        counters,
                Queries:         queries,
                SeveritySummary: severitySummary,
                ScannedPaths:    removeAllURLCredentials(pathExtractionMap),
                LatestVersion:   version,
                FilePaths:       filePaths,
        }</span>
}
</pre>
		
		<pre class="file" id="file64" style="display: none">package comments

import (
        "regexp"
        "strings"

        "github.com/Checkmarx/kics/v2/pkg/model"
)

func getKicsIgnore(comment string) string <span class="cov8" title="8">{
        commentLower := model.KICSCommentRgxp.ReplaceAllString(strings.ToLower(comment), "")
        commentLower = strings.Trim(commentLower, "\r")
        commentLower = strings.Trim(commentLower, "\n")
        return commentLower
}</span>

func getIgnoreLinesFromBlock(lines []string, ignoreBlockLine int) int <span class="cov7" title="7">{
        i := ignoreBlockLine + 1

        if i &gt;= len(lines) </span><span class="cov1" title="1">{
                return ignoreBlockLine
        }</span>

        // Check if the next line is a group: [group_name]
        <span class="cov7" title="6">if match, _ := regexp.MatchString(`^\s*\[`, lines[i]); !match </span><span class="cov3" title="2">{
                return ignoreBlockLine
        }</span>

        // Now needs to find the end of the block (next group or end of file)
        <span class="cov5" title="4">i += 1
        nextGroup := regexp.MustCompile(`^\s*\[`)

        for ; i &lt; len(lines); i++ </span><span class="cov7" title="6">{
                if nextGroup.MatchString(lines[i]) </span><span class="cov3" title="2">{
                        return i - 1
                }</span>
        }
        <span class="cov3" title="2">return i - 1</span>
}

func GetIgnoreLines(lines []string) []int <span class="cov7" title="6">{
        ignoreLines := make([]int, 0)
        comment := regexp.MustCompile(`^[#;]`)

        for i, line := range lines </span><span class="cov10" title="13">{
                if model.KICSCommentRgxp.MatchString(line) </span><span class="cov7" title="6">{
                        kicsIgnore := getKicsIgnore(line)

                        switch model.CommentCommand(kicsIgnore) </span>{
                        case model.IgnoreLine:<span class="cov3" title="2">
                                if i+1 &lt; len(lines) </span><span class="cov1" title="1">{
                                        ignoreLines = append(ignoreLines, i, i+1)
                                }</span> else<span class="cov1" title="1"> {
                                        ignoreLines = append(ignoreLines, i)
                                }</span>
                        case model.IgnoreBlock:<span class="cov5" title="4">
                                until := getIgnoreLinesFromBlock(lines, i)
                                if until &gt; i </span><span class="cov3" title="2">{
                                        ignoreLines = append(ignoreLines, model.Range(i, until)...)
                                }</span> else<span class="cov3" title="2"> {
                                        ignoreLines = append(ignoreLines, i)
                                }</span>
                        }
                } else<span class="cov7" title="7"> if comment.MatchString(line) </span><span class="cov0" title="0">{
                        ignoreLines = append(ignoreLines, i+1)
                }</span>
        }
        <span class="cov7" title="6">return ignoreLines</span>
}
</pre>
		
		<pre class="file" id="file65" style="display: none">package ansibleconfig

import (
        "strconv"
        "strings"

        "github.com/Checkmarx/kics/v2/pkg/model"
        "github.com/Checkmarx/kics/v2/pkg/parser/ansible/ini/comments"
        "github.com/bigkevmcd/go-configparser"
)

// Parser defines a parser type
type Parser struct {
}

func (p *Parser) Resolve(fileContent []byte, _ string, _ bool, _ int) ([]byte, error) <span class="cov0" title="0">{
        return fileContent, nil
}</span>

// Parse parses .cfg/.conf file and returns it as a Document
func (p *Parser) Parse(filePath string, fileContent []byte) ([]model.Document, []int, error) <span class="cov1" title="1">{
        model.NewIgnore.Reset()

        reader := strings.NewReader(string(fileContent))
        configparser.Delimiters("=")
        inline := configparser.InlineCommentPrefixes([]string{";"})

        config, err := configparser.ParseReaderWithOptions(reader, inline)
        if err != nil </span><span class="cov0" title="0">{
                return nil, nil, err
        }</span>

        <span class="cov1" title="1">doc := make(map[string]interface{})
        doc["groups"] = refactorConfig(config)

        ignoreLines := comments.GetIgnoreLines(strings.Split(string(fileContent), "\n"))

        return []model.Document{doc}, ignoreLines, nil</span>
}

// refactorConfig removes all extra information and tries to convert
func refactorConfig(config *configparser.ConfigParser) (doc *model.Document) <span class="cov1" title="1">{
        doc = emptyDocument()
        for _, section := range config.Sections() </span><span class="cov4" title="3">{
                dict, err := config.Items(section)
                if err != nil </span><span class="cov0" title="0">{
                        continue</span>
                }
                <span class="cov4" title="3">dictRefact := make(map[string]interface{})
                for key, value := range dict </span><span class="cov10" title="14">{
                        if boolValue, err := strconv.ParseBool(value); err == nil </span><span class="cov1" title="1">{
                                dictRefact[key] = boolValue
                        }</span> else<span class="cov9" title="13"> if floatValue, err := strconv.ParseFloat(value, 64); err == nil </span><span class="cov3" title="2">{
                                dictRefact[key] = floatValue
                        }</span> else<span class="cov9" title="11"> if strings.Contains(value, ",") </span><span class="cov0" title="0">{
                                elements := strings.Split(value, ",")

                                for i := 0; i &lt; len(elements); i++ </span><span class="cov0" title="0">{
                                        elements[i] = strings.TrimSpace(elements[i])
                                }</span>

                                <span class="cov0" title="0">dictRefact[key] = elements</span>
                        } else<span class="cov9" title="11"> if value == "[]" </span><span class="cov1" title="1">{
                                dictRefact[key] = []string{}
                        }</span> else<span class="cov8" title="10"> {
                                dictRefact[key] = value
                        }</span>
                }
                <span class="cov4" title="3">(*doc)[section] = dictRefact</span>
        }

        <span class="cov1" title="1">return doc</span>
}

// SupportedExtensions returns extensions supported by this parser, which are only ini extension
func (p *Parser) SupportedExtensions() []string <span class="cov1" title="1">{
        return []string{".cfg", ".conf"}
}</span>

// SupportedTypes returns types supported by this parser, which is ansible
func (p *Parser) SupportedTypes() map[string]bool <span class="cov1" title="1">{
        return map[string]bool{
                "ansible": true,
        }
}</span>

// GetKind returns CFG constant kind
func (p *Parser) GetKind() model.FileKind <span class="cov1" title="1">{
        return model.KindCFG
}</span>

// GetCommentToken return the comment token of CFG/CONF - #
func (p *Parser) GetCommentToken() string <span class="cov0" title="0">{
        return "#"
}</span>

// GetResolvedFiles returns resolved files
func (p *Parser) GetResolvedFiles() map[string]model.ResolvedFile <span class="cov0" title="0">{
        return make(map[string]model.ResolvedFile)
}</span>

// StringifyContent converts original content into string formatted version
func (p *Parser) StringifyContent(content []byte) (string, error) <span class="cov0" title="0">{
        return string(content), nil
}</span>

func emptyDocument() *model.Document <span class="cov1" title="1">{
        return &amp;model.Document{}
}</span>
</pre>
		
		<pre class="file" id="file66" style="display: none">package hosts

import (
        "strconv"
        "strings"

        "github.com/Checkmarx/kics/v2/pkg/model"
        "github.com/Checkmarx/kics/v2/pkg/parser/ansible/ini/comments"
        "github.com/relex/aini"
)

// Parser defines a parser type
type Parser struct {
}

func (p *Parser) Resolve(fileContent []byte, _ string, _ bool, _ int) ([]byte, error) <span class="cov0" title="0">{
        return fileContent, nil
}</span>

// Parse parses .ini file and returns it as a Document
func (p *Parser) Parse(_ string, fileContent []byte) ([]model.Document, []int, error) <span class="cov1" title="1">{
        model.NewIgnore.Reset()

        inventoryReader := strings.NewReader(string(fileContent))
        var inventory, err = aini.Parse(inventoryReader)
        if err != nil </span><span class="cov0" title="0">{
                return nil, nil, err
        }</span>

        <span class="cov1" title="1">doc := model.Document{}

        childrenMap, _ := refactorInv(inventory.Groups, 1)

        allMap := emptyDocument()
        (*allMap)["children"] = childrenMap
        doc["all"] = allMap

        ignoreLines := comments.GetIgnoreLines(strings.Split(string(fileContent), "\n"))

        return []model.Document{doc}, ignoreLines, nil</span>
}

// refactorInv removes all extra information
func refactorInv(groups map[string]*aini.Group, parentSize int) (doc *model.Document, children map[string]bool) <span class="cov6" title="7">{
        doc = emptyDocument()
        children = make(map[string]bool)
        for _, group := range groups </span><span class="cov7" title="10">{
                if parentSize != len(group.Parents) </span><span class="cov4" title="4">{
                        continue</span>
                }
                <span class="cov5" title="6">groupMap := emptyDocument()

                ans, childGroup := refactorInv(group.Children, parentSize+1)
                if len(*ans) &gt; 0 </span><span class="cov2" title="2">{
                        (*groupMap)["children"] = ans
                }</span>

                <span class="cov5" title="6">ans = refactorHosts(group.Hosts, childGroup)
                if len(*ans) &gt; 0 </span><span class="cov5" title="5">{
                        (*groupMap)["hosts"] = ans
                }</span>

                <span class="cov5" title="6">children[group.Name] = true
                for child := range childGroup </span><span class="cov8" title="17">{
                        children[child] = true
                }</span>

                <span class="cov5" title="6">(*doc)[group.Name] = groupMap</span>
        }
        <span class="cov6" title="7">return doc, children</span>
}

// refactorHosts only add Hosts that aren't defined in Children
func refactorHosts(hosts map[string]*aini.Host, children map[string]bool) *model.Document <span class="cov5" title="6">{
        hostMap := emptyDocument()
        for _, host := range hosts </span><span class="cov8" title="14">{
                if !children[host.Name] </span><span class="cov6" title="8">{
                        (*hostMap)[host.Name] = refactorVars(host.Vars)
                        children[host.Name] = true
                }</span>
        }
        <span class="cov5" title="6">return hostMap</span>
}

// refactorVars try to convert to float and add all vars
func refactorVars(vars map[string]string) *model.Document <span class="cov6" title="8">{
        varMap := emptyDocument()
        for key, value := range vars </span><span class="cov10" title="28">{
                valueFloat, err := strconv.ParseFloat(value, 64)

                if err == nil </span><span class="cov5" title="6">{
                        (*varMap)[key] = valueFloat
                }</span> else<span class="cov9" title="22"> {
                        if valueBool, err := strconv.ParseBool(value); err == nil </span><span class="cov0" title="0">{
                                (*varMap)[key] = valueBool
                        }</span> else<span class="cov9" title="22"> {
                                (*varMap)[key] = value
                        }</span>
                }
        }
        <span class="cov6" title="8">return varMap</span>
}

// SupportedExtensions returns extensions supported by this parser, which is INI extension
func (p *Parser) SupportedExtensions() []string <span class="cov1" title="1">{
        return []string{".ini"}
}</span>

// SupportedTypes returns types supported by this parser, which are ansible
func (p *Parser) SupportedTypes() map[string]bool <span class="cov1" title="1">{
        return map[string]bool{
                "ansible": true,
        }
}</span>

// GetKind returns INI constant kind
func (p *Parser) GetKind() model.FileKind <span class="cov1" title="1">{
        return model.KindINI
}</span>

// GetCommentToken return the comment token of INI - #
func (p *Parser) GetCommentToken() string <span class="cov0" title="0">{
        return "#"
}</span>

// GetResolvedFiles returns resolved files
func (p *Parser) GetResolvedFiles() map[string]model.ResolvedFile <span class="cov0" title="0">{
        return make(map[string]model.ResolvedFile)
}</span>

// StringifyContent converts original content into string formatted version
func (p *Parser) StringifyContent(content []byte) (string, error) <span class="cov0" title="0">{
        return string(content), nil
}</span>

func emptyDocument() *model.Document <span class="cov10" title="28">{
        return &amp;model.Document{}
}</span>
</pre>
		
		<pre class="file" id="file67" style="display: none">// Code generated from bicep.g4 by ANTLR 4.13.1. DO NOT EDIT.

package parser // bicep

import "github.com/antlr4-go/antlr/v4"

type BasebicepVisitor struct {
        *antlr.BaseParseTreeVisitor
}

func (v *BasebicepVisitor) VisitProgram(ctx *ProgramContext) interface{} <span class="cov0" title="0">{
        return v.VisitChildren(ctx)
}</span>

func (v *BasebicepVisitor) VisitStatement(ctx *StatementContext) interface{} <span class="cov0" title="0">{
        return v.VisitChildren(ctx)
}</span>

func (v *BasebicepVisitor) VisitTargetScopeDecl(ctx *TargetScopeDeclContext) interface{} <span class="cov0" title="0">{
        return v.VisitChildren(ctx)
}</span>

func (v *BasebicepVisitor) VisitImportDecl(ctx *ImportDeclContext) interface{} <span class="cov0" title="0">{
        return v.VisitChildren(ctx)
}</span>

func (v *BasebicepVisitor) VisitMetadataDecl(ctx *MetadataDeclContext) interface{} <span class="cov0" title="0">{
        return v.VisitChildren(ctx)
}</span>

func (v *BasebicepVisitor) VisitParameterDecl(ctx *ParameterDeclContext) interface{} <span class="cov0" title="0">{
        return v.VisitChildren(ctx)
}</span>

func (v *BasebicepVisitor) VisitParameterDefaultValue(ctx *ParameterDefaultValueContext) interface{} <span class="cov0" title="0">{
        return v.VisitChildren(ctx)
}</span>

func (v *BasebicepVisitor) VisitTypeDecl(ctx *TypeDeclContext) interface{} <span class="cov0" title="0">{
        return v.VisitChildren(ctx)
}</span>

func (v *BasebicepVisitor) VisitVariableDecl(ctx *VariableDeclContext) interface{} <span class="cov0" title="0">{
        return v.VisitChildren(ctx)
}</span>

func (v *BasebicepVisitor) VisitResourceDecl(ctx *ResourceDeclContext) interface{} <span class="cov0" title="0">{
        return v.VisitChildren(ctx)
}</span>

func (v *BasebicepVisitor) VisitModuleDecl(ctx *ModuleDeclContext) interface{} <span class="cov0" title="0">{
        return v.VisitChildren(ctx)
}</span>

func (v *BasebicepVisitor) VisitOutputDecl(ctx *OutputDeclContext) interface{} <span class="cov0" title="0">{
        return v.VisitChildren(ctx)
}</span>

func (v *BasebicepVisitor) VisitIfCondition(ctx *IfConditionContext) interface{} <span class="cov0" title="0">{
        return v.VisitChildren(ctx)
}</span>

func (v *BasebicepVisitor) VisitForExpression(ctx *ForExpressionContext) interface{} <span class="cov0" title="0">{
        return v.VisitChildren(ctx)
}</span>

func (v *BasebicepVisitor) VisitForVariableBlock(ctx *ForVariableBlockContext) interface{} <span class="cov0" title="0">{
        return v.VisitChildren(ctx)
}</span>

func (v *BasebicepVisitor) VisitForBody(ctx *ForBodyContext) interface{} <span class="cov0" title="0">{
        return v.VisitChildren(ctx)
}</span>

func (v *BasebicepVisitor) VisitInterpString(ctx *InterpStringContext) interface{} <span class="cov0" title="0">{
        return v.VisitChildren(ctx)
}</span>

func (v *BasebicepVisitor) VisitExpression(ctx *ExpressionContext) interface{} <span class="cov0" title="0">{
        return v.VisitChildren(ctx)
}</span>

func (v *BasebicepVisitor) VisitLambdaExpression(ctx *LambdaExpressionContext) interface{} <span class="cov0" title="0">{
        return v.VisitChildren(ctx)
}</span>

func (v *BasebicepVisitor) VisitLogicCharacter(ctx *LogicCharacterContext) interface{} <span class="cov0" title="0">{
        return v.VisitChildren(ctx)
}</span>

func (v *BasebicepVisitor) VisitPrimaryExpression(ctx *PrimaryExpressionContext) interface{} <span class="cov0" title="0">{
        return v.VisitChildren(ctx)
}</span>

func (v *BasebicepVisitor) VisitParenthesizedExpression(ctx *ParenthesizedExpressionContext) interface{} <span class="cov0" title="0">{
        return v.VisitChildren(ctx)
}</span>

func (v *BasebicepVisitor) VisitTypeExpression(ctx *TypeExpressionContext) interface{} <span class="cov0" title="0">{
        return v.VisitChildren(ctx)
}</span>

func (v *BasebicepVisitor) VisitLiteralValue(ctx *LiteralValueContext) interface{} <span class="cov0" title="0">{
        return v.VisitChildren(ctx)
}</span>

func (v *BasebicepVisitor) VisitObject(ctx *ObjectContext) interface{} <span class="cov0" title="0">{
        return v.VisitChildren(ctx)
}</span>

func (v *BasebicepVisitor) VisitObjectProperty(ctx *ObjectPropertyContext) interface{} <span class="cov0" title="0">{
        return v.VisitChildren(ctx)
}</span>

func (v *BasebicepVisitor) VisitArray(ctx *ArrayContext) interface{} <span class="cov0" title="0">{
        return v.VisitChildren(ctx)
}</span>

func (v *BasebicepVisitor) VisitArrayItem(ctx *ArrayItemContext) interface{} <span class="cov0" title="0">{
        return v.VisitChildren(ctx)
}</span>

func (v *BasebicepVisitor) VisitDecorator(ctx *DecoratorContext) interface{} <span class="cov0" title="0">{
        return v.VisitChildren(ctx)
}</span>

func (v *BasebicepVisitor) VisitDecoratorExpression(ctx *DecoratorExpressionContext) interface{} <span class="cov0" title="0">{
        return v.VisitChildren(ctx)
}</span>

func (v *BasebicepVisitor) VisitFunctionCall(ctx *FunctionCallContext) interface{} <span class="cov0" title="0">{
        return v.VisitChildren(ctx)
}</span>

func (v *BasebicepVisitor) VisitArgumentList(ctx *ArgumentListContext) interface{} <span class="cov0" title="0">{
        return v.VisitChildren(ctx)
}</span>

func (v *BasebicepVisitor) VisitIdentifier(ctx *IdentifierContext) interface{} <span class="cov0" title="0">{
        return v.VisitChildren(ctx)
}</span>
</pre>
		
		<pre class="file" id="file68" style="display: none">// Code generated from bicep.g4 by ANTLR 4.13.1. DO NOT EDIT.

package parser

import (
        "fmt"
        "github.com/antlr4-go/antlr/v4"
        "sync"
        "unicode"
)

// Suppress unused import error
var _ = fmt.Printf
var _ = sync.Once{}
var _ = unicode.IsLetter

type bicepLexer struct {
        *antlr.BaseLexer
        channelNames []string
        modeNames    []string
        // TODO: EOF string
}

var BicepLexerLexerStaticData struct {
        once                   sync.Once
        serializedATN          []int32
        ChannelNames           []string
        ModeNames              []string
        LiteralNames           []string
        SymbolicNames          []string
        RuleNames              []string
        PredictionContextCache *antlr.PredictionContextCache
        atn                    *antlr.ATN
        decisionToDFA          []*antlr.DFA
}

func biceplexerLexerInit() <span class="cov1" title="2">{
        staticData := &amp;BicepLexerLexerStaticData
        staticData.ChannelNames = []string{
                "DEFAULT_TOKEN_CHANNEL", "HIDDEN",
        }
        staticData.ModeNames = []string{
                "DEFAULT_MODE",
        }
        staticData.LiteralNames = []string{
                "", "", "'@'", "','", "'['", "']'", "'('", "')'", "'.'", "'|'", "",
                "'='", "'{'", "'}'", "'param'", "'var'", "'true'", "'false'", "'null'",
                "'array'", "'object'", "'resource'", "'output'", "'targetScope'", "'import'",
                "'with'", "'as'", "'metadata'", "'existing'", "'type'", "'module'",
                "", "", "", "", "'string'", "'int'", "'bool'", "'if'", "'for'", "'in'",
                "'?'", "'&gt;'", "'&gt;='", "'&lt;'", "'&lt;='", "'=='", "'!='", "'=&gt;'",
        }
        staticData.SymbolicNames = []string{
                "", "MULTILINE_STRING", "AT", "COMMA", "OBRACK", "CBRACK", "OPAR", "CPAR",
                "DOT", "PIPE", "COL", "ASSIGN", "OBRACE", "CBRACE", "PARAM", "VAR",
                "TRUE", "FALSE", "NULL", "ARRAY", "OBJECT", "RESOURCE", "OUTPUT", "TARGET_SCOPE",
                "IMPORT", "WITH", "AS", "METADATA", "EXISTING", "TYPE", "MODULE", "STRING_LEFT_PIECE",
                "STRING_MIDDLE_PIECE", "STRING_RIGHT_PIECE", "STRING_COMPLETE", "STRING",
                "INT", "BOOL", "IF", "FOR", "IN", "QMARK", "GT", "GTE", "LT", "LTE",
                "EQ", "NEQ", "ARROW", "IDENTIFIER", "NUMBER", "NL", "SINGLE_LINE_COMMENT",
                "MULTI_LINE_COMMENT", "SPACES", "UNKNOWN",
        }
        staticData.RuleNames = []string{
                "MULTILINE_STRING", "AT", "COMMA", "OBRACK", "CBRACK", "OPAR", "CPAR",
                "DOT", "PIPE", "COL", "ASSIGN", "OBRACE", "CBRACE", "PARAM", "VAR",
                "TRUE", "FALSE", "NULL", "ARRAY", "OBJECT", "RESOURCE", "OUTPUT", "TARGET_SCOPE",
                "IMPORT", "WITH", "AS", "METADATA", "EXISTING", "TYPE", "MODULE", "STRING_LEFT_PIECE",
                "STRING_MIDDLE_PIECE", "STRING_RIGHT_PIECE", "STRING_COMPLETE", "STRING",
                "INT", "BOOL", "IF", "FOR", "IN", "QMARK", "GT", "GTE", "LT", "LTE",
                "EQ", "NEQ", "ARROW", "IDENTIFIER", "NUMBER", "NL", "SINGLE_LINE_COMMENT",
                "MULTI_LINE_COMMENT", "SPACES", "UNKNOWN", "STRINGCHAR", "ESCAPE", "HEX",
        }
        staticData.PredictionContextCache = antlr.NewPredictionContextCache()
        staticData.serializedATN = []int32{
                4, 0, 55, 434, 6, -1, 2, 0, 7, 0, 2, 1, 7, 1, 2, 2, 7, 2, 2, 3, 7, 3, 2,
                4, 7, 4, 2, 5, 7, 5, 2, 6, 7, 6, 2, 7, 7, 7, 2, 8, 7, 8, 2, 9, 7, 9, 2,
                10, 7, 10, 2, 11, 7, 11, 2, 12, 7, 12, 2, 13, 7, 13, 2, 14, 7, 14, 2, 15,
                7, 15, 2, 16, 7, 16, 2, 17, 7, 17, 2, 18, 7, 18, 2, 19, 7, 19, 2, 20, 7,
                20, 2, 21, 7, 21, 2, 22, 7, 22, 2, 23, 7, 23, 2, 24, 7, 24, 2, 25, 7, 25,
                2, 26, 7, 26, 2, 27, 7, 27, 2, 28, 7, 28, 2, 29, 7, 29, 2, 30, 7, 30, 2,
                31, 7, 31, 2, 32, 7, 32, 2, 33, 7, 33, 2, 34, 7, 34, 2, 35, 7, 35, 2, 36,
                7, 36, 2, 37, 7, 37, 2, 38, 7, 38, 2, 39, 7, 39, 2, 40, 7, 40, 2, 41, 7,
                41, 2, 42, 7, 42, 2, 43, 7, 43, 2, 44, 7, 44, 2, 45, 7, 45, 2, 46, 7, 46,
                2, 47, 7, 47, 2, 48, 7, 48, 2, 49, 7, 49, 2, 50, 7, 50, 2, 51, 7, 51, 2,
                52, 7, 52, 2, 53, 7, 53, 2, 54, 7, 54, 2, 55, 7, 55, 2, 56, 7, 56, 2, 57,
                7, 57, 1, 0, 1, 0, 1, 0, 1, 0, 1, 0, 5, 0, 123, 8, 0, 10, 0, 12, 0, 126,
                9, 0, 1, 0, 1, 0, 1, 0, 1, 0, 1, 1, 1, 1, 1, 2, 1, 2, 1, 3, 1, 3, 1, 4,
                1, 4, 1, 5, 1, 5, 1, 6, 1, 6, 1, 7, 1, 7, 1, 8, 1, 8, 1, 9, 1, 9, 1, 9,
                3, 9, 151, 8, 9, 1, 10, 1, 10, 1, 11, 1, 11, 1, 12, 1, 12, 1, 13, 1, 13,
                1, 13, 1, 13, 1, 13, 1, 13, 1, 14, 1, 14, 1, 14, 1, 14, 1, 15, 1, 15, 1,
                15, 1, 15, 1, 15, 1, 16, 1, 16, 1, 16, 1, 16, 1, 16, 1, 16, 1, 17, 1, 17,
                1, 17, 1, 17, 1, 17, 1, 18, 1, 18, 1, 18, 1, 18, 1, 18, 1, 18, 1, 19, 1,
                19, 1, 19, 1, 19, 1, 19, 1, 19, 1, 19, 1, 20, 1, 20, 1, 20, 1, 20, 1, 20,
                1, 20, 1, 20, 1, 20, 1, 20, 1, 21, 1, 21, 1, 21, 1, 21, 1, 21, 1, 21, 1,
                21, 1, 22, 1, 22, 1, 22, 1, 22, 1, 22, 1, 22, 1, 22, 1, 22, 1, 22, 1, 22,
                1, 22, 1, 22, 1, 23, 1, 23, 1, 23, 1, 23, 1, 23, 1, 23, 1, 23, 1, 24, 1,
                24, 1, 24, 1, 24, 1, 24, 1, 25, 1, 25, 1, 25, 1, 26, 1, 26, 1, 26, 1, 26,
                1, 26, 1, 26, 1, 26, 1, 26, 1, 26, 1, 27, 1, 27, 1, 27, 1, 27, 1, 27, 1,
                27, 1, 27, 1, 27, 1, 27, 1, 28, 1, 28, 1, 28, 1, 28, 1, 28, 1, 29, 1, 29,
                1, 29, 1, 29, 1, 29, 1, 29, 1, 29, 1, 30, 1, 30, 5, 30, 273, 8, 30, 10,
                30, 12, 30, 276, 9, 30, 1, 30, 1, 30, 1, 30, 1, 31, 1, 31, 5, 31, 283,
                8, 31, 10, 31, 12, 31, 286, 9, 31, 1, 31, 1, 31, 1, 31, 1, 32, 1, 32, 5,
                32, 293, 8, 32, 10, 32, 12, 32, 296, 9, 32, 1, 32, 1, 32, 1, 33, 1, 33,
                5, 33, 302, 8, 33, 10, 33, 12, 33, 305, 9, 33, 1, 33, 1, 33, 1, 34, 1,
                34, 1, 34, 1, 34, 1, 34, 1, 34, 1, 34, 1, 35, 1, 35, 1, 35, 1, 35, 1, 36,
                1, 36, 1, 36, 1, 36, 1, 36, 1, 37, 1, 37, 1, 37, 1, 38, 1, 38, 1, 38, 1,
                38, 1, 39, 1, 39, 1, 39, 1, 40, 1, 40, 1, 41, 1, 41, 1, 42, 1, 42, 1, 42,
                1, 43, 1, 43, 1, 44, 1, 44, 1, 44, 1, 45, 1, 45, 1, 45, 1, 46, 1, 46, 1,
                46, 1, 47, 1, 47, 1, 47, 1, 48, 1, 48, 5, 48, 358, 8, 48, 10, 48, 12, 48,
                361, 9, 48, 1, 49, 4, 49, 364, 8, 49, 11, 49, 12, 49, 365, 1, 49, 1, 49,
                4, 49, 370, 8, 49, 11, 49, 12, 49, 371, 3, 49, 374, 8, 49, 1, 50, 4, 50,
                377, 8, 50, 11, 50, 12, 50, 378, 1, 51, 1, 51, 1, 51, 1, 51, 5, 51, 385,
                8, 51, 10, 51, 12, 51, 388, 9, 51, 1, 51, 1, 51, 1, 52, 1, 52, 1, 52, 1,
                52, 5, 52, 396, 8, 52, 10, 52, 12, 52, 399, 9, 52, 1, 52, 1, 52, 1, 52,
                1, 52, 1, 52, 1, 53, 4, 53, 407, 8, 53, 11, 53, 12, 53, 408, 1, 53, 1,
                53, 1, 54, 1, 54, 1, 55, 1, 55, 3, 55, 417, 8, 55, 1, 56, 1, 56, 1, 56,
                1, 56, 1, 56, 1, 56, 4, 56, 425, 8, 56, 11, 56, 12, 56, 426, 1, 56, 1,
                56, 3, 56, 431, 8, 56, 1, 57, 1, 57, 2, 124, 397, 0, 58, 1, 1, 3, 2, 5,
                3, 7, 4, 9, 5, 11, 6, 13, 7, 15, 8, 17, 9, 19, 10, 21, 11, 23, 12, 25,
                13, 27, 14, 29, 15, 31, 16, 33, 17, 35, 18, 37, 19, 39, 20, 41, 21, 43,
                22, 45, 23, 47, 24, 49, 25, 51, 26, 53, 27, 55, 28, 57, 29, 59, 30, 61,
                31, 63, 32, 65, 33, 67, 34, 69, 35, 71, 36, 73, 37, 75, 38, 77, 39, 79,
                40, 81, 41, 83, 42, 85, 43, 87, 44, 89, 45, 91, 46, 93, 47, 95, 48, 97,
                49, 99, 50, 101, 51, 103, 52, 105, 53, 107, 54, 109, 55, 111, 0, 113, 0,
                115, 0, 1, 0, 8, 3, 0, 65, 90, 95, 95, 97, 122, 4, 0, 48, 57, 65, 90, 95,
                95, 97, 122, 1, 0, 48, 57, 2, 0, 10, 10, 13, 13, 2, 0, 9, 9, 32, 32, 5,
                0, 9, 10, 13, 13, 36, 36, 39, 39, 92, 92, 6, 0, 36, 36, 39, 39, 92, 92,
                110, 110, 114, 114, 116, 116, 3, 0, 48, 57, 65, 70, 97, 102, 447, 0, 1,
                1, 0, 0, 0, 0, 3, 1, 0, 0, 0, 0, 5, 1, 0, 0, 0, 0, 7, 1, 0, 0, 0, 0, 9,
                1, 0, 0, 0, 0, 11, 1, 0, 0, 0, 0, 13, 1, 0, 0, 0, 0, 15, 1, 0, 0, 0, 0,
                17, 1, 0, 0, 0, 0, 19, 1, 0, 0, 0, 0, 21, 1, 0, 0, 0, 0, 23, 1, 0, 0, 0,
                0, 25, 1, 0, 0, 0, 0, 27, 1, 0, 0, 0, 0, 29, 1, 0, 0, 0, 0, 31, 1, 0, 0,
                0, 0, 33, 1, 0, 0, 0, 0, 35, 1, 0, 0, 0, 0, 37, 1, 0, 0, 0, 0, 39, 1, 0,
                0, 0, 0, 41, 1, 0, 0, 0, 0, 43, 1, 0, 0, 0, 0, 45, 1, 0, 0, 0, 0, 47, 1,
                0, 0, 0, 0, 49, 1, 0, 0, 0, 0, 51, 1, 0, 0, 0, 0, 53, 1, 0, 0, 0, 0, 55,
                1, 0, 0, 0, 0, 57, 1, 0, 0, 0, 0, 59, 1, 0, 0, 0, 0, 61, 1, 0, 0, 0, 0,
                63, 1, 0, 0, 0, 0, 65, 1, 0, 0, 0, 0, 67, 1, 0, 0, 0, 0, 69, 1, 0, 0, 0,
                0, 71, 1, 0, 0, 0, 0, 73, 1, 0, 0, 0, 0, 75, 1, 0, 0, 0, 0, 77, 1, 0, 0,
                0, 0, 79, 1, 0, 0, 0, 0, 81, 1, 0, 0, 0, 0, 83, 1, 0, 0, 0, 0, 85, 1, 0,
                0, 0, 0, 87, 1, 0, 0, 0, 0, 89, 1, 0, 0, 0, 0, 91, 1, 0, 0, 0, 0, 93, 1,
                0, 0, 0, 0, 95, 1, 0, 0, 0, 0, 97, 1, 0, 0, 0, 0, 99, 1, 0, 0, 0, 0, 101,
                1, 0, 0, 0, 0, 103, 1, 0, 0, 0, 0, 105, 1, 0, 0, 0, 0, 107, 1, 0, 0, 0,
                0, 109, 1, 0, 0, 0, 1, 117, 1, 0, 0, 0, 3, 131, 1, 0, 0, 0, 5, 133, 1,
                0, 0, 0, 7, 135, 1, 0, 0, 0, 9, 137, 1, 0, 0, 0, 11, 139, 1, 0, 0, 0, 13,
                141, 1, 0, 0, 0, 15, 143, 1, 0, 0, 0, 17, 145, 1, 0, 0, 0, 19, 150, 1,
                0, 0, 0, 21, 152, 1, 0, 0, 0, 23, 154, 1, 0, 0, 0, 25, 156, 1, 0, 0, 0,
                27, 158, 1, 0, 0, 0, 29, 164, 1, 0, 0, 0, 31, 168, 1, 0, 0, 0, 33, 173,
                1, 0, 0, 0, 35, 179, 1, 0, 0, 0, 37, 184, 1, 0, 0, 0, 39, 190, 1, 0, 0,
                0, 41, 197, 1, 0, 0, 0, 43, 206, 1, 0, 0, 0, 45, 213, 1, 0, 0, 0, 47, 225,
                1, 0, 0, 0, 49, 232, 1, 0, 0, 0, 51, 237, 1, 0, 0, 0, 53, 240, 1, 0, 0,
                0, 55, 249, 1, 0, 0, 0, 57, 258, 1, 0, 0, 0, 59, 263, 1, 0, 0, 0, 61, 270,
                1, 0, 0, 0, 63, 280, 1, 0, 0, 0, 65, 290, 1, 0, 0, 0, 67, 299, 1, 0, 0,
                0, 69, 308, 1, 0, 0, 0, 71, 315, 1, 0, 0, 0, 73, 319, 1, 0, 0, 0, 75, 324,
                1, 0, 0, 0, 77, 327, 1, 0, 0, 0, 79, 331, 1, 0, 0, 0, 81, 334, 1, 0, 0,
                0, 83, 336, 1, 0, 0, 0, 85, 338, 1, 0, 0, 0, 87, 341, 1, 0, 0, 0, 89, 343,
                1, 0, 0, 0, 91, 346, 1, 0, 0, 0, 93, 349, 1, 0, 0, 0, 95, 352, 1, 0, 0,
                0, 97, 355, 1, 0, 0, 0, 99, 363, 1, 0, 0, 0, 101, 376, 1, 0, 0, 0, 103,
                380, 1, 0, 0, 0, 105, 391, 1, 0, 0, 0, 107, 406, 1, 0, 0, 0, 109, 412,
                1, 0, 0, 0, 111, 416, 1, 0, 0, 0, 113, 418, 1, 0, 0, 0, 115, 432, 1, 0,
                0, 0, 117, 118, 5, 39, 0, 0, 118, 119, 5, 39, 0, 0, 119, 120, 5, 39, 0,
                0, 120, 124, 1, 0, 0, 0, 121, 123, 9, 0, 0, 0, 122, 121, 1, 0, 0, 0, 123,
                126, 1, 0, 0, 0, 124, 125, 1, 0, 0, 0, 124, 122, 1, 0, 0, 0, 125, 127,
                1, 0, 0, 0, 126, 124, 1, 0, 0, 0, 127, 128, 5, 39, 0, 0, 128, 129, 5, 39,
                0, 0, 129, 130, 5, 39, 0, 0, 130, 2, 1, 0, 0, 0, 131, 132, 5, 64, 0, 0,
                132, 4, 1, 0, 0, 0, 133, 134, 5, 44, 0, 0, 134, 6, 1, 0, 0, 0, 135, 136,
                5, 91, 0, 0, 136, 8, 1, 0, 0, 0, 137, 138, 5, 93, 0, 0, 138, 10, 1, 0,
                0, 0, 139, 140, 5, 40, 0, 0, 140, 12, 1, 0, 0, 0, 141, 142, 5, 41, 0, 0,
                142, 14, 1, 0, 0, 0, 143, 144, 5, 46, 0, 0, 144, 16, 1, 0, 0, 0, 145, 146,
                5, 124, 0, 0, 146, 18, 1, 0, 0, 0, 147, 151, 5, 58, 0, 0, 148, 149, 5,
                58, 0, 0, 149, 151, 5, 58, 0, 0, 150, 147, 1, 0, 0, 0, 150, 148, 1, 0,
                0, 0, 151, 20, 1, 0, 0, 0, 152, 153, 5, 61, 0, 0, 153, 22, 1, 0, 0, 0,
                154, 155, 5, 123, 0, 0, 155, 24, 1, 0, 0, 0, 156, 157, 5, 125, 0, 0, 157,
                26, 1, 0, 0, 0, 158, 159, 5, 112, 0, 0, 159, 160, 5, 97, 0, 0, 160, 161,
                5, 114, 0, 0, 161, 162, 5, 97, 0, 0, 162, 163, 5, 109, 0, 0, 163, 28, 1,
                0, 0, 0, 164, 165, 5, 118, 0, 0, 165, 166, 5, 97, 0, 0, 166, 167, 5, 114,
                0, 0, 167, 30, 1, 0, 0, 0, 168, 169, 5, 116, 0, 0, 169, 170, 5, 114, 0,
                0, 170, 171, 5, 117, 0, 0, 171, 172, 5, 101, 0, 0, 172, 32, 1, 0, 0, 0,
                173, 174, 5, 102, 0, 0, 174, 175, 5, 97, 0, 0, 175, 176, 5, 108, 0, 0,
                176, 177, 5, 115, 0, 0, 177, 178, 5, 101, 0, 0, 178, 34, 1, 0, 0, 0, 179,
                180, 5, 110, 0, 0, 180, 181, 5, 117, 0, 0, 181, 182, 5, 108, 0, 0, 182,
                183, 5, 108, 0, 0, 183, 36, 1, 0, 0, 0, 184, 185, 5, 97, 0, 0, 185, 186,
                5, 114, 0, 0, 186, 187, 5, 114, 0, 0, 187, 188, 5, 97, 0, 0, 188, 189,
                5, 121, 0, 0, 189, 38, 1, 0, 0, 0, 190, 191, 5, 111, 0, 0, 191, 192, 5,
                98, 0, 0, 192, 193, 5, 106, 0, 0, 193, 194, 5, 101, 0, 0, 194, 195, 5,
                99, 0, 0, 195, 196, 5, 116, 0, 0, 196, 40, 1, 0, 0, 0, 197, 198, 5, 114,
                0, 0, 198, 199, 5, 101, 0, 0, 199, 200, 5, 115, 0, 0, 200, 201, 5, 111,
                0, 0, 201, 202, 5, 117, 0, 0, 202, 203, 5, 114, 0, 0, 203, 204, 5, 99,
                0, 0, 204, 205, 5, 101, 0, 0, 205, 42, 1, 0, 0, 0, 206, 207, 5, 111, 0,
                0, 207, 208, 5, 117, 0, 0, 208, 209, 5, 116, 0, 0, 209, 210, 5, 112, 0,
                0, 210, 211, 5, 117, 0, 0, 211, 212, 5, 116, 0, 0, 212, 44, 1, 0, 0, 0,
                213, 214, 5, 116, 0, 0, 214, 215, 5, 97, 0, 0, 215, 216, 5, 114, 0, 0,
                216, 217, 5, 103, 0, 0, 217, 218, 5, 101, 0, 0, 218, 219, 5, 116, 0, 0,
                219, 220, 5, 83, 0, 0, 220, 221, 5, 99, 0, 0, 221, 222, 5, 111, 0, 0, 222,
                223, 5, 112, 0, 0, 223, 224, 5, 101, 0, 0, 224, 46, 1, 0, 0, 0, 225, 226,
                5, 105, 0, 0, 226, 227, 5, 109, 0, 0, 227, 228, 5, 112, 0, 0, 228, 229,
                5, 111, 0, 0, 229, 230, 5, 114, 0, 0, 230, 231, 5, 116, 0, 0, 231, 48,
                1, 0, 0, 0, 232, 233, 5, 119, 0, 0, 233, 234, 5, 105, 0, 0, 234, 235, 5,
                116, 0, 0, 235, 236, 5, 104, 0, 0, 236, 50, 1, 0, 0, 0, 237, 238, 5, 97,
                0, 0, 238, 239, 5, 115, 0, 0, 239, 52, 1, 0, 0, 0, 240, 241, 5, 109, 0,
                0, 241, 242, 5, 101, 0, 0, 242, 243, 5, 116, 0, 0, 243, 244, 5, 97, 0,
                0, 244, 245, 5, 100, 0, 0, 245, 246, 5, 97, 0, 0, 246, 247, 5, 116, 0,
                0, 247, 248, 5, 97, 0, 0, 248, 54, 1, 0, 0, 0, 249, 250, 5, 101, 0, 0,
                250, 251, 5, 120, 0, 0, 251, 252, 5, 105, 0, 0, 252, 253, 5, 115, 0, 0,
                253, 254, 5, 116, 0, 0, 254, 255, 5, 105, 0, 0, 255, 256, 5, 110, 0, 0,
                256, 257, 5, 103, 0, 0, 257, 56, 1, 0, 0, 0, 258, 259, 5, 116, 0, 0, 259,
                260, 5, 121, 0, 0, 260, 261, 5, 112, 0, 0, 261, 262, 5, 101, 0, 0, 262,
                58, 1, 0, 0, 0, 263, 264, 5, 109, 0, 0, 264, 265, 5, 111, 0, 0, 265, 266,
                5, 100, 0, 0, 266, 267, 5, 117, 0, 0, 267, 268, 5, 108, 0, 0, 268, 269,
                5, 101, 0, 0, 269, 60, 1, 0, 0, 0, 270, 274, 5, 39, 0, 0, 271, 273, 3,
                111, 55, 0, 272, 271, 1, 0, 0, 0, 273, 276, 1, 0, 0, 0, 274, 272, 1, 0,
                0, 0, 274, 275, 1, 0, 0, 0, 275, 277, 1, 0, 0, 0, 276, 274, 1, 0, 0, 0,
                277, 278, 5, 36, 0, 0, 278, 279, 5, 123, 0, 0, 279, 62, 1, 0, 0, 0, 280,
                284, 5, 125, 0, 0, 281, 283, 3, 111, 55, 0, 282, 281, 1, 0, 0, 0, 283,
                286, 1, 0, 0, 0, 284, 282, 1, 0, 0, 0, 284, 285, 1, 0, 0, 0, 285, 287,
                1, 0, 0, 0, 286, 284, 1, 0, 0, 0, 287, 288, 5, 36, 0, 0, 288, 289, 5, 123,
                0, 0, 289, 64, 1, 0, 0, 0, 290, 294, 5, 125, 0, 0, 291, 293, 3, 111, 55,
                0, 292, 291, 1, 0, 0, 0, 293, 296, 1, 0, 0, 0, 294, 292, 1, 0, 0, 0, 294,
                295, 1, 0, 0, 0, 295, 297, 1, 0, 0, 0, 296, 294, 1, 0, 0, 0, 297, 298,
                5, 39, 0, 0, 298, 66, 1, 0, 0, 0, 299, 303, 5, 39, 0, 0, 300, 302, 3, 111,
                55, 0, 301, 300, 1, 0, 0, 0, 302, 305, 1, 0, 0, 0, 303, 301, 1, 0, 0, 0,
                303, 304, 1, 0, 0, 0, 304, 306, 1, 0, 0, 0, 305, 303, 1, 0, 0, 0, 306,
                307, 5, 39, 0, 0, 307, 68, 1, 0, 0, 0, 308, 309, 5, 115, 0, 0, 309, 310,
                5, 116, 0, 0, 310, 311, 5, 114, 0, 0, 311, 312, 5, 105, 0, 0, 312, 313,
                5, 110, 0, 0, 313, 314, 5, 103, 0, 0, 314, 70, 1, 0, 0, 0, 315, 316, 5,
                105, 0, 0, 316, 317, 5, 110, 0, 0, 317, 318, 5, 116, 0, 0, 318, 72, 1,
                0, 0, 0, 319, 320, 5, 98, 0, 0, 320, 321, 5, 111, 0, 0, 321, 322, 5, 111,
                0, 0, 322, 323, 5, 108, 0, 0, 323, 74, 1, 0, 0, 0, 324, 325, 5, 105, 0,
                0, 325, 326, 5, 102, 0, 0, 326, 76, 1, 0, 0, 0, 327, 328, 5, 102, 0, 0,
                328, 329, 5, 111, 0, 0, 329, 330, 5, 114, 0, 0, 330, 78, 1, 0, 0, 0, 331,
                332, 5, 105, 0, 0, 332, 333, 5, 110, 0, 0, 333, 80, 1, 0, 0, 0, 334, 335,
                5, 63, 0, 0, 335, 82, 1, 0, 0, 0, 336, 337, 5, 62, 0, 0, 337, 84, 1, 0,
                0, 0, 338, 339, 5, 62, 0, 0, 339, 340, 5, 61, 0, 0, 340, 86, 1, 0, 0, 0,
                341, 342, 5, 60, 0, 0, 342, 88, 1, 0, 0, 0, 343, 344, 5, 60, 0, 0, 344,
                345, 5, 61, 0, 0, 345, 90, 1, 0, 0, 0, 346, 347, 5, 61, 0, 0, 347, 348,
                5, 61, 0, 0, 348, 92, 1, 0, 0, 0, 349, 350, 5, 33, 0, 0, 350, 351, 5, 61,
                0, 0, 351, 94, 1, 0, 0, 0, 352, 353, 5, 61, 0, 0, 353, 354, 5, 62, 0, 0,
                354, 96, 1, 0, 0, 0, 355, 359, 7, 0, 0, 0, 356, 358, 7, 1, 0, 0, 357, 356,
                1, 0, 0, 0, 358, 361, 1, 0, 0, 0, 359, 357, 1, 0, 0, 0, 359, 360, 1, 0,
                0, 0, 360, 98, 1, 0, 0, 0, 361, 359, 1, 0, 0, 0, 362, 364, 7, 2, 0, 0,
                363, 362, 1, 0, 0, 0, 364, 365, 1, 0, 0, 0, 365, 363, 1, 0, 0, 0, 365,
                366, 1, 0, 0, 0, 366, 373, 1, 0, 0, 0, 367, 369, 5, 46, 0, 0, 368, 370,
                7, 2, 0, 0, 369, 368, 1, 0, 0, 0, 370, 371, 1, 0, 0, 0, 371, 369, 1, 0,
                0, 0, 371, 372, 1, 0, 0, 0, 372, 374, 1, 0, 0, 0, 373, 367, 1, 0, 0, 0,
                373, 374, 1, 0, 0, 0, 374, 100, 1, 0, 0, 0, 375, 377, 7, 3, 0, 0, 376,
                375, 1, 0, 0, 0, 377, 378, 1, 0, 0, 0, 378, 376, 1, 0, 0, 0, 378, 379,
                1, 0, 0, 0, 379, 102, 1, 0, 0, 0, 380, 381, 5, 47, 0, 0, 381, 382, 5, 47,
                0, 0, 382, 386, 1, 0, 0, 0, 383, 385, 8, 3, 0, 0, 384, 383, 1, 0, 0, 0,
                385, 388, 1, 0, 0, 0, 386, 384, 1, 0, 0, 0, 386, 387, 1, 0, 0, 0, 387,
                389, 1, 0, 0, 0, 388, 386, 1, 0, 0, 0, 389, 390, 6, 51, 0, 0, 390, 104,
                1, 0, 0, 0, 391, 392, 5, 47, 0, 0, 392, 393, 5, 42, 0, 0, 393, 397, 1,
                0, 0, 0, 394, 396, 9, 0, 0, 0, 395, 394, 1, 0, 0, 0, 396, 399, 1, 0, 0,
                0, 397, 398, 1, 0, 0, 0, 397, 395, 1, 0, 0, 0, 398, 400, 1, 0, 0, 0, 399,
                397, 1, 0, 0, 0, 400, 401, 5, 42, 0, 0, 401, 402, 5, 47, 0, 0, 402, 403,
                1, 0, 0, 0, 403, 404, 6, 52, 0, 0, 404, 106, 1, 0, 0, 0, 405, 407, 7, 4,
                0, 0, 406, 405, 1, 0, 0, 0, 407, 408, 1, 0, 0, 0, 408, 406, 1, 0, 0, 0,
                408, 409, 1, 0, 0, 0, 409, 410, 1, 0, 0, 0, 410, 411, 6, 53, 0, 0, 411,
                108, 1, 0, 0, 0, 412, 413, 9, 0, 0, 0, 413, 110, 1, 0, 0, 0, 414, 417,
                8, 5, 0, 0, 415, 417, 3, 113, 56, 0, 416, 414, 1, 0, 0, 0, 416, 415, 1,
                0, 0, 0, 417, 112, 1, 0, 0, 0, 418, 430, 5, 92, 0, 0, 419, 431, 7, 6, 0,
                0, 420, 421, 5, 117, 0, 0, 421, 422, 5, 123, 0, 0, 422, 424, 1, 0, 0, 0,
                423, 425, 3, 115, 57, 0, 424, 423, 1, 0, 0, 0, 425, 426, 1, 0, 0, 0, 426,
                424, 1, 0, 0, 0, 426, 427, 1, 0, 0, 0, 427, 428, 1, 0, 0, 0, 428, 429,
                5, 125, 0, 0, 429, 431, 1, 0, 0, 0, 430, 419, 1, 0, 0, 0, 430, 420, 1,
                0, 0, 0, 431, 114, 1, 0, 0, 0, 432, 433, 7, 7, 0, 0, 433, 116, 1, 0, 0,
                0, 18, 0, 124, 150, 274, 284, 294, 303, 359, 365, 371, 373, 378, 386, 397,
                408, 416, 426, 430, 1, 6, 0, 0,
        }
        deserializer := antlr.NewATNDeserializer(nil)
        staticData.atn = deserializer.Deserialize(staticData.serializedATN)
        atn := staticData.atn
        staticData.decisionToDFA = make([]*antlr.DFA, len(atn.DecisionToState))
        decisionToDFA := staticData.decisionToDFA
        for index, state := range atn.DecisionToState </span><span class="cov6" title="36">{
                decisionToDFA[index] = antlr.NewDFA(state, index)
        }</span>
}

// bicepLexerInit initializes any static state used to implement bicepLexer. By default the
// static state used to implement the lexer is lazily initialized during the first call to
// NewbicepLexer(). You can call this function if you wish to initialize the static state ahead
// of time.
func BicepLexerInit() <span class="cov10" title="538">{
        staticData := &amp;BicepLexerLexerStaticData
        staticData.once.Do(biceplexerLexerInit)
}</span>

// NewbicepLexer produces a new lexer instance for the optional input antlr.CharStream.
func NewbicepLexer(input antlr.CharStream) *bicepLexer <span class="cov10" title="538">{
        BicepLexerInit()
        l := new(bicepLexer)
        l.BaseLexer = antlr.NewBaseLexer(input)
        staticData := &amp;BicepLexerLexerStaticData
        l.Interpreter = antlr.NewLexerATNSimulator(l, staticData.atn, staticData.decisionToDFA, staticData.PredictionContextCache)
        l.channelNames = staticData.ChannelNames
        l.modeNames = staticData.ModeNames
        l.RuleNames = staticData.RuleNames
        l.LiteralNames = staticData.LiteralNames
        l.SymbolicNames = staticData.SymbolicNames
        l.GrammarFileName = "bicep.g4"
        // TODO: l.EOF = antlr.TokenEOF

        return l
}</span>

// bicepLexer tokens.
const (
        bicepLexerMULTILINE_STRING    = 1
        bicepLexerAT                  = 2
        bicepLexerCOMMA               = 3
        bicepLexerOBRACK              = 4
        bicepLexerCBRACK              = 5
        bicepLexerOPAR                = 6
        bicepLexerCPAR                = 7
        bicepLexerDOT                 = 8
        bicepLexerPIPE                = 9
        bicepLexerCOL                 = 10
        bicepLexerASSIGN              = 11
        bicepLexerOBRACE              = 12
        bicepLexerCBRACE              = 13
        bicepLexerPARAM               = 14
        bicepLexerVAR                 = 15
        bicepLexerTRUE                = 16
        bicepLexerFALSE               = 17
        bicepLexerNULL                = 18
        bicepLexerARRAY               = 19
        bicepLexerOBJECT              = 20
        bicepLexerRESOURCE            = 21
        bicepLexerOUTPUT              = 22
        bicepLexerTARGET_SCOPE        = 23
        bicepLexerIMPORT              = 24
        bicepLexerWITH                = 25
        bicepLexerAS                  = 26
        bicepLexerMETADATA            = 27
        bicepLexerEXISTING            = 28
        bicepLexerTYPE                = 29
        bicepLexerMODULE              = 30
        bicepLexerSTRING_LEFT_PIECE   = 31
        bicepLexerSTRING_MIDDLE_PIECE = 32
        bicepLexerSTRING_RIGHT_PIECE  = 33
        bicepLexerSTRING_COMPLETE     = 34
        bicepLexerSTRING              = 35
        bicepLexerINT                 = 36
        bicepLexerBOOL                = 37
        bicepLexerIF                  = 38
        bicepLexerFOR                 = 39
        bicepLexerIN                  = 40
        bicepLexerQMARK               = 41
        bicepLexerGT                  = 42
        bicepLexerGTE                 = 43
        bicepLexerLT                  = 44
        bicepLexerLTE                 = 45
        bicepLexerEQ                  = 46
        bicepLexerNEQ                 = 47
        bicepLexerARROW               = 48
        bicepLexerIDENTIFIER          = 49
        bicepLexerNUMBER              = 50
        bicepLexerNL                  = 51
        bicepLexerSINGLE_LINE_COMMENT = 52
        bicepLexerMULTI_LINE_COMMENT  = 53
        bicepLexerSPACES              = 54
        bicepLexerUNKNOWN             = 55
)
</pre>
		
		<pre class="file" id="file69" style="display: none">// Code generated from bicep.g4 by ANTLR 4.13.1. DO NOT EDIT.

package parser // bicep

import (
        "fmt"
        "strconv"
        "sync"

        "github.com/antlr4-go/antlr/v4"
)

// Suppress unused import errors
var _ = fmt.Printf
var _ = strconv.Itoa
var _ = sync.Once{}

type bicepParser struct {
        *antlr.BaseParser
}

var BicepParserStaticData struct {
        once                   sync.Once
        serializedATN          []int32
        LiteralNames           []string
        SymbolicNames          []string
        RuleNames              []string
        PredictionContextCache *antlr.PredictionContextCache
        atn                    *antlr.ATN
        decisionToDFA          []*antlr.DFA
}

func bicepParserInit() <span class="cov1" title="2">{
        staticData := &amp;BicepParserStaticData
        staticData.LiteralNames = []string{
                "", "", "'@'", "','", "'['", "']'", "'('", "')'", "'.'", "'|'", "",
                "'='", "'{'", "'}'", "'param'", "'var'", "'true'", "'false'", "'null'",
                "'array'", "'object'", "'resource'", "'output'", "'targetScope'", "'import'",
                "'with'", "'as'", "'metadata'", "'existing'", "'type'", "'module'",
                "", "", "", "", "'string'", "'int'", "'bool'", "'if'", "'for'", "'in'",
                "'?'", "'&gt;'", "'&gt;='", "'&lt;'", "'&lt;='", "'=='", "'!='", "'=&gt;'",
        }
        staticData.SymbolicNames = []string{
                "", "MULTILINE_STRING", "AT", "COMMA", "OBRACK", "CBRACK", "OPAR", "CPAR",
                "DOT", "PIPE", "COL", "ASSIGN", "OBRACE", "CBRACE", "PARAM", "VAR",
                "TRUE", "FALSE", "NULL", "ARRAY", "OBJECT", "RESOURCE", "OUTPUT", "TARGET_SCOPE",
                "IMPORT", "WITH", "AS", "METADATA", "EXISTING", "TYPE", "MODULE", "STRING_LEFT_PIECE",
                "STRING_MIDDLE_PIECE", "STRING_RIGHT_PIECE", "STRING_COMPLETE", "STRING",
                "INT", "BOOL", "IF", "FOR", "IN", "QMARK", "GT", "GTE", "LT", "LTE",
                "EQ", "NEQ", "ARROW", "IDENTIFIER", "NUMBER", "NL", "SINGLE_LINE_COMMENT",
                "MULTI_LINE_COMMENT", "SPACES", "UNKNOWN",
        }
        staticData.RuleNames = []string{
                "program", "statement", "targetScopeDecl", "importDecl", "metadataDecl",
                "parameterDecl", "parameterDefaultValue", "typeDecl", "variableDecl",
                "resourceDecl", "moduleDecl", "outputDecl", "ifCondition", "forExpression",
                "forVariableBlock", "forBody", "interpString", "expression", "lambdaExpression",
                "logicCharacter", "primaryExpression", "parenthesizedExpression", "typeExpression",
                "literalValue", "object", "objectProperty", "array", "arrayItem", "decorator",
                "decoratorExpression", "functionCall", "argumentList", "identifier",
        }
        staticData.PredictionContextCache = antlr.NewPredictionContextCache()
        staticData.serializedATN = []int32{
                4, 1, 55, 436, 2, 0, 7, 0, 2, 1, 7, 1, 2, 2, 7, 2, 2, 3, 7, 3, 2, 4, 7,
                4, 2, 5, 7, 5, 2, 6, 7, 6, 2, 7, 7, 7, 2, 8, 7, 8, 2, 9, 7, 9, 2, 10, 7,
                10, 2, 11, 7, 11, 2, 12, 7, 12, 2, 13, 7, 13, 2, 14, 7, 14, 2, 15, 7, 15,
                2, 16, 7, 16, 2, 17, 7, 17, 2, 18, 7, 18, 2, 19, 7, 19, 2, 20, 7, 20, 2,
                21, 7, 21, 2, 22, 7, 22, 2, 23, 7, 23, 2, 24, 7, 24, 2, 25, 7, 25, 2, 26,
                7, 26, 2, 27, 7, 27, 2, 28, 7, 28, 2, 29, 7, 29, 2, 30, 7, 30, 2, 31, 7,
                31, 2, 32, 7, 32, 1, 0, 5, 0, 68, 8, 0, 10, 0, 12, 0, 71, 9, 0, 1, 0, 1,
                0, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 3, 1, 85,
                8, 1, 1, 2, 1, 2, 1, 2, 1, 2, 1, 2, 1, 3, 5, 3, 93, 8, 3, 10, 3, 12, 3,
                96, 9, 3, 1, 3, 1, 3, 1, 3, 1, 3, 1, 3, 1, 3, 5, 3, 104, 8, 3, 10, 3, 12,
                3, 107, 9, 3, 1, 3, 1, 3, 1, 4, 1, 4, 1, 4, 1, 4, 1, 4, 1, 4, 1, 5, 5,
                5, 118, 8, 5, 10, 5, 12, 5, 121, 9, 5, 1, 5, 1, 5, 1, 5, 1, 5, 3, 5, 127,
                8, 5, 1, 5, 1, 5, 1, 5, 3, 5, 132, 8, 5, 3, 5, 134, 8, 5, 1, 5, 1, 5, 1,
                6, 1, 6, 1, 6, 1, 7, 5, 7, 142, 8, 7, 10, 7, 12, 7, 145, 9, 7, 1, 7, 1,
                7, 1, 7, 1, 7, 1, 7, 1, 7, 1, 8, 5, 8, 154, 8, 8, 10, 8, 12, 8, 157, 9,
                8, 1, 8, 1, 8, 1, 8, 1, 8, 1, 8, 1, 8, 1, 9, 5, 9, 166, 8, 9, 10, 9, 12,
                9, 169, 9, 9, 1, 9, 1, 9, 1, 9, 1, 9, 3, 9, 175, 8, 9, 1, 9, 1, 9, 1, 9,
                1, 9, 3, 9, 181, 8, 9, 1, 9, 1, 9, 1, 10, 5, 10, 186, 8, 10, 10, 10, 12,
                10, 189, 9, 10, 1, 10, 1, 10, 1, 10, 1, 10, 1, 10, 1, 10, 1, 10, 3, 10,
                198, 8, 10, 1, 10, 1, 10, 1, 11, 5, 11, 203, 8, 11, 10, 11, 12, 11, 206,
                9, 11, 1, 11, 1, 11, 1, 11, 1, 11, 1, 11, 3, 11, 213, 8, 11, 1, 11, 1,
                11, 1, 11, 1, 11, 1, 12, 1, 12, 1, 12, 1, 12, 1, 13, 1, 13, 5, 13, 225,
                8, 13, 10, 13, 12, 13, 228, 9, 13, 1, 13, 1, 13, 1, 13, 3, 13, 233, 8,
                13, 1, 13, 1, 13, 1, 13, 1, 13, 1, 13, 5, 13, 240, 8, 13, 10, 13, 12, 13,
                243, 9, 13, 1, 13, 1, 13, 1, 14, 1, 14, 1, 14, 1, 14, 1, 14, 1, 14, 1,
                15, 1, 15, 3, 15, 255, 8, 15, 1, 16, 1, 16, 1, 16, 1, 16, 5, 16, 261, 8,
                16, 10, 16, 12, 16, 264, 9, 16, 1, 16, 1, 16, 1, 16, 1, 16, 3, 16, 270,
                8, 16, 1, 17, 1, 17, 1, 17, 1, 17, 1, 17, 1, 17, 1, 17, 1, 17, 1, 17, 1,
                17, 1, 17, 1, 17, 1, 17, 1, 17, 1, 17, 1, 17, 1, 17, 1, 17, 1, 17, 1, 17,
                1, 17, 1, 17, 1, 17, 1, 17, 1, 17, 1, 17, 1, 17, 5, 17, 299, 8, 17, 10,
                17, 12, 17, 302, 9, 17, 1, 18, 1, 18, 3, 18, 306, 8, 18, 1, 18, 1, 18,
                3, 18, 310, 8, 18, 1, 18, 1, 18, 1, 18, 1, 19, 1, 19, 1, 20, 1, 20, 1,
                20, 1, 20, 1, 20, 1, 20, 1, 20, 1, 20, 1, 20, 3, 20, 326, 8, 20, 1, 21,
                1, 21, 3, 21, 330, 8, 21, 1, 21, 1, 21, 3, 21, 334, 8, 21, 1, 21, 1, 21,
                1, 22, 1, 22, 1, 23, 1, 23, 1, 23, 1, 23, 1, 23, 3, 23, 345, 8, 23, 1,
                24, 1, 24, 4, 24, 349, 8, 24, 11, 24, 12, 24, 350, 1, 24, 1, 24, 4, 24,
                355, 8, 24, 11, 24, 12, 24, 356, 5, 24, 359, 8, 24, 10, 24, 12, 24, 362,
                9, 24, 3, 24, 364, 8, 24, 1, 24, 1, 24, 1, 25, 1, 25, 3, 25, 370, 8, 25,
                1, 25, 1, 25, 1, 25, 1, 26, 1, 26, 5, 26, 377, 8, 26, 10, 26, 12, 26, 380,
                9, 26, 1, 26, 5, 26, 383, 8, 26, 10, 26, 12, 26, 386, 9, 26, 1, 26, 1,
                26, 1, 27, 1, 27, 4, 27, 392, 8, 27, 11, 27, 12, 27, 393, 1, 27, 3, 27,
                397, 8, 27, 1, 28, 1, 28, 1, 28, 1, 28, 1, 29, 1, 29, 1, 29, 1, 29, 1,
                29, 3, 29, 408, 8, 29, 1, 30, 1, 30, 1, 30, 3, 30, 413, 8, 30, 1, 30, 3,
                30, 416, 8, 30, 1, 30, 3, 30, 419, 8, 30, 1, 30, 1, 30, 1, 31, 1, 31, 1,
                31, 3, 31, 426, 8, 31, 1, 31, 5, 31, 429, 8, 31, 10, 31, 12, 31, 432, 9,
                31, 1, 32, 1, 32, 1, 32, 0, 1, 34, 33, 0, 2, 4, 6, 8, 10, 12, 14, 16, 18,
                20, 22, 24, 26, 28, 30, 32, 34, 36, 38, 40, 42, 44, 46, 48, 50, 52, 54,
                56, 58, 60, 62, 64, 0, 2, 1, 0, 42, 47, 3, 0, 14, 30, 35, 40, 49, 49, 474,
                0, 69, 1, 0, 0, 0, 2, 84, 1, 0, 0, 0, 4, 86, 1, 0, 0, 0, 6, 94, 1, 0, 0,
                0, 8, 110, 1, 0, 0, 0, 10, 119, 1, 0, 0, 0, 12, 137, 1, 0, 0, 0, 14, 143,
                1, 0, 0, 0, 16, 155, 1, 0, 0, 0, 18, 167, 1, 0, 0, 0, 20, 187, 1, 0, 0,
                0, 22, 204, 1, 0, 0, 0, 24, 218, 1, 0, 0, 0, 26, 222, 1, 0, 0, 0, 28, 246,
                1, 0, 0, 0, 30, 254, 1, 0, 0, 0, 32, 269, 1, 0, 0, 0, 34, 271, 1, 0, 0,
                0, 36, 309, 1, 0, 0, 0, 38, 314, 1, 0, 0, 0, 40, 325, 1, 0, 0, 0, 42, 327,
                1, 0, 0, 0, 44, 337, 1, 0, 0, 0, 46, 344, 1, 0, 0, 0, 48, 346, 1, 0, 0,
                0, 50, 369, 1, 0, 0, 0, 52, 374, 1, 0, 0, 0, 54, 389, 1, 0, 0, 0, 56, 398,
                1, 0, 0, 0, 58, 407, 1, 0, 0, 0, 60, 409, 1, 0, 0, 0, 62, 422, 1, 0, 0,
                0, 64, 433, 1, 0, 0, 0, 66, 68, 3, 2, 1, 0, 67, 66, 1, 0, 0, 0, 68, 71,
                1, 0, 0, 0, 69, 67, 1, 0, 0, 0, 69, 70, 1, 0, 0, 0, 70, 72, 1, 0, 0, 0,
                71, 69, 1, 0, 0, 0, 72, 73, 5, 0, 0, 1, 73, 1, 1, 0, 0, 0, 74, 85, 3, 4,
                2, 0, 75, 85, 3, 6, 3, 0, 76, 85, 3, 8, 4, 0, 77, 85, 3, 10, 5, 0, 78,
                85, 3, 14, 7, 0, 79, 85, 3, 16, 8, 0, 80, 85, 3, 18, 9, 0, 81, 85, 3, 20,
                10, 0, 82, 85, 3, 22, 11, 0, 83, 85, 5, 51, 0, 0, 84, 74, 1, 0, 0, 0, 84,
                75, 1, 0, 0, 0, 84, 76, 1, 0, 0, 0, 84, 77, 1, 0, 0, 0, 84, 78, 1, 0, 0,
                0, 84, 79, 1, 0, 0, 0, 84, 80, 1, 0, 0, 0, 84, 81, 1, 0, 0, 0, 84, 82,
                1, 0, 0, 0, 84, 83, 1, 0, 0, 0, 85, 3, 1, 0, 0, 0, 86, 87, 5, 23, 0, 0,
                87, 88, 5, 11, 0, 0, 88, 89, 3, 34, 17, 0, 89, 90, 5, 51, 0, 0, 90, 5,
                1, 0, 0, 0, 91, 93, 3, 56, 28, 0, 92, 91, 1, 0, 0, 0, 93, 96, 1, 0, 0,
                0, 94, 92, 1, 0, 0, 0, 94, 95, 1, 0, 0, 0, 95, 97, 1, 0, 0, 0, 96, 94,
                1, 0, 0, 0, 97, 98, 5, 24, 0, 0, 98, 105, 3, 32, 16, 0, 99, 100, 5, 25,
                0, 0, 100, 104, 3, 48, 24, 0, 101, 102, 5, 26, 0, 0, 102, 104, 3, 64, 32,
                0, 103, 99, 1, 0, 0, 0, 103, 101, 1, 0, 0, 0, 104, 107, 1, 0, 0, 0, 105,
                103, 1, 0, 0, 0, 105, 106, 1, 0, 0, 0, 106, 108, 1, 0, 0, 0, 107, 105,
                1, 0, 0, 0, 108, 109, 5, 51, 0, 0, 109, 7, 1, 0, 0, 0, 110, 111, 5, 27,
                0, 0, 111, 112, 3, 64, 32, 0, 112, 113, 5, 11, 0, 0, 113, 114, 3, 34, 17,
                0, 114, 115, 5, 51, 0, 0, 115, 9, 1, 0, 0, 0, 116, 118, 3, 56, 28, 0, 117,
                116, 1, 0, 0, 0, 118, 121, 1, 0, 0, 0, 119, 117, 1, 0, 0, 0, 119, 120,
                1, 0, 0, 0, 120, 122, 1, 0, 0, 0, 121, 119, 1, 0, 0, 0, 122, 123, 5, 14,
                0, 0, 123, 133, 3, 64, 32, 0, 124, 126, 3, 44, 22, 0, 125, 127, 3, 12,
                6, 0, 126, 125, 1, 0, 0, 0, 126, 127, 1, 0, 0, 0, 127, 134, 1, 0, 0, 0,
                128, 129, 5, 21, 0, 0, 129, 131, 3, 32, 16, 0, 130, 132, 3, 12, 6, 0, 131,
                130, 1, 0, 0, 0, 131, 132, 1, 0, 0, 0, 132, 134, 1, 0, 0, 0, 133, 124,
                1, 0, 0, 0, 133, 128, 1, 0, 0, 0, 134, 135, 1, 0, 0, 0, 135, 136, 5, 51,
                0, 0, 136, 11, 1, 0, 0, 0, 137, 138, 5, 11, 0, 0, 138, 139, 3, 34, 17,
                0, 139, 13, 1, 0, 0, 0, 140, 142, 3, 56, 28, 0, 141, 140, 1, 0, 0, 0, 142,
                145, 1, 0, 0, 0, 143, 141, 1, 0, 0, 0, 143, 144, 1, 0, 0, 0, 144, 146,
                1, 0, 0, 0, 145, 143, 1, 0, 0, 0, 146, 147, 5, 29, 0, 0, 147, 148, 3, 64,
                32, 0, 148, 149, 5, 11, 0, 0, 149, 150, 3, 44, 22, 0, 150, 151, 5, 51,
                0, 0, 151, 15, 1, 0, 0, 0, 152, 154, 3, 56, 28, 0, 153, 152, 1, 0, 0, 0,
                154, 157, 1, 0, 0, 0, 155, 153, 1, 0, 0, 0, 155, 156, 1, 0, 0, 0, 156,
                158, 1, 0, 0, 0, 157, 155, 1, 0, 0, 0, 158, 159, 5, 15, 0, 0, 159, 160,
                3, 64, 32, 0, 160, 161, 5, 11, 0, 0, 161, 162, 3, 34, 17, 0, 162, 163,
                5, 51, 0, 0, 163, 17, 1, 0, 0, 0, 164, 166, 3, 56, 28, 0, 165, 164, 1,
                0, 0, 0, 166, 169, 1, 0, 0, 0, 167, 165, 1, 0, 0, 0, 167, 168, 1, 0, 0,
                0, 168, 170, 1, 0, 0, 0, 169, 167, 1, 0, 0, 0, 170, 171, 5, 21, 0, 0, 171,
                172, 3, 64, 32, 0, 172, 174, 3, 32, 16, 0, 173, 175, 5, 28, 0, 0, 174,
                173, 1, 0, 0, 0, 174, 175, 1, 0, 0, 0, 175, 176, 1, 0, 0, 0, 176, 180,
                5, 11, 0, 0, 177, 181, 3, 24, 12, 0, 178, 181, 3, 48, 24, 0, 179, 181,
                3, 26, 13, 0, 180, 177, 1, 0, 0, 0, 180, 178, 1, 0, 0, 0, 180, 179, 1,
                0, 0, 0, 181, 182, 1, 0, 0, 0, 182, 183, 5, 51, 0, 0, 183, 19, 1, 0, 0,
                0, 184, 186, 3, 56, 28, 0, 185, 184, 1, 0, 0, 0, 186, 189, 1, 0, 0, 0,
                187, 185, 1, 0, 0, 0, 187, 188, 1, 0, 0, 0, 188, 190, 1, 0, 0, 0, 189,
                187, 1, 0, 0, 0, 190, 191, 5, 30, 0, 0, 191, 192, 3, 64, 32, 0, 192, 193,
                3, 32, 16, 0, 193, 197, 5, 11, 0, 0, 194, 198, 3, 24, 12, 0, 195, 198,
                3, 48, 24, 0, 196, 198, 3, 26, 13, 0, 197, 194, 1, 0, 0, 0, 197, 195, 1,
                0, 0, 0, 197, 196, 1, 0, 0, 0, 198, 199, 1, 0, 0, 0, 199, 200, 5, 51, 0,
                0, 200, 21, 1, 0, 0, 0, 201, 203, 3, 56, 28, 0, 202, 201, 1, 0, 0, 0, 203,
                206, 1, 0, 0, 0, 204, 202, 1, 0, 0, 0, 204, 205, 1, 0, 0, 0, 205, 207,
                1, 0, 0, 0, 206, 204, 1, 0, 0, 0, 207, 208, 5, 22, 0, 0, 208, 212, 3, 64,
                32, 0, 209, 213, 3, 64, 32, 0, 210, 211, 5, 21, 0, 0, 211, 213, 3, 32,
                16, 0, 212, 209, 1, 0, 0, 0, 212, 210, 1, 0, 0, 0, 213, 214, 1, 0, 0, 0,
                214, 215, 5, 11, 0, 0, 215, 216, 3, 34, 17, 0, 216, 217, 5, 51, 0, 0, 217,
                23, 1, 0, 0, 0, 218, 219, 5, 38, 0, 0, 219, 220, 3, 42, 21, 0, 220, 221,
                3, 48, 24, 0, 221, 25, 1, 0, 0, 0, 222, 226, 5, 4, 0, 0, 223, 225, 5, 51,
                0, 0, 224, 223, 1, 0, 0, 0, 225, 228, 1, 0, 0, 0, 226, 224, 1, 0, 0, 0,
                226, 227, 1, 0, 0, 0, 227, 229, 1, 0, 0, 0, 228, 226, 1, 0, 0, 0, 229,
                232, 5, 39, 0, 0, 230, 233, 3, 64, 32, 0, 231, 233, 3, 28, 14, 0, 232,
                230, 1, 0, 0, 0, 232, 231, 1, 0, 0, 0, 233, 234, 1, 0, 0, 0, 234, 235,
                5, 40, 0, 0, 235, 236, 3, 34, 17, 0, 236, 237, 5, 10, 0, 0, 237, 241, 3,
                30, 15, 0, 238, 240, 5, 51, 0, 0, 239, 238, 1, 0, 0, 0, 240, 243, 1, 0,
                0, 0, 241, 239, 1, 0, 0, 0, 241, 242, 1, 0, 0, 0, 242, 244, 1, 0, 0, 0,
                243, 241, 1, 0, 0, 0, 244, 245, 5, 5, 0, 0, 245, 27, 1, 0, 0, 0, 246, 247,
                5, 6, 0, 0, 247, 248, 3, 64, 32, 0, 248, 249, 5, 3, 0, 0, 249, 250, 3,
                64, 32, 0, 250, 251, 5, 7, 0, 0, 251, 29, 1, 0, 0, 0, 252, 255, 3, 34,
                17, 0, 253, 255, 3, 24, 12, 0, 254, 252, 1, 0, 0, 0, 254, 253, 1, 0, 0,
                0, 255, 31, 1, 0, 0, 0, 256, 262, 5, 31, 0, 0, 257, 258, 3, 34, 17, 0,
                258, 259, 5, 32, 0, 0, 259, 261, 1, 0, 0, 0, 260, 257, 1, 0, 0, 0, 261,
                264, 1, 0, 0, 0, 262, 260, 1, 0, 0, 0, 262, 263, 1, 0, 0, 0, 263, 265,
                1, 0, 0, 0, 264, 262, 1, 0, 0, 0, 265, 266, 3, 34, 17, 0, 266, 267, 5,
                33, 0, 0, 267, 270, 1, 0, 0, 0, 268, 270, 5, 34, 0, 0, 269, 256, 1, 0,
                0, 0, 269, 268, 1, 0, 0, 0, 270, 33, 1, 0, 0, 0, 271, 272, 6, 17, -1, 0,
                272, 273, 3, 40, 20, 0, 273, 300, 1, 0, 0, 0, 274, 275, 10, 6, 0, 0, 275,
                276, 5, 41, 0, 0, 276, 277, 3, 34, 17, 0, 277, 278, 5, 10, 0, 0, 278, 279,
                3, 34, 17, 7, 279, 299, 1, 0, 0, 0, 280, 281, 10, 2, 0, 0, 281, 282, 3,
                38, 19, 0, 282, 283, 3, 34, 17, 3, 283, 299, 1, 0, 0, 0, 284, 285, 10,
                7, 0, 0, 285, 286, 5, 4, 0, 0, 286, 287, 3, 34, 17, 0, 287, 288, 5, 5,
                0, 0, 288, 299, 1, 0, 0, 0, 289, 290, 10, 5, 0, 0, 290, 291, 5, 8, 0, 0,
                291, 299, 3, 64, 32, 0, 292, 293, 10, 4, 0, 0, 293, 294, 5, 8, 0, 0, 294,
                299, 3, 60, 30, 0, 295, 296, 10, 3, 0, 0, 296, 297, 5, 10, 0, 0, 297, 299,
                3, 64, 32, 0, 298, 274, 1, 0, 0, 0, 298, 280, 1, 0, 0, 0, 298, 284, 1,
                0, 0, 0, 298, 289, 1, 0, 0, 0, 298, 292, 1, 0, 0, 0, 298, 295, 1, 0, 0,
                0, 299, 302, 1, 0, 0, 0, 300, 298, 1, 0, 0, 0, 300, 301, 1, 0, 0, 0, 301,
                35, 1, 0, 0, 0, 302, 300, 1, 0, 0, 0, 303, 305, 5, 6, 0, 0, 304, 306, 3,
                62, 31, 0, 305, 304, 1, 0, 0, 0, 305, 306, 1, 0, 0, 0, 306, 307, 1, 0,
                0, 0, 307, 310, 5, 7, 0, 0, 308, 310, 3, 64, 32, 0, 309, 303, 1, 0, 0,
                0, 309, 308, 1, 0, 0, 0, 310, 311, 1, 0, 0, 0, 311, 312, 5, 48, 0, 0, 312,
                313, 3, 34, 17, 0, 313, 37, 1, 0, 0, 0, 314, 315, 7, 0, 0, 0, 315, 39,
                1, 0, 0, 0, 316, 326, 3, 46, 23, 0, 317, 326, 3, 60, 30, 0, 318, 326, 3,
                32, 16, 0, 319, 326, 5, 1, 0, 0, 320, 326, 3, 52, 26, 0, 321, 326, 3, 48,
                24, 0, 322, 326, 3, 26, 13, 0, 323, 326, 3, 42, 21, 0, 324, 326, 3, 36,
                18, 0, 325, 316, 1, 0, 0, 0, 325, 317, 1, 0, 0, 0, 325, 318, 1, 0, 0, 0,
                325, 319, 1, 0, 0, 0, 325, 320, 1, 0, 0, 0, 325, 321, 1, 0, 0, 0, 325,
                322, 1, 0, 0, 0, 325, 323, 1, 0, 0, 0, 325, 324, 1, 0, 0, 0, 326, 41, 1,
                0, 0, 0, 327, 329, 5, 6, 0, 0, 328, 330, 5, 51, 0, 0, 329, 328, 1, 0, 0,
                0, 329, 330, 1, 0, 0, 0, 330, 331, 1, 0, 0, 0, 331, 333, 3, 34, 17, 0,
                332, 334, 5, 51, 0, 0, 333, 332, 1, 0, 0, 0, 333, 334, 1, 0, 0, 0, 334,
                335, 1, 0, 0, 0, 335, 336, 5, 7, 0, 0, 336, 43, 1, 0, 0, 0, 337, 338, 3,
                64, 32, 0, 338, 45, 1, 0, 0, 0, 339, 345, 5, 50, 0, 0, 340, 345, 5, 16,
                0, 0, 341, 345, 5, 17, 0, 0, 342, 345, 5, 18, 0, 0, 343, 345, 3, 64, 32,
                0, 344, 339, 1, 0, 0, 0, 344, 340, 1, 0, 0, 0, 344, 341, 1, 0, 0, 0, 344,
                342, 1, 0, 0, 0, 344, 343, 1, 0, 0, 0, 345, 47, 1, 0, 0, 0, 346, 363, 5,
                12, 0, 0, 347, 349, 5, 51, 0, 0, 348, 347, 1, 0, 0, 0, 349, 350, 1, 0,
                0, 0, 350, 348, 1, 0, 0, 0, 350, 351, 1, 0, 0, 0, 351, 360, 1, 0, 0, 0,
                352, 354, 3, 50, 25, 0, 353, 355, 5, 51, 0, 0, 354, 353, 1, 0, 0, 0, 355,
                356, 1, 0, 0, 0, 356, 354, 1, 0, 0, 0, 356, 357, 1, 0, 0, 0, 357, 359,
                1, 0, 0, 0, 358, 352, 1, 0, 0, 0, 359, 362, 1, 0, 0, 0, 360, 358, 1, 0,
                0, 0, 360, 361, 1, 0, 0, 0, 361, 364, 1, 0, 0, 0, 362, 360, 1, 0, 0, 0,
                363, 348, 1, 0, 0, 0, 363, 364, 1, 0, 0, 0, 364, 365, 1, 0, 0, 0, 365,
                366, 5, 13, 0, 0, 366, 49, 1, 0, 0, 0, 367, 370, 3, 64, 32, 0, 368, 370,
                3, 32, 16, 0, 369, 367, 1, 0, 0, 0, 369, 368, 1, 0, 0, 0, 370, 371, 1,
                0, 0, 0, 371, 372, 5, 10, 0, 0, 372, 373, 3, 34, 17, 0, 373, 51, 1, 0,
                0, 0, 374, 378, 5, 4, 0, 0, 375, 377, 5, 51, 0, 0, 376, 375, 1, 0, 0, 0,
                377, 380, 1, 0, 0, 0, 378, 376, 1, 0, 0, 0, 378, 379, 1, 0, 0, 0, 379,
                384, 1, 0, 0, 0, 380, 378, 1, 0, 0, 0, 381, 383, 3, 54, 27, 0, 382, 381,
                1, 0, 0, 0, 383, 386, 1, 0, 0, 0, 384, 382, 1, 0, 0, 0, 384, 385, 1, 0,
                0, 0, 385, 387, 1, 0, 0, 0, 386, 384, 1, 0, 0, 0, 387, 388, 5, 5, 0, 0,
                388, 53, 1, 0, 0, 0, 389, 396, 3, 34, 17, 0, 390, 392, 5, 51, 0, 0, 391,
                390, 1, 0, 0, 0, 392, 393, 1, 0, 0, 0, 393, 391, 1, 0, 0, 0, 393, 394,
                1, 0, 0, 0, 394, 397, 1, 0, 0, 0, 395, 397, 5, 3, 0, 0, 396, 391, 1, 0,
                0, 0, 396, 395, 1, 0, 0, 0, 396, 397, 1, 0, 0, 0, 397, 55, 1, 0, 0, 0,
                398, 399, 5, 2, 0, 0, 399, 400, 3, 58, 29, 0, 400, 401, 5, 51, 0, 0, 401,
                57, 1, 0, 0, 0, 402, 408, 3, 60, 30, 0, 403, 404, 3, 34, 17, 0, 404, 405,
                5, 8, 0, 0, 405, 406, 3, 60, 30, 0, 406, 408, 1, 0, 0, 0, 407, 402, 1,
                0, 0, 0, 407, 403, 1, 0, 0, 0, 408, 59, 1, 0, 0, 0, 409, 410, 3, 64, 32,
                0, 410, 415, 5, 6, 0, 0, 411, 413, 5, 51, 0, 0, 412, 411, 1, 0, 0, 0, 412,
                413, 1, 0, 0, 0, 413, 414, 1, 0, 0, 0, 414, 416, 3, 62, 31, 0, 415, 412,
                1, 0, 0, 0, 415, 416, 1, 0, 0, 0, 416, 418, 1, 0, 0, 0, 417, 419, 5, 51,
                0, 0, 418, 417, 1, 0, 0, 0, 418, 419, 1, 0, 0, 0, 419, 420, 1, 0, 0, 0,
                420, 421, 5, 7, 0, 0, 421, 61, 1, 0, 0, 0, 422, 430, 3, 34, 17, 0, 423,
                425, 5, 3, 0, 0, 424, 426, 5, 51, 0, 0, 425, 424, 1, 0, 0, 0, 425, 426,
                1, 0, 0, 0, 426, 427, 1, 0, 0, 0, 427, 429, 3, 34, 17, 0, 428, 423, 1,
                0, 0, 0, 429, 432, 1, 0, 0, 0, 430, 428, 1, 0, 0, 0, 430, 431, 1, 0, 0,
                0, 431, 63, 1, 0, 0, 0, 432, 430, 1, 0, 0, 0, 433, 434, 7, 1, 0, 0, 434,
                65, 1, 0, 0, 0, 47, 69, 84, 94, 103, 105, 119, 126, 131, 133, 143, 155,
                167, 174, 180, 187, 197, 204, 212, 226, 232, 241, 254, 262, 269, 298, 300,
                305, 309, 325, 329, 333, 344, 350, 356, 360, 363, 369, 378, 384, 393, 396,
                407, 412, 415, 418, 425, 430,
        }
        deserializer := antlr.NewATNDeserializer(nil)
        staticData.atn = deserializer.Deserialize(staticData.serializedATN)
        atn := staticData.atn
        staticData.decisionToDFA = make([]*antlr.DFA, len(atn.DecisionToState))
        decisionToDFA := staticData.decisionToDFA
        for index, state := range atn.DecisionToState </span><span class="cov4" title="94">{
                decisionToDFA[index] = antlr.NewDFA(state, index)
        }</span>
}

// bicepParserInit initializes any static state used to implement bicepParser. By default the
// static state used to implement the parser is lazily initialized during the first call to
// NewbicepParser(). You can call this function if you wish to initialize the static state ahead
// of time.
func BicepParserInit() <span class="cov6" title="538">{
        staticData := &amp;BicepParserStaticData
        staticData.once.Do(bicepParserInit)
}</span>

// NewbicepParser produces a new parser instance for the optional input antlr.TokenStream.
func NewbicepParser(input antlr.TokenStream) *bicepParser <span class="cov6" title="538">{
        BicepParserInit()
        this := new(bicepParser)
        this.BaseParser = antlr.NewBaseParser(input)
        staticData := &amp;BicepParserStaticData
        this.Interpreter = antlr.NewParserATNSimulator(this, staticData.atn, staticData.decisionToDFA, staticData.PredictionContextCache)
        this.RuleNames = staticData.RuleNames
        this.LiteralNames = staticData.LiteralNames
        this.SymbolicNames = staticData.SymbolicNames
        this.GrammarFileName = "bicep.g4"

        return this
}</span>

// bicepParser tokens.
const (
        bicepParserEOF                 = antlr.TokenEOF
        bicepParserMULTILINE_STRING    = 1
        bicepParserAT                  = 2
        bicepParserCOMMA               = 3
        bicepParserOBRACK              = 4
        bicepParserCBRACK              = 5
        bicepParserOPAR                = 6
        bicepParserCPAR                = 7
        bicepParserDOT                 = 8
        bicepParserPIPE                = 9
        bicepParserCOL                 = 10
        bicepParserASSIGN              = 11
        bicepParserOBRACE              = 12
        bicepParserCBRACE              = 13
        bicepParserPARAM               = 14
        bicepParserVAR                 = 15
        bicepParserTRUE                = 16
        bicepParserFALSE               = 17
        bicepParserNULL                = 18
        bicepParserARRAY               = 19
        bicepParserOBJECT              = 20
        bicepParserRESOURCE            = 21
        bicepParserOUTPUT              = 22
        bicepParserTARGET_SCOPE        = 23
        bicepParserIMPORT              = 24
        bicepParserWITH                = 25
        bicepParserAS                  = 26
        bicepParserMETADATA            = 27
        bicepParserEXISTING            = 28
        bicepParserTYPE                = 29
        bicepParserMODULE              = 30
        bicepParserSTRING_LEFT_PIECE   = 31
        bicepParserSTRING_MIDDLE_PIECE = 32
        bicepParserSTRING_RIGHT_PIECE  = 33
        bicepParserSTRING_COMPLETE     = 34
        bicepParserSTRING              = 35
        bicepParserINT                 = 36
        bicepParserBOOL                = 37
        bicepParserIF                  = 38
        bicepParserFOR                 = 39
        bicepParserIN                  = 40
        bicepParserQMARK               = 41
        bicepParserGT                  = 42
        bicepParserGTE                 = 43
        bicepParserLT                  = 44
        bicepParserLTE                 = 45
        bicepParserEQ                  = 46
        bicepParserNEQ                 = 47
        bicepParserARROW               = 48
        bicepParserIDENTIFIER          = 49
        bicepParserNUMBER              = 50
        bicepParserNL                  = 51
        bicepParserSINGLE_LINE_COMMENT = 52
        bicepParserMULTI_LINE_COMMENT  = 53
        bicepParserSPACES              = 54
        bicepParserUNKNOWN             = 55
)

// bicepParser rules.
const (
        bicepParserRULE_program                 = 0
        bicepParserRULE_statement               = 1
        bicepParserRULE_targetScopeDecl         = 2
        bicepParserRULE_importDecl              = 3
        bicepParserRULE_metadataDecl            = 4
        bicepParserRULE_parameterDecl           = 5
        bicepParserRULE_parameterDefaultValue   = 6
        bicepParserRULE_typeDecl                = 7
        bicepParserRULE_variableDecl            = 8
        bicepParserRULE_resourceDecl            = 9
        bicepParserRULE_moduleDecl              = 10
        bicepParserRULE_outputDecl              = 11
        bicepParserRULE_ifCondition             = 12
        bicepParserRULE_forExpression           = 13
        bicepParserRULE_forVariableBlock        = 14
        bicepParserRULE_forBody                 = 15
        bicepParserRULE_interpString            = 16
        bicepParserRULE_expression              = 17
        bicepParserRULE_lambdaExpression        = 18
        bicepParserRULE_logicCharacter          = 19
        bicepParserRULE_primaryExpression       = 20
        bicepParserRULE_parenthesizedExpression = 21
        bicepParserRULE_typeExpression          = 22
        bicepParserRULE_literalValue            = 23
        bicepParserRULE_object                  = 24
        bicepParserRULE_objectProperty          = 25
        bicepParserRULE_array                   = 26
        bicepParserRULE_arrayItem               = 27
        bicepParserRULE_decorator               = 28
        bicepParserRULE_decoratorExpression     = 29
        bicepParserRULE_functionCall            = 30
        bicepParserRULE_argumentList            = 31
        bicepParserRULE_identifier              = 32
)

// IProgramContext is an interface to support dynamic dispatch.
type IProgramContext interface {
        antlr.ParserRuleContext

        // GetParser returns the parser.
        GetParser() antlr.Parser

        // Getter signatures
        EOF() antlr.TerminalNode
        AllStatement() []IStatementContext
        Statement(i int) IStatementContext

        // IsProgramContext differentiates from other interfaces.
        IsProgramContext()
}

type ProgramContext struct {
        antlr.BaseParserRuleContext
        parser antlr.Parser
}

func NewEmptyProgramContext() *ProgramContext <span class="cov0" title="0">{
        var p = new(ProgramContext)
        antlr.InitBaseParserRuleContext(&amp;p.BaseParserRuleContext, nil, -1)
        p.RuleIndex = bicepParserRULE_program
        return p
}</span>

func InitEmptyProgramContext(p *ProgramContext) <span class="cov0" title="0">{
        antlr.InitBaseParserRuleContext(&amp;p.BaseParserRuleContext, nil, -1)
        p.RuleIndex = bicepParserRULE_program
}</span>

func (*ProgramContext) IsProgramContext() {<span class="cov0" title="0">}</span>

func NewProgramContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *ProgramContext <span class="cov6" title="538">{
        var p = new(ProgramContext)

        antlr.InitBaseParserRuleContext(&amp;p.BaseParserRuleContext, parent, invokingState)

        p.parser = parser
        p.RuleIndex = bicepParserRULE_program

        return p
}</span>

func (s *ProgramContext) GetParser() antlr.Parser <span class="cov0" title="0">{ return s.parser }</span>

func (s *ProgramContext) EOF() antlr.TerminalNode <span class="cov0" title="0">{
        return s.GetToken(bicepParserEOF, 0)
}</span>

func (s *ProgramContext) AllStatement() []IStatementContext <span class="cov6" title="538">{
        children := s.GetChildren()
        len := 0
        for _, ctx := range children </span><span class="cov7" title="1914">{
                if _, ok := ctx.(IStatementContext); ok </span><span class="cov6" title="1239">{
                        len++
                }</span>
        }

        <span class="cov6" title="538">tst := make([]IStatementContext, len)
        i := 0
        for _, ctx := range children </span><span class="cov7" title="1914">{
                if t, ok := ctx.(IStatementContext); ok </span><span class="cov6" title="1239">{
                        tst[i] = t.(IStatementContext)
                        i++
                }</span>
        }

        <span class="cov6" title="538">return tst</span>
}

func (s *ProgramContext) Statement(i int) IStatementContext <span class="cov0" title="0">{
        var t antlr.RuleContext
        j := 0
        for _, ctx := range s.GetChildren() </span><span class="cov0" title="0">{
                if _, ok := ctx.(IStatementContext); ok </span><span class="cov0" title="0">{
                        if j == i </span><span class="cov0" title="0">{
                                t = ctx.(antlr.RuleContext)
                                break</span>
                        }
                        <span class="cov0" title="0">j++</span>
                }
        }

        <span class="cov0" title="0">if t == nil </span><span class="cov0" title="0">{
                return nil
        }</span>

        <span class="cov0" title="0">return t.(IStatementContext)</span>
}

func (s *ProgramContext) GetRuleContext() antlr.RuleContext <span class="cov0" title="0">{
        return s
}</span>

func (s *ProgramContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string <span class="cov0" title="0">{
        return antlr.TreesStringTree(s, ruleNames, recog)
}</span>

func (s *ProgramContext) Accept(visitor antlr.ParseTreeVisitor) interface{} <span class="cov6" title="538">{
        switch t := visitor.(type) </span>{
        case bicepVisitor:<span class="cov6" title="538">
                return t.VisitProgram(s)</span>

        default:<span class="cov0" title="0">
                return t.VisitChildren(s)</span>
        }
}

func (p *bicepParser) Program() (localctx IProgramContext) <span class="cov6" title="538">{
        localctx = NewProgramContext(p, p.GetParserRuleContext(), p.GetState())
        p.EnterRule(localctx, 0, bicepParserRULE_program)
        var _la int

        p.EnterOuterAlt(localctx, 1)
        p.SetState(69)
        p.GetErrorHandler().Sync(p)
        if p.HasError() </span><span class="cov0" title="0">{
                goto errorExit</span>
        }
        <span class="cov6" title="538">_la = p.GetTokenStream().LA(1)

        for (int64(_la) &amp; ^0x3f) == 0 &amp;&amp; ((int64(1)&lt;&lt;_la)&amp;2251801590022148) != 0 </span><span class="cov6" title="1239">{
                </span><span class="cov6" title="1239">{
                        p.SetState(66)
                        p.Statement()
                }</span>

                <span class="cov6" title="1239">p.SetState(71)
                p.GetErrorHandler().Sync(p)
                if p.HasError() </span><span class="cov0" title="0">{
                        goto errorExit</span>
                }
                <span class="cov6" title="1239">_la = p.GetTokenStream().LA(1)</span>
        }
        <span class="cov6" title="538">{
                p.SetState(72)
                p.Match(bicepParserEOF)
                if p.HasError() </span><span class="cov0" title="0">{
                        // Recognition error - abort rule
                        goto errorExit</span>
                }
        }

errorExit:
        <span class="cov6" title="538">if p.HasError() </span><span class="cov0" title="0">{
                v := p.GetError()
                localctx.SetException(v)
                p.GetErrorHandler().ReportError(p, v)
                p.GetErrorHandler().Recover(p, v)
                p.SetError(nil)
        }</span>
        <span class="cov6" title="538">p.ExitRule()
        return localctx
        goto errorExit</span> // Trick to prevent compiler error if the label is not used
}

// IStatementContext is an interface to support dynamic dispatch.
type IStatementContext interface {
        antlr.ParserRuleContext

        // GetParser returns the parser.
        GetParser() antlr.Parser

        // Getter signatures
        TargetScopeDecl() ITargetScopeDeclContext
        ImportDecl() IImportDeclContext
        MetadataDecl() IMetadataDeclContext
        ParameterDecl() IParameterDeclContext
        TypeDecl() ITypeDeclContext
        VariableDecl() IVariableDeclContext
        ResourceDecl() IResourceDeclContext
        ModuleDecl() IModuleDeclContext
        OutputDecl() IOutputDeclContext
        NL() antlr.TerminalNode

        // IsStatementContext differentiates from other interfaces.
        IsStatementContext()
}

type StatementContext struct {
        antlr.BaseParserRuleContext
        parser antlr.Parser
}

func NewEmptyStatementContext() *StatementContext <span class="cov0" title="0">{
        var p = new(StatementContext)
        antlr.InitBaseParserRuleContext(&amp;p.BaseParserRuleContext, nil, -1)
        p.RuleIndex = bicepParserRULE_statement
        return p
}</span>

func InitEmptyStatementContext(p *StatementContext) <span class="cov0" title="0">{
        antlr.InitBaseParserRuleContext(&amp;p.BaseParserRuleContext, nil, -1)
        p.RuleIndex = bicepParserRULE_statement
}</span>

func (*StatementContext) IsStatementContext() {<span class="cov0" title="0">}</span>

func NewStatementContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *StatementContext <span class="cov6" title="1239">{
        var p = new(StatementContext)

        antlr.InitBaseParserRuleContext(&amp;p.BaseParserRuleContext, parent, invokingState)

        p.parser = parser
        p.RuleIndex = bicepParserRULE_statement

        return p
}</span>

func (s *StatementContext) GetParser() antlr.Parser <span class="cov0" title="0">{ return s.parser }</span>

func (s *StatementContext) TargetScopeDecl() ITargetScopeDeclContext <span class="cov0" title="0">{
        var t antlr.RuleContext
        for _, ctx := range s.GetChildren() </span><span class="cov0" title="0">{
                if _, ok := ctx.(ITargetScopeDeclContext); ok </span><span class="cov0" title="0">{
                        t = ctx.(antlr.RuleContext)
                        break</span>
                }
        }

        <span class="cov0" title="0">if t == nil </span><span class="cov0" title="0">{
                return nil
        }</span>

        <span class="cov0" title="0">return t.(ITargetScopeDeclContext)</span>
}

func (s *StatementContext) ImportDecl() IImportDeclContext <span class="cov0" title="0">{
        var t antlr.RuleContext
        for _, ctx := range s.GetChildren() </span><span class="cov0" title="0">{
                if _, ok := ctx.(IImportDeclContext); ok </span><span class="cov0" title="0">{
                        t = ctx.(antlr.RuleContext)
                        break</span>
                }
        }

        <span class="cov0" title="0">if t == nil </span><span class="cov0" title="0">{
                return nil
        }</span>

        <span class="cov0" title="0">return t.(IImportDeclContext)</span>
}

func (s *StatementContext) MetadataDecl() IMetadataDeclContext <span class="cov0" title="0">{
        var t antlr.RuleContext
        for _, ctx := range s.GetChildren() </span><span class="cov0" title="0">{
                if _, ok := ctx.(IMetadataDeclContext); ok </span><span class="cov0" title="0">{
                        t = ctx.(antlr.RuleContext)
                        break</span>
                }
        }

        <span class="cov0" title="0">if t == nil </span><span class="cov0" title="0">{
                return nil
        }</span>

        <span class="cov0" title="0">return t.(IMetadataDeclContext)</span>
}

func (s *StatementContext) ParameterDecl() IParameterDeclContext <span class="cov7" title="1535">{
        var t antlr.RuleContext
        for _, ctx := range s.GetChildren() </span><span class="cov7" title="1535">{
                if _, ok := ctx.(IParameterDeclContext); ok </span><span class="cov6" title="592">{
                        t = ctx.(antlr.RuleContext)
                        break</span>
                }
        }

        <span class="cov7" title="1535">if t == nil </span><span class="cov6" title="943">{
                return nil
        }</span>

        <span class="cov6" title="592">return t.(IParameterDeclContext)</span>
}

func (s *StatementContext) TypeDecl() ITypeDeclContext <span class="cov0" title="0">{
        var t antlr.RuleContext
        for _, ctx := range s.GetChildren() </span><span class="cov0" title="0">{
                if _, ok := ctx.(ITypeDeclContext); ok </span><span class="cov0" title="0">{
                        t = ctx.(antlr.RuleContext)
                        break</span>
                }
        }

        <span class="cov0" title="0">if t == nil </span><span class="cov0" title="0">{
                return nil
        }</span>

        <span class="cov0" title="0">return t.(ITypeDeclContext)</span>
}

func (s *StatementContext) VariableDecl() IVariableDeclContext <span class="cov6" title="1033">{
        var t antlr.RuleContext
        for _, ctx := range s.GetChildren() </span><span class="cov6" title="1033">{
                if _, ok := ctx.(IVariableDeclContext); ok </span><span class="cov5" title="180">{
                        t = ctx.(antlr.RuleContext)
                        break</span>
                }
        }

        <span class="cov6" title="1033">if t == nil </span><span class="cov6" title="853">{
                return nil
        }</span>

        <span class="cov5" title="180">return t.(IVariableDeclContext)</span>
}

func (s *StatementContext) ResourceDecl() IResourceDeclContext <span class="cov7" title="1633">{
        var t antlr.RuleContext
        for _, ctx := range s.GetChildren() </span><span class="cov7" title="1633">{
                if _, ok := ctx.(IResourceDeclContext); ok </span><span class="cov7" title="1560">{
                        t = ctx.(antlr.RuleContext)
                        break</span>
                }
        }

        <span class="cov7" title="1633">if t == nil </span><span class="cov4" title="73">{
                return nil
        }</span>

        <span class="cov7" title="1560">return t.(IResourceDeclContext)</span>
}

func (s *StatementContext) ModuleDecl() IModuleDeclContext <span class="cov0" title="0">{
        var t antlr.RuleContext
        for _, ctx := range s.GetChildren() </span><span class="cov0" title="0">{
                if _, ok := ctx.(IModuleDeclContext); ok </span><span class="cov0" title="0">{
                        t = ctx.(antlr.RuleContext)
                        break</span>
                }
        }

        <span class="cov0" title="0">if t == nil </span><span class="cov0" title="0">{
                return nil
        }</span>

        <span class="cov0" title="0">return t.(IModuleDeclContext)</span>
}

func (s *StatementContext) OutputDecl() IOutputDeclContext <span class="cov0" title="0">{
        var t antlr.RuleContext
        for _, ctx := range s.GetChildren() </span><span class="cov0" title="0">{
                if _, ok := ctx.(IOutputDeclContext); ok </span><span class="cov0" title="0">{
                        t = ctx.(antlr.RuleContext)
                        break</span>
                }
        }

        <span class="cov0" title="0">if t == nil </span><span class="cov0" title="0">{
                return nil
        }</span>

        <span class="cov0" title="0">return t.(IOutputDeclContext)</span>
}

func (s *StatementContext) NL() antlr.TerminalNode <span class="cov0" title="0">{
        return s.GetToken(bicepParserNL, 0)
}</span>

func (s *StatementContext) GetRuleContext() antlr.RuleContext <span class="cov0" title="0">{
        return s
}</span>

func (s *StatementContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string <span class="cov0" title="0">{
        return antlr.TreesStringTree(s, ruleNames, recog)
}</span>

func (s *StatementContext) Accept(visitor antlr.ParseTreeVisitor) interface{} <span class="cov6" title="1239">{
        switch t := visitor.(type) </span>{
        case bicepVisitor:<span class="cov6" title="1239">
                return t.VisitStatement(s)</span>

        default:<span class="cov0" title="0">
                return t.VisitChildren(s)</span>
        }
}

func (p *bicepParser) Statement() (localctx IStatementContext) <span class="cov6" title="1239">{
        localctx = NewStatementContext(p, p.GetParserRuleContext(), p.GetState())
        p.EnterRule(localctx, 2, bicepParserRULE_statement)
        p.SetState(84)
        p.GetErrorHandler().Sync(p)
        if p.HasError() </span><span class="cov0" title="0">{
                goto errorExit</span>
        }

        <span class="cov6" title="1239">switch p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 1, p.GetParserRuleContext()) </span>{
        case 1:<span class="cov1" title="1">
                p.EnterOuterAlt(localctx, 1)
                </span><span class="cov1" title="1">{
                        p.SetState(74)
                        p.TargetScopeDecl()
                }</span>

        case 2:<span class="cov0" title="0">
                p.EnterOuterAlt(localctx, 2)
                </span><span class="cov0" title="0">{
                        p.SetState(75)
                        p.ImportDecl()
                }</span>

        case 3:<span class="cov1" title="2">
                p.EnterOuterAlt(localctx, 3)
                </span><span class="cov1" title="2">{
                        p.SetState(76)
                        p.MetadataDecl()
                }</span>

        case 4:<span class="cov5" title="296">
                p.EnterOuterAlt(localctx, 4)
                </span><span class="cov5" title="296">{
                        p.SetState(77)
                        p.ParameterDecl()
                }</span>

        case 5:<span class="cov1" title="3">
                p.EnterOuterAlt(localctx, 5)
                </span><span class="cov1" title="3">{
                        p.SetState(78)
                        p.TypeDecl()
                }</span>

        case 6:<span class="cov4" title="90">
                p.EnterOuterAlt(localctx, 6)
                </span><span class="cov4" title="90">{
                        p.SetState(79)
                        p.VariableDecl()
                }</span>

        case 7:<span class="cov6" title="780">
                p.EnterOuterAlt(localctx, 7)
                </span><span class="cov6" title="780">{
                        p.SetState(80)
                        p.ResourceDecl()
                }</span>

        case 8:<span class="cov1" title="2">
                p.EnterOuterAlt(localctx, 8)
                </span><span class="cov1" title="2">{
                        p.SetState(81)
                        p.ModuleDecl()
                }</span>

        case 9:<span class="cov2" title="6">
                p.EnterOuterAlt(localctx, 9)
                </span><span class="cov2" title="6">{
                        p.SetState(82)
                        p.OutputDecl()
                }</span>

        case 10:<span class="cov4" title="59">
                p.EnterOuterAlt(localctx, 10)
                </span><span class="cov4" title="59">{
                        p.SetState(83)
                        p.Match(bicepParserNL)
                        if p.HasError() </span><span class="cov0" title="0">{
                                // Recognition error - abort rule
                                goto errorExit</span>
                        }
                }

        case antlr.ATNInvalidAltNumber:<span class="cov0" title="0">
                goto errorExit</span>
        }

errorExit:
        <span class="cov6" title="1239">if p.HasError() </span><span class="cov0" title="0">{
                v := p.GetError()
                localctx.SetException(v)
                p.GetErrorHandler().ReportError(p, v)
                p.GetErrorHandler().Recover(p, v)
                p.SetError(nil)
        }</span>
        <span class="cov6" title="1239">p.ExitRule()
        return localctx
        goto errorExit</span> // Trick to prevent compiler error if the label is not used
}

// ITargetScopeDeclContext is an interface to support dynamic dispatch.
type ITargetScopeDeclContext interface {
        antlr.ParserRuleContext

        // GetParser returns the parser.
        GetParser() antlr.Parser

        // Getter signatures
        TARGET_SCOPE() antlr.TerminalNode
        ASSIGN() antlr.TerminalNode
        Expression() IExpressionContext
        NL() antlr.TerminalNode

        // IsTargetScopeDeclContext differentiates from other interfaces.
        IsTargetScopeDeclContext()
}

type TargetScopeDeclContext struct {
        antlr.BaseParserRuleContext
        parser antlr.Parser
}

func NewEmptyTargetScopeDeclContext() *TargetScopeDeclContext <span class="cov0" title="0">{
        var p = new(TargetScopeDeclContext)
        antlr.InitBaseParserRuleContext(&amp;p.BaseParserRuleContext, nil, -1)
        p.RuleIndex = bicepParserRULE_targetScopeDecl
        return p
}</span>

func InitEmptyTargetScopeDeclContext(p *TargetScopeDeclContext) <span class="cov0" title="0">{
        antlr.InitBaseParserRuleContext(&amp;p.BaseParserRuleContext, nil, -1)
        p.RuleIndex = bicepParserRULE_targetScopeDecl
}</span>

func (*TargetScopeDeclContext) IsTargetScopeDeclContext() {<span class="cov0" title="0">}</span>

func NewTargetScopeDeclContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *TargetScopeDeclContext <span class="cov1" title="1">{
        var p = new(TargetScopeDeclContext)

        antlr.InitBaseParserRuleContext(&amp;p.BaseParserRuleContext, parent, invokingState)

        p.parser = parser
        p.RuleIndex = bicepParserRULE_targetScopeDecl

        return p
}</span>

func (s *TargetScopeDeclContext) GetParser() antlr.Parser <span class="cov0" title="0">{ return s.parser }</span>

func (s *TargetScopeDeclContext) TARGET_SCOPE() antlr.TerminalNode <span class="cov0" title="0">{
        return s.GetToken(bicepParserTARGET_SCOPE, 0)
}</span>

func (s *TargetScopeDeclContext) ASSIGN() antlr.TerminalNode <span class="cov0" title="0">{
        return s.GetToken(bicepParserASSIGN, 0)
}</span>

func (s *TargetScopeDeclContext) Expression() IExpressionContext <span class="cov0" title="0">{
        var t antlr.RuleContext
        for _, ctx := range s.GetChildren() </span><span class="cov0" title="0">{
                if _, ok := ctx.(IExpressionContext); ok </span><span class="cov0" title="0">{
                        t = ctx.(antlr.RuleContext)
                        break</span>
                }
        }

        <span class="cov0" title="0">if t == nil </span><span class="cov0" title="0">{
                return nil
        }</span>

        <span class="cov0" title="0">return t.(IExpressionContext)</span>
}

func (s *TargetScopeDeclContext) NL() antlr.TerminalNode <span class="cov0" title="0">{
        return s.GetToken(bicepParserNL, 0)
}</span>

func (s *TargetScopeDeclContext) GetRuleContext() antlr.RuleContext <span class="cov0" title="0">{
        return s
}</span>

func (s *TargetScopeDeclContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string <span class="cov0" title="0">{
        return antlr.TreesStringTree(s, ruleNames, recog)
}</span>

func (s *TargetScopeDeclContext) Accept(visitor antlr.ParseTreeVisitor) interface{} <span class="cov0" title="0">{
        switch t := visitor.(type) </span>{
        case bicepVisitor:<span class="cov0" title="0">
                return t.VisitTargetScopeDecl(s)</span>

        default:<span class="cov0" title="0">
                return t.VisitChildren(s)</span>
        }
}

func (p *bicepParser) TargetScopeDecl() (localctx ITargetScopeDeclContext) <span class="cov1" title="1">{
        localctx = NewTargetScopeDeclContext(p, p.GetParserRuleContext(), p.GetState())
        p.EnterRule(localctx, 4, bicepParserRULE_targetScopeDecl)
        p.EnterOuterAlt(localctx, 1)
        </span><span class="cov1" title="1">{
                p.SetState(86)
                p.Match(bicepParserTARGET_SCOPE)
                if p.HasError() </span><span class="cov0" title="0">{
                        // Recognition error - abort rule
                        goto errorExit</span>
                }
        }
        <span class="cov1" title="1">{
                p.SetState(87)
                p.Match(bicepParserASSIGN)
                if p.HasError() </span><span class="cov0" title="0">{
                        // Recognition error - abort rule
                        goto errorExit</span>
                }
        }
        <span class="cov1" title="1">{
                p.SetState(88)
                p.expression(0)
        }</span>
        <span class="cov1" title="1">{
                p.SetState(89)
                p.Match(bicepParserNL)
                if p.HasError() </span><span class="cov0" title="0">{
                        // Recognition error - abort rule
                        goto errorExit</span>
                }
        }

errorExit:
        <span class="cov1" title="1">if p.HasError() </span><span class="cov0" title="0">{
                v := p.GetError()
                localctx.SetException(v)
                p.GetErrorHandler().ReportError(p, v)
                p.GetErrorHandler().Recover(p, v)
                p.SetError(nil)
        }</span>
        <span class="cov1" title="1">p.ExitRule()
        return localctx
        goto errorExit</span> // Trick to prevent compiler error if the label is not used
}

// IImportDeclContext is an interface to support dynamic dispatch.
type IImportDeclContext interface {
        antlr.ParserRuleContext

        // GetParser returns the parser.
        GetParser() antlr.Parser

        // GetSpecification returns the specification rule contexts.
        GetSpecification() IInterpStringContext

        // GetAlias returns the alias rule contexts.
        GetAlias() IIdentifierContext

        // SetSpecification sets the specification rule contexts.
        SetSpecification(IInterpStringContext)

        // SetAlias sets the alias rule contexts.
        SetAlias(IIdentifierContext)

        // Getter signatures
        IMPORT() antlr.TerminalNode
        NL() antlr.TerminalNode
        InterpString() IInterpStringContext
        AllDecorator() []IDecoratorContext
        Decorator(i int) IDecoratorContext
        AllWITH() []antlr.TerminalNode
        WITH(i int) antlr.TerminalNode
        AllObject() []IObjectContext
        Object(i int) IObjectContext
        AllAS() []antlr.TerminalNode
        AS(i int) antlr.TerminalNode
        AllIdentifier() []IIdentifierContext
        Identifier(i int) IIdentifierContext

        // IsImportDeclContext differentiates from other interfaces.
        IsImportDeclContext()
}

type ImportDeclContext struct {
        antlr.BaseParserRuleContext
        parser        antlr.Parser
        specification IInterpStringContext
        alias         IIdentifierContext
}

func NewEmptyImportDeclContext() *ImportDeclContext <span class="cov0" title="0">{
        var p = new(ImportDeclContext)
        antlr.InitBaseParserRuleContext(&amp;p.BaseParserRuleContext, nil, -1)
        p.RuleIndex = bicepParserRULE_importDecl
        return p
}</span>

func InitEmptyImportDeclContext(p *ImportDeclContext) <span class="cov0" title="0">{
        antlr.InitBaseParserRuleContext(&amp;p.BaseParserRuleContext, nil, -1)
        p.RuleIndex = bicepParserRULE_importDecl
}</span>

func (*ImportDeclContext) IsImportDeclContext() {<span class="cov0" title="0">}</span>

func NewImportDeclContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *ImportDeclContext <span class="cov0" title="0">{
        var p = new(ImportDeclContext)

        antlr.InitBaseParserRuleContext(&amp;p.BaseParserRuleContext, parent, invokingState)

        p.parser = parser
        p.RuleIndex = bicepParserRULE_importDecl

        return p
}</span>

func (s *ImportDeclContext) GetParser() antlr.Parser <span class="cov0" title="0">{ return s.parser }</span>

func (s *ImportDeclContext) GetSpecification() IInterpStringContext <span class="cov0" title="0">{ return s.specification }</span>

func (s *ImportDeclContext) GetAlias() IIdentifierContext <span class="cov0" title="0">{ return s.alias }</span>

func (s *ImportDeclContext) SetSpecification(v IInterpStringContext) <span class="cov0" title="0">{ s.specification = v }</span>

func (s *ImportDeclContext) SetAlias(v IIdentifierContext) <span class="cov0" title="0">{ s.alias = v }</span>

func (s *ImportDeclContext) IMPORT() antlr.TerminalNode <span class="cov0" title="0">{
        return s.GetToken(bicepParserIMPORT, 0)
}</span>

func (s *ImportDeclContext) NL() antlr.TerminalNode <span class="cov0" title="0">{
        return s.GetToken(bicepParserNL, 0)
}</span>

func (s *ImportDeclContext) InterpString() IInterpStringContext <span class="cov0" title="0">{
        var t antlr.RuleContext
        for _, ctx := range s.GetChildren() </span><span class="cov0" title="0">{
                if _, ok := ctx.(IInterpStringContext); ok </span><span class="cov0" title="0">{
                        t = ctx.(antlr.RuleContext)
                        break</span>
                }
        }

        <span class="cov0" title="0">if t == nil </span><span class="cov0" title="0">{
                return nil
        }</span>

        <span class="cov0" title="0">return t.(IInterpStringContext)</span>
}

func (s *ImportDeclContext) AllDecorator() []IDecoratorContext <span class="cov0" title="0">{
        children := s.GetChildren()
        len := 0
        for _, ctx := range children </span><span class="cov0" title="0">{
                if _, ok := ctx.(IDecoratorContext); ok </span><span class="cov0" title="0">{
                        len++
                }</span>
        }

        <span class="cov0" title="0">tst := make([]IDecoratorContext, len)
        i := 0
        for _, ctx := range children </span><span class="cov0" title="0">{
                if t, ok := ctx.(IDecoratorContext); ok </span><span class="cov0" title="0">{
                        tst[i] = t.(IDecoratorContext)
                        i++
                }</span>
        }

        <span class="cov0" title="0">return tst</span>
}

func (s *ImportDeclContext) Decorator(i int) IDecoratorContext <span class="cov0" title="0">{
        var t antlr.RuleContext
        j := 0
        for _, ctx := range s.GetChildren() </span><span class="cov0" title="0">{
                if _, ok := ctx.(IDecoratorContext); ok </span><span class="cov0" title="0">{
                        if j == i </span><span class="cov0" title="0">{
                                t = ctx.(antlr.RuleContext)
                                break</span>
                        }
                        <span class="cov0" title="0">j++</span>
                }
        }

        <span class="cov0" title="0">if t == nil </span><span class="cov0" title="0">{
                return nil
        }</span>

        <span class="cov0" title="0">return t.(IDecoratorContext)</span>
}

func (s *ImportDeclContext) AllWITH() []antlr.TerminalNode <span class="cov0" title="0">{
        return s.GetTokens(bicepParserWITH)
}</span>

func (s *ImportDeclContext) WITH(i int) antlr.TerminalNode <span class="cov0" title="0">{
        return s.GetToken(bicepParserWITH, i)
}</span>

func (s *ImportDeclContext) AllObject() []IObjectContext <span class="cov0" title="0">{
        children := s.GetChildren()
        len := 0
        for _, ctx := range children </span><span class="cov0" title="0">{
                if _, ok := ctx.(IObjectContext); ok </span><span class="cov0" title="0">{
                        len++
                }</span>
        }

        <span class="cov0" title="0">tst := make([]IObjectContext, len)
        i := 0
        for _, ctx := range children </span><span class="cov0" title="0">{
                if t, ok := ctx.(IObjectContext); ok </span><span class="cov0" title="0">{
                        tst[i] = t.(IObjectContext)
                        i++
                }</span>
        }

        <span class="cov0" title="0">return tst</span>
}

func (s *ImportDeclContext) Object(i int) IObjectContext <span class="cov0" title="0">{
        var t antlr.RuleContext
        j := 0
        for _, ctx := range s.GetChildren() </span><span class="cov0" title="0">{
                if _, ok := ctx.(IObjectContext); ok </span><span class="cov0" title="0">{
                        if j == i </span><span class="cov0" title="0">{
                                t = ctx.(antlr.RuleContext)
                                break</span>
                        }
                        <span class="cov0" title="0">j++</span>
                }
        }

        <span class="cov0" title="0">if t == nil </span><span class="cov0" title="0">{
                return nil
        }</span>

        <span class="cov0" title="0">return t.(IObjectContext)</span>
}

func (s *ImportDeclContext) AllAS() []antlr.TerminalNode <span class="cov0" title="0">{
        return s.GetTokens(bicepParserAS)
}</span>

func (s *ImportDeclContext) AS(i int) antlr.TerminalNode <span class="cov0" title="0">{
        return s.GetToken(bicepParserAS, i)
}</span>

func (s *ImportDeclContext) AllIdentifier() []IIdentifierContext <span class="cov0" title="0">{
        children := s.GetChildren()
        len := 0
        for _, ctx := range children </span><span class="cov0" title="0">{
                if _, ok := ctx.(IIdentifierContext); ok </span><span class="cov0" title="0">{
                        len++
                }</span>
        }

        <span class="cov0" title="0">tst := make([]IIdentifierContext, len)
        i := 0
        for _, ctx := range children </span><span class="cov0" title="0">{
                if t, ok := ctx.(IIdentifierContext); ok </span><span class="cov0" title="0">{
                        tst[i] = t.(IIdentifierContext)
                        i++
                }</span>
        }

        <span class="cov0" title="0">return tst</span>
}

func (s *ImportDeclContext) Identifier(i int) IIdentifierContext <span class="cov0" title="0">{
        var t antlr.RuleContext
        j := 0
        for _, ctx := range s.GetChildren() </span><span class="cov0" title="0">{
                if _, ok := ctx.(IIdentifierContext); ok </span><span class="cov0" title="0">{
                        if j == i </span><span class="cov0" title="0">{
                                t = ctx.(antlr.RuleContext)
                                break</span>
                        }
                        <span class="cov0" title="0">j++</span>
                }
        }

        <span class="cov0" title="0">if t == nil </span><span class="cov0" title="0">{
                return nil
        }</span>

        <span class="cov0" title="0">return t.(IIdentifierContext)</span>
}

func (s *ImportDeclContext) GetRuleContext() antlr.RuleContext <span class="cov0" title="0">{
        return s
}</span>

func (s *ImportDeclContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string <span class="cov0" title="0">{
        return antlr.TreesStringTree(s, ruleNames, recog)
}</span>

func (s *ImportDeclContext) Accept(visitor antlr.ParseTreeVisitor) interface{} <span class="cov0" title="0">{
        switch t := visitor.(type) </span>{
        case bicepVisitor:<span class="cov0" title="0">
                return t.VisitImportDecl(s)</span>

        default:<span class="cov0" title="0">
                return t.VisitChildren(s)</span>
        }
}

func (p *bicepParser) ImportDecl() (localctx IImportDeclContext) <span class="cov0" title="0">{
        localctx = NewImportDeclContext(p, p.GetParserRuleContext(), p.GetState())
        p.EnterRule(localctx, 6, bicepParserRULE_importDecl)
        var _la int

        p.EnterOuterAlt(localctx, 1)
        p.SetState(94)
        p.GetErrorHandler().Sync(p)
        if p.HasError() </span><span class="cov0" title="0">{
                goto errorExit</span>
        }
        <span class="cov0" title="0">_la = p.GetTokenStream().LA(1)

        for _la == bicepParserAT </span><span class="cov0" title="0">{
                </span><span class="cov0" title="0">{
                        p.SetState(91)
                        p.Decorator()
                }</span>

                <span class="cov0" title="0">p.SetState(96)
                p.GetErrorHandler().Sync(p)
                if p.HasError() </span><span class="cov0" title="0">{
                        goto errorExit</span>
                }
                <span class="cov0" title="0">_la = p.GetTokenStream().LA(1)</span>
        }
        <span class="cov0" title="0">{
                p.SetState(97)
                p.Match(bicepParserIMPORT)
                if p.HasError() </span><span class="cov0" title="0">{
                        // Recognition error - abort rule
                        goto errorExit</span>
                }
        }
        <span class="cov0" title="0">{
                p.SetState(98)

                var _x = p.InterpString()

                localctx.(*ImportDeclContext).specification = _x
        }</span>
        <span class="cov0" title="0">p.SetState(105)
        p.GetErrorHandler().Sync(p)
        if p.HasError() </span><span class="cov0" title="0">{
                goto errorExit</span>
        }
        <span class="cov0" title="0">_la = p.GetTokenStream().LA(1)

        for _la == bicepParserWITH || _la == bicepParserAS </span><span class="cov0" title="0">{
                p.SetState(103)
                p.GetErrorHandler().Sync(p)
                if p.HasError() </span><span class="cov0" title="0">{
                        goto errorExit</span>
                }

                <span class="cov0" title="0">switch p.GetTokenStream().LA(1) </span>{
                case bicepParserWITH:<span class="cov0" title="0">
                        </span><span class="cov0" title="0">{
                                p.SetState(99)
                                p.Match(bicepParserWITH)
                                if p.HasError() </span><span class="cov0" title="0">{
                                        // Recognition error - abort rule
                                        goto errorExit</span>
                                }
                        }
                        <span class="cov0" title="0">{
                                p.SetState(100)
                                p.Object()
                        }</span>

                case bicepParserAS:<span class="cov0" title="0">
                        </span><span class="cov0" title="0">{
                                p.SetState(101)
                                p.Match(bicepParserAS)
                                if p.HasError() </span><span class="cov0" title="0">{
                                        // Recognition error - abort rule
                                        goto errorExit</span>
                                }
                        }
                        <span class="cov0" title="0">{
                                p.SetState(102)

                                var _x = p.Identifier()

                                localctx.(*ImportDeclContext).alias = _x
                        }</span>

                default:<span class="cov0" title="0">
                        p.SetError(antlr.NewNoViableAltException(p, nil, nil, nil, nil, nil))
                        goto errorExit</span>
                }

                <span class="cov0" title="0">p.SetState(107)
                p.GetErrorHandler().Sync(p)
                if p.HasError() </span><span class="cov0" title="0">{
                        goto errorExit</span>
                }
                <span class="cov0" title="0">_la = p.GetTokenStream().LA(1)</span>
        }
        <span class="cov0" title="0">{
                p.SetState(108)
                p.Match(bicepParserNL)
                if p.HasError() </span><span class="cov0" title="0">{
                        // Recognition error - abort rule
                        goto errorExit</span>
                }
        }

errorExit:
        <span class="cov0" title="0">if p.HasError() </span><span class="cov0" title="0">{
                v := p.GetError()
                localctx.SetException(v)
                p.GetErrorHandler().ReportError(p, v)
                p.GetErrorHandler().Recover(p, v)
                p.SetError(nil)
        }</span>
        <span class="cov0" title="0">p.ExitRule()
        return localctx
        goto errorExit</span> // Trick to prevent compiler error if the label is not used
}

// IMetadataDeclContext is an interface to support dynamic dispatch.
type IMetadataDeclContext interface {
        antlr.ParserRuleContext

        // GetParser returns the parser.
        GetParser() antlr.Parser

        // GetName returns the name rule contexts.
        GetName() IIdentifierContext

        // SetName sets the name rule contexts.
        SetName(IIdentifierContext)

        // Getter signatures
        METADATA() antlr.TerminalNode
        ASSIGN() antlr.TerminalNode
        Expression() IExpressionContext
        NL() antlr.TerminalNode
        Identifier() IIdentifierContext

        // IsMetadataDeclContext differentiates from other interfaces.
        IsMetadataDeclContext()
}

type MetadataDeclContext struct {
        antlr.BaseParserRuleContext
        parser antlr.Parser
        name   IIdentifierContext
}

func NewEmptyMetadataDeclContext() *MetadataDeclContext <span class="cov0" title="0">{
        var p = new(MetadataDeclContext)
        antlr.InitBaseParserRuleContext(&amp;p.BaseParserRuleContext, nil, -1)
        p.RuleIndex = bicepParserRULE_metadataDecl
        return p
}</span>

func InitEmptyMetadataDeclContext(p *MetadataDeclContext) <span class="cov0" title="0">{
        antlr.InitBaseParserRuleContext(&amp;p.BaseParserRuleContext, nil, -1)
        p.RuleIndex = bicepParserRULE_metadataDecl
}</span>

func (*MetadataDeclContext) IsMetadataDeclContext() {<span class="cov0" title="0">}</span>

func NewMetadataDeclContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *MetadataDeclContext <span class="cov1" title="2">{
        var p = new(MetadataDeclContext)

        antlr.InitBaseParserRuleContext(&amp;p.BaseParserRuleContext, parent, invokingState)

        p.parser = parser
        p.RuleIndex = bicepParserRULE_metadataDecl

        return p
}</span>

func (s *MetadataDeclContext) GetParser() antlr.Parser <span class="cov0" title="0">{ return s.parser }</span>

func (s *MetadataDeclContext) GetName() IIdentifierContext <span class="cov0" title="0">{ return s.name }</span>

func (s *MetadataDeclContext) SetName(v IIdentifierContext) <span class="cov0" title="0">{ s.name = v }</span>

func (s *MetadataDeclContext) METADATA() antlr.TerminalNode <span class="cov0" title="0">{
        return s.GetToken(bicepParserMETADATA, 0)
}</span>

func (s *MetadataDeclContext) ASSIGN() antlr.TerminalNode <span class="cov0" title="0">{
        return s.GetToken(bicepParserASSIGN, 0)
}</span>

func (s *MetadataDeclContext) Expression() IExpressionContext <span class="cov0" title="0">{
        var t antlr.RuleContext
        for _, ctx := range s.GetChildren() </span><span class="cov0" title="0">{
                if _, ok := ctx.(IExpressionContext); ok </span><span class="cov0" title="0">{
                        t = ctx.(antlr.RuleContext)
                        break</span>
                }
        }

        <span class="cov0" title="0">if t == nil </span><span class="cov0" title="0">{
                return nil
        }</span>

        <span class="cov0" title="0">return t.(IExpressionContext)</span>
}

func (s *MetadataDeclContext) NL() antlr.TerminalNode <span class="cov0" title="0">{
        return s.GetToken(bicepParserNL, 0)
}</span>

func (s *MetadataDeclContext) Identifier() IIdentifierContext <span class="cov0" title="0">{
        var t antlr.RuleContext
        for _, ctx := range s.GetChildren() </span><span class="cov0" title="0">{
                if _, ok := ctx.(IIdentifierContext); ok </span><span class="cov0" title="0">{
                        t = ctx.(antlr.RuleContext)
                        break</span>
                }
        }

        <span class="cov0" title="0">if t == nil </span><span class="cov0" title="0">{
                return nil
        }</span>

        <span class="cov0" title="0">return t.(IIdentifierContext)</span>
}

func (s *MetadataDeclContext) GetRuleContext() antlr.RuleContext <span class="cov0" title="0">{
        return s
}</span>

func (s *MetadataDeclContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string <span class="cov0" title="0">{
        return antlr.TreesStringTree(s, ruleNames, recog)
}</span>

func (s *MetadataDeclContext) Accept(visitor antlr.ParseTreeVisitor) interface{} <span class="cov0" title="0">{
        switch t := visitor.(type) </span>{
        case bicepVisitor:<span class="cov0" title="0">
                return t.VisitMetadataDecl(s)</span>

        default:<span class="cov0" title="0">
                return t.VisitChildren(s)</span>
        }
}

func (p *bicepParser) MetadataDecl() (localctx IMetadataDeclContext) <span class="cov1" title="2">{
        localctx = NewMetadataDeclContext(p, p.GetParserRuleContext(), p.GetState())
        p.EnterRule(localctx, 8, bicepParserRULE_metadataDecl)
        p.EnterOuterAlt(localctx, 1)
        </span><span class="cov1" title="2">{
                p.SetState(110)
                p.Match(bicepParserMETADATA)
                if p.HasError() </span><span class="cov0" title="0">{
                        // Recognition error - abort rule
                        goto errorExit</span>
                }
        }
        <span class="cov1" title="2">{
                p.SetState(111)

                var _x = p.Identifier()

                localctx.(*MetadataDeclContext).name = _x
        }</span>
        <span class="cov1" title="2">{
                p.SetState(112)
                p.Match(bicepParserASSIGN)
                if p.HasError() </span><span class="cov0" title="0">{
                        // Recognition error - abort rule
                        goto errorExit</span>
                }
        }
        <span class="cov1" title="2">{
                p.SetState(113)
                p.expression(0)
        }</span>
        <span class="cov1" title="2">{
                p.SetState(114)
                p.Match(bicepParserNL)
                if p.HasError() </span><span class="cov0" title="0">{
                        // Recognition error - abort rule
                        goto errorExit</span>
                }
        }

errorExit:
        <span class="cov1" title="2">if p.HasError() </span><span class="cov0" title="0">{
                v := p.GetError()
                localctx.SetException(v)
                p.GetErrorHandler().ReportError(p, v)
                p.GetErrorHandler().Recover(p, v)
                p.SetError(nil)
        }</span>
        <span class="cov1" title="2">p.ExitRule()
        return localctx
        goto errorExit</span> // Trick to prevent compiler error if the label is not used
}

// IParameterDeclContext is an interface to support dynamic dispatch.
type IParameterDeclContext interface {
        antlr.ParserRuleContext

        // GetParser returns the parser.
        GetParser() antlr.Parser

        // GetName returns the name rule contexts.
        GetName() IIdentifierContext

        // GetType_ returns the type_ rule contexts.
        GetType_() IInterpStringContext

        // SetName sets the name rule contexts.
        SetName(IIdentifierContext)

        // SetType_ sets the type_ rule contexts.
        SetType_(IInterpStringContext)

        // Getter signatures
        PARAM() antlr.TerminalNode
        NL() antlr.TerminalNode
        Identifier() IIdentifierContext
        TypeExpression() ITypeExpressionContext
        RESOURCE() antlr.TerminalNode
        AllDecorator() []IDecoratorContext
        Decorator(i int) IDecoratorContext
        InterpString() IInterpStringContext
        ParameterDefaultValue() IParameterDefaultValueContext

        // IsParameterDeclContext differentiates from other interfaces.
        IsParameterDeclContext()
}

type ParameterDeclContext struct {
        antlr.BaseParserRuleContext
        parser antlr.Parser
        name   IIdentifierContext
        type_  IInterpStringContext
}

func NewEmptyParameterDeclContext() *ParameterDeclContext <span class="cov0" title="0">{
        var p = new(ParameterDeclContext)
        antlr.InitBaseParserRuleContext(&amp;p.BaseParserRuleContext, nil, -1)
        p.RuleIndex = bicepParserRULE_parameterDecl
        return p
}</span>

func InitEmptyParameterDeclContext(p *ParameterDeclContext) <span class="cov0" title="0">{
        antlr.InitBaseParserRuleContext(&amp;p.BaseParserRuleContext, nil, -1)
        p.RuleIndex = bicepParserRULE_parameterDecl
}</span>

func (*ParameterDeclContext) IsParameterDeclContext() {<span class="cov0" title="0">}</span>

func NewParameterDeclContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *ParameterDeclContext <span class="cov5" title="296">{
        var p = new(ParameterDeclContext)

        antlr.InitBaseParserRuleContext(&amp;p.BaseParserRuleContext, parent, invokingState)

        p.parser = parser
        p.RuleIndex = bicepParserRULE_parameterDecl

        return p
}</span>

func (s *ParameterDeclContext) GetParser() antlr.Parser <span class="cov0" title="0">{ return s.parser }</span>

func (s *ParameterDeclContext) GetName() IIdentifierContext <span class="cov0" title="0">{ return s.name }</span>

func (s *ParameterDeclContext) GetType_() IInterpStringContext <span class="cov0" title="0">{ return s.type_ }</span>

func (s *ParameterDeclContext) SetName(v IIdentifierContext) <span class="cov0" title="0">{ s.name = v }</span>

func (s *ParameterDeclContext) SetType_(v IInterpStringContext) <span class="cov0" title="0">{ s.type_ = v }</span>

func (s *ParameterDeclContext) PARAM() antlr.TerminalNode <span class="cov0" title="0">{
        return s.GetToken(bicepParserPARAM, 0)
}</span>

func (s *ParameterDeclContext) NL() antlr.TerminalNode <span class="cov0" title="0">{
        return s.GetToken(bicepParserNL, 0)
}</span>

func (s *ParameterDeclContext) Identifier() IIdentifierContext <span class="cov5" title="296">{
        var t antlr.RuleContext
        for _, ctx := range s.GetChildren() </span><span class="cov6" title="823">{
                if _, ok := ctx.(IIdentifierContext); ok </span><span class="cov5" title="296">{
                        t = ctx.(antlr.RuleContext)
                        break</span>
                }
        }

        <span class="cov5" title="296">if t == nil </span><span class="cov0" title="0">{
                return nil
        }</span>

        <span class="cov5" title="296">return t.(IIdentifierContext)</span>
}

func (s *ParameterDeclContext) TypeExpression() ITypeExpressionContext <span class="cov6" title="592">{
        var t antlr.RuleContext
        for _, ctx := range s.GetChildren() </span><span class="cov7" title="2238">{
                if _, ok := ctx.(ITypeExpressionContext); ok </span><span class="cov6" title="592">{
                        t = ctx.(antlr.RuleContext)
                        break</span>
                }
        }

        <span class="cov6" title="592">if t == nil </span><span class="cov0" title="0">{
                return nil
        }</span>

        <span class="cov6" title="592">return t.(ITypeExpressionContext)</span>
}

func (s *ParameterDeclContext) RESOURCE() antlr.TerminalNode <span class="cov0" title="0">{
        return s.GetToken(bicepParserRESOURCE, 0)
}</span>

func (s *ParameterDeclContext) AllDecorator() []IDecoratorContext <span class="cov5" title="296">{
        children := s.GetChildren()
        len := 0
        for _, ctx := range children </span><span class="cov7" title="1574">{
                if _, ok := ctx.(IDecoratorContext); ok </span><span class="cov5" title="231">{
                        len++
                }</span>
        }

        <span class="cov5" title="296">tst := make([]IDecoratorContext, len)
        i := 0
        for _, ctx := range children </span><span class="cov7" title="1574">{
                if t, ok := ctx.(IDecoratorContext); ok </span><span class="cov5" title="231">{
                        tst[i] = t.(IDecoratorContext)
                        i++
                }</span>
        }

        <span class="cov5" title="296">return tst</span>
}

func (s *ParameterDeclContext) Decorator(i int) IDecoratorContext <span class="cov0" title="0">{
        var t antlr.RuleContext
        j := 0
        for _, ctx := range s.GetChildren() </span><span class="cov0" title="0">{
                if _, ok := ctx.(IDecoratorContext); ok </span><span class="cov0" title="0">{
                        if j == i </span><span class="cov0" title="0">{
                                t = ctx.(antlr.RuleContext)
                                break</span>
                        }
                        <span class="cov0" title="0">j++</span>
                }
        }

        <span class="cov0" title="0">if t == nil </span><span class="cov0" title="0">{
                return nil
        }</span>

        <span class="cov0" title="0">return t.(IDecoratorContext)</span>
}

func (s *ParameterDeclContext) InterpString() IInterpStringContext <span class="cov0" title="0">{
        var t antlr.RuleContext
        for _, ctx := range s.GetChildren() </span><span class="cov0" title="0">{
                if _, ok := ctx.(IInterpStringContext); ok </span><span class="cov0" title="0">{
                        t = ctx.(antlr.RuleContext)
                        break</span>
                }
        }

        <span class="cov0" title="0">if t == nil </span><span class="cov0" title="0">{
                return nil
        }</span>

        <span class="cov0" title="0">return t.(IInterpStringContext)</span>
}

func (s *ParameterDeclContext) ParameterDefaultValue() IParameterDefaultValueContext <span class="cov6" title="455">{
        var t antlr.RuleContext
        for _, ctx := range s.GetChildren() </span><span class="cov7" title="2195">{
                if _, ok := ctx.(IParameterDefaultValueContext); ok </span><span class="cov5" title="318">{
                        t = ctx.(antlr.RuleContext)
                        break</span>
                }
        }

        <span class="cov6" title="455">if t == nil </span><span class="cov5" title="137">{
                return nil
        }</span>

        <span class="cov5" title="318">return t.(IParameterDefaultValueContext)</span>
}

func (s *ParameterDeclContext) GetRuleContext() antlr.RuleContext <span class="cov0" title="0">{
        return s
}</span>

func (s *ParameterDeclContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string <span class="cov0" title="0">{
        return antlr.TreesStringTree(s, ruleNames, recog)
}</span>

func (s *ParameterDeclContext) Accept(visitor antlr.ParseTreeVisitor) interface{} <span class="cov5" title="296">{
        switch t := visitor.(type) </span>{
        case bicepVisitor:<span class="cov5" title="296">
                return t.VisitParameterDecl(s)</span>

        default:<span class="cov0" title="0">
                return t.VisitChildren(s)</span>
        }
}

func (p *bicepParser) ParameterDecl() (localctx IParameterDeclContext) <span class="cov5" title="296">{
        localctx = NewParameterDeclContext(p, p.GetParserRuleContext(), p.GetState())
        p.EnterRule(localctx, 10, bicepParserRULE_parameterDecl)
        var _la int

        p.EnterOuterAlt(localctx, 1)
        p.SetState(119)
        p.GetErrorHandler().Sync(p)
        if p.HasError() </span><span class="cov0" title="0">{
                goto errorExit</span>
        }
        <span class="cov5" title="296">_la = p.GetTokenStream().LA(1)

        for _la == bicepParserAT </span><span class="cov5" title="231">{
                </span><span class="cov5" title="231">{
                        p.SetState(116)
                        p.Decorator()
                }</span>

                <span class="cov5" title="231">p.SetState(121)
                p.GetErrorHandler().Sync(p)
                if p.HasError() </span><span class="cov0" title="0">{
                        goto errorExit</span>
                }
                <span class="cov5" title="231">_la = p.GetTokenStream().LA(1)</span>
        }
        <span class="cov5" title="296">{
                p.SetState(122)
                p.Match(bicepParserPARAM)
                if p.HasError() </span><span class="cov0" title="0">{
                        // Recognition error - abort rule
                        goto errorExit</span>
                }
        }
        <span class="cov5" title="296">{
                p.SetState(123)

                var _x = p.Identifier()

                localctx.(*ParameterDeclContext).name = _x
        }</span>
        <span class="cov5" title="296">p.SetState(133)
        p.GetErrorHandler().Sync(p)
        if p.HasError() </span><span class="cov0" title="0">{
                goto errorExit</span>
        }

        <span class="cov5" title="296">switch p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 8, p.GetParserRuleContext()) </span>{
        case 1:<span class="cov5" title="296">
                </span><span class="cov5" title="296">{
                        p.SetState(124)
                        p.TypeExpression()
                }</span>
                <span class="cov5" title="296">p.SetState(126)
                p.GetErrorHandler().Sync(p)
                if p.HasError() </span><span class="cov0" title="0">{
                        goto errorExit</span>
                }
                <span class="cov5" title="296">_la = p.GetTokenStream().LA(1)

                if _la == bicepParserASSIGN </span><span class="cov5" title="159">{
                        </span><span class="cov5" title="159">{
                                p.SetState(125)
                                p.ParameterDefaultValue()
                        }</span>

                }

        case 2:<span class="cov0" title="0">
                </span><span class="cov0" title="0">{
                        p.SetState(128)
                        p.Match(bicepParserRESOURCE)
                        if p.HasError() </span><span class="cov0" title="0">{
                                // Recognition error - abort rule
                                goto errorExit</span>
                        }
                }
                <span class="cov0" title="0">{
                        p.SetState(129)

                        var _x = p.InterpString()

                        localctx.(*ParameterDeclContext).type_ = _x
                }</span>
                <span class="cov0" title="0">p.SetState(131)
                p.GetErrorHandler().Sync(p)
                if p.HasError() </span><span class="cov0" title="0">{
                        goto errorExit</span>
                }
                <span class="cov0" title="0">_la = p.GetTokenStream().LA(1)

                if _la == bicepParserASSIGN </span><span class="cov0" title="0">{
                        </span><span class="cov0" title="0">{
                                p.SetState(130)
                                p.ParameterDefaultValue()
                        }</span>

                }

        case antlr.ATNInvalidAltNumber:<span class="cov0" title="0">
                goto errorExit</span>
        }
        <span class="cov5" title="296">{
                p.SetState(135)
                p.Match(bicepParserNL)
                if p.HasError() </span><span class="cov0" title="0">{
                        // Recognition error - abort rule
                        goto errorExit</span>
                }
        }

errorExit:
        <span class="cov5" title="296">if p.HasError() </span><span class="cov0" title="0">{
                v := p.GetError()
                localctx.SetException(v)
                p.GetErrorHandler().ReportError(p, v)
                p.GetErrorHandler().Recover(p, v)
                p.SetError(nil)
        }</span>
        <span class="cov5" title="296">p.ExitRule()
        return localctx
        goto errorExit</span> // Trick to prevent compiler error if the label is not used
}

// IParameterDefaultValueContext is an interface to support dynamic dispatch.
type IParameterDefaultValueContext interface {
        antlr.ParserRuleContext

        // GetParser returns the parser.
        GetParser() antlr.Parser

        // Getter signatures
        ASSIGN() antlr.TerminalNode
        Expression() IExpressionContext

        // IsParameterDefaultValueContext differentiates from other interfaces.
        IsParameterDefaultValueContext()
}

type ParameterDefaultValueContext struct {
        antlr.BaseParserRuleContext
        parser antlr.Parser
}

func NewEmptyParameterDefaultValueContext() *ParameterDefaultValueContext <span class="cov0" title="0">{
        var p = new(ParameterDefaultValueContext)
        antlr.InitBaseParserRuleContext(&amp;p.BaseParserRuleContext, nil, -1)
        p.RuleIndex = bicepParserRULE_parameterDefaultValue
        return p
}</span>

func InitEmptyParameterDefaultValueContext(p *ParameterDefaultValueContext) <span class="cov0" title="0">{
        antlr.InitBaseParserRuleContext(&amp;p.BaseParserRuleContext, nil, -1)
        p.RuleIndex = bicepParserRULE_parameterDefaultValue
}</span>

func (*ParameterDefaultValueContext) IsParameterDefaultValueContext() {<span class="cov0" title="0">}</span>

func NewParameterDefaultValueContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *ParameterDefaultValueContext <span class="cov5" title="159">{
        var p = new(ParameterDefaultValueContext)

        antlr.InitBaseParserRuleContext(&amp;p.BaseParserRuleContext, parent, invokingState)

        p.parser = parser
        p.RuleIndex = bicepParserRULE_parameterDefaultValue

        return p
}</span>

func (s *ParameterDefaultValueContext) GetParser() antlr.Parser <span class="cov0" title="0">{ return s.parser }</span>

func (s *ParameterDefaultValueContext) ASSIGN() antlr.TerminalNode <span class="cov0" title="0">{
        return s.GetToken(bicepParserASSIGN, 0)
}</span>

func (s *ParameterDefaultValueContext) Expression() IExpressionContext <span class="cov5" title="159">{
        var t antlr.RuleContext
        for _, ctx := range s.GetChildren() </span><span class="cov5" title="318">{
                if _, ok := ctx.(IExpressionContext); ok </span><span class="cov5" title="159">{
                        t = ctx.(antlr.RuleContext)
                        break</span>
                }
        }

        <span class="cov5" title="159">if t == nil </span><span class="cov0" title="0">{
                return nil
        }</span>

        <span class="cov5" title="159">return t.(IExpressionContext)</span>
}

func (s *ParameterDefaultValueContext) GetRuleContext() antlr.RuleContext <span class="cov0" title="0">{
        return s
}</span>

func (s *ParameterDefaultValueContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string <span class="cov0" title="0">{
        return antlr.TreesStringTree(s, ruleNames, recog)
}</span>

func (s *ParameterDefaultValueContext) Accept(visitor antlr.ParseTreeVisitor) interface{} <span class="cov5" title="159">{
        switch t := visitor.(type) </span>{
        case bicepVisitor:<span class="cov5" title="159">
                return t.VisitParameterDefaultValue(s)</span>

        default:<span class="cov0" title="0">
                return t.VisitChildren(s)</span>
        }
}

func (p *bicepParser) ParameterDefaultValue() (localctx IParameterDefaultValueContext) <span class="cov5" title="159">{
        localctx = NewParameterDefaultValueContext(p, p.GetParserRuleContext(), p.GetState())
        p.EnterRule(localctx, 12, bicepParserRULE_parameterDefaultValue)
        p.EnterOuterAlt(localctx, 1)
        </span><span class="cov5" title="159">{
                p.SetState(137)
                p.Match(bicepParserASSIGN)
                if p.HasError() </span><span class="cov0" title="0">{
                        // Recognition error - abort rule
                        goto errorExit</span>
                }
        }
        <span class="cov5" title="159">{
                p.SetState(138)
                p.expression(0)
        }</span>

errorExit:
        <span class="cov5" title="159">if p.HasError() </span><span class="cov0" title="0">{
                v := p.GetError()
                localctx.SetException(v)
                p.GetErrorHandler().ReportError(p, v)
                p.GetErrorHandler().Recover(p, v)
                p.SetError(nil)
        }</span>
        <span class="cov5" title="159">p.ExitRule()
        return localctx
        goto errorExit</span> // Trick to prevent compiler error if the label is not used
}

// ITypeDeclContext is an interface to support dynamic dispatch.
type ITypeDeclContext interface {
        antlr.ParserRuleContext

        // GetParser returns the parser.
        GetParser() antlr.Parser

        // GetName returns the name rule contexts.
        GetName() IIdentifierContext

        // SetName sets the name rule contexts.
        SetName(IIdentifierContext)

        // Getter signatures
        TYPE() antlr.TerminalNode
        ASSIGN() antlr.TerminalNode
        TypeExpression() ITypeExpressionContext
        NL() antlr.TerminalNode
        Identifier() IIdentifierContext
        AllDecorator() []IDecoratorContext
        Decorator(i int) IDecoratorContext

        // IsTypeDeclContext differentiates from other interfaces.
        IsTypeDeclContext()
}

type TypeDeclContext struct {
        antlr.BaseParserRuleContext
        parser antlr.Parser
        name   IIdentifierContext
}

func NewEmptyTypeDeclContext() *TypeDeclContext <span class="cov0" title="0">{
        var p = new(TypeDeclContext)
        antlr.InitBaseParserRuleContext(&amp;p.BaseParserRuleContext, nil, -1)
        p.RuleIndex = bicepParserRULE_typeDecl
        return p
}</span>

func InitEmptyTypeDeclContext(p *TypeDeclContext) <span class="cov0" title="0">{
        antlr.InitBaseParserRuleContext(&amp;p.BaseParserRuleContext, nil, -1)
        p.RuleIndex = bicepParserRULE_typeDecl
}</span>

func (*TypeDeclContext) IsTypeDeclContext() {<span class="cov0" title="0">}</span>

func NewTypeDeclContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *TypeDeclContext <span class="cov1" title="3">{
        var p = new(TypeDeclContext)

        antlr.InitBaseParserRuleContext(&amp;p.BaseParserRuleContext, parent, invokingState)

        p.parser = parser
        p.RuleIndex = bicepParserRULE_typeDecl

        return p
}</span>

func (s *TypeDeclContext) GetParser() antlr.Parser <span class="cov0" title="0">{ return s.parser }</span>

func (s *TypeDeclContext) GetName() IIdentifierContext <span class="cov0" title="0">{ return s.name }</span>

func (s *TypeDeclContext) SetName(v IIdentifierContext) <span class="cov0" title="0">{ s.name = v }</span>

func (s *TypeDeclContext) TYPE() antlr.TerminalNode <span class="cov0" title="0">{
        return s.GetToken(bicepParserTYPE, 0)
}</span>

func (s *TypeDeclContext) ASSIGN() antlr.TerminalNode <span class="cov0" title="0">{
        return s.GetToken(bicepParserASSIGN, 0)
}</span>

func (s *TypeDeclContext) TypeExpression() ITypeExpressionContext <span class="cov0" title="0">{
        var t antlr.RuleContext
        for _, ctx := range s.GetChildren() </span><span class="cov0" title="0">{
                if _, ok := ctx.(ITypeExpressionContext); ok </span><span class="cov0" title="0">{
                        t = ctx.(antlr.RuleContext)
                        break</span>
                }
        }

        <span class="cov0" title="0">if t == nil </span><span class="cov0" title="0">{
                return nil
        }</span>

        <span class="cov0" title="0">return t.(ITypeExpressionContext)</span>
}

func (s *TypeDeclContext) NL() antlr.TerminalNode <span class="cov0" title="0">{
        return s.GetToken(bicepParserNL, 0)
}</span>

func (s *TypeDeclContext) Identifier() IIdentifierContext <span class="cov0" title="0">{
        var t antlr.RuleContext
        for _, ctx := range s.GetChildren() </span><span class="cov0" title="0">{
                if _, ok := ctx.(IIdentifierContext); ok </span><span class="cov0" title="0">{
                        t = ctx.(antlr.RuleContext)
                        break</span>
                }
        }

        <span class="cov0" title="0">if t == nil </span><span class="cov0" title="0">{
                return nil
        }</span>

        <span class="cov0" title="0">return t.(IIdentifierContext)</span>
}

func (s *TypeDeclContext) AllDecorator() []IDecoratorContext <span class="cov0" title="0">{
        children := s.GetChildren()
        len := 0
        for _, ctx := range children </span><span class="cov0" title="0">{
                if _, ok := ctx.(IDecoratorContext); ok </span><span class="cov0" title="0">{
                        len++
                }</span>
        }

        <span class="cov0" title="0">tst := make([]IDecoratorContext, len)
        i := 0
        for _, ctx := range children </span><span class="cov0" title="0">{
                if t, ok := ctx.(IDecoratorContext); ok </span><span class="cov0" title="0">{
                        tst[i] = t.(IDecoratorContext)
                        i++
                }</span>
        }

        <span class="cov0" title="0">return tst</span>
}

func (s *TypeDeclContext) Decorator(i int) IDecoratorContext <span class="cov0" title="0">{
        var t antlr.RuleContext
        j := 0
        for _, ctx := range s.GetChildren() </span><span class="cov0" title="0">{
                if _, ok := ctx.(IDecoratorContext); ok </span><span class="cov0" title="0">{
                        if j == i </span><span class="cov0" title="0">{
                                t = ctx.(antlr.RuleContext)
                                break</span>
                        }
                        <span class="cov0" title="0">j++</span>
                }
        }

        <span class="cov0" title="0">if t == nil </span><span class="cov0" title="0">{
                return nil
        }</span>

        <span class="cov0" title="0">return t.(IDecoratorContext)</span>
}

func (s *TypeDeclContext) GetRuleContext() antlr.RuleContext <span class="cov0" title="0">{
        return s
}</span>

func (s *TypeDeclContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string <span class="cov0" title="0">{
        return antlr.TreesStringTree(s, ruleNames, recog)
}</span>

func (s *TypeDeclContext) Accept(visitor antlr.ParseTreeVisitor) interface{} <span class="cov0" title="0">{
        switch t := visitor.(type) </span>{
        case bicepVisitor:<span class="cov0" title="0">
                return t.VisitTypeDecl(s)</span>

        default:<span class="cov0" title="0">
                return t.VisitChildren(s)</span>
        }
}

func (p *bicepParser) TypeDecl() (localctx ITypeDeclContext) <span class="cov1" title="3">{
        localctx = NewTypeDeclContext(p, p.GetParserRuleContext(), p.GetState())
        p.EnterRule(localctx, 14, bicepParserRULE_typeDecl)
        var _la int

        p.EnterOuterAlt(localctx, 1)
        p.SetState(143)
        p.GetErrorHandler().Sync(p)
        if p.HasError() </span><span class="cov0" title="0">{
                goto errorExit</span>
        }
        <span class="cov1" title="3">_la = p.GetTokenStream().LA(1)

        for _la == bicepParserAT </span><span class="cov0" title="0">{
                </span><span class="cov0" title="0">{
                        p.SetState(140)
                        p.Decorator()
                }</span>

                <span class="cov0" title="0">p.SetState(145)
                p.GetErrorHandler().Sync(p)
                if p.HasError() </span><span class="cov0" title="0">{
                        goto errorExit</span>
                }
                <span class="cov0" title="0">_la = p.GetTokenStream().LA(1)</span>
        }
        <span class="cov1" title="3">{
                p.SetState(146)
                p.Match(bicepParserTYPE)
                if p.HasError() </span><span class="cov0" title="0">{
                        // Recognition error - abort rule
                        goto errorExit</span>
                }
        }
        <span class="cov1" title="3">{
                p.SetState(147)

                var _x = p.Identifier()

                localctx.(*TypeDeclContext).name = _x
        }</span>
        <span class="cov1" title="3">{
                p.SetState(148)
                p.Match(bicepParserASSIGN)
                if p.HasError() </span><span class="cov0" title="0">{
                        // Recognition error - abort rule
                        goto errorExit</span>
                }
        }
        <span class="cov1" title="3">{
                p.SetState(149)
                p.TypeExpression()
        }</span>
        <span class="cov1" title="3">{
                p.SetState(150)
                p.Match(bicepParserNL)
                if p.HasError() </span><span class="cov1" title="1">{
                        // Recognition error - abort rule
                        goto errorExit</span>
                }
        }

errorExit:
        <span class="cov1" title="3">if p.HasError() </span><span class="cov1" title="1">{
                v := p.GetError()
                localctx.SetException(v)
                p.GetErrorHandler().ReportError(p, v)
                p.GetErrorHandler().Recover(p, v)
                p.SetError(nil)
        }</span>
        <span class="cov1" title="3">p.ExitRule()
        return localctx
        goto errorExit</span> // Trick to prevent compiler error if the label is not used
}

// IVariableDeclContext is an interface to support dynamic dispatch.
type IVariableDeclContext interface {
        antlr.ParserRuleContext

        // GetParser returns the parser.
        GetParser() antlr.Parser

        // GetName returns the name rule contexts.
        GetName() IIdentifierContext

        // SetName sets the name rule contexts.
        SetName(IIdentifierContext)

        // Getter signatures
        VAR() antlr.TerminalNode
        ASSIGN() antlr.TerminalNode
        Expression() IExpressionContext
        NL() antlr.TerminalNode
        Identifier() IIdentifierContext
        AllDecorator() []IDecoratorContext
        Decorator(i int) IDecoratorContext

        // IsVariableDeclContext differentiates from other interfaces.
        IsVariableDeclContext()
}

type VariableDeclContext struct {
        antlr.BaseParserRuleContext
        parser antlr.Parser
        name   IIdentifierContext
}

func NewEmptyVariableDeclContext() *VariableDeclContext <span class="cov0" title="0">{
        var p = new(VariableDeclContext)
        antlr.InitBaseParserRuleContext(&amp;p.BaseParserRuleContext, nil, -1)
        p.RuleIndex = bicepParserRULE_variableDecl
        return p
}</span>

func InitEmptyVariableDeclContext(p *VariableDeclContext) <span class="cov0" title="0">{
        antlr.InitBaseParserRuleContext(&amp;p.BaseParserRuleContext, nil, -1)
        p.RuleIndex = bicepParserRULE_variableDecl
}</span>

func (*VariableDeclContext) IsVariableDeclContext() {<span class="cov0" title="0">}</span>

func NewVariableDeclContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *VariableDeclContext <span class="cov4" title="90">{
        var p = new(VariableDeclContext)

        antlr.InitBaseParserRuleContext(&amp;p.BaseParserRuleContext, parent, invokingState)

        p.parser = parser
        p.RuleIndex = bicepParserRULE_variableDecl

        return p
}</span>

func (s *VariableDeclContext) GetParser() antlr.Parser <span class="cov0" title="0">{ return s.parser }</span>

func (s *VariableDeclContext) GetName() IIdentifierContext <span class="cov0" title="0">{ return s.name }</span>

func (s *VariableDeclContext) SetName(v IIdentifierContext) <span class="cov0" title="0">{ s.name = v }</span>

func (s *VariableDeclContext) VAR() antlr.TerminalNode <span class="cov0" title="0">{
        return s.GetToken(bicepParserVAR, 0)
}</span>

func (s *VariableDeclContext) ASSIGN() antlr.TerminalNode <span class="cov0" title="0">{
        return s.GetToken(bicepParserASSIGN, 0)
}</span>

func (s *VariableDeclContext) Expression() IExpressionContext <span class="cov4" title="90">{
        var t antlr.RuleContext
        for _, ctx := range s.GetChildren() </span><span class="cov5" title="362">{
                if _, ok := ctx.(IExpressionContext); ok </span><span class="cov4" title="90">{
                        t = ctx.(antlr.RuleContext)
                        break</span>
                }
        }

        <span class="cov4" title="90">if t == nil </span><span class="cov0" title="0">{
                return nil
        }</span>

        <span class="cov4" title="90">return t.(IExpressionContext)</span>
}

func (s *VariableDeclContext) NL() antlr.TerminalNode <span class="cov0" title="0">{
        return s.GetToken(bicepParserNL, 0)
}</span>

func (s *VariableDeclContext) Identifier() IIdentifierContext <span class="cov4" title="90">{
        var t antlr.RuleContext
        for _, ctx := range s.GetChildren() </span><span class="cov5" title="182">{
                if _, ok := ctx.(IIdentifierContext); ok </span><span class="cov4" title="90">{
                        t = ctx.(antlr.RuleContext)
                        break</span>
                }
        }

        <span class="cov4" title="90">if t == nil </span><span class="cov0" title="0">{
                return nil
        }</span>

        <span class="cov4" title="90">return t.(IIdentifierContext)</span>
}

func (s *VariableDeclContext) AllDecorator() []IDecoratorContext <span class="cov4" title="90">{
        children := s.GetChildren()
        len := 0
        for _, ctx := range children </span><span class="cov6" title="452">{
                if _, ok := ctx.(IDecoratorContext); ok </span><span class="cov1" title="2">{
                        len++
                }</span>
        }

        <span class="cov4" title="90">tst := make([]IDecoratorContext, len)
        i := 0
        for _, ctx := range children </span><span class="cov6" title="452">{
                if t, ok := ctx.(IDecoratorContext); ok </span><span class="cov1" title="2">{
                        tst[i] = t.(IDecoratorContext)
                        i++
                }</span>
        }

        <span class="cov4" title="90">return tst</span>
}

func (s *VariableDeclContext) Decorator(i int) IDecoratorContext <span class="cov0" title="0">{
        var t antlr.RuleContext
        j := 0
        for _, ctx := range s.GetChildren() </span><span class="cov0" title="0">{
                if _, ok := ctx.(IDecoratorContext); ok </span><span class="cov0" title="0">{
                        if j == i </span><span class="cov0" title="0">{
                                t = ctx.(antlr.RuleContext)
                                break</span>
                        }
                        <span class="cov0" title="0">j++</span>
                }
        }

        <span class="cov0" title="0">if t == nil </span><span class="cov0" title="0">{
                return nil
        }</span>

        <span class="cov0" title="0">return t.(IDecoratorContext)</span>
}

func (s *VariableDeclContext) GetRuleContext() antlr.RuleContext <span class="cov0" title="0">{
        return s
}</span>

func (s *VariableDeclContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string <span class="cov0" title="0">{
        return antlr.TreesStringTree(s, ruleNames, recog)
}</span>

func (s *VariableDeclContext) Accept(visitor antlr.ParseTreeVisitor) interface{} <span class="cov4" title="90">{
        switch t := visitor.(type) </span>{
        case bicepVisitor:<span class="cov4" title="90">
                return t.VisitVariableDecl(s)</span>

        default:<span class="cov0" title="0">
                return t.VisitChildren(s)</span>
        }
}

func (p *bicepParser) VariableDecl() (localctx IVariableDeclContext) <span class="cov4" title="90">{
        localctx = NewVariableDeclContext(p, p.GetParserRuleContext(), p.GetState())
        p.EnterRule(localctx, 16, bicepParserRULE_variableDecl)
        var _la int

        p.EnterOuterAlt(localctx, 1)
        p.SetState(155)
        p.GetErrorHandler().Sync(p)
        if p.HasError() </span><span class="cov0" title="0">{
                goto errorExit</span>
        }
        <span class="cov4" title="90">_la = p.GetTokenStream().LA(1)

        for _la == bicepParserAT </span><span class="cov1" title="2">{
                </span><span class="cov1" title="2">{
                        p.SetState(152)
                        p.Decorator()
                }</span>

                <span class="cov1" title="2">p.SetState(157)
                p.GetErrorHandler().Sync(p)
                if p.HasError() </span><span class="cov0" title="0">{
                        goto errorExit</span>
                }
                <span class="cov1" title="2">_la = p.GetTokenStream().LA(1)</span>
        }
        <span class="cov4" title="90">{
                p.SetState(158)
                p.Match(bicepParserVAR)
                if p.HasError() </span><span class="cov0" title="0">{
                        // Recognition error - abort rule
                        goto errorExit</span>
                }
        }
        <span class="cov4" title="90">{
                p.SetState(159)

                var _x = p.Identifier()

                localctx.(*VariableDeclContext).name = _x
        }</span>
        <span class="cov4" title="90">{
                p.SetState(160)
                p.Match(bicepParserASSIGN)
                if p.HasError() </span><span class="cov0" title="0">{
                        // Recognition error - abort rule
                        goto errorExit</span>
                }
        }
        <span class="cov4" title="90">{
                p.SetState(161)
                p.expression(0)
        }</span>
        <span class="cov4" title="90">{
                p.SetState(162)
                p.Match(bicepParserNL)
                if p.HasError() </span><span class="cov0" title="0">{
                        // Recognition error - abort rule
                        goto errorExit</span>
                }
        }

errorExit:
        <span class="cov4" title="90">if p.HasError() </span><span class="cov0" title="0">{
                v := p.GetError()
                localctx.SetException(v)
                p.GetErrorHandler().ReportError(p, v)
                p.GetErrorHandler().Recover(p, v)
                p.SetError(nil)
        }</span>
        <span class="cov4" title="90">p.ExitRule()
        return localctx
        goto errorExit</span> // Trick to prevent compiler error if the label is not used
}

// IResourceDeclContext is an interface to support dynamic dispatch.
type IResourceDeclContext interface {
        antlr.ParserRuleContext

        // GetParser returns the parser.
        GetParser() antlr.Parser

        // GetName returns the name rule contexts.
        GetName() IIdentifierContext

        // GetType_ returns the type_ rule contexts.
        GetType_() IInterpStringContext

        // SetName sets the name rule contexts.
        SetName(IIdentifierContext)

        // SetType_ sets the type_ rule contexts.
        SetType_(IInterpStringContext)

        // Getter signatures
        RESOURCE() antlr.TerminalNode
        ASSIGN() antlr.TerminalNode
        NL() antlr.TerminalNode
        Identifier() IIdentifierContext
        InterpString() IInterpStringContext
        IfCondition() IIfConditionContext
        Object() IObjectContext
        ForExpression() IForExpressionContext
        AllDecorator() []IDecoratorContext
        Decorator(i int) IDecoratorContext
        EXISTING() antlr.TerminalNode

        // IsResourceDeclContext differentiates from other interfaces.
        IsResourceDeclContext()
}

type ResourceDeclContext struct {
        antlr.BaseParserRuleContext
        parser antlr.Parser
        name   IIdentifierContext
        type_  IInterpStringContext
}

func NewEmptyResourceDeclContext() *ResourceDeclContext <span class="cov0" title="0">{
        var p = new(ResourceDeclContext)
        antlr.InitBaseParserRuleContext(&amp;p.BaseParserRuleContext, nil, -1)
        p.RuleIndex = bicepParserRULE_resourceDecl
        return p
}</span>

func InitEmptyResourceDeclContext(p *ResourceDeclContext) <span class="cov0" title="0">{
        antlr.InitBaseParserRuleContext(&amp;p.BaseParserRuleContext, nil, -1)
        p.RuleIndex = bicepParserRULE_resourceDecl
}</span>

func (*ResourceDeclContext) IsResourceDeclContext() {<span class="cov0" title="0">}</span>

func NewResourceDeclContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *ResourceDeclContext <span class="cov6" title="780">{
        var p = new(ResourceDeclContext)

        antlr.InitBaseParserRuleContext(&amp;p.BaseParserRuleContext, parent, invokingState)

        p.parser = parser
        p.RuleIndex = bicepParserRULE_resourceDecl

        return p
}</span>

func (s *ResourceDeclContext) GetParser() antlr.Parser <span class="cov0" title="0">{ return s.parser }</span>

func (s *ResourceDeclContext) GetName() IIdentifierContext <span class="cov0" title="0">{ return s.name }</span>

func (s *ResourceDeclContext) GetType_() IInterpStringContext <span class="cov0" title="0">{ return s.type_ }</span>

func (s *ResourceDeclContext) SetName(v IIdentifierContext) <span class="cov0" title="0">{ s.name = v }</span>

func (s *ResourceDeclContext) SetType_(v IInterpStringContext) <span class="cov0" title="0">{ s.type_ = v }</span>

func (s *ResourceDeclContext) RESOURCE() antlr.TerminalNode <span class="cov0" title="0">{
        return s.GetToken(bicepParserRESOURCE, 0)
}</span>

func (s *ResourceDeclContext) ASSIGN() antlr.TerminalNode <span class="cov0" title="0">{
        return s.GetToken(bicepParserASSIGN, 0)
}</span>

func (s *ResourceDeclContext) NL() antlr.TerminalNode <span class="cov0" title="0">{
        return s.GetToken(bicepParserNL, 0)
}</span>

func (s *ResourceDeclContext) Identifier() IIdentifierContext <span class="cov6" title="780">{
        var t antlr.RuleContext
        for _, ctx := range s.GetChildren() </span><span class="cov7" title="1561">{
                if _, ok := ctx.(IIdentifierContext); ok </span><span class="cov6" title="780">{
                        t = ctx.(antlr.RuleContext)
                        break</span>
                }
        }

        <span class="cov6" title="780">if t == nil </span><span class="cov0" title="0">{
                return nil
        }</span>

        <span class="cov6" title="780">return t.(IIdentifierContext)</span>
}

func (s *ResourceDeclContext) InterpString() IInterpStringContext <span class="cov6" title="780">{
        var t antlr.RuleContext
        for _, ctx := range s.GetChildren() </span><span class="cov7" title="2341">{
                if _, ok := ctx.(IInterpStringContext); ok </span><span class="cov6" title="780">{
                        t = ctx.(antlr.RuleContext)
                        break</span>
                }
        }

        <span class="cov6" title="780">if t == nil </span><span class="cov0" title="0">{
                return nil
        }</span>

        <span class="cov6" title="780">return t.(IInterpStringContext)</span>
}

func (s *ResourceDeclContext) IfCondition() IIfConditionContext <span class="cov0" title="0">{
        var t antlr.RuleContext
        for _, ctx := range s.GetChildren() </span><span class="cov0" title="0">{
                if _, ok := ctx.(IIfConditionContext); ok </span><span class="cov0" title="0">{
                        t = ctx.(antlr.RuleContext)
                        break</span>
                }
        }

        <span class="cov0" title="0">if t == nil </span><span class="cov0" title="0">{
                return nil
        }</span>

        <span class="cov0" title="0">return t.(IIfConditionContext)</span>
}

func (s *ResourceDeclContext) Object() IObjectContext <span class="cov7" title="1557">{
        var t antlr.RuleContext
        for _, ctx := range s.GetChildren() </span><span class="cov8" title="7794">{
                if _, ok := ctx.(IObjectContext); ok </span><span class="cov7" title="1554">{
                        t = ctx.(antlr.RuleContext)
                        break</span>
                }
        }

        <span class="cov7" title="1557">if t == nil </span><span class="cov1" title="3">{
                return nil
        }</span>

        <span class="cov7" title="1554">return t.(IObjectContext)</span>
}

func (s *ResourceDeclContext) ForExpression() IForExpressionContext <span class="cov0" title="0">{
        var t antlr.RuleContext
        for _, ctx := range s.GetChildren() </span><span class="cov0" title="0">{
                if _, ok := ctx.(IForExpressionContext); ok </span><span class="cov0" title="0">{
                        t = ctx.(antlr.RuleContext)
                        break</span>
                }
        }

        <span class="cov0" title="0">if t == nil </span><span class="cov0" title="0">{
                return nil
        }</span>

        <span class="cov0" title="0">return t.(IForExpressionContext)</span>
}

func (s *ResourceDeclContext) AllDecorator() []IDecoratorContext <span class="cov6" title="780">{
        children := s.GetChildren()
        len := 0
        for _, ctx := range children </span><span class="cov8" title="4683">{
                if _, ok := ctx.(IDecoratorContext); ok </span><span class="cov1" title="1">{
                        len++
                }</span>
        }

        <span class="cov6" title="780">tst := make([]IDecoratorContext, len)
        i := 0
        for _, ctx := range children </span><span class="cov8" title="4683">{
                if t, ok := ctx.(IDecoratorContext); ok </span><span class="cov1" title="1">{
                        tst[i] = t.(IDecoratorContext)
                        i++
                }</span>
        }

        <span class="cov6" title="780">return tst</span>
}

func (s *ResourceDeclContext) Decorator(i int) IDecoratorContext <span class="cov0" title="0">{
        var t antlr.RuleContext
        j := 0
        for _, ctx := range s.GetChildren() </span><span class="cov0" title="0">{
                if _, ok := ctx.(IDecoratorContext); ok </span><span class="cov0" title="0">{
                        if j == i </span><span class="cov0" title="0">{
                                t = ctx.(antlr.RuleContext)
                                break</span>
                        }
                        <span class="cov0" title="0">j++</span>
                }
        }

        <span class="cov0" title="0">if t == nil </span><span class="cov0" title="0">{
                return nil
        }</span>

        <span class="cov0" title="0">return t.(IDecoratorContext)</span>
}

func (s *ResourceDeclContext) EXISTING() antlr.TerminalNode <span class="cov0" title="0">{
        return s.GetToken(bicepParserEXISTING, 0)
}</span>

func (s *ResourceDeclContext) GetRuleContext() antlr.RuleContext <span class="cov0" title="0">{
        return s
}</span>

func (s *ResourceDeclContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string <span class="cov0" title="0">{
        return antlr.TreesStringTree(s, ruleNames, recog)
}</span>

func (s *ResourceDeclContext) Accept(visitor antlr.ParseTreeVisitor) interface{} <span class="cov6" title="780">{
        switch t := visitor.(type) </span>{
        case bicepVisitor:<span class="cov6" title="780">
                return t.VisitResourceDecl(s)</span>

        default:<span class="cov0" title="0">
                return t.VisitChildren(s)</span>
        }
}

func (p *bicepParser) ResourceDecl() (localctx IResourceDeclContext) <span class="cov6" title="780">{
        localctx = NewResourceDeclContext(p, p.GetParserRuleContext(), p.GetState())
        p.EnterRule(localctx, 18, bicepParserRULE_resourceDecl)
        var _la int

        p.EnterOuterAlt(localctx, 1)
        p.SetState(167)
        p.GetErrorHandler().Sync(p)
        if p.HasError() </span><span class="cov0" title="0">{
                goto errorExit</span>
        }
        <span class="cov6" title="780">_la = p.GetTokenStream().LA(1)

        for _la == bicepParserAT </span><span class="cov1" title="1">{
                </span><span class="cov1" title="1">{
                        p.SetState(164)
                        p.Decorator()
                }</span>

                <span class="cov1" title="1">p.SetState(169)
                p.GetErrorHandler().Sync(p)
                if p.HasError() </span><span class="cov0" title="0">{
                        goto errorExit</span>
                }
                <span class="cov1" title="1">_la = p.GetTokenStream().LA(1)</span>
        }
        <span class="cov6" title="780">{
                p.SetState(170)
                p.Match(bicepParserRESOURCE)
                if p.HasError() </span><span class="cov0" title="0">{
                        // Recognition error - abort rule
                        goto errorExit</span>
                }
        }
        <span class="cov6" title="780">{
                p.SetState(171)

                var _x = p.Identifier()

                localctx.(*ResourceDeclContext).name = _x
        }</span>
        <span class="cov6" title="780">{
                p.SetState(172)

                var _x = p.InterpString()

                localctx.(*ResourceDeclContext).type_ = _x
        }</span>
        <span class="cov6" title="780">p.SetState(174)
        p.GetErrorHandler().Sync(p)
        if p.HasError() </span><span class="cov0" title="0">{
                goto errorExit</span>
        }
        <span class="cov6" title="780">_la = p.GetTokenStream().LA(1)

        if _la == bicepParserEXISTING </span><span class="cov1" title="2">{
                </span><span class="cov1" title="2">{
                        p.SetState(173)
                        p.Match(bicepParserEXISTING)
                        if p.HasError() </span><span class="cov0" title="0">{
                                // Recognition error - abort rule
                                goto errorExit</span>
                        }
                }

        }
        <span class="cov6" title="780">{
                p.SetState(176)
                p.Match(bicepParserASSIGN)
                if p.HasError() </span><span class="cov0" title="0">{
                        // Recognition error - abort rule
                        goto errorExit</span>
                }
        }
        <span class="cov6" title="780">p.SetState(180)
        p.GetErrorHandler().Sync(p)
        if p.HasError() </span><span class="cov0" title="0">{
                goto errorExit</span>
        }

        <span class="cov6" title="780">switch p.GetTokenStream().LA(1) </span>{
        case bicepParserIF:<span class="cov1" title="2">
                </span><span class="cov1" title="2">{
                        p.SetState(177)
                        p.IfCondition()
                }</span>

        case bicepParserOBRACE:<span class="cov6" title="777">
                </span><span class="cov6" title="777">{
                        p.SetState(178)
                        p.Object()
                }</span>

        case bicepParserOBRACK:<span class="cov1" title="1">
                </span><span class="cov1" title="1">{
                        p.SetState(179)
                        p.ForExpression()
                }</span>

        default:<span class="cov0" title="0">
                p.SetError(antlr.NewNoViableAltException(p, nil, nil, nil, nil, nil))
                goto errorExit</span>
        }
        <span class="cov6" title="780">{
                p.SetState(182)
                p.Match(bicepParserNL)
                if p.HasError() </span><span class="cov0" title="0">{
                        // Recognition error - abort rule
                        goto errorExit</span>
                }
        }

errorExit:
        <span class="cov6" title="780">if p.HasError() </span><span class="cov0" title="0">{
                v := p.GetError()
                localctx.SetException(v)
                p.GetErrorHandler().ReportError(p, v)
                p.GetErrorHandler().Recover(p, v)
                p.SetError(nil)
        }</span>
        <span class="cov6" title="780">p.ExitRule()
        return localctx
        goto errorExit</span> // Trick to prevent compiler error if the label is not used
}

// IModuleDeclContext is an interface to support dynamic dispatch.
type IModuleDeclContext interface {
        antlr.ParserRuleContext

        // GetParser returns the parser.
        GetParser() antlr.Parser

        // GetName returns the name rule contexts.
        GetName() IIdentifierContext

        // GetType_ returns the type_ rule contexts.
        GetType_() IInterpStringContext

        // SetName sets the name rule contexts.
        SetName(IIdentifierContext)

        // SetType_ sets the type_ rule contexts.
        SetType_(IInterpStringContext)

        // Getter signatures
        MODULE() antlr.TerminalNode
        ASSIGN() antlr.TerminalNode
        NL() antlr.TerminalNode
        Identifier() IIdentifierContext
        InterpString() IInterpStringContext
        IfCondition() IIfConditionContext
        Object() IObjectContext
        ForExpression() IForExpressionContext
        AllDecorator() []IDecoratorContext
        Decorator(i int) IDecoratorContext

        // IsModuleDeclContext differentiates from other interfaces.
        IsModuleDeclContext()
}

type ModuleDeclContext struct {
        antlr.BaseParserRuleContext
        parser antlr.Parser
        name   IIdentifierContext
        type_  IInterpStringContext
}

func NewEmptyModuleDeclContext() *ModuleDeclContext <span class="cov0" title="0">{
        var p = new(ModuleDeclContext)
        antlr.InitBaseParserRuleContext(&amp;p.BaseParserRuleContext, nil, -1)
        p.RuleIndex = bicepParserRULE_moduleDecl
        return p
}</span>

func InitEmptyModuleDeclContext(p *ModuleDeclContext) <span class="cov0" title="0">{
        antlr.InitBaseParserRuleContext(&amp;p.BaseParserRuleContext, nil, -1)
        p.RuleIndex = bicepParserRULE_moduleDecl
}</span>

func (*ModuleDeclContext) IsModuleDeclContext() {<span class="cov0" title="0">}</span>

func NewModuleDeclContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *ModuleDeclContext <span class="cov1" title="2">{
        var p = new(ModuleDeclContext)

        antlr.InitBaseParserRuleContext(&amp;p.BaseParserRuleContext, parent, invokingState)

        p.parser = parser
        p.RuleIndex = bicepParserRULE_moduleDecl

        return p
}</span>

func (s *ModuleDeclContext) GetParser() antlr.Parser <span class="cov0" title="0">{ return s.parser }</span>

func (s *ModuleDeclContext) GetName() IIdentifierContext <span class="cov0" title="0">{ return s.name }</span>

func (s *ModuleDeclContext) GetType_() IInterpStringContext <span class="cov0" title="0">{ return s.type_ }</span>

func (s *ModuleDeclContext) SetName(v IIdentifierContext) <span class="cov0" title="0">{ s.name = v }</span>

func (s *ModuleDeclContext) SetType_(v IInterpStringContext) <span class="cov0" title="0">{ s.type_ = v }</span>

func (s *ModuleDeclContext) MODULE() antlr.TerminalNode <span class="cov0" title="0">{
        return s.GetToken(bicepParserMODULE, 0)
}</span>

func (s *ModuleDeclContext) ASSIGN() antlr.TerminalNode <span class="cov0" title="0">{
        return s.GetToken(bicepParserASSIGN, 0)
}</span>

func (s *ModuleDeclContext) NL() antlr.TerminalNode <span class="cov0" title="0">{
        return s.GetToken(bicepParserNL, 0)
}</span>

func (s *ModuleDeclContext) Identifier() IIdentifierContext <span class="cov0" title="0">{
        var t antlr.RuleContext
        for _, ctx := range s.GetChildren() </span><span class="cov0" title="0">{
                if _, ok := ctx.(IIdentifierContext); ok </span><span class="cov0" title="0">{
                        t = ctx.(antlr.RuleContext)
                        break</span>
                }
        }

        <span class="cov0" title="0">if t == nil </span><span class="cov0" title="0">{
                return nil
        }</span>

        <span class="cov0" title="0">return t.(IIdentifierContext)</span>
}

func (s *ModuleDeclContext) InterpString() IInterpStringContext <span class="cov0" title="0">{
        var t antlr.RuleContext
        for _, ctx := range s.GetChildren() </span><span class="cov0" title="0">{
                if _, ok := ctx.(IInterpStringContext); ok </span><span class="cov0" title="0">{
                        t = ctx.(antlr.RuleContext)
                        break</span>
                }
        }

        <span class="cov0" title="0">if t == nil </span><span class="cov0" title="0">{
                return nil
        }</span>

        <span class="cov0" title="0">return t.(IInterpStringContext)</span>
}

func (s *ModuleDeclContext) IfCondition() IIfConditionContext <span class="cov0" title="0">{
        var t antlr.RuleContext
        for _, ctx := range s.GetChildren() </span><span class="cov0" title="0">{
                if _, ok := ctx.(IIfConditionContext); ok </span><span class="cov0" title="0">{
                        t = ctx.(antlr.RuleContext)
                        break</span>
                }
        }

        <span class="cov0" title="0">if t == nil </span><span class="cov0" title="0">{
                return nil
        }</span>

        <span class="cov0" title="0">return t.(IIfConditionContext)</span>
}

func (s *ModuleDeclContext) Object() IObjectContext <span class="cov0" title="0">{
        var t antlr.RuleContext
        for _, ctx := range s.GetChildren() </span><span class="cov0" title="0">{
                if _, ok := ctx.(IObjectContext); ok </span><span class="cov0" title="0">{
                        t = ctx.(antlr.RuleContext)
                        break</span>
                }
        }

        <span class="cov0" title="0">if t == nil </span><span class="cov0" title="0">{
                return nil
        }</span>

        <span class="cov0" title="0">return t.(IObjectContext)</span>
}

func (s *ModuleDeclContext) ForExpression() IForExpressionContext <span class="cov0" title="0">{
        var t antlr.RuleContext
        for _, ctx := range s.GetChildren() </span><span class="cov0" title="0">{
                if _, ok := ctx.(IForExpressionContext); ok </span><span class="cov0" title="0">{
                        t = ctx.(antlr.RuleContext)
                        break</span>
                }
        }

        <span class="cov0" title="0">if t == nil </span><span class="cov0" title="0">{
                return nil
        }</span>

        <span class="cov0" title="0">return t.(IForExpressionContext)</span>
}

func (s *ModuleDeclContext) AllDecorator() []IDecoratorContext <span class="cov0" title="0">{
        children := s.GetChildren()
        len := 0
        for _, ctx := range children </span><span class="cov0" title="0">{
                if _, ok := ctx.(IDecoratorContext); ok </span><span class="cov0" title="0">{
                        len++
                }</span>
        }

        <span class="cov0" title="0">tst := make([]IDecoratorContext, len)
        i := 0
        for _, ctx := range children </span><span class="cov0" title="0">{
                if t, ok := ctx.(IDecoratorContext); ok </span><span class="cov0" title="0">{
                        tst[i] = t.(IDecoratorContext)
                        i++
                }</span>
        }

        <span class="cov0" title="0">return tst</span>
}

func (s *ModuleDeclContext) Decorator(i int) IDecoratorContext <span class="cov0" title="0">{
        var t antlr.RuleContext
        j := 0
        for _, ctx := range s.GetChildren() </span><span class="cov0" title="0">{
                if _, ok := ctx.(IDecoratorContext); ok </span><span class="cov0" title="0">{
                        if j == i </span><span class="cov0" title="0">{
                                t = ctx.(antlr.RuleContext)
                                break</span>
                        }
                        <span class="cov0" title="0">j++</span>
                }
        }

        <span class="cov0" title="0">if t == nil </span><span class="cov0" title="0">{
                return nil
        }</span>

        <span class="cov0" title="0">return t.(IDecoratorContext)</span>
}

func (s *ModuleDeclContext) GetRuleContext() antlr.RuleContext <span class="cov0" title="0">{
        return s
}</span>

func (s *ModuleDeclContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string <span class="cov0" title="0">{
        return antlr.TreesStringTree(s, ruleNames, recog)
}</span>

func (s *ModuleDeclContext) Accept(visitor antlr.ParseTreeVisitor) interface{} <span class="cov0" title="0">{
        switch t := visitor.(type) </span>{
        case bicepVisitor:<span class="cov0" title="0">
                return t.VisitModuleDecl(s)</span>

        default:<span class="cov0" title="0">
                return t.VisitChildren(s)</span>
        }
}

func (p *bicepParser) ModuleDecl() (localctx IModuleDeclContext) <span class="cov1" title="2">{
        localctx = NewModuleDeclContext(p, p.GetParserRuleContext(), p.GetState())
        p.EnterRule(localctx, 20, bicepParserRULE_moduleDecl)
        var _la int

        p.EnterOuterAlt(localctx, 1)
        p.SetState(187)
        p.GetErrorHandler().Sync(p)
        if p.HasError() </span><span class="cov0" title="0">{
                goto errorExit</span>
        }
        <span class="cov1" title="2">_la = p.GetTokenStream().LA(1)

        for _la == bicepParserAT </span><span class="cov0" title="0">{
                </span><span class="cov0" title="0">{
                        p.SetState(184)
                        p.Decorator()
                }</span>

                <span class="cov0" title="0">p.SetState(189)
                p.GetErrorHandler().Sync(p)
                if p.HasError() </span><span class="cov0" title="0">{
                        goto errorExit</span>
                }
                <span class="cov0" title="0">_la = p.GetTokenStream().LA(1)</span>
        }
        <span class="cov1" title="2">{
                p.SetState(190)
                p.Match(bicepParserMODULE)
                if p.HasError() </span><span class="cov0" title="0">{
                        // Recognition error - abort rule
                        goto errorExit</span>
                }
        }
        <span class="cov1" title="2">{
                p.SetState(191)

                var _x = p.Identifier()

                localctx.(*ModuleDeclContext).name = _x
        }</span>
        <span class="cov1" title="2">{
                p.SetState(192)

                var _x = p.InterpString()

                localctx.(*ModuleDeclContext).type_ = _x
        }</span>
        <span class="cov1" title="2">{
                p.SetState(193)
                p.Match(bicepParserASSIGN)
                if p.HasError() </span><span class="cov0" title="0">{
                        // Recognition error - abort rule
                        goto errorExit</span>
                }
        }
        <span class="cov1" title="2">p.SetState(197)
        p.GetErrorHandler().Sync(p)
        if p.HasError() </span><span class="cov0" title="0">{
                goto errorExit</span>
        }

        <span class="cov1" title="2">switch p.GetTokenStream().LA(1) </span>{
        case bicepParserIF:<span class="cov0" title="0">
                </span><span class="cov0" title="0">{
                        p.SetState(194)
                        p.IfCondition()
                }</span>

        case bicepParserOBRACE:<span class="cov1" title="1">
                </span><span class="cov1" title="1">{
                        p.SetState(195)
                        p.Object()
                }</span>

        case bicepParserOBRACK:<span class="cov1" title="1">
                </span><span class="cov1" title="1">{
                        p.SetState(196)
                        p.ForExpression()
                }</span>

        default:<span class="cov0" title="0">
                p.SetError(antlr.NewNoViableAltException(p, nil, nil, nil, nil, nil))
                goto errorExit</span>
        }
        <span class="cov1" title="2">{
                p.SetState(199)
                p.Match(bicepParserNL)
                if p.HasError() </span><span class="cov1" title="1">{
                        // Recognition error - abort rule
                        goto errorExit</span>
                }
        }

errorExit:
        <span class="cov1" title="2">if p.HasError() </span><span class="cov1" title="1">{
                v := p.GetError()
                localctx.SetException(v)
                p.GetErrorHandler().ReportError(p, v)
                p.GetErrorHandler().Recover(p, v)
                p.SetError(nil)
        }</span>
        <span class="cov1" title="2">p.ExitRule()
        return localctx
        goto errorExit</span> // Trick to prevent compiler error if the label is not used
}

// IOutputDeclContext is an interface to support dynamic dispatch.
type IOutputDeclContext interface {
        antlr.ParserRuleContext

        // GetParser returns the parser.
        GetParser() antlr.Parser

        // GetName returns the name rule contexts.
        GetName() IIdentifierContext

        // GetType1 returns the type1 rule contexts.
        GetType1() IIdentifierContext

        // GetType2 returns the type2 rule contexts.
        GetType2() IInterpStringContext

        // SetName sets the name rule contexts.
        SetName(IIdentifierContext)

        // SetType1 sets the type1 rule contexts.
        SetType1(IIdentifierContext)

        // SetType2 sets the type2 rule contexts.
        SetType2(IInterpStringContext)

        // Getter signatures
        OUTPUT() antlr.TerminalNode
        ASSIGN() antlr.TerminalNode
        Expression() IExpressionContext
        NL() antlr.TerminalNode
        AllIdentifier() []IIdentifierContext
        Identifier(i int) IIdentifierContext
        RESOURCE() antlr.TerminalNode
        AllDecorator() []IDecoratorContext
        Decorator(i int) IDecoratorContext
        InterpString() IInterpStringContext

        // IsOutputDeclContext differentiates from other interfaces.
        IsOutputDeclContext()
}

type OutputDeclContext struct {
        antlr.BaseParserRuleContext
        parser antlr.Parser
        name   IIdentifierContext
        type1  IIdentifierContext
        type2  IInterpStringContext
}

func NewEmptyOutputDeclContext() *OutputDeclContext <span class="cov0" title="0">{
        var p = new(OutputDeclContext)
        antlr.InitBaseParserRuleContext(&amp;p.BaseParserRuleContext, nil, -1)
        p.RuleIndex = bicepParserRULE_outputDecl
        return p
}</span>

func InitEmptyOutputDeclContext(p *OutputDeclContext) <span class="cov0" title="0">{
        antlr.InitBaseParserRuleContext(&amp;p.BaseParserRuleContext, nil, -1)
        p.RuleIndex = bicepParserRULE_outputDecl
}</span>

func (*OutputDeclContext) IsOutputDeclContext() {<span class="cov0" title="0">}</span>

func NewOutputDeclContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *OutputDeclContext <span class="cov2" title="6">{
        var p = new(OutputDeclContext)

        antlr.InitBaseParserRuleContext(&amp;p.BaseParserRuleContext, parent, invokingState)

        p.parser = parser
        p.RuleIndex = bicepParserRULE_outputDecl

        return p
}</span>

func (s *OutputDeclContext) GetParser() antlr.Parser <span class="cov0" title="0">{ return s.parser }</span>

func (s *OutputDeclContext) GetName() IIdentifierContext <span class="cov0" title="0">{ return s.name }</span>

func (s *OutputDeclContext) GetType1() IIdentifierContext <span class="cov0" title="0">{ return s.type1 }</span>

func (s *OutputDeclContext) GetType2() IInterpStringContext <span class="cov0" title="0">{ return s.type2 }</span>

func (s *OutputDeclContext) SetName(v IIdentifierContext) <span class="cov0" title="0">{ s.name = v }</span>

func (s *OutputDeclContext) SetType1(v IIdentifierContext) <span class="cov0" title="0">{ s.type1 = v }</span>

func (s *OutputDeclContext) SetType2(v IInterpStringContext) <span class="cov0" title="0">{ s.type2 = v }</span>

func (s *OutputDeclContext) OUTPUT() antlr.TerminalNode <span class="cov0" title="0">{
        return s.GetToken(bicepParserOUTPUT, 0)
}</span>

func (s *OutputDeclContext) ASSIGN() antlr.TerminalNode <span class="cov0" title="0">{
        return s.GetToken(bicepParserASSIGN, 0)
}</span>

func (s *OutputDeclContext) Expression() IExpressionContext <span class="cov0" title="0">{
        var t antlr.RuleContext
        for _, ctx := range s.GetChildren() </span><span class="cov0" title="0">{
                if _, ok := ctx.(IExpressionContext); ok </span><span class="cov0" title="0">{
                        t = ctx.(antlr.RuleContext)
                        break</span>
                }
        }

        <span class="cov0" title="0">if t == nil </span><span class="cov0" title="0">{
                return nil
        }</span>

        <span class="cov0" title="0">return t.(IExpressionContext)</span>
}

func (s *OutputDeclContext) NL() antlr.TerminalNode <span class="cov0" title="0">{
        return s.GetToken(bicepParserNL, 0)
}</span>

func (s *OutputDeclContext) AllIdentifier() []IIdentifierContext <span class="cov0" title="0">{
        children := s.GetChildren()
        len := 0
        for _, ctx := range children </span><span class="cov0" title="0">{
                if _, ok := ctx.(IIdentifierContext); ok </span><span class="cov0" title="0">{
                        len++
                }</span>
        }

        <span class="cov0" title="0">tst := make([]IIdentifierContext, len)
        i := 0
        for _, ctx := range children </span><span class="cov0" title="0">{
                if t, ok := ctx.(IIdentifierContext); ok </span><span class="cov0" title="0">{
                        tst[i] = t.(IIdentifierContext)
                        i++
                }</span>
        }

        <span class="cov0" title="0">return tst</span>
}

func (s *OutputDeclContext) Identifier(i int) IIdentifierContext <span class="cov0" title="0">{
        var t antlr.RuleContext
        j := 0
        for _, ctx := range s.GetChildren() </span><span class="cov0" title="0">{
                if _, ok := ctx.(IIdentifierContext); ok </span><span class="cov0" title="0">{
                        if j == i </span><span class="cov0" title="0">{
                                t = ctx.(antlr.RuleContext)
                                break</span>
                        }
                        <span class="cov0" title="0">j++</span>
                }
        }

        <span class="cov0" title="0">if t == nil </span><span class="cov0" title="0">{
                return nil
        }</span>

        <span class="cov0" title="0">return t.(IIdentifierContext)</span>
}

func (s *OutputDeclContext) RESOURCE() antlr.TerminalNode <span class="cov0" title="0">{
        return s.GetToken(bicepParserRESOURCE, 0)
}</span>

func (s *OutputDeclContext) AllDecorator() []IDecoratorContext <span class="cov0" title="0">{
        children := s.GetChildren()
        len := 0
        for _, ctx := range children </span><span class="cov0" title="0">{
                if _, ok := ctx.(IDecoratorContext); ok </span><span class="cov0" title="0">{
                        len++
                }</span>
        }

        <span class="cov0" title="0">tst := make([]IDecoratorContext, len)
        i := 0
        for _, ctx := range children </span><span class="cov0" title="0">{
                if t, ok := ctx.(IDecoratorContext); ok </span><span class="cov0" title="0">{
                        tst[i] = t.(IDecoratorContext)
                        i++
                }</span>
        }

        <span class="cov0" title="0">return tst</span>
}

func (s *OutputDeclContext) Decorator(i int) IDecoratorContext <span class="cov0" title="0">{
        var t antlr.RuleContext
        j := 0
        for _, ctx := range s.GetChildren() </span><span class="cov0" title="0">{
                if _, ok := ctx.(IDecoratorContext); ok </span><span class="cov0" title="0">{
                        if j == i </span><span class="cov0" title="0">{
                                t = ctx.(antlr.RuleContext)
                                break</span>
                        }
                        <span class="cov0" title="0">j++</span>
                }
        }

        <span class="cov0" title="0">if t == nil </span><span class="cov0" title="0">{
                return nil
        }</span>

        <span class="cov0" title="0">return t.(IDecoratorContext)</span>
}

func (s *OutputDeclContext) InterpString() IInterpStringContext <span class="cov0" title="0">{
        var t antlr.RuleContext
        for _, ctx := range s.GetChildren() </span><span class="cov0" title="0">{
                if _, ok := ctx.(IInterpStringContext); ok </span><span class="cov0" title="0">{
                        t = ctx.(antlr.RuleContext)
                        break</span>
                }
        }

        <span class="cov0" title="0">if t == nil </span><span class="cov0" title="0">{
                return nil
        }</span>

        <span class="cov0" title="0">return t.(IInterpStringContext)</span>
}

func (s *OutputDeclContext) GetRuleContext() antlr.RuleContext <span class="cov0" title="0">{
        return s
}</span>

func (s *OutputDeclContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string <span class="cov0" title="0">{
        return antlr.TreesStringTree(s, ruleNames, recog)
}</span>

func (s *OutputDeclContext) Accept(visitor antlr.ParseTreeVisitor) interface{} <span class="cov0" title="0">{
        switch t := visitor.(type) </span>{
        case bicepVisitor:<span class="cov0" title="0">
                return t.VisitOutputDecl(s)</span>

        default:<span class="cov0" title="0">
                return t.VisitChildren(s)</span>
        }
}

func (p *bicepParser) OutputDecl() (localctx IOutputDeclContext) <span class="cov2" title="6">{
        localctx = NewOutputDeclContext(p, p.GetParserRuleContext(), p.GetState())
        p.EnterRule(localctx, 22, bicepParserRULE_outputDecl)
        var _la int

        p.EnterOuterAlt(localctx, 1)
        p.SetState(204)
        p.GetErrorHandler().Sync(p)
        if p.HasError() </span><span class="cov0" title="0">{
                goto errorExit</span>
        }
        <span class="cov2" title="6">_la = p.GetTokenStream().LA(1)

        for _la == bicepParserAT </span><span class="cov1" title="1">{
                </span><span class="cov1" title="1">{
                        p.SetState(201)
                        p.Decorator()
                }</span>

                <span class="cov1" title="1">p.SetState(206)
                p.GetErrorHandler().Sync(p)
                if p.HasError() </span><span class="cov0" title="0">{
                        goto errorExit</span>
                }
                <span class="cov1" title="1">_la = p.GetTokenStream().LA(1)</span>
        }
        <span class="cov2" title="6">{
                p.SetState(207)
                p.Match(bicepParserOUTPUT)
                if p.HasError() </span><span class="cov0" title="0">{
                        // Recognition error - abort rule
                        goto errorExit</span>
                }
        }
        <span class="cov2" title="6">{
                p.SetState(208)

                var _x = p.Identifier()

                localctx.(*OutputDeclContext).name = _x
        }</span>
        <span class="cov2" title="6">p.SetState(212)
        p.GetErrorHandler().Sync(p)
        if p.HasError() </span><span class="cov0" title="0">{
                goto errorExit</span>
        }

        <span class="cov2" title="6">switch p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 17, p.GetParserRuleContext()) </span>{
        case 1:<span class="cov2" title="6">
                </span><span class="cov2" title="6">{
                        p.SetState(209)

                        var _x = p.Identifier()

                        localctx.(*OutputDeclContext).type1 = _x
                }</span>

        case 2:<span class="cov0" title="0">
                </span><span class="cov0" title="0">{
                        p.SetState(210)
                        p.Match(bicepParserRESOURCE)
                        if p.HasError() </span><span class="cov0" title="0">{
                                // Recognition error - abort rule
                                goto errorExit</span>
                        }
                }
                <span class="cov0" title="0">{
                        p.SetState(211)

                        var _x = p.InterpString()

                        localctx.(*OutputDeclContext).type2 = _x
                }</span>

        case antlr.ATNInvalidAltNumber:<span class="cov0" title="0">
                goto errorExit</span>
        }
        <span class="cov2" title="6">{
                p.SetState(214)
                p.Match(bicepParserASSIGN)
                if p.HasError() </span><span class="cov0" title="0">{
                        // Recognition error - abort rule
                        goto errorExit</span>
                }
        }
        <span class="cov2" title="6">{
                p.SetState(215)
                p.expression(0)
        }</span>
        <span class="cov2" title="6">{
                p.SetState(216)
                p.Match(bicepParserNL)
                if p.HasError() </span><span class="cov0" title="0">{
                        // Recognition error - abort rule
                        goto errorExit</span>
                }
        }

errorExit:
        <span class="cov2" title="6">if p.HasError() </span><span class="cov0" title="0">{
                v := p.GetError()
                localctx.SetException(v)
                p.GetErrorHandler().ReportError(p, v)
                p.GetErrorHandler().Recover(p, v)
                p.SetError(nil)
        }</span>
        <span class="cov2" title="6">p.ExitRule()
        return localctx
        goto errorExit</span> // Trick to prevent compiler error if the label is not used
}

// IIfConditionContext is an interface to support dynamic dispatch.
type IIfConditionContext interface {
        antlr.ParserRuleContext

        // GetParser returns the parser.
        GetParser() antlr.Parser

        // Getter signatures
        IF() antlr.TerminalNode
        ParenthesizedExpression() IParenthesizedExpressionContext
        Object() IObjectContext

        // IsIfConditionContext differentiates from other interfaces.
        IsIfConditionContext()
}

type IfConditionContext struct {
        antlr.BaseParserRuleContext
        parser antlr.Parser
}

func NewEmptyIfConditionContext() *IfConditionContext <span class="cov0" title="0">{
        var p = new(IfConditionContext)
        antlr.InitBaseParserRuleContext(&amp;p.BaseParserRuleContext, nil, -1)
        p.RuleIndex = bicepParserRULE_ifCondition
        return p
}</span>

func InitEmptyIfConditionContext(p *IfConditionContext) <span class="cov0" title="0">{
        antlr.InitBaseParserRuleContext(&amp;p.BaseParserRuleContext, nil, -1)
        p.RuleIndex = bicepParserRULE_ifCondition
}</span>

func (*IfConditionContext) IsIfConditionContext() {<span class="cov0" title="0">}</span>

func NewIfConditionContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *IfConditionContext <span class="cov1" title="2">{
        var p = new(IfConditionContext)

        antlr.InitBaseParserRuleContext(&amp;p.BaseParserRuleContext, parent, invokingState)

        p.parser = parser
        p.RuleIndex = bicepParserRULE_ifCondition

        return p
}</span>

func (s *IfConditionContext) GetParser() antlr.Parser <span class="cov0" title="0">{ return s.parser }</span>

func (s *IfConditionContext) IF() antlr.TerminalNode <span class="cov0" title="0">{
        return s.GetToken(bicepParserIF, 0)
}</span>

func (s *IfConditionContext) ParenthesizedExpression() IParenthesizedExpressionContext <span class="cov0" title="0">{
        var t antlr.RuleContext
        for _, ctx := range s.GetChildren() </span><span class="cov0" title="0">{
                if _, ok := ctx.(IParenthesizedExpressionContext); ok </span><span class="cov0" title="0">{
                        t = ctx.(antlr.RuleContext)
                        break</span>
                }
        }

        <span class="cov0" title="0">if t == nil </span><span class="cov0" title="0">{
                return nil
        }</span>

        <span class="cov0" title="0">return t.(IParenthesizedExpressionContext)</span>
}

func (s *IfConditionContext) Object() IObjectContext <span class="cov0" title="0">{
        var t antlr.RuleContext
        for _, ctx := range s.GetChildren() </span><span class="cov0" title="0">{
                if _, ok := ctx.(IObjectContext); ok </span><span class="cov0" title="0">{
                        t = ctx.(antlr.RuleContext)
                        break</span>
                }
        }

        <span class="cov0" title="0">if t == nil </span><span class="cov0" title="0">{
                return nil
        }</span>

        <span class="cov0" title="0">return t.(IObjectContext)</span>
}

func (s *IfConditionContext) GetRuleContext() antlr.RuleContext <span class="cov0" title="0">{
        return s
}</span>

func (s *IfConditionContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string <span class="cov0" title="0">{
        return antlr.TreesStringTree(s, ruleNames, recog)
}</span>

func (s *IfConditionContext) Accept(visitor antlr.ParseTreeVisitor) interface{} <span class="cov0" title="0">{
        switch t := visitor.(type) </span>{
        case bicepVisitor:<span class="cov0" title="0">
                return t.VisitIfCondition(s)</span>

        default:<span class="cov0" title="0">
                return t.VisitChildren(s)</span>
        }
}

func (p *bicepParser) IfCondition() (localctx IIfConditionContext) <span class="cov1" title="2">{
        localctx = NewIfConditionContext(p, p.GetParserRuleContext(), p.GetState())
        p.EnterRule(localctx, 24, bicepParserRULE_ifCondition)
        p.EnterOuterAlt(localctx, 1)
        </span><span class="cov1" title="2">{
                p.SetState(218)
                p.Match(bicepParserIF)
                if p.HasError() </span><span class="cov0" title="0">{
                        // Recognition error - abort rule
                        goto errorExit</span>
                }
        }
        <span class="cov1" title="2">{
                p.SetState(219)
                p.ParenthesizedExpression()
        }</span>
        <span class="cov1" title="2">{
                p.SetState(220)
                p.Object()
        }</span>

errorExit:
        <span class="cov1" title="2">if p.HasError() </span><span class="cov0" title="0">{
                v := p.GetError()
                localctx.SetException(v)
                p.GetErrorHandler().ReportError(p, v)
                p.GetErrorHandler().Recover(p, v)
                p.SetError(nil)
        }</span>
        <span class="cov1" title="2">p.ExitRule()
        return localctx
        goto errorExit</span> // Trick to prevent compiler error if the label is not used
}

// IForExpressionContext is an interface to support dynamic dispatch.
type IForExpressionContext interface {
        antlr.ParserRuleContext

        // GetParser returns the parser.
        GetParser() antlr.Parser

        // GetItem returns the item rule contexts.
        GetItem() IIdentifierContext

        // SetItem sets the item rule contexts.
        SetItem(IIdentifierContext)

        // Getter signatures
        OBRACK() antlr.TerminalNode
        FOR() antlr.TerminalNode
        IN() antlr.TerminalNode
        Expression() IExpressionContext
        COL() antlr.TerminalNode
        ForBody() IForBodyContext
        CBRACK() antlr.TerminalNode
        ForVariableBlock() IForVariableBlockContext
        AllNL() []antlr.TerminalNode
        NL(i int) antlr.TerminalNode
        Identifier() IIdentifierContext

        // IsForExpressionContext differentiates from other interfaces.
        IsForExpressionContext()
}

type ForExpressionContext struct {
        antlr.BaseParserRuleContext
        parser antlr.Parser
        item   IIdentifierContext
}

func NewEmptyForExpressionContext() *ForExpressionContext <span class="cov0" title="0">{
        var p = new(ForExpressionContext)
        antlr.InitBaseParserRuleContext(&amp;p.BaseParserRuleContext, nil, -1)
        p.RuleIndex = bicepParserRULE_forExpression
        return p
}</span>

func InitEmptyForExpressionContext(p *ForExpressionContext) <span class="cov0" title="0">{
        antlr.InitBaseParserRuleContext(&amp;p.BaseParserRuleContext, nil, -1)
        p.RuleIndex = bicepParserRULE_forExpression
}</span>

func (*ForExpressionContext) IsForExpressionContext() {<span class="cov0" title="0">}</span>

func NewForExpressionContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *ForExpressionContext <span class="cov2" title="7">{
        var p = new(ForExpressionContext)

        antlr.InitBaseParserRuleContext(&amp;p.BaseParserRuleContext, parent, invokingState)

        p.parser = parser
        p.RuleIndex = bicepParserRULE_forExpression

        return p
}</span>

func (s *ForExpressionContext) GetParser() antlr.Parser <span class="cov0" title="0">{ return s.parser }</span>

func (s *ForExpressionContext) GetItem() IIdentifierContext <span class="cov0" title="0">{ return s.item }</span>

func (s *ForExpressionContext) SetItem(v IIdentifierContext) <span class="cov0" title="0">{ s.item = v }</span>

func (s *ForExpressionContext) OBRACK() antlr.TerminalNode <span class="cov0" title="0">{
        return s.GetToken(bicepParserOBRACK, 0)
}</span>

func (s *ForExpressionContext) FOR() antlr.TerminalNode <span class="cov0" title="0">{
        return s.GetToken(bicepParserFOR, 0)
}</span>

func (s *ForExpressionContext) IN() antlr.TerminalNode <span class="cov0" title="0">{
        return s.GetToken(bicepParserIN, 0)
}</span>

func (s *ForExpressionContext) Expression() IExpressionContext <span class="cov0" title="0">{
        var t antlr.RuleContext
        for _, ctx := range s.GetChildren() </span><span class="cov0" title="0">{
                if _, ok := ctx.(IExpressionContext); ok </span><span class="cov0" title="0">{
                        t = ctx.(antlr.RuleContext)
                        break</span>
                }
        }

        <span class="cov0" title="0">if t == nil </span><span class="cov0" title="0">{
                return nil
        }</span>

        <span class="cov0" title="0">return t.(IExpressionContext)</span>
}

func (s *ForExpressionContext) COL() antlr.TerminalNode <span class="cov0" title="0">{
        return s.GetToken(bicepParserCOL, 0)
}</span>

func (s *ForExpressionContext) ForBody() IForBodyContext <span class="cov0" title="0">{
        var t antlr.RuleContext
        for _, ctx := range s.GetChildren() </span><span class="cov0" title="0">{
                if _, ok := ctx.(IForBodyContext); ok </span><span class="cov0" title="0">{
                        t = ctx.(antlr.RuleContext)
                        break</span>
                }
        }

        <span class="cov0" title="0">if t == nil </span><span class="cov0" title="0">{
                return nil
        }</span>

        <span class="cov0" title="0">return t.(IForBodyContext)</span>
}

func (s *ForExpressionContext) CBRACK() antlr.TerminalNode <span class="cov0" title="0">{
        return s.GetToken(bicepParserCBRACK, 0)
}</span>

func (s *ForExpressionContext) ForVariableBlock() IForVariableBlockContext <span class="cov0" title="0">{
        var t antlr.RuleContext
        for _, ctx := range s.GetChildren() </span><span class="cov0" title="0">{
                if _, ok := ctx.(IForVariableBlockContext); ok </span><span class="cov0" title="0">{
                        t = ctx.(antlr.RuleContext)
                        break</span>
                }
        }

        <span class="cov0" title="0">if t == nil </span><span class="cov0" title="0">{
                return nil
        }</span>

        <span class="cov0" title="0">return t.(IForVariableBlockContext)</span>
}

func (s *ForExpressionContext) AllNL() []antlr.TerminalNode <span class="cov0" title="0">{
        return s.GetTokens(bicepParserNL)
}</span>

func (s *ForExpressionContext) NL(i int) antlr.TerminalNode <span class="cov0" title="0">{
        return s.GetToken(bicepParserNL, i)
}</span>

func (s *ForExpressionContext) Identifier() IIdentifierContext <span class="cov0" title="0">{
        var t antlr.RuleContext
        for _, ctx := range s.GetChildren() </span><span class="cov0" title="0">{
                if _, ok := ctx.(IIdentifierContext); ok </span><span class="cov0" title="0">{
                        t = ctx.(antlr.RuleContext)
                        break</span>
                }
        }

        <span class="cov0" title="0">if t == nil </span><span class="cov0" title="0">{
                return nil
        }</span>

        <span class="cov0" title="0">return t.(IIdentifierContext)</span>
}

func (s *ForExpressionContext) GetRuleContext() antlr.RuleContext <span class="cov0" title="0">{
        return s
}</span>

func (s *ForExpressionContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string <span class="cov0" title="0">{
        return antlr.TreesStringTree(s, ruleNames, recog)
}</span>

func (s *ForExpressionContext) Accept(visitor antlr.ParseTreeVisitor) interface{} <span class="cov0" title="0">{
        switch t := visitor.(type) </span>{
        case bicepVisitor:<span class="cov0" title="0">
                return t.VisitForExpression(s)</span>

        default:<span class="cov0" title="0">
                return t.VisitChildren(s)</span>
        }
}

func (p *bicepParser) ForExpression() (localctx IForExpressionContext) <span class="cov2" title="7">{
        localctx = NewForExpressionContext(p, p.GetParserRuleContext(), p.GetState())
        p.EnterRule(localctx, 26, bicepParserRULE_forExpression)
        var _la int

        p.EnterOuterAlt(localctx, 1)
        </span><span class="cov2" title="7">{
                p.SetState(222)
                p.Match(bicepParserOBRACK)
                if p.HasError() </span><span class="cov0" title="0">{
                        // Recognition error - abort rule
                        goto errorExit</span>
                }
        }
        <span class="cov2" title="7">p.SetState(226)
        p.GetErrorHandler().Sync(p)
        if p.HasError() </span><span class="cov0" title="0">{
                goto errorExit</span>
        }
        <span class="cov2" title="7">_la = p.GetTokenStream().LA(1)

        for _la == bicepParserNL </span><span class="cov1" title="2">{
                </span><span class="cov1" title="2">{
                        p.SetState(223)
                        p.Match(bicepParserNL)
                        if p.HasError() </span><span class="cov0" title="0">{
                                // Recognition error - abort rule
                                goto errorExit</span>
                        }
                }

                <span class="cov1" title="2">p.SetState(228)
                p.GetErrorHandler().Sync(p)
                if p.HasError() </span><span class="cov0" title="0">{
                        goto errorExit</span>
                }
                <span class="cov1" title="2">_la = p.GetTokenStream().LA(1)</span>
        }
        <span class="cov2" title="7">{
                p.SetState(229)
                p.Match(bicepParserFOR)
                if p.HasError() </span><span class="cov0" title="0">{
                        // Recognition error - abort rule
                        goto errorExit</span>
                }
        }
        <span class="cov2" title="7">p.SetState(232)
        p.GetErrorHandler().Sync(p)
        if p.HasError() </span><span class="cov0" title="0">{
                goto errorExit</span>
        }

        <span class="cov2" title="7">switch p.GetTokenStream().LA(1) </span>{
        case bicepParserPARAM, bicepParserVAR, bicepParserTRUE, bicepParserFALSE, bicepParserNULL, bicepParserARRAY, bicepParserOBJECT, bicepParserRESOURCE, bicepParserOUTPUT, bicepParserTARGET_SCOPE, bicepParserIMPORT, bicepParserWITH, bicepParserAS, bicepParserMETADATA, bicepParserEXISTING, bicepParserTYPE, bicepParserMODULE, bicepParserSTRING, bicepParserINT, bicepParserBOOL, bicepParserIF, bicepParserFOR, bicepParserIN, bicepParserIDENTIFIER:<span class="cov2" title="7">
                </span><span class="cov2" title="7">{
                        p.SetState(230)

                        var _x = p.Identifier()

                        localctx.(*ForExpressionContext).item = _x
                }</span>

        case bicepParserOPAR:<span class="cov0" title="0">
                </span><span class="cov0" title="0">{
                        p.SetState(231)
                        p.ForVariableBlock()
                }</span>

        default:<span class="cov0" title="0">
                p.SetError(antlr.NewNoViableAltException(p, nil, nil, nil, nil, nil))
                goto errorExit</span>
        }
        <span class="cov2" title="7">{
                p.SetState(234)
                p.Match(bicepParserIN)
                if p.HasError() </span><span class="cov0" title="0">{
                        // Recognition error - abort rule
                        goto errorExit</span>
                }
        }
        <span class="cov2" title="7">{
                p.SetState(235)
                p.expression(0)
        }</span>
        <span class="cov2" title="7">{
                p.SetState(236)
                p.Match(bicepParserCOL)
                if p.HasError() </span><span class="cov0" title="0">{
                        // Recognition error - abort rule
                        goto errorExit</span>
                }
        }
        <span class="cov2" title="7">{
                p.SetState(237)
                p.ForBody()
        }</span>
        <span class="cov2" title="7">p.SetState(241)
        p.GetErrorHandler().Sync(p)
        if p.HasError() </span><span class="cov0" title="0">{
                goto errorExit</span>
        }
        <span class="cov2" title="7">_la = p.GetTokenStream().LA(1)

        for _la == bicepParserNL </span><span class="cov1" title="2">{
                </span><span class="cov1" title="2">{
                        p.SetState(238)
                        p.Match(bicepParserNL)
                        if p.HasError() </span><span class="cov0" title="0">{
                                // Recognition error - abort rule
                                goto errorExit</span>
                        }
                }

                <span class="cov1" title="2">p.SetState(243)
                p.GetErrorHandler().Sync(p)
                if p.HasError() </span><span class="cov0" title="0">{
                        goto errorExit</span>
                }
                <span class="cov1" title="2">_la = p.GetTokenStream().LA(1)</span>
        }
        <span class="cov2" title="7">{
                p.SetState(244)
                p.Match(bicepParserCBRACK)
                if p.HasError() </span><span class="cov0" title="0">{
                        // Recognition error - abort rule
                        goto errorExit</span>
                }
        }

errorExit:
        <span class="cov2" title="7">if p.HasError() </span><span class="cov0" title="0">{
                v := p.GetError()
                localctx.SetException(v)
                p.GetErrorHandler().ReportError(p, v)
                p.GetErrorHandler().Recover(p, v)
                p.SetError(nil)
        }</span>
        <span class="cov2" title="7">p.ExitRule()
        return localctx
        goto errorExit</span> // Trick to prevent compiler error if the label is not used
}

// IForVariableBlockContext is an interface to support dynamic dispatch.
type IForVariableBlockContext interface {
        antlr.ParserRuleContext

        // GetParser returns the parser.
        GetParser() antlr.Parser

        // GetItem returns the item rule contexts.
        GetItem() IIdentifierContext

        // GetIndex returns the index rule contexts.
        GetIndex() IIdentifierContext

        // SetItem sets the item rule contexts.
        SetItem(IIdentifierContext)

        // SetIndex sets the index rule contexts.
        SetIndex(IIdentifierContext)

        // Getter signatures
        OPAR() antlr.TerminalNode
        COMMA() antlr.TerminalNode
        CPAR() antlr.TerminalNode
        AllIdentifier() []IIdentifierContext
        Identifier(i int) IIdentifierContext

        // IsForVariableBlockContext differentiates from other interfaces.
        IsForVariableBlockContext()
}

type ForVariableBlockContext struct {
        antlr.BaseParserRuleContext
        parser antlr.Parser
        item   IIdentifierContext
        index  IIdentifierContext
}

func NewEmptyForVariableBlockContext() *ForVariableBlockContext <span class="cov0" title="0">{
        var p = new(ForVariableBlockContext)
        antlr.InitBaseParserRuleContext(&amp;p.BaseParserRuleContext, nil, -1)
        p.RuleIndex = bicepParserRULE_forVariableBlock
        return p
}</span>

func InitEmptyForVariableBlockContext(p *ForVariableBlockContext) <span class="cov0" title="0">{
        antlr.InitBaseParserRuleContext(&amp;p.BaseParserRuleContext, nil, -1)
        p.RuleIndex = bicepParserRULE_forVariableBlock
}</span>

func (*ForVariableBlockContext) IsForVariableBlockContext() {<span class="cov0" title="0">}</span>

func NewForVariableBlockContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *ForVariableBlockContext <span class="cov0" title="0">{
        var p = new(ForVariableBlockContext)

        antlr.InitBaseParserRuleContext(&amp;p.BaseParserRuleContext, parent, invokingState)

        p.parser = parser
        p.RuleIndex = bicepParserRULE_forVariableBlock

        return p
}</span>

func (s *ForVariableBlockContext) GetParser() antlr.Parser <span class="cov0" title="0">{ return s.parser }</span>

func (s *ForVariableBlockContext) GetItem() IIdentifierContext <span class="cov0" title="0">{ return s.item }</span>

func (s *ForVariableBlockContext) GetIndex() IIdentifierContext <span class="cov0" title="0">{ return s.index }</span>

func (s *ForVariableBlockContext) SetItem(v IIdentifierContext) <span class="cov0" title="0">{ s.item = v }</span>

func (s *ForVariableBlockContext) SetIndex(v IIdentifierContext) <span class="cov0" title="0">{ s.index = v }</span>

func (s *ForVariableBlockContext) OPAR() antlr.TerminalNode <span class="cov0" title="0">{
        return s.GetToken(bicepParserOPAR, 0)
}</span>

func (s *ForVariableBlockContext) COMMA() antlr.TerminalNode <span class="cov0" title="0">{
        return s.GetToken(bicepParserCOMMA, 0)
}</span>

func (s *ForVariableBlockContext) CPAR() antlr.TerminalNode <span class="cov0" title="0">{
        return s.GetToken(bicepParserCPAR, 0)
}</span>

func (s *ForVariableBlockContext) AllIdentifier() []IIdentifierContext <span class="cov0" title="0">{
        children := s.GetChildren()
        len := 0
        for _, ctx := range children </span><span class="cov0" title="0">{
                if _, ok := ctx.(IIdentifierContext); ok </span><span class="cov0" title="0">{
                        len++
                }</span>
        }

        <span class="cov0" title="0">tst := make([]IIdentifierContext, len)
        i := 0
        for _, ctx := range children </span><span class="cov0" title="0">{
                if t, ok := ctx.(IIdentifierContext); ok </span><span class="cov0" title="0">{
                        tst[i] = t.(IIdentifierContext)
                        i++
                }</span>
        }

        <span class="cov0" title="0">return tst</span>
}

func (s *ForVariableBlockContext) Identifier(i int) IIdentifierContext <span class="cov0" title="0">{
        var t antlr.RuleContext
        j := 0
        for _, ctx := range s.GetChildren() </span><span class="cov0" title="0">{
                if _, ok := ctx.(IIdentifierContext); ok </span><span class="cov0" title="0">{
                        if j == i </span><span class="cov0" title="0">{
                                t = ctx.(antlr.RuleContext)
                                break</span>
                        }
                        <span class="cov0" title="0">j++</span>
                }
        }

        <span class="cov0" title="0">if t == nil </span><span class="cov0" title="0">{
                return nil
        }</span>

        <span class="cov0" title="0">return t.(IIdentifierContext)</span>
}

func (s *ForVariableBlockContext) GetRuleContext() antlr.RuleContext <span class="cov0" title="0">{
        return s
}</span>

func (s *ForVariableBlockContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string <span class="cov0" title="0">{
        return antlr.TreesStringTree(s, ruleNames, recog)
}</span>

func (s *ForVariableBlockContext) Accept(visitor antlr.ParseTreeVisitor) interface{} <span class="cov0" title="0">{
        switch t := visitor.(type) </span>{
        case bicepVisitor:<span class="cov0" title="0">
                return t.VisitForVariableBlock(s)</span>

        default:<span class="cov0" title="0">
                return t.VisitChildren(s)</span>
        }
}

func (p *bicepParser) ForVariableBlock() (localctx IForVariableBlockContext) <span class="cov0" title="0">{
        localctx = NewForVariableBlockContext(p, p.GetParserRuleContext(), p.GetState())
        p.EnterRule(localctx, 28, bicepParserRULE_forVariableBlock)
        p.EnterOuterAlt(localctx, 1)
        </span><span class="cov0" title="0">{
                p.SetState(246)
                p.Match(bicepParserOPAR)
                if p.HasError() </span><span class="cov0" title="0">{
                        // Recognition error - abort rule
                        goto errorExit</span>
                }
        }
        <span class="cov0" title="0">{
                p.SetState(247)

                var _x = p.Identifier()

                localctx.(*ForVariableBlockContext).item = _x
        }</span>
        <span class="cov0" title="0">{
                p.SetState(248)
                p.Match(bicepParserCOMMA)
                if p.HasError() </span><span class="cov0" title="0">{
                        // Recognition error - abort rule
                        goto errorExit</span>
                }
        }
        <span class="cov0" title="0">{
                p.SetState(249)

                var _x = p.Identifier()

                localctx.(*ForVariableBlockContext).index = _x
        }</span>
        <span class="cov0" title="0">{
                p.SetState(250)
                p.Match(bicepParserCPAR)
                if p.HasError() </span><span class="cov0" title="0">{
                        // Recognition error - abort rule
                        goto errorExit</span>
                }
        }

errorExit:
        <span class="cov0" title="0">if p.HasError() </span><span class="cov0" title="0">{
                v := p.GetError()
                localctx.SetException(v)
                p.GetErrorHandler().ReportError(p, v)
                p.GetErrorHandler().Recover(p, v)
                p.SetError(nil)
        }</span>
        <span class="cov0" title="0">p.ExitRule()
        return localctx
        goto errorExit</span> // Trick to prevent compiler error if the label is not used
}

// IForBodyContext is an interface to support dynamic dispatch.
type IForBodyContext interface {
        antlr.ParserRuleContext

        // GetParser returns the parser.
        GetParser() antlr.Parser

        // GetBody returns the body rule contexts.
        GetBody() IExpressionContext

        // SetBody sets the body rule contexts.
        SetBody(IExpressionContext)

        // Getter signatures
        Expression() IExpressionContext
        IfCondition() IIfConditionContext

        // IsForBodyContext differentiates from other interfaces.
        IsForBodyContext()
}

type ForBodyContext struct {
        antlr.BaseParserRuleContext
        parser antlr.Parser
        body   IExpressionContext
}

func NewEmptyForBodyContext() *ForBodyContext <span class="cov0" title="0">{
        var p = new(ForBodyContext)
        antlr.InitBaseParserRuleContext(&amp;p.BaseParserRuleContext, nil, -1)
        p.RuleIndex = bicepParserRULE_forBody
        return p
}</span>

func InitEmptyForBodyContext(p *ForBodyContext) <span class="cov0" title="0">{
        antlr.InitBaseParserRuleContext(&amp;p.BaseParserRuleContext, nil, -1)
        p.RuleIndex = bicepParserRULE_forBody
}</span>

func (*ForBodyContext) IsForBodyContext() {<span class="cov0" title="0">}</span>

func NewForBodyContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *ForBodyContext <span class="cov2" title="7">{
        var p = new(ForBodyContext)

        antlr.InitBaseParserRuleContext(&amp;p.BaseParserRuleContext, parent, invokingState)

        p.parser = parser
        p.RuleIndex = bicepParserRULE_forBody

        return p
}</span>

func (s *ForBodyContext) GetParser() antlr.Parser <span class="cov0" title="0">{ return s.parser }</span>

func (s *ForBodyContext) GetBody() IExpressionContext <span class="cov0" title="0">{ return s.body }</span>

func (s *ForBodyContext) SetBody(v IExpressionContext) <span class="cov0" title="0">{ s.body = v }</span>

func (s *ForBodyContext) Expression() IExpressionContext <span class="cov0" title="0">{
        var t antlr.RuleContext
        for _, ctx := range s.GetChildren() </span><span class="cov0" title="0">{
                if _, ok := ctx.(IExpressionContext); ok </span><span class="cov0" title="0">{
                        t = ctx.(antlr.RuleContext)
                        break</span>
                }
        }

        <span class="cov0" title="0">if t == nil </span><span class="cov0" title="0">{
                return nil
        }</span>

        <span class="cov0" title="0">return t.(IExpressionContext)</span>
}

func (s *ForBodyContext) IfCondition() IIfConditionContext <span class="cov0" title="0">{
        var t antlr.RuleContext
        for _, ctx := range s.GetChildren() </span><span class="cov0" title="0">{
                if _, ok := ctx.(IIfConditionContext); ok </span><span class="cov0" title="0">{
                        t = ctx.(antlr.RuleContext)
                        break</span>
                }
        }

        <span class="cov0" title="0">if t == nil </span><span class="cov0" title="0">{
                return nil
        }</span>

        <span class="cov0" title="0">return t.(IIfConditionContext)</span>
}

func (s *ForBodyContext) GetRuleContext() antlr.RuleContext <span class="cov0" title="0">{
        return s
}</span>

func (s *ForBodyContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string <span class="cov0" title="0">{
        return antlr.TreesStringTree(s, ruleNames, recog)
}</span>

func (s *ForBodyContext) Accept(visitor antlr.ParseTreeVisitor) interface{} <span class="cov0" title="0">{
        switch t := visitor.(type) </span>{
        case bicepVisitor:<span class="cov0" title="0">
                return t.VisitForBody(s)</span>

        default:<span class="cov0" title="0">
                return t.VisitChildren(s)</span>
        }
}

func (p *bicepParser) ForBody() (localctx IForBodyContext) <span class="cov2" title="7">{
        localctx = NewForBodyContext(p, p.GetParserRuleContext(), p.GetState())
        p.EnterRule(localctx, 30, bicepParserRULE_forBody)
        p.SetState(254)
        p.GetErrorHandler().Sync(p)
        if p.HasError() </span><span class="cov0" title="0">{
                goto errorExit</span>
        }

        <span class="cov2" title="7">switch p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 21, p.GetParserRuleContext()) </span>{
        case 1:<span class="cov2" title="7">
                p.EnterOuterAlt(localctx, 1)
                </span><span class="cov2" title="7">{
                        p.SetState(252)

                        var _x = p.expression(0)

                        localctx.(*ForBodyContext).body = _x
                }</span>

        case 2:<span class="cov0" title="0">
                p.EnterOuterAlt(localctx, 2)
                </span><span class="cov0" title="0">{
                        p.SetState(253)
                        p.IfCondition()
                }</span>

        case antlr.ATNInvalidAltNumber:<span class="cov0" title="0">
                goto errorExit</span>
        }

errorExit:
        <span class="cov2" title="7">if p.HasError() </span><span class="cov0" title="0">{
                v := p.GetError()
                localctx.SetException(v)
                p.GetErrorHandler().ReportError(p, v)
                p.GetErrorHandler().Recover(p, v)
                p.SetError(nil)
        }</span>
        <span class="cov2" title="7">p.ExitRule()
        return localctx
        goto errorExit</span> // Trick to prevent compiler error if the label is not used
}

// IInterpStringContext is an interface to support dynamic dispatch.
type IInterpStringContext interface {
        antlr.ParserRuleContext

        // GetParser returns the parser.
        GetParser() antlr.Parser

        // Getter signatures
        STRING_LEFT_PIECE() antlr.TerminalNode
        AllExpression() []IExpressionContext
        Expression(i int) IExpressionContext
        STRING_RIGHT_PIECE() antlr.TerminalNode
        AllSTRING_MIDDLE_PIECE() []antlr.TerminalNode
        STRING_MIDDLE_PIECE(i int) antlr.TerminalNode
        STRING_COMPLETE() antlr.TerminalNode

        // IsInterpStringContext differentiates from other interfaces.
        IsInterpStringContext()
}

type InterpStringContext struct {
        antlr.BaseParserRuleContext
        parser antlr.Parser
}

func NewEmptyInterpStringContext() *InterpStringContext <span class="cov0" title="0">{
        var p = new(InterpStringContext)
        antlr.InitBaseParserRuleContext(&amp;p.BaseParserRuleContext, nil, -1)
        p.RuleIndex = bicepParserRULE_interpString
        return p
}</span>

func InitEmptyInterpStringContext(p *InterpStringContext) <span class="cov0" title="0">{
        antlr.InitBaseParserRuleContext(&amp;p.BaseParserRuleContext, nil, -1)
        p.RuleIndex = bicepParserRULE_interpString
}</span>

func (*InterpStringContext) IsInterpStringContext() {<span class="cov0" title="0">}</span>

func NewInterpStringContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *InterpStringContext <span class="cov8" title="6298">{
        var p = new(InterpStringContext)

        antlr.InitBaseParserRuleContext(&amp;p.BaseParserRuleContext, parent, invokingState)

        p.parser = parser
        p.RuleIndex = bicepParserRULE_interpString

        return p
}</span>

func (s *InterpStringContext) GetParser() antlr.Parser <span class="cov0" title="0">{ return s.parser }</span>

func (s *InterpStringContext) STRING_LEFT_PIECE() antlr.TerminalNode <span class="cov5" title="220">{
        return s.GetToken(bicepParserSTRING_LEFT_PIECE, 0)
}</span>

func (s *InterpStringContext) AllExpression() []IExpressionContext <span class="cov0" title="0">{
        children := s.GetChildren()
        len := 0
        for _, ctx := range children </span><span class="cov0" title="0">{
                if _, ok := ctx.(IExpressionContext); ok </span><span class="cov0" title="0">{
                        len++
                }</span>
        }

        <span class="cov0" title="0">tst := make([]IExpressionContext, len)
        i := 0
        for _, ctx := range children </span><span class="cov0" title="0">{
                if t, ok := ctx.(IExpressionContext); ok </span><span class="cov0" title="0">{
                        tst[i] = t.(IExpressionContext)
                        i++
                }</span>
        }

        <span class="cov0" title="0">return tst</span>
}

func (s *InterpStringContext) Expression(i int) IExpressionContext <span class="cov5" title="236">{
        var t antlr.RuleContext
        j := 0
        for _, ctx := range s.GetChildren() </span><span class="cov6" title="508">{
                if _, ok := ctx.(IExpressionContext); ok </span><span class="cov5" title="254">{
                        if j == i </span><span class="cov5" title="236">{
                                t = ctx.(antlr.RuleContext)
                                break</span>
                        }
                        <span class="cov3" title="18">j++</span>
                }
        }

        <span class="cov5" title="236">if t == nil </span><span class="cov0" title="0">{
                return nil
        }</span>

        <span class="cov5" title="236">return t.(IExpressionContext)</span>
}

func (s *InterpStringContext) STRING_RIGHT_PIECE() antlr.TerminalNode <span class="cov5" title="220">{
        return s.GetToken(bicepParserSTRING_RIGHT_PIECE, 0)
}</span>

func (s *InterpStringContext) AllSTRING_MIDDLE_PIECE() []antlr.TerminalNode <span class="cov4" title="110">{
        return s.GetTokens(bicepParserSTRING_MIDDLE_PIECE)
}</span>

func (s *InterpStringContext) STRING_MIDDLE_PIECE(i int) antlr.TerminalNode <span class="cov0" title="0">{
        return s.GetToken(bicepParserSTRING_MIDDLE_PIECE, i)
}</span>

func (s *InterpStringContext) STRING_COMPLETE() antlr.TerminalNode <span class="cov8" title="12312">{
        return s.GetToken(bicepParserSTRING_COMPLETE, 0)
}</span>

func (s *InterpStringContext) GetRuleContext() antlr.RuleContext <span class="cov0" title="0">{
        return s
}</span>

func (s *InterpStringContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string <span class="cov0" title="0">{
        return antlr.TreesStringTree(s, ruleNames, recog)
}</span>

func (s *InterpStringContext) Accept(visitor antlr.ParseTreeVisitor) interface{} <span class="cov8" title="6266">{
        switch t := visitor.(type) </span>{
        case bicepVisitor:<span class="cov8" title="6266">
                return t.VisitInterpString(s)</span>

        default:<span class="cov0" title="0">
                return t.VisitChildren(s)</span>
        }
}

func (p *bicepParser) InterpString() (localctx IInterpStringContext) <span class="cov8" title="6298">{
        localctx = NewInterpStringContext(p, p.GetParserRuleContext(), p.GetState())
        p.EnterRule(localctx, 32, bicepParserRULE_interpString)
        var _alt int

        p.SetState(269)
        p.GetErrorHandler().Sync(p)
        if p.HasError() </span><span class="cov0" title="0">{
                goto errorExit</span>
        }

        <span class="cov8" title="6298">switch p.GetTokenStream().LA(1) </span>{
        case bicepParserSTRING_LEFT_PIECE:<span class="cov4" title="112">
                p.EnterOuterAlt(localctx, 1)
                </span><span class="cov4" title="112">{
                        p.SetState(256)
                        p.Match(bicepParserSTRING_LEFT_PIECE)
                        if p.HasError() </span><span class="cov0" title="0">{
                                // Recognition error - abort rule
                                goto errorExit</span>
                        }
                }
                <span class="cov4" title="112">p.SetState(262)
                p.GetErrorHandler().Sync(p)
                if p.HasError() </span><span class="cov0" title="0">{
                        goto errorExit</span>
                }
                <span class="cov4" title="112">_alt = p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 22, p.GetParserRuleContext())
                if p.HasError() </span><span class="cov0" title="0">{
                        goto errorExit</span>
                }
                <span class="cov4" title="112">for _alt != 2 &amp;&amp; _alt != antlr.ATNInvalidAltNumber </span><span class="cov2" title="10">{
                        if _alt == 1 </span><span class="cov2" title="10">{
                                </span><span class="cov2" title="10">{
                                        p.SetState(257)
                                        p.expression(0)
                                }</span>
                                <span class="cov2" title="10">{
                                        p.SetState(258)
                                        p.Match(bicepParserSTRING_MIDDLE_PIECE)
                                        if p.HasError() </span><span class="cov0" title="0">{
                                                // Recognition error - abort rule
                                                goto errorExit</span>
                                        }
                                }

                        }
                        <span class="cov2" title="10">p.SetState(264)
                        p.GetErrorHandler().Sync(p)
                        if p.HasError() </span><span class="cov0" title="0">{
                                goto errorExit</span>
                        }
                        <span class="cov2" title="10">_alt = p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 22, p.GetParserRuleContext())
                        if p.HasError() </span><span class="cov1" title="1">{
                                goto errorExit</span>
                        }
                }
                <span class="cov4" title="111">{
                        p.SetState(265)
                        p.expression(0)
                }</span>
                <span class="cov4" title="111">{
                        p.SetState(266)
                        p.Match(bicepParserSTRING_RIGHT_PIECE)
                        if p.HasError() </span><span class="cov0" title="0">{
                                // Recognition error - abort rule
                                goto errorExit</span>
                        }
                }

        case bicepParserSTRING_COMPLETE:<span class="cov8" title="6186">
                p.EnterOuterAlt(localctx, 2)
                </span><span class="cov8" title="6186">{
                        p.SetState(268)
                        p.Match(bicepParserSTRING_COMPLETE)
                        if p.HasError() </span><span class="cov0" title="0">{
                                // Recognition error - abort rule
                                goto errorExit</span>
                        }
                }

        default:<span class="cov0" title="0">
                p.SetError(antlr.NewNoViableAltException(p, nil, nil, nil, nil, nil))
                goto errorExit</span>
        }

errorExit:
        <span class="cov8" title="6298">if p.HasError() </span><span class="cov1" title="1">{
                v := p.GetError()
                localctx.SetException(v)
                p.GetErrorHandler().ReportError(p, v)
                p.GetErrorHandler().Recover(p, v)
                p.SetError(nil)
        }</span>
        <span class="cov8" title="6298">p.ExitRule()
        return localctx
        goto errorExit</span> // Trick to prevent compiler error if the label is not used
}

// IExpressionContext is an interface to support dynamic dispatch.
type IExpressionContext interface {
        antlr.ParserRuleContext

        // GetParser returns the parser.
        GetParser() antlr.Parser

        // GetProperty returns the property rule contexts.
        GetProperty() IIdentifierContext

        // GetName returns the name rule contexts.
        GetName() IIdentifierContext

        // SetProperty sets the property rule contexts.
        SetProperty(IIdentifierContext)

        // SetName sets the name rule contexts.
        SetName(IIdentifierContext)

        // Getter signatures
        PrimaryExpression() IPrimaryExpressionContext
        AllExpression() []IExpressionContext
        Expression(i int) IExpressionContext
        QMARK() antlr.TerminalNode
        COL() antlr.TerminalNode
        LogicCharacter() ILogicCharacterContext
        OBRACK() antlr.TerminalNode
        CBRACK() antlr.TerminalNode
        DOT() antlr.TerminalNode
        Identifier() IIdentifierContext
        FunctionCall() IFunctionCallContext

        // IsExpressionContext differentiates from other interfaces.
        IsExpressionContext()
}

type ExpressionContext struct {
        antlr.BaseParserRuleContext
        parser   antlr.Parser
        property IIdentifierContext
        name     IIdentifierContext
}

func NewEmptyExpressionContext() *ExpressionContext <span class="cov0" title="0">{
        var p = new(ExpressionContext)
        antlr.InitBaseParserRuleContext(&amp;p.BaseParserRuleContext, nil, -1)
        p.RuleIndex = bicepParserRULE_expression
        return p
}</span>

func InitEmptyExpressionContext(p *ExpressionContext) <span class="cov0" title="0">{
        antlr.InitBaseParserRuleContext(&amp;p.BaseParserRuleContext, nil, -1)
        p.RuleIndex = bicepParserRULE_expression
}</span>

func (*ExpressionContext) IsExpressionContext() {<span class="cov0" title="0">}</span>

func NewExpressionContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *ExpressionContext <span class="cov8" title="10994">{
        var p = new(ExpressionContext)

        antlr.InitBaseParserRuleContext(&amp;p.BaseParserRuleContext, parent, invokingState)

        p.parser = parser
        p.RuleIndex = bicepParserRULE_expression

        return p
}</span>

func (s *ExpressionContext) GetParser() antlr.Parser <span class="cov0" title="0">{ return s.parser }</span>

func (s *ExpressionContext) GetProperty() IIdentifierContext <span class="cov0" title="0">{ return s.property }</span>

func (s *ExpressionContext) GetName() IIdentifierContext <span class="cov0" title="0">{ return s.name }</span>

func (s *ExpressionContext) SetProperty(v IIdentifierContext) <span class="cov0" title="0">{ s.property = v }</span>

func (s *ExpressionContext) SetName(v IIdentifierContext) <span class="cov0" title="0">{ s.name = v }</span>

func (s *ExpressionContext) PrimaryExpression() IPrimaryExpressionContext <span class="cov9" title="20637">{
        var t antlr.RuleContext
        for _, ctx := range s.GetChildren() </span><span class="cov9" title="20670">{
                if _, ok := ctx.(IPrimaryExpressionContext); ok </span><span class="cov9" title="20626">{
                        t = ctx.(antlr.RuleContext)
                        break</span>
                }
        }

        <span class="cov9" title="20637">if t == nil </span><span class="cov2" title="11">{
                return nil
        }</span>

        <span class="cov9" title="20626">return t.(IPrimaryExpressionContext)</span>
}

func (s *ExpressionContext) AllExpression() []IExpressionContext <span class="cov0" title="0">{
        children := s.GetChildren()
        len := 0
        for _, ctx := range children </span><span class="cov0" title="0">{
                if _, ok := ctx.(IExpressionContext); ok </span><span class="cov0" title="0">{
                        len++
                }</span>
        }

        <span class="cov0" title="0">tst := make([]IExpressionContext, len)
        i := 0
        for _, ctx := range children </span><span class="cov0" title="0">{
                if t, ok := ctx.(IExpressionContext); ok </span><span class="cov0" title="0">{
                        tst[i] = t.(IExpressionContext)
                        i++
                }</span>
        }

        <span class="cov0" title="0">return tst</span>
}

func (s *ExpressionContext) Expression(i int) IExpressionContext <span class="cov6" title="936">{
        var t antlr.RuleContext
        j := 0
        for _, ctx := range s.GetChildren() </span><span class="cov6" title="936">{
                if _, ok := ctx.(IExpressionContext); ok </span><span class="cov6" title="936">{
                        if j == i </span><span class="cov6" title="936">{
                                t = ctx.(antlr.RuleContext)
                                break</span>
                        }
                        <span class="cov0" title="0">j++</span>
                }
        }

        <span class="cov6" title="936">if t == nil </span><span class="cov0" title="0">{
                return nil
        }</span>

        <span class="cov6" title="936">return t.(IExpressionContext)</span>
}

func (s *ExpressionContext) QMARK() antlr.TerminalNode <span class="cov0" title="0">{
        return s.GetToken(bicepParserQMARK, 0)
}</span>

func (s *ExpressionContext) COL() antlr.TerminalNode <span class="cov0" title="0">{
        return s.GetToken(bicepParserCOL, 0)
}</span>

func (s *ExpressionContext) LogicCharacter() ILogicCharacterContext <span class="cov0" title="0">{
        var t antlr.RuleContext
        for _, ctx := range s.GetChildren() </span><span class="cov0" title="0">{
                if _, ok := ctx.(ILogicCharacterContext); ok </span><span class="cov0" title="0">{
                        t = ctx.(antlr.RuleContext)
                        break</span>
                }
        }

        <span class="cov0" title="0">if t == nil </span><span class="cov0" title="0">{
                return nil
        }</span>

        <span class="cov0" title="0">return t.(ILogicCharacterContext)</span>
}

func (s *ExpressionContext) OBRACK() antlr.TerminalNode <span class="cov0" title="0">{
        return s.GetToken(bicepParserOBRACK, 0)
}</span>

func (s *ExpressionContext) CBRACK() antlr.TerminalNode <span class="cov0" title="0">{
        return s.GetToken(bicepParserCBRACK, 0)
}</span>

func (s *ExpressionContext) DOT() antlr.TerminalNode <span class="cov6" title="479">{
        return s.GetToken(bicepParserDOT, 0)
}</span>

func (s *ExpressionContext) Identifier() IIdentifierContext <span class="cov6" title="935">{
        var t antlr.RuleContext
        for _, ctx := range s.GetChildren() </span><span class="cov7" title="2805">{
                if _, ok := ctx.(IIdentifierContext); ok </span><span class="cov6" title="934">{
                        t = ctx.(antlr.RuleContext)
                        break</span>
                }
        }

        <span class="cov6" title="935">if t == nil </span><span class="cov1" title="1">{
                return nil
        }</span>

        <span class="cov6" title="934">return t.(IIdentifierContext)</span>
}

func (s *ExpressionContext) FunctionCall() IFunctionCallContext <span class="cov1" title="2">{
        var t antlr.RuleContext
        for _, ctx := range s.GetChildren() </span><span class="cov2" title="6">{
                if _, ok := ctx.(IFunctionCallContext); ok </span><span class="cov1" title="2">{
                        t = ctx.(antlr.RuleContext)
                        break</span>
                }
        }

        <span class="cov1" title="2">if t == nil </span><span class="cov0" title="0">{
                return nil
        }</span>

        <span class="cov1" title="2">return t.(IFunctionCallContext)</span>
}

func (s *ExpressionContext) GetRuleContext() antlr.RuleContext <span class="cov0" title="0">{
        return s
}</span>

func (s *ExpressionContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string <span class="cov0" title="0">{
        return antlr.TreesStringTree(s, ruleNames, recog)
}</span>

func (s *ExpressionContext) Accept(visitor antlr.ParseTreeVisitor) interface{} <span class="cov8" title="10792">{
        switch t := visitor.(type) </span>{
        case bicepVisitor:<span class="cov8" title="10792">
                return t.VisitExpression(s)</span>

        default:<span class="cov0" title="0">
                return t.VisitChildren(s)</span>
        }
}

func (p *bicepParser) Expression() (localctx IExpressionContext) <span class="cov0" title="0">{
        return p.expression(0)
}</span>

func (p *bicepParser) expression(_p int) (localctx IExpressionContext) <span class="cov8" title="10493">{
        var _parentctx antlr.ParserRuleContext = p.GetParserRuleContext()

        _parentState := p.GetState()
        localctx = NewExpressionContext(p, p.GetParserRuleContext(), _parentState)
        var _prevctx IExpressionContext = localctx
        var _ antlr.ParserRuleContext = _prevctx // TODO: To prevent unused variable warning.
        _startState := 34
        p.EnterRecursionRule(localctx, 34, bicepParserRULE_expression, _p)
        var _alt int

        p.EnterOuterAlt(localctx, 1)
        </span><span class="cov8" title="10493">{
                p.SetState(272)
                p.PrimaryExpression()
        }</span>

        <span class="cov8" title="10493">p.GetParserRuleContext().SetStop(p.GetTokenStream().LT(-1))
        p.SetState(300)
        p.GetErrorHandler().Sync(p)
        if p.HasError() </span><span class="cov0" title="0">{
                goto errorExit</span>
        }
        <span class="cov8" title="10493">_alt = p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 25, p.GetParserRuleContext())
        if p.HasError() </span><span class="cov0" title="0">{
                goto errorExit</span>
        }
        <span class="cov8" title="10493">for _alt != 2 &amp;&amp; _alt != antlr.ATNInvalidAltNumber </span><span class="cov6" title="501">{
                if _alt == 1 </span><span class="cov6" title="501">{
                        if p.GetParseListeners() != nil </span><span class="cov6" title="501">{
                                p.TriggerExitRuleEvent()
                        }</span>
                        <span class="cov6" title="501">_prevctx = localctx
                        p.SetState(298)
                        p.GetErrorHandler().Sync(p)
                        if p.HasError() </span><span class="cov0" title="0">{
                                goto errorExit</span>
                        }

                        <span class="cov6" title="501">switch p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 24, p.GetParserRuleContext()) </span>{
                        case 1:<span class="cov3" title="16">
                                localctx = NewExpressionContext(p, _parentctx, _parentState)
                                p.PushNewRecursionContext(localctx, _startState, bicepParserRULE_expression)
                                p.SetState(274)

                                if !(p.Precpred(p.GetParserRuleContext(), 6)) </span><span class="cov0" title="0">{
                                        p.SetError(antlr.NewFailedPredicateException(p, "p.Precpred(p.GetParserRuleContext(), 6)", ""))
                                        goto errorExit</span>
                                }
                                <span class="cov3" title="16">{
                                        p.SetState(275)
                                        p.Match(bicepParserQMARK)
                                        if p.HasError() </span><span class="cov0" title="0">{
                                                // Recognition error - abort rule
                                                goto errorExit</span>
                                        }
                                }
                                <span class="cov3" title="16">{
                                        p.SetState(276)
                                        p.expression(0)
                                }</span>
                                <span class="cov3" title="16">{
                                        p.SetState(277)
                                        p.Match(bicepParserCOL)
                                        if p.HasError() </span><span class="cov0" title="0">{
                                                // Recognition error - abort rule
                                                goto errorExit</span>
                                        }
                                }
                                <span class="cov3" title="16">{
                                        p.SetState(278)
                                        p.expression(7)
                                }</span>

                        case 2:<span class="cov2" title="8">
                                localctx = NewExpressionContext(p, _parentctx, _parentState)
                                p.PushNewRecursionContext(localctx, _startState, bicepParserRULE_expression)
                                p.SetState(280)

                                if !(p.Precpred(p.GetParserRuleContext(), 2)) </span><span class="cov0" title="0">{
                                        p.SetError(antlr.NewFailedPredicateException(p, "p.Precpred(p.GetParserRuleContext(), 2)", ""))
                                        goto errorExit</span>
                                }
                                <span class="cov2" title="8">{
                                        p.SetState(281)
                                        p.LogicCharacter()
                                }</span>
                                <span class="cov2" title="8">{
                                        p.SetState(282)
                                        p.expression(3)
                                }</span>

                        case 3:<span class="cov1" title="3">
                                localctx = NewExpressionContext(p, _parentctx, _parentState)
                                p.PushNewRecursionContext(localctx, _startState, bicepParserRULE_expression)
                                p.SetState(284)

                                if !(p.Precpred(p.GetParserRuleContext(), 7)) </span><span class="cov0" title="0">{
                                        p.SetError(antlr.NewFailedPredicateException(p, "p.Precpred(p.GetParserRuleContext(), 7)", ""))
                                        goto errorExit</span>
                                }
                                <span class="cov1" title="3">{
                                        p.SetState(285)
                                        p.Match(bicepParserOBRACK)
                                        if p.HasError() </span><span class="cov0" title="0">{
                                                // Recognition error - abort rule
                                                goto errorExit</span>
                                        }
                                }
                                <span class="cov1" title="3">{
                                        p.SetState(286)
                                        p.expression(0)
                                }</span>
                                <span class="cov1" title="3">{
                                        p.SetState(287)
                                        p.Match(bicepParserCBRACK)
                                        if p.HasError() </span><span class="cov0" title="0">{
                                                // Recognition error - abort rule
                                                goto errorExit</span>
                                        }
                                }

                        case 4:<span class="cov6" title="473">
                                localctx = NewExpressionContext(p, _parentctx, _parentState)
                                p.PushNewRecursionContext(localctx, _startState, bicepParserRULE_expression)
                                p.SetState(289)

                                if !(p.Precpred(p.GetParserRuleContext(), 5)) </span><span class="cov0" title="0">{
                                        p.SetError(antlr.NewFailedPredicateException(p, "p.Precpred(p.GetParserRuleContext(), 5)", ""))
                                        goto errorExit</span>
                                }
                                <span class="cov6" title="473">{
                                        p.SetState(290)
                                        p.Match(bicepParserDOT)
                                        if p.HasError() </span><span class="cov0" title="0">{
                                                // Recognition error - abort rule
                                                goto errorExit</span>
                                        }
                                }
                                <span class="cov6" title="473">{
                                        p.SetState(291)

                                        var _x = p.Identifier()

                                        localctx.(*ExpressionContext).property = _x
                                }</span>

                        case 5:<span class="cov1" title="1">
                                localctx = NewExpressionContext(p, _parentctx, _parentState)
                                p.PushNewRecursionContext(localctx, _startState, bicepParserRULE_expression)
                                p.SetState(292)

                                if !(p.Precpred(p.GetParserRuleContext(), 4)) </span><span class="cov0" title="0">{
                                        p.SetError(antlr.NewFailedPredicateException(p, "p.Precpred(p.GetParserRuleContext(), 4)", ""))
                                        goto errorExit</span>
                                }
                                <span class="cov1" title="1">{
                                        p.SetState(293)
                                        p.Match(bicepParserDOT)
                                        if p.HasError() </span><span class="cov0" title="0">{
                                                // Recognition error - abort rule
                                                goto errorExit</span>
                                        }
                                }
                                <span class="cov1" title="1">{
                                        p.SetState(294)
                                        p.FunctionCall()
                                }</span>

                        case 6:<span class="cov0" title="0">
                                localctx = NewExpressionContext(p, _parentctx, _parentState)
                                p.PushNewRecursionContext(localctx, _startState, bicepParserRULE_expression)
                                p.SetState(295)

                                if !(p.Precpred(p.GetParserRuleContext(), 3)) </span><span class="cov0" title="0">{
                                        p.SetError(antlr.NewFailedPredicateException(p, "p.Precpred(p.GetParserRuleContext(), 3)", ""))
                                        goto errorExit</span>
                                }
                                <span class="cov0" title="0">{
                                        p.SetState(296)
                                        p.Match(bicepParserCOL)
                                        if p.HasError() </span><span class="cov0" title="0">{
                                                // Recognition error - abort rule
                                                goto errorExit</span>
                                        }
                                }
                                <span class="cov0" title="0">{
                                        p.SetState(297)

                                        var _x = p.Identifier()

                                        localctx.(*ExpressionContext).name = _x
                                }</span>

                        case antlr.ATNInvalidAltNumber:<span class="cov0" title="0">
                                goto errorExit</span>
                        }

                }
                <span class="cov6" title="501">p.SetState(302)
                p.GetErrorHandler().Sync(p)
                if p.HasError() </span><span class="cov0" title="0">{
                        goto errorExit</span>
                }
                <span class="cov6" title="501">_alt = p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 25, p.GetParserRuleContext())
                if p.HasError() </span><span class="cov0" title="0">{
                        goto errorExit</span>
                }
        }

errorExit:
        <span class="cov8" title="10493">if p.HasError() </span><span class="cov0" title="0">{
                v := p.GetError()
                localctx.SetException(v)
                p.GetErrorHandler().ReportError(p, v)
                p.GetErrorHandler().Recover(p, v)
                p.SetError(nil)
        }</span>
        <span class="cov8" title="10493">p.UnrollRecursionContexts(_parentctx)
        return localctx
        goto errorExit</span> // Trick to prevent compiler error if the label is not used
}

// ILambdaExpressionContext is an interface to support dynamic dispatch.
type ILambdaExpressionContext interface {
        antlr.ParserRuleContext

        // GetParser returns the parser.
        GetParser() antlr.Parser

        // Getter signatures
        ARROW() antlr.TerminalNode
        Expression() IExpressionContext
        OPAR() antlr.TerminalNode
        CPAR() antlr.TerminalNode
        Identifier() IIdentifierContext
        ArgumentList() IArgumentListContext

        // IsLambdaExpressionContext differentiates from other interfaces.
        IsLambdaExpressionContext()
}

type LambdaExpressionContext struct {
        antlr.BaseParserRuleContext
        parser antlr.Parser
}

func NewEmptyLambdaExpressionContext() *LambdaExpressionContext <span class="cov0" title="0">{
        var p = new(LambdaExpressionContext)
        antlr.InitBaseParserRuleContext(&amp;p.BaseParserRuleContext, nil, -1)
        p.RuleIndex = bicepParserRULE_lambdaExpression
        return p
}</span>

func InitEmptyLambdaExpressionContext(p *LambdaExpressionContext) <span class="cov0" title="0">{
        antlr.InitBaseParserRuleContext(&amp;p.BaseParserRuleContext, nil, -1)
        p.RuleIndex = bicepParserRULE_lambdaExpression
}</span>

func (*LambdaExpressionContext) IsLambdaExpressionContext() {<span class="cov0" title="0">}</span>

func NewLambdaExpressionContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *LambdaExpressionContext <span class="cov1" title="3">{
        var p = new(LambdaExpressionContext)

        antlr.InitBaseParserRuleContext(&amp;p.BaseParserRuleContext, parent, invokingState)

        p.parser = parser
        p.RuleIndex = bicepParserRULE_lambdaExpression

        return p
}</span>

func (s *LambdaExpressionContext) GetParser() antlr.Parser <span class="cov0" title="0">{ return s.parser }</span>

func (s *LambdaExpressionContext) ARROW() antlr.TerminalNode <span class="cov0" title="0">{
        return s.GetToken(bicepParserARROW, 0)
}</span>

func (s *LambdaExpressionContext) Expression() IExpressionContext <span class="cov0" title="0">{
        var t antlr.RuleContext
        for _, ctx := range s.GetChildren() </span><span class="cov0" title="0">{
                if _, ok := ctx.(IExpressionContext); ok </span><span class="cov0" title="0">{
                        t = ctx.(antlr.RuleContext)
                        break</span>
                }
        }

        <span class="cov0" title="0">if t == nil </span><span class="cov0" title="0">{
                return nil
        }</span>

        <span class="cov0" title="0">return t.(IExpressionContext)</span>
}

func (s *LambdaExpressionContext) OPAR() antlr.TerminalNode <span class="cov0" title="0">{
        return s.GetToken(bicepParserOPAR, 0)
}</span>

func (s *LambdaExpressionContext) CPAR() antlr.TerminalNode <span class="cov0" title="0">{
        return s.GetToken(bicepParserCPAR, 0)
}</span>

func (s *LambdaExpressionContext) Identifier() IIdentifierContext <span class="cov0" title="0">{
        var t antlr.RuleContext
        for _, ctx := range s.GetChildren() </span><span class="cov0" title="0">{
                if _, ok := ctx.(IIdentifierContext); ok </span><span class="cov0" title="0">{
                        t = ctx.(antlr.RuleContext)
                        break</span>
                }
        }

        <span class="cov0" title="0">if t == nil </span><span class="cov0" title="0">{
                return nil
        }</span>

        <span class="cov0" title="0">return t.(IIdentifierContext)</span>
}

func (s *LambdaExpressionContext) ArgumentList() IArgumentListContext <span class="cov0" title="0">{
        var t antlr.RuleContext
        for _, ctx := range s.GetChildren() </span><span class="cov0" title="0">{
                if _, ok := ctx.(IArgumentListContext); ok </span><span class="cov0" title="0">{
                        t = ctx.(antlr.RuleContext)
                        break</span>
                }
        }

        <span class="cov0" title="0">if t == nil </span><span class="cov0" title="0">{
                return nil
        }</span>

        <span class="cov0" title="0">return t.(IArgumentListContext)</span>
}

func (s *LambdaExpressionContext) GetRuleContext() antlr.RuleContext <span class="cov0" title="0">{
        return s
}</span>

func (s *LambdaExpressionContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string <span class="cov0" title="0">{
        return antlr.TreesStringTree(s, ruleNames, recog)
}</span>

func (s *LambdaExpressionContext) Accept(visitor antlr.ParseTreeVisitor) interface{} <span class="cov0" title="0">{
        switch t := visitor.(type) </span>{
        case bicepVisitor:<span class="cov0" title="0">
                return t.VisitLambdaExpression(s)</span>

        default:<span class="cov0" title="0">
                return t.VisitChildren(s)</span>
        }
}

func (p *bicepParser) LambdaExpression() (localctx ILambdaExpressionContext) <span class="cov1" title="3">{
        localctx = NewLambdaExpressionContext(p, p.GetParserRuleContext(), p.GetState())
        p.EnterRule(localctx, 36, bicepParserRULE_lambdaExpression)
        var _la int

        p.EnterOuterAlt(localctx, 1)
        p.SetState(309)
        p.GetErrorHandler().Sync(p)
        if p.HasError() </span><span class="cov0" title="0">{
                goto errorExit</span>
        }

        <span class="cov1" title="3">switch p.GetTokenStream().LA(1) </span>{
        case bicepParserOPAR:<span class="cov0" title="0">
                </span><span class="cov0" title="0">{
                        p.SetState(303)
                        p.Match(bicepParserOPAR)
                        if p.HasError() </span><span class="cov0" title="0">{
                                // Recognition error - abort rule
                                goto errorExit</span>
                        }
                }
                <span class="cov0" title="0">p.SetState(305)
                p.GetErrorHandler().Sync(p)
                if p.HasError() </span><span class="cov0" title="0">{
                        goto errorExit</span>
                }
                <span class="cov0" title="0">_la = p.GetTokenStream().LA(1)

                if (int64(_la) &amp; ^0x3f) == 0 &amp;&amp; ((int64(1)&lt;&lt;_la)&amp;1691035998605394) != 0 </span><span class="cov0" title="0">{
                        </span><span class="cov0" title="0">{
                                p.SetState(304)
                                p.ArgumentList()
                        }</span>

                }
                <span class="cov0" title="0">{
                        p.SetState(307)
                        p.Match(bicepParserCPAR)
                        if p.HasError() </span><span class="cov0" title="0">{
                                // Recognition error - abort rule
                                goto errorExit</span>
                        }
                }

        case bicepParserPARAM, bicepParserVAR, bicepParserTRUE, bicepParserFALSE, bicepParserNULL, bicepParserARRAY, bicepParserOBJECT, bicepParserRESOURCE, bicepParserOUTPUT, bicepParserTARGET_SCOPE, bicepParserIMPORT, bicepParserWITH, bicepParserAS, bicepParserMETADATA, bicepParserEXISTING, bicepParserTYPE, bicepParserMODULE, bicepParserSTRING, bicepParserINT, bicepParserBOOL, bicepParserIF, bicepParserFOR, bicepParserIN, bicepParserIDENTIFIER:<span class="cov1" title="3">
                </span><span class="cov1" title="3">{
                        p.SetState(308)
                        p.Identifier()
                }</span>

        default:<span class="cov0" title="0">
                p.SetError(antlr.NewNoViableAltException(p, nil, nil, nil, nil, nil))
                goto errorExit</span>
        }
        <span class="cov1" title="3">{
                p.SetState(311)
                p.Match(bicepParserARROW)
                if p.HasError() </span><span class="cov0" title="0">{
                        // Recognition error - abort rule
                        goto errorExit</span>
                }
        }
        <span class="cov1" title="3">{
                p.SetState(312)
                p.expression(0)
        }</span>

errorExit:
        <span class="cov1" title="3">if p.HasError() </span><span class="cov0" title="0">{
                v := p.GetError()
                localctx.SetException(v)
                p.GetErrorHandler().ReportError(p, v)
                p.GetErrorHandler().Recover(p, v)
                p.SetError(nil)
        }</span>
        <span class="cov1" title="3">p.ExitRule()
        return localctx
        goto errorExit</span> // Trick to prevent compiler error if the label is not used
}

// ILogicCharacterContext is an interface to support dynamic dispatch.
type ILogicCharacterContext interface {
        antlr.ParserRuleContext

        // GetParser returns the parser.
        GetParser() antlr.Parser

        // Getter signatures
        GT() antlr.TerminalNode
        GTE() antlr.TerminalNode
        LT() antlr.TerminalNode
        LTE() antlr.TerminalNode
        EQ() antlr.TerminalNode
        NEQ() antlr.TerminalNode

        // IsLogicCharacterContext differentiates from other interfaces.
        IsLogicCharacterContext()
}

type LogicCharacterContext struct {
        antlr.BaseParserRuleContext
        parser antlr.Parser
}

func NewEmptyLogicCharacterContext() *LogicCharacterContext <span class="cov0" title="0">{
        var p = new(LogicCharacterContext)
        antlr.InitBaseParserRuleContext(&amp;p.BaseParserRuleContext, nil, -1)
        p.RuleIndex = bicepParserRULE_logicCharacter
        return p
}</span>

func InitEmptyLogicCharacterContext(p *LogicCharacterContext) <span class="cov0" title="0">{
        antlr.InitBaseParserRuleContext(&amp;p.BaseParserRuleContext, nil, -1)
        p.RuleIndex = bicepParserRULE_logicCharacter
}</span>

func (*LogicCharacterContext) IsLogicCharacterContext() {<span class="cov0" title="0">}</span>

func NewLogicCharacterContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *LogicCharacterContext <span class="cov2" title="8">{
        var p = new(LogicCharacterContext)

        antlr.InitBaseParserRuleContext(&amp;p.BaseParserRuleContext, parent, invokingState)

        p.parser = parser
        p.RuleIndex = bicepParserRULE_logicCharacter

        return p
}</span>

func (s *LogicCharacterContext) GetParser() antlr.Parser <span class="cov0" title="0">{ return s.parser }</span>

func (s *LogicCharacterContext) GT() antlr.TerminalNode <span class="cov0" title="0">{
        return s.GetToken(bicepParserGT, 0)
}</span>

func (s *LogicCharacterContext) GTE() antlr.TerminalNode <span class="cov0" title="0">{
        return s.GetToken(bicepParserGTE, 0)
}</span>

func (s *LogicCharacterContext) LT() antlr.TerminalNode <span class="cov0" title="0">{
        return s.GetToken(bicepParserLT, 0)
}</span>

func (s *LogicCharacterContext) LTE() antlr.TerminalNode <span class="cov0" title="0">{
        return s.GetToken(bicepParserLTE, 0)
}</span>

func (s *LogicCharacterContext) EQ() antlr.TerminalNode <span class="cov0" title="0">{
        return s.GetToken(bicepParserEQ, 0)
}</span>

func (s *LogicCharacterContext) NEQ() antlr.TerminalNode <span class="cov0" title="0">{
        return s.GetToken(bicepParserNEQ, 0)
}</span>

func (s *LogicCharacterContext) GetRuleContext() antlr.RuleContext <span class="cov0" title="0">{
        return s
}</span>

func (s *LogicCharacterContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string <span class="cov0" title="0">{
        return antlr.TreesStringTree(s, ruleNames, recog)
}</span>

func (s *LogicCharacterContext) Accept(visitor antlr.ParseTreeVisitor) interface{} <span class="cov0" title="0">{
        switch t := visitor.(type) </span>{
        case bicepVisitor:<span class="cov0" title="0">
                return t.VisitLogicCharacter(s)</span>

        default:<span class="cov0" title="0">
                return t.VisitChildren(s)</span>
        }
}

func (p *bicepParser) LogicCharacter() (localctx ILogicCharacterContext) <span class="cov2" title="8">{
        localctx = NewLogicCharacterContext(p, p.GetParserRuleContext(), p.GetState())
        p.EnterRule(localctx, 38, bicepParserRULE_logicCharacter)
        var _la int

        p.EnterOuterAlt(localctx, 1)
        </span><span class="cov2" title="8">{
                p.SetState(314)
                _la = p.GetTokenStream().LA(1)

                if !((int64(_la) &amp; ^0x3f) == 0 &amp;&amp; ((int64(1)&lt;&lt;_la)&amp;277076930199552) != 0) </span><span class="cov0" title="0">{
                        p.GetErrorHandler().RecoverInline(p)
                }</span> else<span class="cov2" title="8"> {
                        p.GetErrorHandler().ReportMatch(p)
                        p.Consume()
                }</span>
        }

errorExit:
        <span class="cov2" title="8">if p.HasError() </span><span class="cov0" title="0">{
                v := p.GetError()
                localctx.SetException(v)
                p.GetErrorHandler().ReportError(p, v)
                p.GetErrorHandler().Recover(p, v)
                p.SetError(nil)
        }</span>
        <span class="cov2" title="8">p.ExitRule()
        return localctx
        goto errorExit</span> // Trick to prevent compiler error if the label is not used
}

// IPrimaryExpressionContext is an interface to support dynamic dispatch.
type IPrimaryExpressionContext interface {
        antlr.ParserRuleContext

        // GetParser returns the parser.
        GetParser() antlr.Parser

        // Getter signatures
        LiteralValue() ILiteralValueContext
        FunctionCall() IFunctionCallContext
        InterpString() IInterpStringContext
        MULTILINE_STRING() antlr.TerminalNode
        Array() IArrayContext
        Object() IObjectContext
        ForExpression() IForExpressionContext
        ParenthesizedExpression() IParenthesizedExpressionContext
        LambdaExpression() ILambdaExpressionContext

        // IsPrimaryExpressionContext differentiates from other interfaces.
        IsPrimaryExpressionContext()
}

type PrimaryExpressionContext struct {
        antlr.BaseParserRuleContext
        parser antlr.Parser
}

func NewEmptyPrimaryExpressionContext() *PrimaryExpressionContext <span class="cov0" title="0">{
        var p = new(PrimaryExpressionContext)
        antlr.InitBaseParserRuleContext(&amp;p.BaseParserRuleContext, nil, -1)
        p.RuleIndex = bicepParserRULE_primaryExpression
        return p
}</span>

func InitEmptyPrimaryExpressionContext(p *PrimaryExpressionContext) <span class="cov0" title="0">{
        antlr.InitBaseParserRuleContext(&amp;p.BaseParserRuleContext, nil, -1)
        p.RuleIndex = bicepParserRULE_primaryExpression
}</span>

func (*PrimaryExpressionContext) IsPrimaryExpressionContext() {<span class="cov0" title="0">}</span>

func NewPrimaryExpressionContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *PrimaryExpressionContext <span class="cov8" title="10493">{
        var p = new(PrimaryExpressionContext)

        antlr.InitBaseParserRuleContext(&amp;p.BaseParserRuleContext, parent, invokingState)

        p.parser = parser
        p.RuleIndex = bicepParserRULE_primaryExpression

        return p
}</span>

func (s *PrimaryExpressionContext) GetParser() antlr.Parser <span class="cov0" title="0">{ return s.parser }</span>

func (s *PrimaryExpressionContext) LiteralValue() ILiteralValueContext <span class="cov8" title="11804">{
        var t antlr.RuleContext
        for _, ctx := range s.GetChildren() </span><span class="cov8" title="11803">{
                if _, ok := ctx.(ILiteralValueContext); ok </span><span class="cov7" title="2982">{
                        t = ctx.(antlr.RuleContext)
                        break</span>
                }
        }

        <span class="cov8" title="11804">if t == nil </span><span class="cov8" title="8822">{
                return nil
        }</span>

        <span class="cov7" title="2982">return t.(ILiteralValueContext)</span>
}

func (s *PrimaryExpressionContext) FunctionCall() IFunctionCallContext <span class="cov8" title="9322">{
        var t antlr.RuleContext
        for _, ctx := range s.GetChildren() </span><span class="cov8" title="9321">{
                if _, ok := ctx.(IFunctionCallContext); ok </span><span class="cov6" title="1000">{
                        t = ctx.(antlr.RuleContext)
                        break</span>
                }
        }

        <span class="cov8" title="9322">if t == nil </span><span class="cov8" title="8322">{
                return nil
        }</span>

        <span class="cov6" title="1000">return t.(IFunctionCallContext)</span>
}

func (s *PrimaryExpressionContext) InterpString() IInterpStringContext <span class="cov8" title="13779">{
        var t antlr.RuleContext
        for _, ctx := range s.GetChildren() </span><span class="cov8" title="13778">{
                if _, ok := ctx.(IInterpStringContext); ok </span><span class="cov8" title="10914">{
                        t = ctx.(antlr.RuleContext)
                        break</span>
                }
        }

        <span class="cov8" title="13779">if t == nil </span><span class="cov7" title="2865">{
                return nil
        }</span>

        <span class="cov8" title="10914">return t.(IInterpStringContext)</span>
}

func (s *PrimaryExpressionContext) MULTILINE_STRING() antlr.TerminalNode <span class="cov7" title="2866">{
        return s.GetToken(bicepParserMULTILINE_STRING, 0)
}</span>

func (s *PrimaryExpressionContext) Array() IArrayContext <span class="cov7" title="3473">{
        var t antlr.RuleContext
        for _, ctx := range s.GetChildren() </span><span class="cov7" title="3472">{
                if _, ok := ctx.(IArrayContext); ok </span><span class="cov6" title="1218">{
                        t = ctx.(antlr.RuleContext)
                        break</span>
                }
        }

        <span class="cov7" title="3473">if t == nil </span><span class="cov7" title="2255">{
                return nil
        }</span>

        <span class="cov6" title="1218">return t.(IArrayContext)</span>
}

func (s *PrimaryExpressionContext) Object() IObjectContext <span class="cov7" title="4503">{
        var t antlr.RuleContext
        for _, ctx := range s.GetChildren() </span><span class="cov7" title="4502">{
                if _, ok := ctx.(IObjectContext); ok </span><span class="cov7" title="4496">{
                        t = ctx.(antlr.RuleContext)
                        break</span>
                }
        }

        <span class="cov7" title="4503">if t == nil </span><span class="cov2" title="7">{
                return nil
        }</span>

        <span class="cov7" title="4496">return t.(IObjectContext)</span>
}

func (s *PrimaryExpressionContext) ForExpression() IForExpressionContext <span class="cov0" title="0">{
        var t antlr.RuleContext
        for _, ctx := range s.GetChildren() </span><span class="cov0" title="0">{
                if _, ok := ctx.(IForExpressionContext); ok </span><span class="cov0" title="0">{
                        t = ctx.(antlr.RuleContext)
                        break</span>
                }
        }

        <span class="cov0" title="0">if t == nil </span><span class="cov0" title="0">{
                return nil
        }</span>

        <span class="cov0" title="0">return t.(IForExpressionContext)</span>
}

func (s *PrimaryExpressionContext) ParenthesizedExpression() IParenthesizedExpressionContext <span class="cov2" title="8">{
        var t antlr.RuleContext
        for _, ctx := range s.GetChildren() </span><span class="cov2" title="7">{
                if _, ok := ctx.(IParenthesizedExpressionContext); ok </span><span class="cov1" title="2">{
                        t = ctx.(antlr.RuleContext)
                        break</span>
                }
        }

        <span class="cov2" title="8">if t == nil </span><span class="cov2" title="6">{
                return nil
        }</span>

        <span class="cov1" title="2">return t.(IParenthesizedExpressionContext)</span>
}

func (s *PrimaryExpressionContext) LambdaExpression() ILambdaExpressionContext <span class="cov0" title="0">{
        var t antlr.RuleContext
        for _, ctx := range s.GetChildren() </span><span class="cov0" title="0">{
                if _, ok := ctx.(ILambdaExpressionContext); ok </span><span class="cov0" title="0">{
                        t = ctx.(antlr.RuleContext)
                        break</span>
                }
        }

        <span class="cov0" title="0">if t == nil </span><span class="cov0" title="0">{
                return nil
        }</span>

        <span class="cov0" title="0">return t.(ILambdaExpressionContext)</span>
}

func (s *PrimaryExpressionContext) GetRuleContext() antlr.RuleContext <span class="cov0" title="0">{
        return s
}</span>

func (s *PrimaryExpressionContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string <span class="cov0" title="0">{
        return antlr.TreesStringTree(s, ruleNames, recog)
}</span>

func (s *PrimaryExpressionContext) Accept(visitor antlr.ParseTreeVisitor) interface{} <span class="cov8" title="10313">{
        switch t := visitor.(type) </span>{
        case bicepVisitor:<span class="cov8" title="10313">
                return t.VisitPrimaryExpression(s)</span>

        default:<span class="cov0" title="0">
                return t.VisitChildren(s)</span>
        }
}

func (p *bicepParser) PrimaryExpression() (localctx IPrimaryExpressionContext) <span class="cov8" title="10493">{
        localctx = NewPrimaryExpressionContext(p, p.GetParserRuleContext(), p.GetState())
        p.EnterRule(localctx, 40, bicepParserRULE_primaryExpression)
        p.SetState(325)
        p.GetErrorHandler().Sync(p)
        if p.HasError() </span><span class="cov0" title="0">{
                goto errorExit</span>
        }

        <span class="cov8" title="10493">switch p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 28, p.GetParserRuleContext()) </span>{
        case 1:<span class="cov7" title="1592">
                p.EnterOuterAlt(localctx, 1)
                </span><span class="cov7" title="1592">{
                        p.SetState(316)
                        p.LiteralValue()
                }</span>

        case 2:<span class="cov6" title="519">
                p.EnterOuterAlt(localctx, 2)
                </span><span class="cov6" title="519">{
                        p.SetState(317)
                        p.FunctionCall()
                }</span>

        case 3:<span class="cov8" title="5487">
                p.EnterOuterAlt(localctx, 3)
                </span><span class="cov8" title="5487">{
                        p.SetState(318)
                        p.InterpString()
                }</span>

        case 4:<span class="cov1" title="1">
                p.EnterOuterAlt(localctx, 4)
                </span><span class="cov1" title="1">{
                        p.SetState(319)
                        p.Match(bicepParserMULTILINE_STRING)
                        if p.HasError() </span><span class="cov0" title="0">{
                                // Recognition error - abort rule
                                goto errorExit</span>
                        }
                }

        case 5:<span class="cov6" title="613">
                p.EnterOuterAlt(localctx, 5)
                </span><span class="cov6" title="613">{
                        p.SetState(320)
                        p.Array()
                }</span>

        case 6:<span class="cov7" title="2271">
                p.EnterOuterAlt(localctx, 6)
                </span><span class="cov7" title="2271">{
                        p.SetState(321)
                        p.Object()
                }</span>

        case 7:<span class="cov2" title="5">
                p.EnterOuterAlt(localctx, 7)
                </span><span class="cov2" title="5">{
                        p.SetState(322)
                        p.ForExpression()
                }</span>

        case 8:<span class="cov1" title="1">
                p.EnterOuterAlt(localctx, 8)
                </span><span class="cov1" title="1">{
                        p.SetState(323)
                        p.ParenthesizedExpression()
                }</span>

        case 9:<span class="cov1" title="3">
                p.EnterOuterAlt(localctx, 9)
                </span><span class="cov1" title="3">{
                        p.SetState(324)
                        p.LambdaExpression()
                }</span>

        case antlr.ATNInvalidAltNumber:<span class="cov1" title="1">
                goto errorExit</span>
        }

errorExit:
        <span class="cov8" title="10493">if p.HasError() </span><span class="cov1" title="1">{
                v := p.GetError()
                localctx.SetException(v)
                p.GetErrorHandler().ReportError(p, v)
                p.GetErrorHandler().Recover(p, v)
                p.SetError(nil)
        }</span>
        <span class="cov8" title="10493">p.ExitRule()
        return localctx
        goto errorExit</span> // Trick to prevent compiler error if the label is not used
}

// IParenthesizedExpressionContext is an interface to support dynamic dispatch.
type IParenthesizedExpressionContext interface {
        antlr.ParserRuleContext

        // GetParser returns the parser.
        GetParser() antlr.Parser

        // Getter signatures
        OPAR() antlr.TerminalNode
        Expression() IExpressionContext
        CPAR() antlr.TerminalNode
        AllNL() []antlr.TerminalNode
        NL(i int) antlr.TerminalNode

        // IsParenthesizedExpressionContext differentiates from other interfaces.
        IsParenthesizedExpressionContext()
}

type ParenthesizedExpressionContext struct {
        antlr.BaseParserRuleContext
        parser antlr.Parser
}

func NewEmptyParenthesizedExpressionContext() *ParenthesizedExpressionContext <span class="cov0" title="0">{
        var p = new(ParenthesizedExpressionContext)
        antlr.InitBaseParserRuleContext(&amp;p.BaseParserRuleContext, nil, -1)
        p.RuleIndex = bicepParserRULE_parenthesizedExpression
        return p
}</span>

func InitEmptyParenthesizedExpressionContext(p *ParenthesizedExpressionContext) <span class="cov0" title="0">{
        antlr.InitBaseParserRuleContext(&amp;p.BaseParserRuleContext, nil, -1)
        p.RuleIndex = bicepParserRULE_parenthesizedExpression
}</span>

func (*ParenthesizedExpressionContext) IsParenthesizedExpressionContext() {<span class="cov0" title="0">}</span>

func NewParenthesizedExpressionContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *ParenthesizedExpressionContext <span class="cov1" title="3">{
        var p = new(ParenthesizedExpressionContext)

        antlr.InitBaseParserRuleContext(&amp;p.BaseParserRuleContext, parent, invokingState)

        p.parser = parser
        p.RuleIndex = bicepParserRULE_parenthesizedExpression

        return p
}</span>

func (s *ParenthesizedExpressionContext) GetParser() antlr.Parser <span class="cov0" title="0">{ return s.parser }</span>

func (s *ParenthesizedExpressionContext) OPAR() antlr.TerminalNode <span class="cov0" title="0">{
        return s.GetToken(bicepParserOPAR, 0)
}</span>

func (s *ParenthesizedExpressionContext) Expression() IExpressionContext <span class="cov1" title="1">{
        var t antlr.RuleContext
        for _, ctx := range s.GetChildren() </span><span class="cov1" title="2">{
                if _, ok := ctx.(IExpressionContext); ok </span><span class="cov1" title="1">{
                        t = ctx.(antlr.RuleContext)
                        break</span>
                }
        }

        <span class="cov1" title="1">if t == nil </span><span class="cov0" title="0">{
                return nil
        }</span>

        <span class="cov1" title="1">return t.(IExpressionContext)</span>
}

func (s *ParenthesizedExpressionContext) CPAR() antlr.TerminalNode <span class="cov0" title="0">{
        return s.GetToken(bicepParserCPAR, 0)
}</span>

func (s *ParenthesizedExpressionContext) AllNL() []antlr.TerminalNode <span class="cov0" title="0">{
        return s.GetTokens(bicepParserNL)
}</span>

func (s *ParenthesizedExpressionContext) NL(i int) antlr.TerminalNode <span class="cov0" title="0">{
        return s.GetToken(bicepParserNL, i)
}</span>

func (s *ParenthesizedExpressionContext) GetRuleContext() antlr.RuleContext <span class="cov0" title="0">{
        return s
}</span>

func (s *ParenthesizedExpressionContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string <span class="cov0" title="0">{
        return antlr.TreesStringTree(s, ruleNames, recog)
}</span>

func (s *ParenthesizedExpressionContext) Accept(visitor antlr.ParseTreeVisitor) interface{} <span class="cov1" title="1">{
        switch t := visitor.(type) </span>{
        case bicepVisitor:<span class="cov1" title="1">
                return t.VisitParenthesizedExpression(s)</span>

        default:<span class="cov0" title="0">
                return t.VisitChildren(s)</span>
        }
}

func (p *bicepParser) ParenthesizedExpression() (localctx IParenthesizedExpressionContext) <span class="cov1" title="3">{
        localctx = NewParenthesizedExpressionContext(p, p.GetParserRuleContext(), p.GetState())
        p.EnterRule(localctx, 42, bicepParserRULE_parenthesizedExpression)
        var _la int

        p.EnterOuterAlt(localctx, 1)
        </span><span class="cov1" title="3">{
                p.SetState(327)
                p.Match(bicepParserOPAR)
                if p.HasError() </span><span class="cov0" title="0">{
                        // Recognition error - abort rule
                        goto errorExit</span>
                }
        }
        <span class="cov1" title="3">p.SetState(329)
        p.GetErrorHandler().Sync(p)
        if p.HasError() </span><span class="cov0" title="0">{
                goto errorExit</span>
        }
        <span class="cov1" title="3">_la = p.GetTokenStream().LA(1)

        if _la == bicepParserNL </span><span class="cov0" title="0">{
                </span><span class="cov0" title="0">{
                        p.SetState(328)
                        p.Match(bicepParserNL)
                        if p.HasError() </span><span class="cov0" title="0">{
                                // Recognition error - abort rule
                                goto errorExit</span>
                        }
                }

        }
        <span class="cov1" title="3">{
                p.SetState(331)
                p.expression(0)
        }</span>
        <span class="cov1" title="3">p.SetState(333)
        p.GetErrorHandler().Sync(p)
        if p.HasError() </span><span class="cov0" title="0">{
                goto errorExit</span>
        }
        <span class="cov1" title="3">_la = p.GetTokenStream().LA(1)

        if _la == bicepParserNL </span><span class="cov0" title="0">{
                </span><span class="cov0" title="0">{
                        p.SetState(332)
                        p.Match(bicepParserNL)
                        if p.HasError() </span><span class="cov0" title="0">{
                                // Recognition error - abort rule
                                goto errorExit</span>
                        }
                }

        }
        <span class="cov1" title="3">{
                p.SetState(335)
                p.Match(bicepParserCPAR)
                if p.HasError() </span><span class="cov0" title="0">{
                        // Recognition error - abort rule
                        goto errorExit</span>
                }
        }

errorExit:
        <span class="cov1" title="3">if p.HasError() </span><span class="cov0" title="0">{
                v := p.GetError()
                localctx.SetException(v)
                p.GetErrorHandler().ReportError(p, v)
                p.GetErrorHandler().Recover(p, v)
                p.SetError(nil)
        }</span>
        <span class="cov1" title="3">p.ExitRule()
        return localctx
        goto errorExit</span> // Trick to prevent compiler error if the label is not used
}

// ITypeExpressionContext is an interface to support dynamic dispatch.
type ITypeExpressionContext interface {
        antlr.ParserRuleContext

        // GetParser returns the parser.
        GetParser() antlr.Parser

        // GetType_ returns the type_ rule contexts.
        GetType_() IIdentifierContext

        // SetType_ sets the type_ rule contexts.
        SetType_(IIdentifierContext)

        // Getter signatures
        Identifier() IIdentifierContext

        // IsTypeExpressionContext differentiates from other interfaces.
        IsTypeExpressionContext()
}

type TypeExpressionContext struct {
        antlr.BaseParserRuleContext
        parser antlr.Parser
        type_  IIdentifierContext
}

func NewEmptyTypeExpressionContext() *TypeExpressionContext <span class="cov0" title="0">{
        var p = new(TypeExpressionContext)
        antlr.InitBaseParserRuleContext(&amp;p.BaseParserRuleContext, nil, -1)
        p.RuleIndex = bicepParserRULE_typeExpression
        return p
}</span>

func InitEmptyTypeExpressionContext(p *TypeExpressionContext) <span class="cov0" title="0">{
        antlr.InitBaseParserRuleContext(&amp;p.BaseParserRuleContext, nil, -1)
        p.RuleIndex = bicepParserRULE_typeExpression
}</span>

func (*TypeExpressionContext) IsTypeExpressionContext() {<span class="cov0" title="0">}</span>

func NewTypeExpressionContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *TypeExpressionContext <span class="cov5" title="299">{
        var p = new(TypeExpressionContext)

        antlr.InitBaseParserRuleContext(&amp;p.BaseParserRuleContext, parent, invokingState)

        p.parser = parser
        p.RuleIndex = bicepParserRULE_typeExpression

        return p
}</span>

func (s *TypeExpressionContext) GetParser() antlr.Parser <span class="cov0" title="0">{ return s.parser }</span>

func (s *TypeExpressionContext) GetType_() IIdentifierContext <span class="cov0" title="0">{ return s.type_ }</span>

func (s *TypeExpressionContext) SetType_(v IIdentifierContext) <span class="cov0" title="0">{ s.type_ = v }</span>

func (s *TypeExpressionContext) Identifier() IIdentifierContext <span class="cov5" title="296">{
        var t antlr.RuleContext
        for _, ctx := range s.GetChildren() </span><span class="cov5" title="296">{
                if _, ok := ctx.(IIdentifierContext); ok </span><span class="cov5" title="296">{
                        t = ctx.(antlr.RuleContext)
                        break</span>
                }
        }

        <span class="cov5" title="296">if t == nil </span><span class="cov0" title="0">{
                return nil
        }</span>

        <span class="cov5" title="296">return t.(IIdentifierContext)</span>
}

func (s *TypeExpressionContext) GetRuleContext() antlr.RuleContext <span class="cov0" title="0">{
        return s
}</span>

func (s *TypeExpressionContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string <span class="cov0" title="0">{
        return antlr.TreesStringTree(s, ruleNames, recog)
}</span>

func (s *TypeExpressionContext) Accept(visitor antlr.ParseTreeVisitor) interface{} <span class="cov5" title="296">{
        switch t := visitor.(type) </span>{
        case bicepVisitor:<span class="cov5" title="296">
                return t.VisitTypeExpression(s)</span>

        default:<span class="cov0" title="0">
                return t.VisitChildren(s)</span>
        }
}

func (p *bicepParser) TypeExpression() (localctx ITypeExpressionContext) <span class="cov5" title="299">{
        localctx = NewTypeExpressionContext(p, p.GetParserRuleContext(), p.GetState())
        p.EnterRule(localctx, 44, bicepParserRULE_typeExpression)
        p.EnterOuterAlt(localctx, 1)
        </span><span class="cov5" title="299">{
                p.SetState(337)

                var _x = p.Identifier()

                localctx.(*TypeExpressionContext).type_ = _x
        }</span>

errorExit:
        <span class="cov5" title="299">if p.HasError() </span><span class="cov0" title="0">{
                v := p.GetError()
                localctx.SetException(v)
                p.GetErrorHandler().ReportError(p, v)
                p.GetErrorHandler().Recover(p, v)
                p.SetError(nil)
        }</span>
        <span class="cov5" title="299">p.ExitRule()
        return localctx
        goto errorExit</span> // Trick to prevent compiler error if the label is not used
}

// ILiteralValueContext is an interface to support dynamic dispatch.
type ILiteralValueContext interface {
        antlr.ParserRuleContext

        // GetParser returns the parser.
        GetParser() antlr.Parser

        // Getter signatures
        NUMBER() antlr.TerminalNode
        TRUE() antlr.TerminalNode
        FALSE() antlr.TerminalNode
        NULL() antlr.TerminalNode
        Identifier() IIdentifierContext

        // IsLiteralValueContext differentiates from other interfaces.
        IsLiteralValueContext()
}

type LiteralValueContext struct {
        antlr.BaseParserRuleContext
        parser antlr.Parser
}

func NewEmptyLiteralValueContext() *LiteralValueContext <span class="cov0" title="0">{
        var p = new(LiteralValueContext)
        antlr.InitBaseParserRuleContext(&amp;p.BaseParserRuleContext, nil, -1)
        p.RuleIndex = bicepParserRULE_literalValue
        return p
}</span>

func InitEmptyLiteralValueContext(p *LiteralValueContext) <span class="cov0" title="0">{
        antlr.InitBaseParserRuleContext(&amp;p.BaseParserRuleContext, nil, -1)
        p.RuleIndex = bicepParserRULE_literalValue
}</span>

func (*LiteralValueContext) IsLiteralValueContext() {<span class="cov0" title="0">}</span>

func NewLiteralValueContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *LiteralValueContext <span class="cov7" title="1592">{
        var p = new(LiteralValueContext)

        antlr.InitBaseParserRuleContext(&amp;p.BaseParserRuleContext, parent, invokingState)

        p.parser = parser
        p.RuleIndex = bicepParserRULE_literalValue

        return p
}</span>

func (s *LiteralValueContext) GetParser() antlr.Parser <span class="cov0" title="0">{ return s.parser }</span>

func (s *LiteralValueContext) NUMBER() antlr.TerminalNode <span class="cov7" title="1915">{
        return s.GetToken(bicepParserNUMBER, 0)
}</span>

func (s *LiteralValueContext) TRUE() antlr.TerminalNode <span class="cov6" title="1067">{
        return s.GetToken(bicepParserTRUE, 0)
}</span>

func (s *LiteralValueContext) FALSE() antlr.TerminalNode <span class="cov6" title="738">{
        return s.GetToken(bicepParserFALSE, 0)
}</span>

func (s *LiteralValueContext) NULL() antlr.TerminalNode <span class="cov0" title="0">{
        return s.GetToken(bicepParserNULL, 0)
}</span>

func (s *LiteralValueContext) Identifier() IIdentifierContext <span class="cov6" title="1297">{
        var t antlr.RuleContext
        for _, ctx := range s.GetChildren() </span><span class="cov6" title="1297">{
                if _, ok := ctx.(IIdentifierContext); ok </span><span class="cov6" title="1296">{
                        t = ctx.(antlr.RuleContext)
                        break</span>
                }
        }

        <span class="cov6" title="1297">if t == nil </span><span class="cov1" title="1">{
                return nil
        }</span>

        <span class="cov6" title="1296">return t.(IIdentifierContext)</span>
}

func (s *LiteralValueContext) GetRuleContext() antlr.RuleContext <span class="cov0" title="0">{
        return s
}</span>

func (s *LiteralValueContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string <span class="cov0" title="0">{
        return antlr.TreesStringTree(s, ruleNames, recog)
}</span>

func (s *LiteralValueContext) Accept(visitor antlr.ParseTreeVisitor) interface{} <span class="cov7" title="1491">{
        switch t := visitor.(type) </span>{
        case bicepVisitor:<span class="cov7" title="1491">
                return t.VisitLiteralValue(s)</span>

        default:<span class="cov0" title="0">
                return t.VisitChildren(s)</span>
        }
}

func (p *bicepParser) LiteralValue() (localctx ILiteralValueContext) <span class="cov7" title="1592">{
        localctx = NewLiteralValueContext(p, p.GetParserRuleContext(), p.GetState())
        p.EnterRule(localctx, 46, bicepParserRULE_literalValue)
        p.SetState(344)
        p.GetErrorHandler().Sync(p)
        if p.HasError() </span><span class="cov0" title="0">{
                goto errorExit</span>
        }

        <span class="cov7" title="1592">switch p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 31, p.GetParserRuleContext()) </span>{
        case 1:<span class="cov6" title="429">
                p.EnterOuterAlt(localctx, 1)
                </span><span class="cov6" title="429">{
                        p.SetState(339)
                        p.Match(bicepParserNUMBER)
                        if p.HasError() </span><span class="cov0" title="0">{
                                // Recognition error - abort rule
                                goto errorExit</span>
                        }
                }

        case 2:<span class="cov5" title="335">
                p.EnterOuterAlt(localctx, 2)
                </span><span class="cov5" title="335">{
                        p.SetState(340)
                        p.Match(bicepParserTRUE)
                        if p.HasError() </span><span class="cov0" title="0">{
                                // Recognition error - abort rule
                                goto errorExit</span>
                        }
                }

        case 3:<span class="cov4" title="90">
                p.EnterOuterAlt(localctx, 3)
                </span><span class="cov4" title="90">{
                        p.SetState(341)
                        p.Match(bicepParserFALSE)
                        if p.HasError() </span><span class="cov0" title="0">{
                                // Recognition error - abort rule
                                goto errorExit</span>
                        }
                }

        case 4:<span class="cov3" title="22">
                p.EnterOuterAlt(localctx, 4)
                </span><span class="cov3" title="22">{
                        p.SetState(342)
                        p.Match(bicepParserNULL)
                        if p.HasError() </span><span class="cov0" title="0">{
                                // Recognition error - abort rule
                                goto errorExit</span>
                        }
                }

        case 5:<span class="cov6" title="716">
                p.EnterOuterAlt(localctx, 5)
                </span><span class="cov6" title="716">{
                        p.SetState(343)
                        p.Identifier()
                }</span>

        case antlr.ATNInvalidAltNumber:<span class="cov0" title="0">
                goto errorExit</span>
        }

errorExit:
        <span class="cov7" title="1592">if p.HasError() </span><span class="cov0" title="0">{
                v := p.GetError()
                localctx.SetException(v)
                p.GetErrorHandler().ReportError(p, v)
                p.GetErrorHandler().Recover(p, v)
                p.SetError(nil)
        }</span>
        <span class="cov7" title="1592">p.ExitRule()
        return localctx
        goto errorExit</span> // Trick to prevent compiler error if the label is not used
}

// IObjectContext is an interface to support dynamic dispatch.
type IObjectContext interface {
        antlr.ParserRuleContext

        // GetParser returns the parser.
        GetParser() antlr.Parser

        // Getter signatures
        OBRACE() antlr.TerminalNode
        CBRACE() antlr.TerminalNode
        AllNL() []antlr.TerminalNode
        NL(i int) antlr.TerminalNode
        AllObjectProperty() []IObjectPropertyContext
        ObjectProperty(i int) IObjectPropertyContext

        // IsObjectContext differentiates from other interfaces.
        IsObjectContext()
}

type ObjectContext struct {
        antlr.BaseParserRuleContext
        parser antlr.Parser
}

func NewEmptyObjectContext() *ObjectContext <span class="cov0" title="0">{
        var p = new(ObjectContext)
        antlr.InitBaseParserRuleContext(&amp;p.BaseParserRuleContext, nil, -1)
        p.RuleIndex = bicepParserRULE_object
        return p
}</span>

func InitEmptyObjectContext(p *ObjectContext) <span class="cov0" title="0">{
        antlr.InitBaseParserRuleContext(&amp;p.BaseParserRuleContext, nil, -1)
        p.RuleIndex = bicepParserRULE_object
}</span>

func (*ObjectContext) IsObjectContext() {<span class="cov0" title="0">}</span>

func NewObjectContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *ObjectContext <span class="cov7" title="3051">{
        var p = new(ObjectContext)

        antlr.InitBaseParserRuleContext(&amp;p.BaseParserRuleContext, parent, invokingState)

        p.parser = parser
        p.RuleIndex = bicepParserRULE_object

        return p
}</span>

func (s *ObjectContext) GetParser() antlr.Parser <span class="cov0" title="0">{ return s.parser }</span>

func (s *ObjectContext) OBRACE() antlr.TerminalNode <span class="cov0" title="0">{
        return s.GetToken(bicepParserOBRACE, 0)
}</span>

func (s *ObjectContext) CBRACE() antlr.TerminalNode <span class="cov0" title="0">{
        return s.GetToken(bicepParserCBRACE, 0)
}</span>

func (s *ObjectContext) AllNL() []antlr.TerminalNode <span class="cov0" title="0">{
        return s.GetTokens(bicepParserNL)
}</span>

func (s *ObjectContext) NL(i int) antlr.TerminalNode <span class="cov0" title="0">{
        return s.GetToken(bicepParserNL, i)
}</span>

func (s *ObjectContext) AllObjectProperty() []IObjectPropertyContext <span class="cov7" title="3025">{
        children := s.GetChildren()
        len := 0
        for _, ctx := range children </span><span class="cov9" title="26225">{
                if _, ok := ctx.(IObjectPropertyContext); ok </span><span class="cov8" title="8682">{
                        len++
                }</span>
        }

        <span class="cov7" title="3025">tst := make([]IObjectPropertyContext, len)
        i := 0
        for _, ctx := range children </span><span class="cov9" title="26225">{
                if t, ok := ctx.(IObjectPropertyContext); ok </span><span class="cov8" title="8682">{
                        tst[i] = t.(IObjectPropertyContext)
                        i++
                }</span>
        }

        <span class="cov7" title="3025">return tst</span>
}

func (s *ObjectContext) ObjectProperty(i int) IObjectPropertyContext <span class="cov0" title="0">{
        var t antlr.RuleContext
        j := 0
        for _, ctx := range s.GetChildren() </span><span class="cov0" title="0">{
                if _, ok := ctx.(IObjectPropertyContext); ok </span><span class="cov0" title="0">{
                        if j == i </span><span class="cov0" title="0">{
                                t = ctx.(antlr.RuleContext)
                                break</span>
                        }
                        <span class="cov0" title="0">j++</span>
                }
        }

        <span class="cov0" title="0">if t == nil </span><span class="cov0" title="0">{
                return nil
        }</span>

        <span class="cov0" title="0">return t.(IObjectPropertyContext)</span>
}

func (s *ObjectContext) GetRuleContext() antlr.RuleContext <span class="cov0" title="0">{
        return s
}</span>

func (s *ObjectContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string <span class="cov0" title="0">{
        return antlr.TreesStringTree(s, ruleNames, recog)
}</span>

func (s *ObjectContext) Accept(visitor antlr.ParseTreeVisitor) interface{} <span class="cov7" title="3025">{
        switch t := visitor.(type) </span>{
        case bicepVisitor:<span class="cov7" title="3025">
                return t.VisitObject(s)</span>

        default:<span class="cov0" title="0">
                return t.VisitChildren(s)</span>
        }
}

func (p *bicepParser) Object() (localctx IObjectContext) <span class="cov7" title="3051">{
        localctx = NewObjectContext(p, p.GetParserRuleContext(), p.GetState())
        p.EnterRule(localctx, 48, bicepParserRULE_object)
        var _la int

        p.EnterOuterAlt(localctx, 1)
        </span><span class="cov7" title="3051">{
                p.SetState(346)
                p.Match(bicepParserOBRACE)
                if p.HasError() </span><span class="cov0" title="0">{
                        // Recognition error - abort rule
                        goto errorExit</span>
                }
        }
        <span class="cov7" title="3051">p.SetState(363)
        p.GetErrorHandler().Sync(p)
        if p.HasError() </span><span class="cov0" title="0">{
                goto errorExit</span>
        }
        <span class="cov7" title="3051">_la = p.GetTokenStream().LA(1)

        if _la == bicepParserNL </span><span class="cov7" title="2828">{
                p.SetState(348)
                p.GetErrorHandler().Sync(p)
                if p.HasError() </span><span class="cov0" title="0">{
                        goto errorExit</span>
                }
                <span class="cov7" title="2828">_la = p.GetTokenStream().LA(1)

                for ok := true; ok; ok = _la == bicepParserNL </span><span class="cov7" title="2828">{
                        </span><span class="cov7" title="2828">{
                                p.SetState(347)
                                p.Match(bicepParserNL)
                                if p.HasError() </span><span class="cov0" title="0">{
                                        // Recognition error - abort rule
                                        goto errorExit</span>
                                }
                        }

                        <span class="cov7" title="2828">p.SetState(350)
                        p.GetErrorHandler().Sync(p)
                        if p.HasError() </span><span class="cov0" title="0">{
                                goto errorExit</span>
                        }
                        <span class="cov7" title="2828">_la = p.GetTokenStream().LA(1)</span>
                }
                <span class="cov7" title="2828">p.SetState(360)
                p.GetErrorHandler().Sync(p)
                if p.HasError() </span><span class="cov0" title="0">{
                        goto errorExit</span>
                }
                <span class="cov7" title="2828">_la = p.GetTokenStream().LA(1)

                for (int64(_la) &amp; ^0x3f) == 0 &amp;&amp; ((int64(1)&lt;&lt;_la)&amp;565136091758592) != 0 </span><span class="cov8" title="8745">{
                        </span><span class="cov8" title="8745">{
                                p.SetState(352)
                                p.ObjectProperty()
                        }</span>
                        <span class="cov8" title="8745">p.SetState(354)
                        p.GetErrorHandler().Sync(p)
                        if p.HasError() </span><span class="cov1" title="3">{
                                goto errorExit</span>
                        }
                        <span class="cov8" title="8742">_la = p.GetTokenStream().LA(1)

                        for ok := true; ok; ok = _la == bicepParserNL </span><span class="cov8" title="8743">{
                                </span><span class="cov8" title="8743">{
                                        p.SetState(353)
                                        p.Match(bicepParserNL)
                                        if p.HasError() </span><span class="cov2" title="4">{
                                                // Recognition error - abort rule
                                                goto errorExit</span>
                                        }
                                }

                                <span class="cov8" title="8739">p.SetState(356)
                                p.GetErrorHandler().Sync(p)
                                if p.HasError() </span><span class="cov0" title="0">{
                                        goto errorExit</span>
                                }
                                <span class="cov8" title="8739">_la = p.GetTokenStream().LA(1)</span>
                        }

                        <span class="cov8" title="8738">p.SetState(362)
                        p.GetErrorHandler().Sync(p)
                        if p.HasError() </span><span class="cov0" title="0">{
                                goto errorExit</span>
                        }
                        <span class="cov8" title="8738">_la = p.GetTokenStream().LA(1)</span>
                }

        }
        <span class="cov7" title="3044">{
                p.SetState(365)
                p.Match(bicepParserCBRACE)
                if p.HasError() </span><span class="cov0" title="0">{
                        // Recognition error - abort rule
                        goto errorExit</span>
                }
        }

errorExit:
        <span class="cov7" title="3051">if p.HasError() </span><span class="cov2" title="7">{
                v := p.GetError()
                localctx.SetException(v)
                p.GetErrorHandler().ReportError(p, v)
                p.GetErrorHandler().Recover(p, v)
                p.SetError(nil)
        }</span>
        <span class="cov7" title="3051">p.ExitRule()
        return localctx
        goto errorExit</span> // Trick to prevent compiler error if the label is not used
}

// IObjectPropertyContext is an interface to support dynamic dispatch.
type IObjectPropertyContext interface {
        antlr.ParserRuleContext

        // GetParser returns the parser.
        GetParser() antlr.Parser

        // GetName returns the name rule contexts.
        GetName() IIdentifierContext

        // SetName sets the name rule contexts.
        SetName(IIdentifierContext)

        // Getter signatures
        COL() antlr.TerminalNode
        Expression() IExpressionContext
        InterpString() IInterpStringContext
        Identifier() IIdentifierContext

        // IsObjectPropertyContext differentiates from other interfaces.
        IsObjectPropertyContext()
}

type ObjectPropertyContext struct {
        antlr.BaseParserRuleContext
        parser antlr.Parser
        name   IIdentifierContext
}

func NewEmptyObjectPropertyContext() *ObjectPropertyContext <span class="cov0" title="0">{
        var p = new(ObjectPropertyContext)
        antlr.InitBaseParserRuleContext(&amp;p.BaseParserRuleContext, nil, -1)
        p.RuleIndex = bicepParserRULE_objectProperty
        return p
}</span>

func InitEmptyObjectPropertyContext(p *ObjectPropertyContext) <span class="cov0" title="0">{
        antlr.InitBaseParserRuleContext(&amp;p.BaseParserRuleContext, nil, -1)
        p.RuleIndex = bicepParserRULE_objectProperty
}</span>

func (*ObjectPropertyContext) IsObjectPropertyContext() {<span class="cov0" title="0">}</span>

func NewObjectPropertyContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *ObjectPropertyContext <span class="cov8" title="8745">{
        var p = new(ObjectPropertyContext)

        antlr.InitBaseParserRuleContext(&amp;p.BaseParserRuleContext, parent, invokingState)

        p.parser = parser
        p.RuleIndex = bicepParserRULE_objectProperty

        return p
}</span>

func (s *ObjectPropertyContext) GetParser() antlr.Parser <span class="cov0" title="0">{ return s.parser }</span>

func (s *ObjectPropertyContext) GetName() IIdentifierContext <span class="cov0" title="0">{ return s.name }</span>

func (s *ObjectPropertyContext) SetName(v IIdentifierContext) <span class="cov0" title="0">{ s.name = v }</span>

func (s *ObjectPropertyContext) COL() antlr.TerminalNode <span class="cov0" title="0">{
        return s.GetToken(bicepParserCOL, 0)
}</span>

func (s *ObjectPropertyContext) Expression() IExpressionContext <span class="cov9" title="17364">{
        var t antlr.RuleContext
        for _, ctx := range s.GetChildren() </span><span class="cov10" title="52092">{
                if _, ok := ctx.(IExpressionContext); ok </span><span class="cov9" title="17364">{
                        t = ctx.(antlr.RuleContext)
                        break</span>
                }
        }

        <span class="cov9" title="17364">if t == nil </span><span class="cov0" title="0">{
                return nil
        }</span>

        <span class="cov9" title="17364">return t.(IExpressionContext)</span>
}

func (s *ObjectPropertyContext) InterpString() IInterpStringContext <span class="cov8" title="8711">{
        var t antlr.RuleContext
        for _, ctx := range s.GetChildren() </span><span class="cov9" title="26017">{
                if _, ok := ctx.(IInterpStringContext); ok </span><span class="cov4" title="58">{
                        t = ctx.(antlr.RuleContext)
                        break</span>
                }
        }

        <span class="cov8" title="8711">if t == nil </span><span class="cov8" title="8653">{
                return nil
        }</span>

        <span class="cov4" title="58">return t.(IInterpStringContext)</span>
}

func (s *ObjectPropertyContext) Identifier() IIdentifierContext <span class="cov9" title="17335">{
        var t antlr.RuleContext
        for _, ctx := range s.GetChildren() </span><span class="cov9" title="17393">{
                if _, ok := ctx.(IIdentifierContext); ok </span><span class="cov9" title="17306">{
                        t = ctx.(antlr.RuleContext)
                        break</span>
                }
        }

        <span class="cov9" title="17335">if t == nil </span><span class="cov3" title="29">{
                return nil
        }</span>

        <span class="cov9" title="17306">return t.(IIdentifierContext)</span>
}

func (s *ObjectPropertyContext) GetRuleContext() antlr.RuleContext <span class="cov0" title="0">{
        return s
}</span>

func (s *ObjectPropertyContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string <span class="cov0" title="0">{
        return antlr.TreesStringTree(s, ruleNames, recog)
}</span>

func (s *ObjectPropertyContext) Accept(visitor antlr.ParseTreeVisitor) interface{} <span class="cov8" title="8682">{
        switch t := visitor.(type) </span>{
        case bicepVisitor:<span class="cov8" title="8682">
                return t.VisitObjectProperty(s)</span>

        default:<span class="cov0" title="0">
                return t.VisitChildren(s)</span>
        }
}

func (p *bicepParser) ObjectProperty() (localctx IObjectPropertyContext) <span class="cov8" title="8745">{
        localctx = NewObjectPropertyContext(p, p.GetParserRuleContext(), p.GetState())
        p.EnterRule(localctx, 50, bicepParserRULE_objectProperty)
        p.EnterOuterAlt(localctx, 1)
        p.SetState(369)
        p.GetErrorHandler().Sync(p)
        if p.HasError() </span><span class="cov0" title="0">{
                goto errorExit</span>
        }

        <span class="cov8" title="8745">switch p.GetTokenStream().LA(1) </span>{
        case bicepParserPARAM, bicepParserVAR, bicepParserTRUE, bicepParserFALSE, bicepParserNULL, bicepParserARRAY, bicepParserOBJECT, bicepParserRESOURCE, bicepParserOUTPUT, bicepParserTARGET_SCOPE, bicepParserIMPORT, bicepParserWITH, bicepParserAS, bicepParserMETADATA, bicepParserEXISTING, bicepParserTYPE, bicepParserMODULE, bicepParserSTRING, bicepParserINT, bicepParserBOOL, bicepParserIF, bicepParserFOR, bicepParserIN, bicepParserIDENTIFIER:<span class="cov8" title="8716">
                </span><span class="cov8" title="8716">{
                        p.SetState(367)

                        var _x = p.Identifier()

                        localctx.(*ObjectPropertyContext).name = _x
                }</span>

        case bicepParserSTRING_LEFT_PIECE, bicepParserSTRING_COMPLETE:<span class="cov3" title="29">
                </span><span class="cov3" title="29">{
                        p.SetState(368)
                        p.InterpString()
                }</span>

        default:<span class="cov0" title="0">
                p.SetError(antlr.NewNoViableAltException(p, nil, nil, nil, nil, nil))
                goto errorExit</span>
        }
        <span class="cov8" title="8745">{
                p.SetState(371)
                p.Match(bicepParserCOL)
                if p.HasError() </span><span class="cov0" title="0">{
                        // Recognition error - abort rule
                        goto errorExit</span>
                }
        }
        <span class="cov8" title="8745">{
                p.SetState(372)
                p.expression(0)
        }</span>

errorExit:
        <span class="cov8" title="8745">if p.HasError() </span><span class="cov0" title="0">{
                v := p.GetError()
                localctx.SetException(v)
                p.GetErrorHandler().ReportError(p, v)
                p.GetErrorHandler().Recover(p, v)
                p.SetError(nil)
        }</span>
        <span class="cov8" title="8745">p.ExitRule()
        return localctx
        goto errorExit</span> // Trick to prevent compiler error if the label is not used
}

// IArrayContext is an interface to support dynamic dispatch.
type IArrayContext interface {
        antlr.ParserRuleContext

        // GetParser returns the parser.
        GetParser() antlr.Parser

        // Getter signatures
        OBRACK() antlr.TerminalNode
        CBRACK() antlr.TerminalNode
        AllNL() []antlr.TerminalNode
        NL(i int) antlr.TerminalNode
        AllArrayItem() []IArrayItemContext
        ArrayItem(i int) IArrayItemContext

        // IsArrayContext differentiates from other interfaces.
        IsArrayContext()
}

type ArrayContext struct {
        antlr.BaseParserRuleContext
        parser antlr.Parser
}

func NewEmptyArrayContext() *ArrayContext <span class="cov0" title="0">{
        var p = new(ArrayContext)
        antlr.InitBaseParserRuleContext(&amp;p.BaseParserRuleContext, nil, -1)
        p.RuleIndex = bicepParserRULE_array
        return p
}</span>

func InitEmptyArrayContext(p *ArrayContext) <span class="cov0" title="0">{
        antlr.InitBaseParserRuleContext(&amp;p.BaseParserRuleContext, nil, -1)
        p.RuleIndex = bicepParserRULE_array
}</span>

func (*ArrayContext) IsArrayContext() {<span class="cov0" title="0">}</span>

func NewArrayContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *ArrayContext <span class="cov6" title="613">{
        var p = new(ArrayContext)

        antlr.InitBaseParserRuleContext(&amp;p.BaseParserRuleContext, parent, invokingState)

        p.parser = parser
        p.RuleIndex = bicepParserRULE_array

        return p
}</span>

func (s *ArrayContext) GetParser() antlr.Parser <span class="cov0" title="0">{ return s.parser }</span>

func (s *ArrayContext) OBRACK() antlr.TerminalNode <span class="cov0" title="0">{
        return s.GetToken(bicepParserOBRACK, 0)
}</span>

func (s *ArrayContext) CBRACK() antlr.TerminalNode <span class="cov0" title="0">{
        return s.GetToken(bicepParserCBRACK, 0)
}</span>

func (s *ArrayContext) AllNL() []antlr.TerminalNode <span class="cov0" title="0">{
        return s.GetTokens(bicepParserNL)
}</span>

func (s *ArrayContext) NL(i int) antlr.TerminalNode <span class="cov0" title="0">{
        return s.GetToken(bicepParserNL, i)
}</span>

func (s *ArrayContext) AllArrayItem() []IArrayItemContext <span class="cov6" title="609">{
        children := s.GetChildren()
        len := 0
        for _, ctx := range children </span><span class="cov7" title="2426">{
                if _, ok := ctx.(IArrayItemContext); ok </span><span class="cov6" title="914">{
                        len++
                }</span>
        }

        <span class="cov6" title="609">tst := make([]IArrayItemContext, len)
        i := 0
        for _, ctx := range children </span><span class="cov7" title="2426">{
                if t, ok := ctx.(IArrayItemContext); ok </span><span class="cov6" title="914">{
                        tst[i] = t.(IArrayItemContext)
                        i++
                }</span>
        }

        <span class="cov6" title="609">return tst</span>
}

func (s *ArrayContext) ArrayItem(i int) IArrayItemContext <span class="cov0" title="0">{
        var t antlr.RuleContext
        j := 0
        for _, ctx := range s.GetChildren() </span><span class="cov0" title="0">{
                if _, ok := ctx.(IArrayItemContext); ok </span><span class="cov0" title="0">{
                        if j == i </span><span class="cov0" title="0">{
                                t = ctx.(antlr.RuleContext)
                                break</span>
                        }
                        <span class="cov0" title="0">j++</span>
                }
        }

        <span class="cov0" title="0">if t == nil </span><span class="cov0" title="0">{
                return nil
        }</span>

        <span class="cov0" title="0">return t.(IArrayItemContext)</span>
}

func (s *ArrayContext) GetRuleContext() antlr.RuleContext <span class="cov0" title="0">{
        return s
}</span>

func (s *ArrayContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string <span class="cov0" title="0">{
        return antlr.TreesStringTree(s, ruleNames, recog)
}</span>

func (s *ArrayContext) Accept(visitor antlr.ParseTreeVisitor) interface{} <span class="cov6" title="609">{
        switch t := visitor.(type) </span>{
        case bicepVisitor:<span class="cov6" title="609">
                return t.VisitArray(s)</span>

        default:<span class="cov0" title="0">
                return t.VisitChildren(s)</span>
        }
}

func (p *bicepParser) Array() (localctx IArrayContext) <span class="cov6" title="613">{
        localctx = NewArrayContext(p, p.GetParserRuleContext(), p.GetState())
        p.EnterRule(localctx, 52, bicepParserRULE_array)
        var _la int

        p.EnterOuterAlt(localctx, 1)
        </span><span class="cov6" title="613">{
                p.SetState(374)
                p.Match(bicepParserOBRACK)
                if p.HasError() </span><span class="cov0" title="0">{
                        // Recognition error - abort rule
                        goto errorExit</span>
                }
        }
        <span class="cov6" title="613">p.SetState(378)
        p.GetErrorHandler().Sync(p)
        if p.HasError() </span><span class="cov0" title="0">{
                goto errorExit</span>
        }
        <span class="cov6" title="613">_la = p.GetTokenStream().LA(1)

        for _la == bicepParserNL </span><span class="cov5" title="297">{
                </span><span class="cov5" title="297">{
                        p.SetState(375)
                        p.Match(bicepParserNL)
                        if p.HasError() </span><span class="cov0" title="0">{
                                // Recognition error - abort rule
                                goto errorExit</span>
                        }
                }

                <span class="cov5" title="297">p.SetState(380)
                p.GetErrorHandler().Sync(p)
                if p.HasError() </span><span class="cov0" title="0">{
                        goto errorExit</span>
                }
                <span class="cov5" title="297">_la = p.GetTokenStream().LA(1)</span>
        }
        <span class="cov6" title="613">p.SetState(384)
        p.GetErrorHandler().Sync(p)
        if p.HasError() </span><span class="cov0" title="0">{
                goto errorExit</span>
        }
        <span class="cov6" title="613">_la = p.GetTokenStream().LA(1)

        for (int64(_la) &amp; ^0x3f) == 0 &amp;&amp; ((int64(1)&lt;&lt;_la)&amp;1691035998605394) != 0 </span><span class="cov6" title="918">{
                </span><span class="cov6" title="918">{
                        p.SetState(381)
                        p.ArrayItem()
                }</span>

                <span class="cov6" title="918">p.SetState(386)
                p.GetErrorHandler().Sync(p)
                if p.HasError() </span><span class="cov0" title="0">{
                        goto errorExit</span>
                }
                <span class="cov6" title="918">_la = p.GetTokenStream().LA(1)</span>
        }
        <span class="cov6" title="613">{
                p.SetState(387)
                p.Match(bicepParserCBRACK)
                if p.HasError() </span><span class="cov0" title="0">{
                        // Recognition error - abort rule
                        goto errorExit</span>
                }
        }

errorExit:
        <span class="cov6" title="613">if p.HasError() </span><span class="cov0" title="0">{
                v := p.GetError()
                localctx.SetException(v)
                p.GetErrorHandler().ReportError(p, v)
                p.GetErrorHandler().Recover(p, v)
                p.SetError(nil)
        }</span>
        <span class="cov6" title="613">p.ExitRule()
        return localctx
        goto errorExit</span> // Trick to prevent compiler error if the label is not used
}

// IArrayItemContext is an interface to support dynamic dispatch.
type IArrayItemContext interface {
        antlr.ParserRuleContext

        // GetParser returns the parser.
        GetParser() antlr.Parser

        // Getter signatures
        Expression() IExpressionContext
        COMMA() antlr.TerminalNode
        AllNL() []antlr.TerminalNode
        NL(i int) antlr.TerminalNode

        // IsArrayItemContext differentiates from other interfaces.
        IsArrayItemContext()
}

type ArrayItemContext struct {
        antlr.BaseParserRuleContext
        parser antlr.Parser
}

func NewEmptyArrayItemContext() *ArrayItemContext <span class="cov0" title="0">{
        var p = new(ArrayItemContext)
        antlr.InitBaseParserRuleContext(&amp;p.BaseParserRuleContext, nil, -1)
        p.RuleIndex = bicepParserRULE_arrayItem
        return p
}</span>

func InitEmptyArrayItemContext(p *ArrayItemContext) <span class="cov0" title="0">{
        antlr.InitBaseParserRuleContext(&amp;p.BaseParserRuleContext, nil, -1)
        p.RuleIndex = bicepParserRULE_arrayItem
}</span>

func (*ArrayItemContext) IsArrayItemContext() {<span class="cov0" title="0">}</span>

func NewArrayItemContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *ArrayItemContext <span class="cov6" title="918">{
        var p = new(ArrayItemContext)

        antlr.InitBaseParserRuleContext(&amp;p.BaseParserRuleContext, parent, invokingState)

        p.parser = parser
        p.RuleIndex = bicepParserRULE_arrayItem

        return p
}</span>

func (s *ArrayItemContext) GetParser() antlr.Parser <span class="cov0" title="0">{ return s.parser }</span>

func (s *ArrayItemContext) Expression() IExpressionContext <span class="cov6" title="914">{
        var t antlr.RuleContext
        for _, ctx := range s.GetChildren() </span><span class="cov6" title="914">{
                if _, ok := ctx.(IExpressionContext); ok </span><span class="cov6" title="914">{
                        t = ctx.(antlr.RuleContext)
                        break</span>
                }
        }

        <span class="cov6" title="914">if t == nil </span><span class="cov0" title="0">{
                return nil
        }</span>

        <span class="cov6" title="914">return t.(IExpressionContext)</span>
}

func (s *ArrayItemContext) COMMA() antlr.TerminalNode <span class="cov0" title="0">{
        return s.GetToken(bicepParserCOMMA, 0)
}</span>

func (s *ArrayItemContext) AllNL() []antlr.TerminalNode <span class="cov0" title="0">{
        return s.GetTokens(bicepParserNL)
}</span>

func (s *ArrayItemContext) NL(i int) antlr.TerminalNode <span class="cov0" title="0">{
        return s.GetToken(bicepParserNL, i)
}</span>

func (s *ArrayItemContext) GetRuleContext() antlr.RuleContext <span class="cov0" title="0">{
        return s
}</span>

func (s *ArrayItemContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string <span class="cov0" title="0">{
        return antlr.TreesStringTree(s, ruleNames, recog)
}</span>

func (s *ArrayItemContext) Accept(visitor antlr.ParseTreeVisitor) interface{} <span class="cov6" title="914">{
        switch t := visitor.(type) </span>{
        case bicepVisitor:<span class="cov6" title="914">
                return t.VisitArrayItem(s)</span>

        default:<span class="cov0" title="0">
                return t.VisitChildren(s)</span>
        }
}

func (p *bicepParser) ArrayItem() (localctx IArrayItemContext) <span class="cov6" title="918">{
        localctx = NewArrayItemContext(p, p.GetParserRuleContext(), p.GetState())
        p.EnterRule(localctx, 54, bicepParserRULE_arrayItem)
        var _la int

        p.EnterOuterAlt(localctx, 1)
        </span><span class="cov6" title="918">{
                p.SetState(389)
                p.expression(0)
        }</span>
        <span class="cov6" title="918">p.SetState(396)
        p.GetErrorHandler().Sync(p)
        if p.HasError() </span><span class="cov0" title="0">{
                goto errorExit</span>
        }
        <span class="cov6" title="918">switch p.GetTokenStream().LA(1) </span>{
        case bicepParserNL:<span class="cov6" title="573">
                p.SetState(391)
                p.GetErrorHandler().Sync(p)
                if p.HasError() </span><span class="cov0" title="0">{
                        goto errorExit</span>
                }
                <span class="cov6" title="573">_la = p.GetTokenStream().LA(1)

                for ok := true; ok; ok = _la == bicepParserNL </span><span class="cov6" title="573">{
                        </span><span class="cov6" title="573">{
                                p.SetState(390)
                                p.Match(bicepParserNL)
                                if p.HasError() </span><span class="cov0" title="0">{
                                        // Recognition error - abort rule
                                        goto errorExit</span>
                                }
                        }

                        <span class="cov6" title="573">p.SetState(393)
                        p.GetErrorHandler().Sync(p)
                        if p.HasError() </span><span class="cov0" title="0">{
                                goto errorExit</span>
                        }
                        <span class="cov6" title="573">_la = p.GetTokenStream().LA(1)</span>
                }

        case bicepParserCOMMA:<span class="cov4" title="65">
                </span><span class="cov4" title="65">{
                        p.SetState(395)
                        p.Match(bicepParserCOMMA)
                        if p.HasError() </span><span class="cov0" title="0">{
                                // Recognition error - abort rule
                                goto errorExit</span>
                        }
                }

        case bicepParserMULTILINE_STRING, bicepParserOBRACK, bicepParserCBRACK, bicepParserOPAR, bicepParserOBRACE, bicepParserPARAM, bicepParserVAR, bicepParserTRUE, bicepParserFALSE, bicepParserNULL, bicepParserARRAY, bicepParserOBJECT, bicepParserRESOURCE, bicepParserOUTPUT, bicepParserTARGET_SCOPE, bicepParserIMPORT, bicepParserWITH, bicepParserAS, bicepParserMETADATA, bicepParserEXISTING, bicepParserTYPE, bicepParserMODULE, bicepParserSTRING_LEFT_PIECE, bicepParserSTRING_COMPLETE, bicepParserSTRING, bicepParserINT, bicepParserBOOL, bicepParserIF, bicepParserFOR, bicepParserIN, bicepParserIDENTIFIER, bicepParserNUMBER:<span class="cov5" title="280"></span>

        default:<span class="cov0" title="0"></span>
        }

errorExit:
        <span class="cov6" title="918">if p.HasError() </span><span class="cov0" title="0">{
                v := p.GetError()
                localctx.SetException(v)
                p.GetErrorHandler().ReportError(p, v)
                p.GetErrorHandler().Recover(p, v)
                p.SetError(nil)
        }</span>
        <span class="cov6" title="918">p.ExitRule()
        return localctx
        goto errorExit</span> // Trick to prevent compiler error if the label is not used
}

// IDecoratorContext is an interface to support dynamic dispatch.
type IDecoratorContext interface {
        antlr.ParserRuleContext

        // GetParser returns the parser.
        GetParser() antlr.Parser

        // Getter signatures
        AT() antlr.TerminalNode
        DecoratorExpression() IDecoratorExpressionContext
        NL() antlr.TerminalNode

        // IsDecoratorContext differentiates from other interfaces.
        IsDecoratorContext()
}

type DecoratorContext struct {
        antlr.BaseParserRuleContext
        parser antlr.Parser
}

func NewEmptyDecoratorContext() *DecoratorContext <span class="cov0" title="0">{
        var p = new(DecoratorContext)
        antlr.InitBaseParserRuleContext(&amp;p.BaseParserRuleContext, nil, -1)
        p.RuleIndex = bicepParserRULE_decorator
        return p
}</span>

func InitEmptyDecoratorContext(p *DecoratorContext) <span class="cov0" title="0">{
        antlr.InitBaseParserRuleContext(&amp;p.BaseParserRuleContext, nil, -1)
        p.RuleIndex = bicepParserRULE_decorator
}</span>

func (*DecoratorContext) IsDecoratorContext() {<span class="cov0" title="0">}</span>

func NewDecoratorContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *DecoratorContext <span class="cov5" title="235">{
        var p = new(DecoratorContext)

        antlr.InitBaseParserRuleContext(&amp;p.BaseParserRuleContext, parent, invokingState)

        p.parser = parser
        p.RuleIndex = bicepParserRULE_decorator

        return p
}</span>

func (s *DecoratorContext) GetParser() antlr.Parser <span class="cov0" title="0">{ return s.parser }</span>

func (s *DecoratorContext) AT() antlr.TerminalNode <span class="cov0" title="0">{
        return s.GetToken(bicepParserAT, 0)
}</span>

func (s *DecoratorContext) DecoratorExpression() IDecoratorExpressionContext <span class="cov6" title="468">{
        var t antlr.RuleContext
        for _, ctx := range s.GetChildren() </span><span class="cov6" title="936">{
                if _, ok := ctx.(IDecoratorExpressionContext); ok </span><span class="cov6" title="468">{
                        t = ctx.(antlr.RuleContext)
                        break</span>
                }
        }

        <span class="cov6" title="468">if t == nil </span><span class="cov0" title="0">{
                return nil
        }</span>

        <span class="cov6" title="468">return t.(IDecoratorExpressionContext)</span>
}

func (s *DecoratorContext) NL() antlr.TerminalNode <span class="cov0" title="0">{
        return s.GetToken(bicepParserNL, 0)
}</span>

func (s *DecoratorContext) GetRuleContext() antlr.RuleContext <span class="cov0" title="0">{
        return s
}</span>

func (s *DecoratorContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string <span class="cov0" title="0">{
        return antlr.TreesStringTree(s, ruleNames, recog)
}</span>

func (s *DecoratorContext) Accept(visitor antlr.ParseTreeVisitor) interface{} <span class="cov5" title="234">{
        switch t := visitor.(type) </span>{
        case bicepVisitor:<span class="cov5" title="234">
                return t.VisitDecorator(s)</span>

        default:<span class="cov0" title="0">
                return t.VisitChildren(s)</span>
        }
}

func (p *bicepParser) Decorator() (localctx IDecoratorContext) <span class="cov5" title="235">{
        localctx = NewDecoratorContext(p, p.GetParserRuleContext(), p.GetState())
        p.EnterRule(localctx, 56, bicepParserRULE_decorator)
        p.EnterOuterAlt(localctx, 1)
        </span><span class="cov5" title="235">{
                p.SetState(398)
                p.Match(bicepParserAT)
                if p.HasError() </span><span class="cov0" title="0">{
                        // Recognition error - abort rule
                        goto errorExit</span>
                }
        }
        <span class="cov5" title="235">{
                p.SetState(399)
                p.DecoratorExpression()
        }</span>
        <span class="cov5" title="235">{
                p.SetState(400)
                p.Match(bicepParserNL)
                if p.HasError() </span><span class="cov0" title="0">{
                        // Recognition error - abort rule
                        goto errorExit</span>
                }
        }

errorExit:
        <span class="cov5" title="235">if p.HasError() </span><span class="cov0" title="0">{
                v := p.GetError()
                localctx.SetException(v)
                p.GetErrorHandler().ReportError(p, v)
                p.GetErrorHandler().Recover(p, v)
                p.SetError(nil)
        }</span>
        <span class="cov5" title="235">p.ExitRule()
        return localctx
        goto errorExit</span> // Trick to prevent compiler error if the label is not used
}

// IDecoratorExpressionContext is an interface to support dynamic dispatch.
type IDecoratorExpressionContext interface {
        antlr.ParserRuleContext

        // GetParser returns the parser.
        GetParser() antlr.Parser

        // Getter signatures
        FunctionCall() IFunctionCallContext
        Expression() IExpressionContext
        DOT() antlr.TerminalNode

        // IsDecoratorExpressionContext differentiates from other interfaces.
        IsDecoratorExpressionContext()
}

type DecoratorExpressionContext struct {
        antlr.BaseParserRuleContext
        parser antlr.Parser
}

func NewEmptyDecoratorExpressionContext() *DecoratorExpressionContext <span class="cov0" title="0">{
        var p = new(DecoratorExpressionContext)
        antlr.InitBaseParserRuleContext(&amp;p.BaseParserRuleContext, nil, -1)
        p.RuleIndex = bicepParserRULE_decoratorExpression
        return p
}</span>

func InitEmptyDecoratorExpressionContext(p *DecoratorExpressionContext) <span class="cov0" title="0">{
        antlr.InitBaseParserRuleContext(&amp;p.BaseParserRuleContext, nil, -1)
        p.RuleIndex = bicepParserRULE_decoratorExpression
}</span>

func (*DecoratorExpressionContext) IsDecoratorExpressionContext() {<span class="cov0" title="0">}</span>

func NewDecoratorExpressionContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *DecoratorExpressionContext <span class="cov5" title="235">{
        var p = new(DecoratorExpressionContext)

        antlr.InitBaseParserRuleContext(&amp;p.BaseParserRuleContext, parent, invokingState)

        p.parser = parser
        p.RuleIndex = bicepParserRULE_decoratorExpression

        return p
}</span>

func (s *DecoratorExpressionContext) GetParser() antlr.Parser <span class="cov0" title="0">{ return s.parser }</span>

func (s *DecoratorExpressionContext) FunctionCall() IFunctionCallContext <span class="cov6" title="468">{
        var t antlr.RuleContext
        for _, ctx := range s.GetChildren() </span><span class="cov6" title="472">{
                if _, ok := ctx.(IFunctionCallContext); ok </span><span class="cov6" title="468">{
                        t = ctx.(antlr.RuleContext)
                        break</span>
                }
        }

        <span class="cov6" title="468">if t == nil </span><span class="cov0" title="0">{
                return nil
        }</span>

        <span class="cov6" title="468">return t.(IFunctionCallContext)</span>
}

func (s *DecoratorExpressionContext) Expression() IExpressionContext <span class="cov0" title="0">{
        var t antlr.RuleContext
        for _, ctx := range s.GetChildren() </span><span class="cov0" title="0">{
                if _, ok := ctx.(IExpressionContext); ok </span><span class="cov0" title="0">{
                        t = ctx.(antlr.RuleContext)
                        break</span>
                }
        }

        <span class="cov0" title="0">if t == nil </span><span class="cov0" title="0">{
                return nil
        }</span>

        <span class="cov0" title="0">return t.(IExpressionContext)</span>
}

func (s *DecoratorExpressionContext) DOT() antlr.TerminalNode <span class="cov0" title="0">{
        return s.GetToken(bicepParserDOT, 0)
}</span>

func (s *DecoratorExpressionContext) GetRuleContext() antlr.RuleContext <span class="cov0" title="0">{
        return s
}</span>

func (s *DecoratorExpressionContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string <span class="cov0" title="0">{
        return antlr.TreesStringTree(s, ruleNames, recog)
}</span>

func (s *DecoratorExpressionContext) Accept(visitor antlr.ParseTreeVisitor) interface{} <span class="cov5" title="234">{
        switch t := visitor.(type) </span>{
        case bicepVisitor:<span class="cov5" title="234">
                return t.VisitDecoratorExpression(s)</span>

        default:<span class="cov0" title="0">
                return t.VisitChildren(s)</span>
        }
}

func (p *bicepParser) DecoratorExpression() (localctx IDecoratorExpressionContext) <span class="cov5" title="235">{
        localctx = NewDecoratorExpressionContext(p, p.GetParserRuleContext(), p.GetState())
        p.EnterRule(localctx, 58, bicepParserRULE_decoratorExpression)
        p.SetState(407)
        p.GetErrorHandler().Sync(p)
        if p.HasError() </span><span class="cov0" title="0">{
                goto errorExit</span>
        }

        <span class="cov5" title="235">switch p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 41, p.GetParserRuleContext()) </span>{
        case 1:<span class="cov5" title="234">
                p.EnterOuterAlt(localctx, 1)
                </span><span class="cov5" title="234">{
                        p.SetState(402)
                        p.FunctionCall()
                }</span>

        case 2:<span class="cov1" title="1">
                p.EnterOuterAlt(localctx, 2)
                </span><span class="cov1" title="1">{
                        p.SetState(403)
                        p.expression(0)
                }</span>
                <span class="cov1" title="1">{
                        p.SetState(404)
                        p.Match(bicepParserDOT)
                        if p.HasError() </span><span class="cov0" title="0">{
                                // Recognition error - abort rule
                                goto errorExit</span>
                        }
                }
                <span class="cov1" title="1">{
                        p.SetState(405)
                        p.FunctionCall()
                }</span>

        case antlr.ATNInvalidAltNumber:<span class="cov0" title="0">
                goto errorExit</span>
        }

errorExit:
        <span class="cov5" title="235">if p.HasError() </span><span class="cov0" title="0">{
                v := p.GetError()
                localctx.SetException(v)
                p.GetErrorHandler().ReportError(p, v)
                p.GetErrorHandler().Recover(p, v)
                p.SetError(nil)
        }</span>
        <span class="cov5" title="235">p.ExitRule()
        return localctx
        goto errorExit</span> // Trick to prevent compiler error if the label is not used
}

// IFunctionCallContext is an interface to support dynamic dispatch.
type IFunctionCallContext interface {
        antlr.ParserRuleContext

        // GetParser returns the parser.
        GetParser() antlr.Parser

        // Getter signatures
        Identifier() IIdentifierContext
        OPAR() antlr.TerminalNode
        CPAR() antlr.TerminalNode
        ArgumentList() IArgumentListContext
        AllNL() []antlr.TerminalNode
        NL(i int) antlr.TerminalNode

        // IsFunctionCallContext differentiates from other interfaces.
        IsFunctionCallContext()
}

type FunctionCallContext struct {
        antlr.BaseParserRuleContext
        parser antlr.Parser
}

func NewEmptyFunctionCallContext() *FunctionCallContext <span class="cov0" title="0">{
        var p = new(FunctionCallContext)
        antlr.InitBaseParserRuleContext(&amp;p.BaseParserRuleContext, nil, -1)
        p.RuleIndex = bicepParserRULE_functionCall
        return p
}</span>

func InitEmptyFunctionCallContext(p *FunctionCallContext) <span class="cov0" title="0">{
        antlr.InitBaseParserRuleContext(&amp;p.BaseParserRuleContext, nil, -1)
        p.RuleIndex = bicepParserRULE_functionCall
}</span>

func (*FunctionCallContext) IsFunctionCallContext() {<span class="cov0" title="0">}</span>

func NewFunctionCallContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *FunctionCallContext <span class="cov6" title="755">{
        var p = new(FunctionCallContext)

        antlr.InitBaseParserRuleContext(&amp;p.BaseParserRuleContext, parent, invokingState)

        p.parser = parser
        p.RuleIndex = bicepParserRULE_functionCall

        return p
}</span>

func (s *FunctionCallContext) GetParser() antlr.Parser <span class="cov0" title="0">{ return s.parser }</span>

func (s *FunctionCallContext) Identifier() IIdentifierContext <span class="cov6" title="735">{
        var t antlr.RuleContext
        for _, ctx := range s.GetChildren() </span><span class="cov6" title="735">{
                if _, ok := ctx.(IIdentifierContext); ok </span><span class="cov6" title="735">{
                        t = ctx.(antlr.RuleContext)
                        break</span>
                }
        }

        <span class="cov6" title="735">if t == nil </span><span class="cov0" title="0">{
                return nil
        }</span>

        <span class="cov6" title="735">return t.(IIdentifierContext)</span>
}

func (s *FunctionCallContext) OPAR() antlr.TerminalNode <span class="cov0" title="0">{
        return s.GetToken(bicepParserOPAR, 0)
}</span>

func (s *FunctionCallContext) CPAR() antlr.TerminalNode <span class="cov0" title="0">{
        return s.GetToken(bicepParserCPAR, 0)
}</span>

func (s *FunctionCallContext) ArgumentList() IArgumentListContext <span class="cov6" title="1027">{
        var t antlr.RuleContext
        for _, ctx := range s.GetChildren() </span><span class="cov7" title="3193">{
                if _, ok := ctx.(IArgumentListContext); ok </span><span class="cov6" title="584">{
                        t = ctx.(antlr.RuleContext)
                        break</span>
                }
        }

        <span class="cov6" title="1027">if t == nil </span><span class="cov6" title="443">{
                return nil
        }</span>

        <span class="cov6" title="584">return t.(IArgumentListContext)</span>
}

func (s *FunctionCallContext) AllNL() []antlr.TerminalNode <span class="cov0" title="0">{
        return s.GetTokens(bicepParserNL)
}</span>

func (s *FunctionCallContext) NL(i int) antlr.TerminalNode <span class="cov0" title="0">{
        return s.GetToken(bicepParserNL, i)
}</span>

func (s *FunctionCallContext) GetRuleContext() antlr.RuleContext <span class="cov0" title="0">{
        return s
}</span>

func (s *FunctionCallContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string <span class="cov0" title="0">{
        return antlr.TreesStringTree(s, ruleNames, recog)
}</span>

func (s *FunctionCallContext) Accept(visitor antlr.ParseTreeVisitor) interface{} <span class="cov6" title="735">{
        switch t := visitor.(type) </span>{
        case bicepVisitor:<span class="cov6" title="735">
                return t.VisitFunctionCall(s)</span>

        default:<span class="cov0" title="0">
                return t.VisitChildren(s)</span>
        }
}

func (p *bicepParser) FunctionCall() (localctx IFunctionCallContext) <span class="cov6" title="755">{
        localctx = NewFunctionCallContext(p, p.GetParserRuleContext(), p.GetState())
        p.EnterRule(localctx, 60, bicepParserRULE_functionCall)
        var _la int

        p.EnterOuterAlt(localctx, 1)
        </span><span class="cov6" title="755">{
                p.SetState(409)
                p.Identifier()
        }</span>
        <span class="cov6" title="755">{
                p.SetState(410)
                p.Match(bicepParserOPAR)
                if p.HasError() </span><span class="cov0" title="0">{
                        // Recognition error - abort rule
                        goto errorExit</span>
                }
        }
        <span class="cov6" title="755">p.SetState(415)
        p.GetErrorHandler().Sync(p)

        if p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 43, p.GetParserRuleContext()) == 1 </span><span class="cov5" title="310">{
                p.SetState(412)
                p.GetErrorHandler().Sync(p)
                if p.HasError() </span><span class="cov0" title="0">{
                        goto errorExit</span>
                }
                <span class="cov5" title="310">_la = p.GetTokenStream().LA(1)

                if _la == bicepParserNL </span><span class="cov4" title="56">{
                        </span><span class="cov4" title="56">{
                                p.SetState(411)
                                p.Match(bicepParserNL)
                                if p.HasError() </span><span class="cov0" title="0">{
                                        // Recognition error - abort rule
                                        goto errorExit</span>
                                }
                        }

                }
                <span class="cov5" title="310">{
                        p.SetState(414)
                        p.ArgumentList()
                }</span>

        } else<span class="cov6" title="445"> if p.HasError() </span><span class="cov0" title="0">{ // JIM
                goto errorExit</span>
        }
        <span class="cov6" title="755">p.SetState(418)
        p.GetErrorHandler().Sync(p)
        if p.HasError() </span><span class="cov0" title="0">{
                goto errorExit</span>
        }
        <span class="cov6" title="755">_la = p.GetTokenStream().LA(1)

        if _la == bicepParserNL </span><span class="cov4" title="56">{
                </span><span class="cov4" title="56">{
                        p.SetState(417)
                        p.Match(bicepParserNL)
                        if p.HasError() </span><span class="cov0" title="0">{
                                // Recognition error - abort rule
                                goto errorExit</span>
                        }
                }

        }
        <span class="cov6" title="755">{
                p.SetState(420)
                p.Match(bicepParserCPAR)
                if p.HasError() </span><span class="cov0" title="0">{
                        // Recognition error - abort rule
                        goto errorExit</span>
                }
        }

errorExit:
        <span class="cov6" title="755">if p.HasError() </span><span class="cov0" title="0">{
                v := p.GetError()
                localctx.SetException(v)
                p.GetErrorHandler().ReportError(p, v)
                p.GetErrorHandler().Recover(p, v)
                p.SetError(nil)
        }</span>
        <span class="cov6" title="755">p.ExitRule()
        return localctx
        goto errorExit</span> // Trick to prevent compiler error if the label is not used
}

// IArgumentListContext is an interface to support dynamic dispatch.
type IArgumentListContext interface {
        antlr.ParserRuleContext

        // GetParser returns the parser.
        GetParser() antlr.Parser

        // Getter signatures
        AllExpression() []IExpressionContext
        Expression(i int) IExpressionContext
        AllCOMMA() []antlr.TerminalNode
        COMMA(i int) antlr.TerminalNode
        AllNL() []antlr.TerminalNode
        NL(i int) antlr.TerminalNode

        // IsArgumentListContext differentiates from other interfaces.
        IsArgumentListContext()
}

type ArgumentListContext struct {
        antlr.BaseParserRuleContext
        parser antlr.Parser
}

func NewEmptyArgumentListContext() *ArgumentListContext <span class="cov0" title="0">{
        var p = new(ArgumentListContext)
        antlr.InitBaseParserRuleContext(&amp;p.BaseParserRuleContext, nil, -1)
        p.RuleIndex = bicepParserRULE_argumentList
        return p
}</span>

func InitEmptyArgumentListContext(p *ArgumentListContext) <span class="cov0" title="0">{
        antlr.InitBaseParserRuleContext(&amp;p.BaseParserRuleContext, nil, -1)
        p.RuleIndex = bicepParserRULE_argumentList
}</span>

func (*ArgumentListContext) IsArgumentListContext() {<span class="cov0" title="0">}</span>

func NewArgumentListContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *ArgumentListContext <span class="cov5" title="310">{
        var p = new(ArgumentListContext)

        antlr.InitBaseParserRuleContext(&amp;p.BaseParserRuleContext, parent, invokingState)

        p.parser = parser
        p.RuleIndex = bicepParserRULE_argumentList

        return p
}</span>

func (s *ArgumentListContext) GetParser() antlr.Parser <span class="cov0" title="0">{ return s.parser }</span>

func (s *ArgumentListContext) AllExpression() []IExpressionContext <span class="cov5" title="292">{
        children := s.GetChildren()
        len := 0
        for _, ctx := range children </span><span class="cov6" title="457">{
                if _, ok := ctx.(IExpressionContext); ok </span><span class="cov5" title="360">{
                        len++
                }</span>
        }

        <span class="cov5" title="292">tst := make([]IExpressionContext, len)
        i := 0
        for _, ctx := range children </span><span class="cov6" title="457">{
                if t, ok := ctx.(IExpressionContext); ok </span><span class="cov5" title="360">{
                        tst[i] = t.(IExpressionContext)
                        i++
                }</span>
        }

        <span class="cov5" title="292">return tst</span>
}

func (s *ArgumentListContext) Expression(i int) IExpressionContext <span class="cov0" title="0">{
        var t antlr.RuleContext
        j := 0
        for _, ctx := range s.GetChildren() </span><span class="cov0" title="0">{
                if _, ok := ctx.(IExpressionContext); ok </span><span class="cov0" title="0">{
                        if j == i </span><span class="cov0" title="0">{
                                t = ctx.(antlr.RuleContext)
                                break</span>
                        }
                        <span class="cov0" title="0">j++</span>
                }
        }

        <span class="cov0" title="0">if t == nil </span><span class="cov0" title="0">{
                return nil
        }</span>

        <span class="cov0" title="0">return t.(IExpressionContext)</span>
}

func (s *ArgumentListContext) AllCOMMA() []antlr.TerminalNode <span class="cov0" title="0">{
        return s.GetTokens(bicepParserCOMMA)
}</span>

func (s *ArgumentListContext) COMMA(i int) antlr.TerminalNode <span class="cov0" title="0">{
        return s.GetToken(bicepParserCOMMA, i)
}</span>

func (s *ArgumentListContext) AllNL() []antlr.TerminalNode <span class="cov0" title="0">{
        return s.GetTokens(bicepParserNL)
}</span>

func (s *ArgumentListContext) NL(i int) antlr.TerminalNode <span class="cov0" title="0">{
        return s.GetToken(bicepParserNL, i)
}</span>

func (s *ArgumentListContext) GetRuleContext() antlr.RuleContext <span class="cov0" title="0">{
        return s
}</span>

func (s *ArgumentListContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string <span class="cov0" title="0">{
        return antlr.TreesStringTree(s, ruleNames, recog)
}</span>

func (s *ArgumentListContext) Accept(visitor antlr.ParseTreeVisitor) interface{} <span class="cov5" title="292">{
        switch t := visitor.(type) </span>{
        case bicepVisitor:<span class="cov5" title="292">
                return t.VisitArgumentList(s)</span>

        default:<span class="cov0" title="0">
                return t.VisitChildren(s)</span>
        }
}

func (p *bicepParser) ArgumentList() (localctx IArgumentListContext) <span class="cov5" title="310">{
        localctx = NewArgumentListContext(p, p.GetParserRuleContext(), p.GetState())
        p.EnterRule(localctx, 62, bicepParserRULE_argumentList)
        var _la int

        p.EnterOuterAlt(localctx, 1)
        </span><span class="cov5" title="310">{
                p.SetState(422)
                p.expression(0)
        }</span>
        <span class="cov5" title="310">p.SetState(430)
        p.GetErrorHandler().Sync(p)
        if p.HasError() </span><span class="cov0" title="0">{
                goto errorExit</span>
        }
        <span class="cov5" title="310">_la = p.GetTokenStream().LA(1)

        for _la == bicepParserCOMMA </span><span class="cov4" title="77">{
                </span><span class="cov4" title="77">{
                        p.SetState(423)
                        p.Match(bicepParserCOMMA)
                        if p.HasError() </span><span class="cov0" title="0">{
                                // Recognition error - abort rule
                                goto errorExit</span>
                        }
                }
                <span class="cov4" title="77">p.SetState(425)
                p.GetErrorHandler().Sync(p)
                if p.HasError() </span><span class="cov0" title="0">{
                        goto errorExit</span>
                }
                <span class="cov4" title="77">_la = p.GetTokenStream().LA(1)

                if _la == bicepParserNL </span><span class="cov3" title="29">{
                        </span><span class="cov3" title="29">{
                                p.SetState(424)
                                p.Match(bicepParserNL)
                                if p.HasError() </span><span class="cov0" title="0">{
                                        // Recognition error - abort rule
                                        goto errorExit</span>
                                }
                        }

                }
                <span class="cov4" title="77">{
                        p.SetState(427)
                        p.expression(0)
                }</span>

                <span class="cov4" title="77">p.SetState(432)
                p.GetErrorHandler().Sync(p)
                if p.HasError() </span><span class="cov0" title="0">{
                        goto errorExit</span>
                }
                <span class="cov4" title="77">_la = p.GetTokenStream().LA(1)</span>
        }

errorExit:
        <span class="cov5" title="310">if p.HasError() </span><span class="cov0" title="0">{
                v := p.GetError()
                localctx.SetException(v)
                p.GetErrorHandler().ReportError(p, v)
                p.GetErrorHandler().Recover(p, v)
                p.SetError(nil)
        }</span>
        <span class="cov5" title="310">p.ExitRule()
        return localctx
        goto errorExit</span> // Trick to prevent compiler error if the label is not used
}

// IIdentifierContext is an interface to support dynamic dispatch.
type IIdentifierContext interface {
        antlr.ParserRuleContext

        // GetParser returns the parser.
        GetParser() antlr.Parser

        // Getter signatures
        IDENTIFIER() antlr.TerminalNode
        IMPORT() antlr.TerminalNode
        WITH() antlr.TerminalNode
        AS() antlr.TerminalNode
        METADATA() antlr.TerminalNode
        PARAM() antlr.TerminalNode
        RESOURCE() antlr.TerminalNode
        MODULE() antlr.TerminalNode
        OUTPUT() antlr.TerminalNode
        EXISTING() antlr.TerminalNode
        TYPE() antlr.TerminalNode
        VAR() antlr.TerminalNode
        IF() antlr.TerminalNode
        FOR() antlr.TerminalNode
        IN() antlr.TerminalNode
        TRUE() antlr.TerminalNode
        FALSE() antlr.TerminalNode
        NULL() antlr.TerminalNode
        TARGET_SCOPE() antlr.TerminalNode
        STRING() antlr.TerminalNode
        INT() antlr.TerminalNode
        BOOL() antlr.TerminalNode
        ARRAY() antlr.TerminalNode
        OBJECT() antlr.TerminalNode

        // IsIdentifierContext differentiates from other interfaces.
        IsIdentifierContext()
}

type IdentifierContext struct {
        antlr.BaseParserRuleContext
        parser antlr.Parser
}

func NewEmptyIdentifierContext() *IdentifierContext <span class="cov0" title="0">{
        var p = new(IdentifierContext)
        antlr.InitBaseParserRuleContext(&amp;p.BaseParserRuleContext, nil, -1)
        p.RuleIndex = bicepParserRULE_identifier
        return p
}</span>

func InitEmptyIdentifierContext(p *IdentifierContext) <span class="cov0" title="0">{
        antlr.InitBaseParserRuleContext(&amp;p.BaseParserRuleContext, nil, -1)
        p.RuleIndex = bicepParserRULE_identifier
}</span>

func (*IdentifierContext) IsIdentifierContext() {<span class="cov0" title="0">}</span>

func NewIdentifierContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *IdentifierContext <span class="cov8" title="12154">{
        var p = new(IdentifierContext)

        antlr.InitBaseParserRuleContext(&amp;p.BaseParserRuleContext, parent, invokingState)

        p.parser = parser
        p.RuleIndex = bicepParserRULE_identifier

        return p
}</span>

func (s *IdentifierContext) GetParser() antlr.Parser <span class="cov0" title="0">{ return s.parser }</span>

func (s *IdentifierContext) IDENTIFIER() antlr.TerminalNode <span class="cov8" title="11965">{
        return s.GetToken(bicepParserIDENTIFIER, 0)
}</span>

func (s *IdentifierContext) IMPORT() antlr.TerminalNode <span class="cov8" title="11965">{
        return s.GetToken(bicepParserIMPORT, 0)
}</span>

func (s *IdentifierContext) WITH() antlr.TerminalNode <span class="cov8" title="11965">{
        return s.GetToken(bicepParserWITH, 0)
}</span>

func (s *IdentifierContext) AS() antlr.TerminalNode <span class="cov8" title="11965">{
        return s.GetToken(bicepParserAS, 0)
}</span>

func (s *IdentifierContext) METADATA() antlr.TerminalNode <span class="cov8" title="11965">{
        return s.GetToken(bicepParserMETADATA, 0)
}</span>

func (s *IdentifierContext) PARAM() antlr.TerminalNode <span class="cov8" title="11965">{
        return s.GetToken(bicepParserPARAM, 0)
}</span>

func (s *IdentifierContext) RESOURCE() antlr.TerminalNode <span class="cov8" title="11965">{
        return s.GetToken(bicepParserRESOURCE, 0)
}</span>

func (s *IdentifierContext) MODULE() antlr.TerminalNode <span class="cov8" title="11965">{
        return s.GetToken(bicepParserMODULE, 0)
}</span>

func (s *IdentifierContext) OUTPUT() antlr.TerminalNode <span class="cov8" title="11965">{
        return s.GetToken(bicepParserOUTPUT, 0)
}</span>

func (s *IdentifierContext) EXISTING() antlr.TerminalNode <span class="cov8" title="11965">{
        return s.GetToken(bicepParserEXISTING, 0)
}</span>

func (s *IdentifierContext) TYPE() antlr.TerminalNode <span class="cov8" title="11965">{
        return s.GetToken(bicepParserTYPE, 0)
}</span>

func (s *IdentifierContext) VAR() antlr.TerminalNode <span class="cov8" title="11965">{
        return s.GetToken(bicepParserVAR, 0)
}</span>

func (s *IdentifierContext) IF() antlr.TerminalNode <span class="cov8" title="11965">{
        return s.GetToken(bicepParserIF, 0)
}</span>

func (s *IdentifierContext) FOR() antlr.TerminalNode <span class="cov8" title="11965">{
        return s.GetToken(bicepParserFOR, 0)
}</span>

func (s *IdentifierContext) IN() antlr.TerminalNode <span class="cov8" title="11965">{
        return s.GetToken(bicepParserIN, 0)
}</span>

func (s *IdentifierContext) TRUE() antlr.TerminalNode <span class="cov8" title="11965">{
        return s.GetToken(bicepParserTRUE, 0)
}</span>

func (s *IdentifierContext) FALSE() antlr.TerminalNode <span class="cov8" title="11965">{
        return s.GetToken(bicepParserFALSE, 0)
}</span>

func (s *IdentifierContext) NULL() antlr.TerminalNode <span class="cov8" title="11965">{
        return s.GetToken(bicepParserNULL, 0)
}</span>

func (s *IdentifierContext) TARGET_SCOPE() antlr.TerminalNode <span class="cov8" title="11965">{
        return s.GetToken(bicepParserTARGET_SCOPE, 0)
}</span>

func (s *IdentifierContext) STRING() antlr.TerminalNode <span class="cov8" title="11965">{
        return s.GetToken(bicepParserSTRING, 0)
}</span>

func (s *IdentifierContext) INT() antlr.TerminalNode <span class="cov8" title="11965">{
        return s.GetToken(bicepParserINT, 0)
}</span>

func (s *IdentifierContext) BOOL() antlr.TerminalNode <span class="cov8" title="11965">{
        return s.GetToken(bicepParserBOOL, 0)
}</span>

func (s *IdentifierContext) ARRAY() antlr.TerminalNode <span class="cov8" title="11965">{
        return s.GetToken(bicepParserARRAY, 0)
}</span>

func (s *IdentifierContext) OBJECT() antlr.TerminalNode <span class="cov8" title="11965">{
        return s.GetToken(bicepParserOBJECT, 0)
}</span>

func (s *IdentifierContext) GetRuleContext() antlr.RuleContext <span class="cov0" title="0">{
        return s
}</span>

func (s *IdentifierContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string <span class="cov0" title="0">{
        return antlr.TreesStringTree(s, ruleNames, recog)
}</span>

func (s *IdentifierContext) Accept(visitor antlr.ParseTreeVisitor) interface{} <span class="cov8" title="11965">{
        switch t := visitor.(type) </span>{
        case bicepVisitor:<span class="cov8" title="11965">
                return t.VisitIdentifier(s)</span>

        default:<span class="cov0" title="0">
                return t.VisitChildren(s)</span>
        }
}

func (p *bicepParser) Identifier() (localctx IIdentifierContext) <span class="cov8" title="12154">{
        localctx = NewIdentifierContext(p, p.GetParserRuleContext(), p.GetState())
        p.EnterRule(localctx, 64, bicepParserRULE_identifier)
        var _la int

        p.EnterOuterAlt(localctx, 1)
        </span><span class="cov8" title="12154">{
                p.SetState(433)
                _la = p.GetTokenStream().LA(1)

                if !((int64(_la) &amp; ^0x3f) == 0 &amp;&amp; ((int64(1)&lt;&lt;_la)&amp;565116764405760) != 0) </span><span class="cov1" title="3">{
                        p.GetErrorHandler().RecoverInline(p)
                }</span> else<span class="cov8" title="12151"> {
                        p.GetErrorHandler().ReportMatch(p)
                        p.Consume()
                }</span>
        }

errorExit:
        <span class="cov8" title="12154">if p.HasError() </span><span class="cov1" title="2">{
                v := p.GetError()
                localctx.SetException(v)
                p.GetErrorHandler().ReportError(p, v)
                p.GetErrorHandler().Recover(p, v)
                p.SetError(nil)
        }</span>
        <span class="cov8" title="12154">p.ExitRule()
        return localctx
        goto errorExit</span> // Trick to prevent compiler error if the label is not used
}

func (p *bicepParser) Sempred(localctx antlr.RuleContext, ruleIndex, predIndex int) bool <span class="cov0" title="0">{
        switch ruleIndex </span>{
        case 17:<span class="cov0" title="0">
                var t *ExpressionContext = nil
                if localctx != nil </span><span class="cov0" title="0">{
                        t = localctx.(*ExpressionContext)
                }</span>
                <span class="cov0" title="0">return p.Expression_Sempred(t, predIndex)</span>

        default:<span class="cov0" title="0">
                panic("No predicate with index: " + fmt.Sprint(ruleIndex))</span>
        }
}

func (p *bicepParser) Expression_Sempred(localctx antlr.RuleContext, predIndex int) bool <span class="cov0" title="0">{
        switch predIndex </span>{
        case 0:<span class="cov0" title="0">
                return p.Precpred(p.GetParserRuleContext(), 6)</span>

        case 1:<span class="cov0" title="0">
                return p.Precpred(p.GetParserRuleContext(), 2)</span>

        case 2:<span class="cov0" title="0">
                return p.Precpred(p.GetParserRuleContext(), 7)</span>

        case 3:<span class="cov0" title="0">
                return p.Precpred(p.GetParserRuleContext(), 5)</span>

        case 4:<span class="cov0" title="0">
                return p.Precpred(p.GetParserRuleContext(), 4)</span>

        case 5:<span class="cov0" title="0">
                return p.Precpred(p.GetParserRuleContext(), 3)</span>

        default:<span class="cov0" title="0">
                panic("No predicate with index: " + fmt.Sprint(predIndex))</span>
        }
}
</pre>
		
		<pre class="file" id="file70" style="display: none">package bicep

import (
        "encoding/json"
        "strconv"
        "strings"

        "github.com/Checkmarx/kics/v2/pkg/model"
        "github.com/Checkmarx/kics/v2/pkg/parser/bicep/antlr/parser"
        "github.com/antlr4-go/antlr/v4"
)

type Parser struct {
}

const kicsPrefix = "_kics_"
const kicsLine = kicsPrefix + "line"
const kicsLines = kicsPrefix + "lines"
const kicsArray = kicsPrefix + "arr"

const CloseParenthesis = "')"

type BicepVisitor struct {
        parser.BasebicepVisitor
        paramList    map[string]interface{}
        varList      map[string]interface{}
        resourceList []interface{}
}

type JSONBicep struct {
        Parameters map[string]interface{} `json:"parameters"`
        Variables  map[string]interface{} `json:"variables"`
        Resources  []interface{}          `json:"resources"`
}

type KicsObjectProperty struct {
        objectProperty map[string]interface{}
        line           int
}

func NewBicepVisitor() *BicepVisitor <span class="cov2" title="4">{
        paramList := map[string]interface{}{}
        varList := map[string]interface{}{}
        resourceList := []interface{}{}
        return &amp;BicepVisitor{paramList: paramList, varList: varList, resourceList: resourceList}
}</span>

func convertVisitorToJSONBicep(visitor *BicepVisitor) *JSONBicep <span class="cov2" title="4">{
        return &amp;JSONBicep{
                Parameters: visitor.paramList,
                Variables:  visitor.varList,
                Resources:  visitor.resourceList,
        }
}</span>

type Resource struct {
        Name         string
        FullType     string
        Parent       string
        Children     []*Resource
        ResourceData interface{}
}

// Filters the Resource array in order to keep only the top-level resources while reformatting them
func filterParentStructs(resources []*Resource) []interface{} <span class="cov2" title="4">{
        filteredResources := []interface{}{}

        for _, resource := range resources </span><span class="cov4" title="11">{
                if resource.Parent == "" </span><span class="cov3" title="8">{
                        formattedNode := reformatTestTree(resource)
                        filteredResources = append(filteredResources, formattedNode)
                }</span>
        }

        <span class="cov2" title="4">return filteredResources</span>
}

func setChildType(child map[string]interface{}, parentType string) <span class="cov2" title="3">{
        childType, hasType := child["type"]
        if !hasType </span><span class="cov0" title="0">{
                return
        }</span>
        <span class="cov2" title="3">childTypeString, ok := childType.(string)
        if !ok </span><span class="cov0" title="0">{
                return
        }</span>
        <span class="cov2" title="3">if parentType != "" </span><span class="cov2" title="3">{
                childTypeString = strings.Replace(childTypeString, parentType+"/", "", 1)
                child["type"] = childTypeString
        }</span>
}

// Converts Resource struct array back to a JBicep structure
func reformatTestTree(resource *Resource) map[string]interface{} <span class="cov4" title="11">{
        reformattedResource := map[string]interface{}{}

        children := []interface{}{}
        for _, child := range resource.Children </span><span class="cov2" title="3">{
                formattedChild := reformatTestTree(child)
                setChildType(formattedChild, resource.FullType)
                children = append(children, formattedChild)
        }</span>
        <span class="cov4" title="11">if len(children) &gt; 0 </span><span class="cov2" title="3">{
                reformattedResource["resources"] = children
        }</span>

        <span class="cov4" title="11">resData, ok := resource.ResourceData.(map[string]interface{})
        if !ok </span><span class="cov0" title="0">{
                return reformattedResource
        }</span>
        <span class="cov4" title="11">for k, v := range resData </span><span class="cov6" title="73">{
                reformattedResource[k] = v
        }</span>

        <span class="cov4" title="11">return reformattedResource</span>
}

// Adds resource to its parent's children array
func addChildrenToParents(resources []*Resource) <span class="cov2" title="4">{
        resourceMap := map[string]*Resource{}

        // Loops twice through the resources array in order to first fill the resourceMap with the required data
        for _, resource := range resources </span><span class="cov4" title="11">{
                resourceMap[resource.Name] = resource
        }</span>

        <span class="cov2" title="4">for _, resource := range resources </span><span class="cov4" title="11">{
                if resource.Parent != "" </span><span class="cov2" title="3">{
                        parent, ok := resourceMap[resource.Parent]
                        if !ok </span><span class="cov0" title="0">{
                                continue</span>
                        }
                        <span class="cov2" title="3">parent.Children = append(parent.Children, resource)</span>
                }
        }
}

// Converts JBicep structure to a Resource struct array
func convertOriginalResourcesToStruct(resources []interface{}) []*Resource <span class="cov2" title="4">{
        newResources := []*Resource{}

        for _, res := range resources </span><span class="cov4" title="11">{
                actualRes, ok := res.(map[string]interface{})
                if !ok </span><span class="cov0" title="0">{
                        return newResources
                }</span>
                <span class="cov4" title="11">resName, hasName := actualRes["identifier"]
                resType, hasType := actualRes["type"]

                if !hasName || !hasType </span><span class="cov0" title="0">{
                        return newResources
                }</span>

                <span class="cov4" title="11">resNameString, ok := resName.(string)
                if !ok </span><span class="cov0" title="0">{
                        return newResources
                }</span>
                <span class="cov4" title="11">resTypeString, ok := resType.(string)
                if !ok </span><span class="cov0" title="0">{
                        return newResources
                }</span>

                <span class="cov4" title="11">newRes := Resource{
                        Name:         resNameString,
                        FullType:     resTypeString,
                        ResourceData: res,
                }

                if resParent, hasParent := actualRes["parent"]; hasParent </span><span class="cov2" title="3">{
                        var ok bool
                        newRes.Parent, ok = resParent.(string)
                        if !ok </span><span class="cov0" title="0">{
                                return newResources
                        }</span>
                }

                <span class="cov4" title="11">newResources = append(newResources, &amp;newRes)</span>
        }

        <span class="cov2" title="4">return newResources</span>
}

func makeResourcesNestedStructure(jBicep *JSONBicep) []interface{} <span class="cov2" title="4">{
        originalResources := jBicep.Resources

        resources := convertOriginalResourcesToStruct(originalResources)
        addChildrenToParents(resources)
        filteredResources := filterParentStructs(resources)

        return filteredResources
}</span>

// Parse - parses bicep to BicepVisitor template (json file)
func (p *Parser) Parse(file string, _ []byte) ([]model.Document, []int, error) <span class="cov2" title="4">{
        bicepVisitor := NewBicepVisitor()
        stream, err := antlr.NewFileStream(file)
        if err != nil </span><span class="cov0" title="0">{
                return nil, nil, err
        }</span>
        <span class="cov2" title="4">lexer := parser.NewbicepLexer(stream)

        tokenStream := antlr.NewCommonTokenStream(lexer, antlr.TokenDefaultChannel)
        bicepParser := parser.NewbicepParser(tokenStream)

        bicepParser.RemoveErrorListeners()
        bicepParser.AddErrorListener(antlr.NewDiagnosticErrorListener(true))

        program := bicepParser.Program()
        if program != nil </span><span class="cov2" title="4">{
                program.Accept(bicepVisitor)
        }</span>

        <span class="cov2" title="4">var doc model.Document

        jBicep := convertVisitorToJSONBicep(bicepVisitor)

        nestedResources := makeResourcesNestedStructure(jBicep)
        jBicep.Resources = nestedResources

        bicepBytes, err := json.Marshal(jBicep)
        if err != nil </span><span class="cov0" title="0">{
                return nil, nil, err
        }</span>

        <span class="cov2" title="4">err = json.Unmarshal(bicepBytes, &amp;doc)
        if err != nil </span><span class="cov0" title="0">{
                return nil, nil, err
        }</span>

        <span class="cov2" title="4">return []model.Document{doc}, nil, nil</span>
}

func (s *BicepVisitor) VisitProgram(ctx *parser.ProgramContext) interface{} <span class="cov2" title="4">{
        for _, val := range ctx.AllStatement() </span><span class="cov6" title="97">{
                val.Accept(s)
        }</span>

        <span class="cov2" title="4">return nil</span>
}

func (s *BicepVisitor) VisitStatement(ctx *parser.StatementContext) interface{} <span class="cov6" title="97">{
        if ctx.ParameterDecl() != nil </span><span class="cov5" title="40">{
                return ctx.ParameterDecl().Accept(s)
        }</span>
        <span class="cov6" title="57">if ctx.VariableDecl() != nil </span><span class="cov4" title="13">{
                return ctx.VariableDecl().Accept(s)
        }</span>
        <span class="cov5" title="44">if ctx.ResourceDecl() != nil </span><span class="cov4" title="11">{
                return ctx.ResourceDecl().Accept(s)
        }</span>

        <span class="cov5" title="33">return nil</span>
}

func parseDecorators(decorators []parser.IDecoratorContext, s *BicepVisitor) map[string]interface{} <span class="cov6" title="64">{
        decoratorsMap := map[string]interface{}{}

        for _, val := range decorators </span><span class="cov6" title="56">{
                if val == nil </span><span class="cov0" title="0">{
                        continue</span>
                }

                <span class="cov6" title="56">decorator, ok := val.Accept(s).(map[string][]interface{})
                if !ok </span><span class="cov0" title="0">{
                        return map[string]interface{}{}
                }</span>
                <span class="cov6" title="56">for name, values := range decorator </span><span class="cov6" title="56">{
                        if name == "description" </span><span class="cov5" title="38">{
                                if len(values) &gt; 0 </span><span class="cov5" title="38">{
                                        metadata := map[string]interface{}{}
                                        metadata["description"] = values[0]
                                        decoratorsMap["metadata"] = metadata
                                }</span>
                        } else<span class="cov4" title="18"> if name == "maxLength" || name == "minLength" || name == "minValue" || name == "maxValue" </span><span class="cov3" title="8">{
                                if len(values) &gt; 0 </span><span class="cov3" title="8">{
                                        decoratorsMap[name] = values[0]
                                }</span>
                        } else<span class="cov3" title="10"> {
                                decoratorsMap[name] = values
                        }</span>
                }
        }

        <span class="cov6" title="64">return decoratorsMap</span>
}

func (s *BicepVisitor) VisitParameterDecl(ctx *parser.ParameterDeclContext) interface{} <span class="cov5" title="40">{
        param := map[string]interface{}{}

        identifier := checkAcceptAntlrString(ctx.Identifier(), s)

        if ctx.ParameterDefaultValue() != nil </span><span class="cov5" title="31">{
                paramVal := ctx.ParameterDefaultValue().Accept(s)
                switch paramVal := paramVal.(type) </span>{
                case map[string][]interface{}:<span class="cov1" title="1">
                        stringifiedFunction := parseFunctionCall(paramVal)
                        param["defaultValue"] = "[" + stringifiedFunction + "]"</span>
                case interface{}:<span class="cov5" title="29">
                        if isDotFunction(paramVal) </span><span class="cov1" title="1">{
                                paramVal = "[" + paramVal.(string) + "]"
                        }</span>
                        <span class="cov5" title="29">param["defaultValue"] = paramVal</span>
                default:<span class="cov1" title="1">
                        param["defaultValue"] = nil</span>
                }
        }

        <span class="cov5" title="40">if ctx.TypeExpression() != nil </span><span class="cov5" title="40">{
                typeExpression := ctx.TypeExpression().Accept(s)
                param["type"] = typeExpression
        }</span>

        <span class="cov5" title="40">decoratorsMap := parseDecorators(ctx.AllDecorator(), s)
        for name, values := range decoratorsMap </span><span class="cov6" title="53">{
                if name == "secure" </span><span class="cov2" title="3">{
                        if param["type"] == "string" </span><span class="cov1" title="2">{
                                param["type"] = "secureString"
                        }</span> else<span class="cov1" title="1"> if param["type"] == "object" </span><span class="cov1" title="1">{
                                param["type"] = "secureObject"
                        }</span>
                } else<span class="cov6" title="50"> {
                        if name == "allowed" </span><span class="cov3" title="7">{
                                param["allowedValues"] = values
                        }</span> else<span class="cov5" title="43"> {
                                param[name] = values
                        }</span>
                }
        }

        <span class="cov5" title="40">line := map[string]int{kicsLine: ctx.GetStop().GetLine()}
        lines := map[string]map[string]int{
                kicsPrefix + "defaultValue": line,
                kicsPrefix + "type":         line,
        }

        param[kicsLines] = lines

        s.paramList[identifier] = param

        return nil</span>
}

func (s *BicepVisitor) VisitVariableDecl(ctx *parser.VariableDeclContext) interface{} <span class="cov4" title="13">{
        var variable = map[string]interface{}{}

        identifier := checkAcceptAntlrString(ctx.Identifier(), s)

        decoratorsMap := parseDecorators(ctx.AllDecorator(), s)
        for name, values := range decoratorsMap </span><span class="cov1" title="2">{
                variable[name] = values
        }</span>

        <span class="cov4" title="13">expression := checkAcceptExpression(ctx.Expression(), s)
        variable["value"] = expression
        s.varList[identifier] = variable

        return nil</span>
}

func (s *BicepVisitor) VisitResourceDecl(ctx *parser.ResourceDeclContext) interface{} <span class="cov4" title="11">{
        resource := map[string]interface{}{}
        resourceType := ""
        apiVersion := ""

        interpString := checkAcceptAntlrString(ctx.InterpString(), s)
        identifier := checkAcceptAntlrString(ctx.Identifier(), s)

        fullType := strings.Split(interpString, "@")
        if len(fullType) &gt; 0 </span><span class="cov4" title="11">{
                resourceType = fullType[0]
        }</span>
        <span class="cov4" title="11">if len(fullType) &gt; 1 </span><span class="cov4" title="11">{
                apiVersion = fullType[1]
        }</span>

        <span class="cov4" title="11">resource["identifier"] = identifier
        resource["type"] = resourceType
        resource["apiVersion"] = apiVersion

        decoratorsMap := parseDecorators(ctx.AllDecorator(), s)
        for name, values := range decoratorsMap </span><span class="cov1" title="1">{
                resource[name] = values
        }</span>

        <span class="cov4" title="11">if ctx.Object() != nil </span><span class="cov3" title="9">{
                object, ok := ctx.Object().Accept(s).(map[string]interface{})
                if ok </span><span class="cov3" title="9">{
                        for key, val := range object </span><span class="cov5" title="39">{
                                resource[key] = val
                        }</span>
                }
        }

        <span class="cov4" title="11">lines := map[string]interface{}{}
        if resKicsLines, hasLines := resource[kicsLines]; hasLines </span><span class="cov3" title="9">{
                var ok bool
                lines, ok = resKicsLines.(map[string]interface{})
                if !ok </span><span class="cov0" title="0">{
                        lines = map[string]interface{}{}
                }</span>
        }

        <span class="cov4" title="11">line := map[string]int{kicsLine: ctx.GetStart().GetLine()}
        lines[kicsPrefix+"apiVersion"] = line
        lines[kicsPrefix+"type"] = line

        s.resourceList = append(s.resourceList, resource)

        return nil</span>
}

func checkAcceptAntlrString(ctx antlr.ParserRuleContext, s *BicepVisitor) string <span class="cov7" title="196">{
        if ctx != nil </span><span class="cov7" title="196">{
                if result, ok := ctx.Accept(s).(string); ok </span><span class="cov7" title="196">{
                        return result
                }</span>
        }

        <span class="cov0" title="0">return ""</span>
}

func checkAcceptExpression(ctx antlr.ParserRuleContext, s *BicepVisitor) interface{} <span class="cov6" title="91">{
        if ctx != nil </span><span class="cov6" title="91">{
                return ctx.Accept(s)
        }</span>

        <span class="cov0" title="0">return ""</span>
}

func (s *BicepVisitor) VisitParameterDefaultValue(ctx *parser.ParameterDefaultValueContext) interface{} <span class="cov5" title="31">{
        param := checkAcceptExpression(ctx.Expression(), s)
        return param
}</span>

/*
Converts functioncall data (map of identifying string to slice of arguments) into a string

        Example: "FunctionName": ["arg1", 2, "arg3", map[Function2: [arg4, arg5]]] becomes
        "FunctionName(arg1, 2, arg3, Function2(arg4, arg5))"
*/
func parseFunctionCall(functionData map[string][]interface{}) string <span class="cov3" title="8">{
        stringifiedFunctionCall := ""

        for functionName, argumentList := range functionData </span><span class="cov3" title="8">{
                stringifiedFunctionCall += functionName + "("
                for index, argument := range argumentList </span><span class="cov2" title="3">{
                        switch argument := argument.(type) </span>{
                        case string:<span class="cov1" title="2">
                                stringifiedFunctionCall += argument</span>
                        case int:<span class="cov0" title="0">
                                convertedArgument := strconv.Itoa(argument)
                                stringifiedFunctionCall += convertedArgument</span>
                        case map[string][]interface{}:<span class="cov1" title="1">
                                stringifiedFunctionCall += parseFunctionCall(argument)</span>
                        }

                        <span class="cov2" title="3">if index &lt; len(argumentList)-1 </span><span class="cov1" title="1">{
                                stringifiedFunctionCall += ", "
                        }</span>
                }
                <span class="cov3" title="8">stringifiedFunctionCall += ")"</span>
        }

        <span class="cov3" title="8">return stringifiedFunctionCall</span>
}

// function to check if an identifier is a parameter/variable and add the required keyword if so
func convertToParamVar(str string, s *BicepVisitor) string <span class="cov5" title="44">{
        for variable := range s.varList </span><span class="cov7" title="210">{
                if variable == str </span><span class="cov3" title="7">{
                        return "variables('" + str + CloseParenthesis
                }</span>
        }
        <span class="cov5" title="37">for parameter := range s.paramList </span><span class="cov9" title="583">{
                if parameter == str </span><span class="cov4" title="22">{
                        return "parameters('" + str + CloseParenthesis
                }</span>
        }

        <span class="cov4" title="15">return str</span>
}

func (s *BicepVisitor) VisitExpression(ctx *parser.ExpressionContext) interface{} <span class="cov8" title="286">{
        if ctx.GetChildCount() &gt; 1 </span><span class="cov4" title="21">{
                if ctx.DOT() != nil </span><span class="cov3" title="10">{
                        var expressionString string

                        var exp interface{} = ""
                        if ctx.Expression(0) != nil </span><span class="cov3" title="10">{
                                exp = ctx.Expression(0).Accept(s)
                        }</span>

                        <span class="cov3" title="10">switch exp := exp.(type) </span>{
                        case map[string][]interface{}:<span class="cov3" title="5">
                                expressionString = parseFunctionCall(exp)</span>
                        case string:<span class="cov3" title="5">
                                expressionString = exp</span>
                        default:<span class="cov0" title="0">
                                expressionString = ""</span>
                        }

                        <span class="cov3" title="10">if ctx.Identifier() != nil </span><span class="cov3" title="9">{
                                identifier := checkAcceptAntlrString(ctx.Identifier(), s)
                                identifier = convertToParamVar(identifier, s)

                                return expressionString + "." + identifier
                        }</span>

                        <span class="cov1" title="1">if ctx.FunctionCall() != nil </span><span class="cov1" title="1">{
                                fc := ctx.FunctionCall().Accept(s)
                                fcData, ok := fc.(map[string][]interface{})
                                if !ok </span><span class="cov0" title="0">{
                                        return ""
                                }</span>
                                <span class="cov1" title="1">functionCallString := parseFunctionCall(fcData)
                                return expressionString + "." + functionCallString</span>
                        }
                }
        }

        <span class="cov8" title="276">if ctx.PrimaryExpression() != nil </span><span class="cov8" title="265">{
                return ctx.PrimaryExpression().Accept(s)
        }</span>

        <span class="cov4" title="11">return nil</span>
}

func (s *BicepVisitor) VisitPrimaryExpression(ctx *parser.PrimaryExpressionContext) interface{} <span class="cov8" title="265">{
        if ctx.LiteralValue() != nil </span><span class="cov6" title="70">{
                return ctx.LiteralValue().Accept(s)
        }</span>
        <span class="cov7" title="195">if ctx.FunctionCall() != nil </span><span class="cov4" title="15">{
                return ctx.FunctionCall().Accept(s)
        }</span>
        <span class="cov7" title="180">if ctx.InterpString() != nil </span><span class="cov7" title="119">{
                return ctx.InterpString().Accept(s)
        }</span>
        <span class="cov6" title="61">if ctx.MULTILINE_STRING() != nil </span><span class="cov1" title="1">{
                finalString := strings.ReplaceAll(ctx.MULTILINE_STRING().GetText(), "'''", "")
                finalString = strings.ReplaceAll(finalString, "\r", "")
                finalString = strings.ReplaceAll(finalString, "\n", "")
                return finalString
        }</span>
        <span class="cov6" title="60">if ctx.Array() != nil </span><span class="cov4" title="19">{
                return ctx.Array().Accept(s)
        }</span>
        <span class="cov5" title="41">if ctx.Object() != nil </span><span class="cov5" title="35">{
                return ctx.Object().Accept(s)
        }</span>
        <span class="cov3" title="6">if ctx.ParenthesizedExpression() != nil </span><span class="cov1" title="1">{
                return ctx.ParenthesizedExpression().Accept(s)
        }</span>

        <span class="cov3" title="5">return nil</span>
}

func (s *BicepVisitor) VisitLiteralValue(ctx *parser.LiteralValueContext) interface{} <span class="cov6" title="70">{
        if ctx.NUMBER() != nil </span><span class="cov5" title="24">{
                number, _ := strconv.ParseFloat(ctx.NUMBER().GetText(), 32)
                return number
        }</span>
        <span class="cov5" title="46">if ctx.TRUE() != nil </span><span class="cov3" title="6">{
                return true
        }</span>
        <span class="cov5" title="40">if ctx.FALSE() != nil </span><span class="cov2" title="4">{
                return false
        }</span>
        <span class="cov5" title="36">if ctx.Identifier() != nil </span><span class="cov5" title="35">{
                identifier, ok := ctx.Identifier().Accept(s).(string)
                if ok </span><span class="cov5" title="35">{
                        identifier = convertToParamVar(identifier, s)
                        return identifier
                }</span>
        }

        <span class="cov1" title="1">return nil</span>
}

func acceptExpressionAtIndex(idx int, ctx *parser.InterpStringContext, s *BicepVisitor) interface{} <span class="cov3" title="9">{
        if ctx.Expression(idx) != nil </span><span class="cov3" title="9">{
                return ctx.Expression(idx).Accept(s)
        }</span>

        <span class="cov0" title="0">return ""</span>
}

func buildComplexInterp(interpStringValues []interface{}) string <span class="cov3" title="7">{
        str := ""
        for _, v := range interpStringValues </span><span class="cov5" title="25">{
                switch v := v.(type) </span>{
                case string:<span class="cov4" title="22">
                        str += v</span>
                case map[string][]interface{}:<span class="cov2" title="3">
                        for identifier, argumentList := range v </span><span class="cov2" title="3">{
                                resStr := "[" + identifier + "("
                                for idx, arg := range argumentList </span><span class="cov2" title="4">{
                                        stringArg, ok := arg.(string)
                                        if !ok </span><span class="cov0" title="0">{
                                                return ""
                                        }</span>
                                        <span class="cov2" title="4">resStr += stringArg
                                        if idx &lt; len(argumentList)-1 </span><span class="cov1" title="1">{
                                                resStr += ", "
                                        }</span>
                                }

                                <span class="cov2" title="3">resStr += ")]"
                                str += resStr</span>
                        }
                }
        }

        <span class="cov3" title="7">return str</span>
}

func parseComplexInterp(ctx *parser.InterpStringContext, s *BicepVisitor) string <span class="cov3" title="7">{
        interpString := []interface{}{}

        if ctx.STRING_LEFT_PIECE() == nil || ctx.STRING_RIGHT_PIECE() == nil </span><span class="cov0" title="0">{
                return ""
        }</span>

        <span class="cov3" title="7">leftPiece := ctx.STRING_LEFT_PIECE().GetText()
        rightPiece := ctx.STRING_RIGHT_PIECE().GetText()
        middlePieces := ctx.AllSTRING_MIDDLE_PIECE()

        interpString = append(interpString, leftPiece)

        if middlePieces != nil &amp;&amp; (len(middlePieces) &gt; 0) </span><span class="cov1" title="2">{
                for idx, val := range middlePieces </span><span class="cov1" title="2">{
                        expression := acceptExpressionAtIndex(idx, ctx, s)
                        interpString = append(interpString, expression, val.GetText())
                }</span>
        }

        <span class="cov3" title="7">lastExpression := acceptExpressionAtIndex(len(middlePieces), ctx, s)
        interpString = append(interpString,
                lastExpression,
                rightPiece)

        resultString := buildComplexInterp(interpString)

        return resultString</span>
}

func (s *BicepVisitor) VisitInterpString(ctx *parser.InterpStringContext) interface{} <span class="cov7" title="131">{
        if ctx.GetChildCount() &gt; 1 </span><span class="cov3" title="7">{
                complexInterpString := parseComplexInterp(ctx, s)
                return complexInterpString
        }</span>

        <span class="cov7" title="124">if ctx.STRING_COMPLETE() != nil </span><span class="cov7" title="124">{
                unformattedString := ctx.STRING_COMPLETE().GetText()
                finalString := strings.ReplaceAll(unformattedString, "'", "")
                return finalString
        }</span>

        <span class="cov0" title="0">return ""</span>
}

func (s *BicepVisitor) VisitArray(ctx *parser.ArrayContext) interface{} <span class="cov4" title="19">{
        array := []interface{}{}
        for _, val := range ctx.AllArrayItem() </span><span class="cov5" title="46">{
                expression := val.Accept(s)
                if isParameter(expression) || isDotFunction(expression) </span><span class="cov1" title="1">{
                        expression = "[" + expression.(string) + "]"
                }</span>
                <span class="cov5" title="46">array = append(array, expression)</span>
        }
        <span class="cov4" title="19">return array</span>
}

func (s *BicepVisitor) VisitArrayItem(ctx *parser.ArrayItemContext) interface{} <span class="cov5" title="46">{
        return checkAcceptExpression(ctx.Expression(), s)
}</span>

func isParameter(expression interface{}) bool <span class="cov7" title="150">{
        exp, ok := expression.(string)
        if !ok </span><span class="cov6" title="68">{
                return false
        }</span>

        <span class="cov6" title="82">return strings.Contains(exp, "parameters(") || strings.Contains(exp, "variables(")</span>
}

func isDotFunction(expression interface{}) bool <span class="cov7" title="160">{
        exp, ok := expression.(string)
        if !ok </span><span class="cov6" title="85">{
                return false
        }</span>

        <span class="cov6" title="75">return strings.Contains(exp, ").")</span>
}

func (s *BicepVisitor) VisitObject(ctx *parser.ObjectContext) interface{} <span class="cov5" title="44">{
        object := map[string]interface{}{}
        propertiesLines := map[string]interface{}{}

        for _, val := range ctx.AllObjectProperty() </span><span class="cov6" title="104">{
                objectProperty, ok := val.Accept(s).(KicsObjectProperty)
                if !ok </span><span class="cov0" title="0">{
                        return object
                }</span>
                <span class="cov6" title="104">for key, val := range objectProperty.objectProperty </span><span class="cov6" title="104">{
                        object[key] = val
                        line := map[string]interface{}{kicsLine: objectProperty.line}

                        arr, isArray := val.([]interface{})
                        if isArray </span><span class="cov3" title="5">{
                                for range arr </span><span class="cov3" title="7">{
                                        arrLine := map[string]int{kicsLine: objectProperty.line}
                                        kicsDefault := map[string]interface{}{kicsPrefix + "_default": arrLine}
                                        kicsArr := []interface{}{kicsDefault}
                                        line[kicsArray] = kicsArr
                                }</span>
                        }
                        <span class="cov6" title="104">propertiesLines[kicsPrefix+key] = line</span>
                }
        }

        <span class="cov5" title="44">defaultLine := map[string]int{kicsLine: ctx.GetStart().GetLine()}
        propertiesLines[kicsPrefix+"_default"] = defaultLine

        object[kicsLines] = propertiesLines

        return object</span>
}

func (s *BicepVisitor) VisitObjectProperty(ctx *parser.ObjectPropertyContext) interface{} <span class="cov6" title="104">{
        objectProperty := map[string]interface{}{}

        if ctx.Expression() != nil </span><span class="cov6" title="104">{
                objectValue := ctx.Expression().Accept(s)
                if isParameter(objectValue) || isDotFunction(objectValue) </span><span class="cov4" title="20">{
                        objectValue = "[" + objectValue.(string) + "]"
                }</span>

                <span class="cov6" title="104">if ctx.Identifier() != nil </span><span class="cov6" title="103">{
                        identifier, ok := ctx.Identifier().Accept(s).(string)
                        if ok </span><span class="cov6" title="103">{
                                objectProperty[identifier] = objectValue
                        }</span>
                }
                <span class="cov6" title="104">if ctx.InterpString() != nil </span><span class="cov1" title="1">{
                        interpString, ok := ctx.InterpString().Accept(s).(string)
                        if ok </span><span class="cov1" title="1">{
                                objectProperty[interpString] = objectValue
                        }</span>
                }
        }

        <span class="cov6" title="104">return KicsObjectProperty{objectProperty: objectProperty, line: ctx.GetStart().GetLine()}</span>
}

func (s *BicepVisitor) VisitIdentifier(ctx *parser.IdentifierContext) interface{} <span class="cov8" title="323">{
        contexts := []antlr.TerminalNode{
                ctx.IDENTIFIER(),
                ctx.IMPORT(),
                ctx.WITH(),
                ctx.AS(),
                ctx.METADATA(),
                ctx.PARAM(),
                ctx.RESOURCE(),
                ctx.OUTPUT(),
                ctx.EXISTING(),
                ctx.VAR(),
                ctx.IF(),
                ctx.FOR(),
                ctx.IN(),
                ctx.TRUE(),
                ctx.FALSE(),
                ctx.NULL(),
                ctx.TARGET_SCOPE(),
                ctx.STRING(),
                ctx.INT(),
                ctx.BOOL(),
                ctx.ARRAY(),
                ctx.OBJECT(),
                ctx.TYPE(),
                ctx.MODULE(),
        }

        for _, context := range contexts </span><span class="cov10" title="1080">{
                if context != nil </span><span class="cov8" title="323">{
                        return context.GetText()
                }</span>
        }

        <span class="cov0" title="0">return ""</span>
}

func (s *BicepVisitor) VisitParenthesizedExpression(ctx *parser.ParenthesizedExpressionContext) interface{} <span class="cov1" title="1">{
        return checkAcceptExpression(ctx.Expression(), s)
}</span>

func (s *BicepVisitor) VisitDecorator(ctx *parser.DecoratorContext) interface{} <span class="cov6" title="56">{
        if ctx.DecoratorExpression() == nil </span><span class="cov0" title="0">{
                return map[string][]interface{}{}
        }</span>
        <span class="cov6" title="56">decorator := ctx.DecoratorExpression().Accept(s)
        return decorator</span>
}

func (s *BicepVisitor) VisitDecoratorExpression(ctx *parser.DecoratorExpressionContext) interface{} <span class="cov6" title="56">{
        if ctx.FunctionCall() == nil </span><span class="cov0" title="0">{
                return map[string][]interface{}{}
        }</span>
        <span class="cov6" title="56">return ctx.FunctionCall().Accept(s)</span>
}

func (s *BicepVisitor) VisitFunctionCall(ctx *parser.FunctionCallContext) interface{} <span class="cov6" title="72">{
        var argumentList []interface{}
        identifier := checkAcceptAntlrString(ctx.Identifier(), s)

        if ctx.ArgumentList() != nil </span><span class="cov6" title="63">{
                var ok bool
                argumentList, ok = ctx.ArgumentList().Accept(s).([]interface{})
                if !ok </span><span class="cov0" title="0">{
                        return map[string]interface{}{}
                }</span>
        }
        <span class="cov6" title="72">functionCall := map[string][]interface{}{
                identifier: argumentList,
        }

        return functionCall</span>
}

func (s *BicepVisitor) VisitArgumentList(ctx *parser.ArgumentListContext) interface{} <span class="cov6" title="63">{
        var argumentList []interface{}

        for _, val := range ctx.AllExpression() </span><span class="cov6" title="72">{
                argument := val.Accept(s)
                argumentList = append(argumentList, argument)
        }</span>
        <span class="cov6" title="63">return argumentList</span>
}

func (s *BicepVisitor) VisitTypeExpression(ctx *parser.TypeExpressionContext) interface{} <span class="cov5" title="40">{
        return checkAcceptAntlrString(ctx.Identifier(), s)
}</span>

// GetKind returns the kind of the parser
func (p *Parser) GetKind() model.FileKind <span class="cov1" title="1">{
        return model.KindBICEP
}</span>

// SupportedExtensions returns Bicep extensions
func (p *Parser) SupportedExtensions() []string <span class="cov1" title="1">{
        return []string{".bicep"}
}</span>

// SupportedTypes returns types supported by this parser, which are bicep files
func (p *Parser) SupportedTypes() map[string]bool <span class="cov1" title="1">{
        return map[string]bool{"bicep": true, "azureresourcemanager": true}
}</span>

// GetCommentToken return the comment token of Bicep files - #
func (p *Parser) GetCommentToken() string <span class="cov1" title="1">{
        return "//"
}</span>

// StringifyContent converts original content into string formatted version
func (p *Parser) StringifyContent(content []byte) (string, error) <span class="cov1" title="1">{
        return string(content), nil
}</span>

// Resolve resolves bicep files variables
func (p *Parser) Resolve(fileContent []byte, _ string, _ bool, _ int) ([]byte, error) <span class="cov1" title="1">{
        return fileContent, nil
}</span>

// GetResolvedFiles returns the list of files that are resolved
func (p *Parser) GetResolvedFiles() map[string]model.ResolvedFile <span class="cov1" title="1">{
        return make(map[string]model.ResolvedFile)
}</span>
</pre>
		
		<pre class="file" id="file71" style="display: none">package buildah

import (
        "strings"

        "github.com/Checkmarx/kics/v2/pkg/model"
        "mvdan.cc/sh/v3/syntax"
)

func getKicsIgnore(comment string) string <span class="cov6" title="5">{
        commentLower := model.KICSCommentRgxp.ReplaceAllString(strings.ToLower(comment), "")
        commentLower = strings.Trim(commentLower, "\r")
        commentLower = strings.Trim(commentLower, "\n")

        return commentLower
}</span>

func (i *Info) getIgnoreLines(comment *syntax.Comment) <span class="cov9" title="10">{
        // get normal comments
        i.IgnoreLines = append(i.IgnoreLines, int(comment.Hash.Line()))

        if model.KICSCommentRgxp.MatchString(comment.Text) </span><span class="cov4" title="3">{
                kicsIgnore := getKicsIgnore(comment.Text)

                switch model.CommentCommand(kicsIgnore) </span>{
                case model.IgnoreLine:<span class="cov1" title="1">
                        // get kics-scan ignore-line
                        i.IgnoreLines = append(i.IgnoreLines, int(comment.Hash.Line())+1)</span>
                case model.IgnoreBlock:<span class="cov3" title="2">
                        // get kics-scan ignore-block for ignoreFromBlock
                        i.IgnoreBlockLines = append(i.IgnoreBlockLines, int(comment.Pos().Line()))</span>
                }
        }
}

func (i *Info) getIgnoreBlockLines(comments []syntax.Comment, start, end int) <span class="cov10" title="13">{
        for c := range comments </span><span class="cov4" title="3">{
                comment := comments[c]

                // get kics-scan ignore-block related to command
                if model.KICSCommentRgxp.MatchString(comment.Text) </span><span class="cov3" title="2">{
                        kicsIgnore := getKicsIgnore(comment.Text)

                        if model.CommentCommand(kicsIgnore) == model.IgnoreBlock </span><span class="cov1" title="1">{
                                if int(comment.Hash.Line()) == start-1 </span><span class="cov1" title="1">{
                                        i.IgnoreLines = append(i.IgnoreLines, model.Range(start, end)...)
                                        i.IgnoreBlockLines = append(i.IgnoreBlockLines, model.Range(start, end)...)
                                }</span>
                        }
                }
        }
}

func (i *Info) ignoreFromBlock() <span class="cov6" title="5">{
        for j := range i.IgnoreBlockLines </span><span class="cov5" title="4">{
                for z := range i.FromValues </span><span class="cov6" title="5">{
                        i.getIgnoreLinesFromBlock(i.IgnoreBlockLines[j], i.FromValues[z])
                }</span>
        }
}

func (i *Info) getIgnoreLinesFromBlock(ignoreBlockLine int, fromValue FromValue) <span class="cov6" title="5">{
        start := fromValue.Line
        value := fromValue.Value
        if start == ignoreBlockLine+1 </span><span class="cov1" title="1">{
                targetFrom := i.From[value]
                end := targetFrom[len(targetFrom)-1].EndLine
                i.IgnoreLines = append(i.IgnoreLines, model.Range(start, end)...)
        }</span>
}
</pre>
		
		<pre class="file" id="file72" style="display: none">package buildah

import (
        "bytes"
        "sort"
        "strings"

        "github.com/rs/zerolog/log"

        "encoding/json"

        "github.com/Checkmarx/kics/v2/pkg/model"
        "github.com/pkg/errors"
        "mvdan.cc/sh/v3/syntax"
)

// Parser is a Buildah parser
type Parser struct {
}

// Resource separates the list of commands by file
type Resource struct {
        CommandList map[string][]Command `json:"command"`
}

// Command is the struct for each Buildah command
type Command struct {
        Cmd       string
        Original  string
        Value     string
        StartLine int `json:"_kics_line"`
        EndLine   int
}

// FromValue is the struct for each from
type FromValue struct {
        Value string
        Line  int
}

// Info has the relevant information to Buildah parser
type Info struct {
        IgnoreLines      []int
        From             map[string][]Command
        FromValues       []FromValue
        IgnoreBlockLines []int
}

const (
        buildah = "buildah"
)

// Resolve - replace or modifies in-memory content before parsing
func (p *Parser) Resolve(fileContent []byte, _ string, _ bool, _ int) ([]byte, error) <span class="cov1" title="1">{
        return fileContent, nil
}</span>

// Parse - parses Buildah file to Json
func (p *Parser) Parse(_ string, fileContent []byte) ([]model.Document, []int, error) <span class="cov3" title="5">{
        var info Info
        info.From = map[string][]Command{}

        reader := bytes.NewReader(fileContent)
        f, err := syntax.NewParser(syntax.KeepComments(true)).Parse(reader, "")

        if err != nil </span><span class="cov0" title="0">{
                return nil, []int{}, err
        }</span>

        <span class="cov3" title="5">syntax.Walk(f, func(node syntax.Node) bool </span><span class="cov10" title="384">{
                switch x := node.(type) </span>{
                case *syntax.Stmt:<span class="cov5" title="19">
                        info.getStmt(x)</span>
                case *syntax.Comment:<span class="cov4" title="10">
                        info.getIgnoreLines(x)</span>
                }
                <span class="cov10" title="384">return true</span>
        })

        // get kics-scan ignore-block related to from
        <span class="cov3" title="5">info.ignoreFromBlock()

        var documents []model.Document
        var resource Resource
        resource.CommandList = info.From
        doc := &amp;model.Document{}
        j, err := json.Marshal(resource)
        if err != nil </span><span class="cov0" title="0">{
                return nil, []int{}, errors.Wrap(err, "failed to Marshal Buildah")
        }</span>

        <span class="cov3" title="5">err = json.Unmarshal(j, &amp;doc)
        if err != nil </span><span class="cov0" title="0">{
                return nil, []int{}, errors.Wrap(err, "failed to Unmarshal Buildah")
        }</span>

        <span class="cov3" title="5">documents = append(documents, *doc)

        sort.Ints(info.IgnoreLines)

        return documents, info.IgnoreLines, nil</span>
}

func (i *Info) getStmt(stmt *syntax.Stmt) <span class="cov5" title="19">{
        if cmd, ok := stmt.Cmd.(*syntax.CallExpr); ok </span><span class="cov5" title="19">{
                args := cmd.Args

                // get kics-scan ignore-block related to command + get command
                stCommand := i.getStmtInfo(stmt, args)

                if stCommand.Cmd == "buildah from" </span><span class="cov3" title="6">{
                        fromValue := FromValue{
                                Value: stCommand.Value,
                                Line:  stCommand.StartLine,
                        }
                        i.FromValues = append(i.FromValues, fromValue)
                }</span>

                <span class="cov5" title="19">if stCommand.Cmd != "" </span><span class="cov4" title="13">{
                        if len(i.FromValues) != 0 </span><span class="cov4" title="13">{
                                v := i.FromValues[len(i.FromValues)-1].Value
                                i.From[v] = append(i.From[v], stCommand)
                        }</span>
                }
        }
}

func (i *Info) getStmtInfo(stmt *syntax.Stmt, args []*syntax.Word) Command <span class="cov5" title="19">{
        var command Command
        minimumArgs := 2

        if len(args) &gt; minimumArgs </span><span class="cov4" title="13">{
                if getWordValue(args[0]) == buildah </span><span class="cov4" title="13">{
                        cmd := "buildah " + strings.TrimSpace(getWordValue(args[1]))
                        fullCmd := strings.TrimSpace(getFullCommand(args))
                        value := strings.TrimPrefix(fullCmd, cmd)
                        start := int(args[0].Pos().Line())
                        end := int(args[len(args)-1].End().Line())

                        command = Command{
                                Cmd:       cmd,
                                Original:  fullCmd,
                                StartLine: start,
                                EndLine:   end,
                                Value:     strings.TrimSpace(value),
                        }

                        // get kics-scan ignore-block comments
                        i.getIgnoreBlockLines(stmt.Comments, start, end)

                        return command
                }</span>
        }
        <span class="cov3" title="6">return command</span>
}

func getWordValue(wd *syntax.Word) string <span class="cov5" title="26">{
        printer := syntax.NewPrinter()
        var buf bytes.Buffer

        err := printer.Print(&amp;buf, wd)

        if err != nil </span><span class="cov0" title="0">{
                log.Debug().Msgf("failed to get word value: %s", err)
        }</span>

        <span class="cov5" title="26">value := buf.String()
        buf.Reset()

        return value</span>
}

func getFullCommand(args []*syntax.Word) string <span class="cov4" title="13">{
        var buf bytes.Buffer
        printer := syntax.NewPrinter()

        call := &amp;syntax.CallExpr{Args: args}

        err := printer.Print(&amp;buf, call)

        if err != nil </span><span class="cov0" title="0">{
                log.Debug().Msgf("failed to get full command: %s", err)
        }</span>

        <span class="cov4" title="13">command := buf.String()
        buf.Reset()

        command = strings.Replace(command, "\n", "", -1)
        command = strings.Replace(command, "\r", "", -1)
        command = strings.Replace(command, "\t", "", -1)
        command = strings.Replace(command, "\\", "", -1)

        return command</span>
}

// GetKind returns the kind of the parser
func (p *Parser) GetKind() model.FileKind <span class="cov0" title="0">{
        return model.KindBUILDAH
}</span>

// SupportedExtensions returns Buildah extensions
func (p *Parser) SupportedExtensions() []string <span class="cov1" title="1">{
        return []string{".sh"}
}</span>

// SupportedTypes returns types supported by this parser, which are Buildah
func (p *Parser) SupportedTypes() map[string]bool <span class="cov1" title="1">{
        return map[string]bool{"buildah": true}
}</span>

// GetCommentToken return the comment token of Buildah - #
func (p *Parser) GetCommentToken() string <span class="cov0" title="0">{
        return "#"
}</span>

// StringifyContent converts original content into string formatted version
func (p *Parser) StringifyContent(content []byte) (string, error) <span class="cov0" title="0">{
        return string(content), nil
}</span>

// GetResolvedFiles returns the resolved files
func (p *Parser) GetResolvedFiles() map[string]model.ResolvedFile <span class="cov1" title="1">{
        return make(map[string]model.ResolvedFile)
}</span>
</pre>
		
		<pre class="file" id="file73" style="display: none">package docker

import (
        "strings"

        "github.com/Checkmarx/kics/v2/pkg/model"
        "github.com/moby/buildkit/frontend/dockerfile/parser"
)

// ignore is a structure that contains information about the lines that are being ignored.
type ignore struct {
        from  map[string]bool
        lines []int
}

// newIgnore returns a new ignore struct.
func newIgnore() *ignore <span class="cov5" title="6">{
        return &amp;ignore{
                from:  make(map[string]bool),
                lines: make([]int, 0),
        }
}</span>

// setIgnore adds a new entry to the ignore struct for the 'FROM' block to be ignored
func (i *ignore) setIgnore(from string) <span class="cov2" title="2">{
        i.from[from] = true
}</span>

// ignoreBlock adds block lines to be ignored to the ignore struct.
func (i *ignore) ignoreBlock(node *parser.Node, from string) <span class="cov9" title="29">{
        if _, ok := i.from[from]; ok </span><span class="cov5" title="6">{
                i.lines = append(i.lines, model.Range(node.StartLine, node.EndLine)...)
        }</span>
}

// getIgnoreLines returns the lines that are being ignored.
func (i *ignore) getIgnoreLines() []int <span class="cov7" title="14">{
        return model.RemoveDuplicates(i.lines)
}</span>

// getIgnoreComments returns lines to be ignored for each node of the dockerfile
func (i *ignore) getIgnoreComments(node *parser.Node) (ignore bool) <span class="cov10" title="32">{
        if len(node.PrevComment) == 0 </span><span class="cov9" title="25">{
                return false
        }</span>

        <span class="cov6" title="7">for idx, comment := range node.PrevComment </span><span class="cov6" title="8">{
                switch processComment(comment) </span>{
                case model.IgnoreLine:<span class="cov4" title="4">
                        i.lines = append(i.lines, model.Range(node.StartLine-(idx+1), node.EndLine)...)</span>
                case model.IgnoreBlock:<span class="cov2" title="2">
                        i.lines = append(i.lines, node.StartLine-(idx+1))
                        ignore = true</span>
                default:<span class="cov2" title="2">
                        i.lines = append(i.lines, node.StartLine-(idx+1))</span>
                }
        }

        <span class="cov6" title="7">return</span>
}

// processComment returns the type of comment given.
func processComment(comment string) (value model.CommentCommand) <span class="cov6" title="8">{
        commentLower := strings.ToLower(comment)

        if model.KICSCommentRgxp.MatchString(commentLower) </span><span class="cov6" title="7">{
                commentLower = model.KICSCommentRgxp.ReplaceAllString(commentLower, "")
                commands := strings.Split(strings.Trim(commentLower, "\n"), " ")
                value = model.ProcessCommands(commands)
                return
        }</span>
        <span class="cov1" title="1">return model.CommentCommand(comment)</span>
}
</pre>
		
		<pre class="file" id="file74" style="display: none">package docker

import (
        "bytes"
        "encoding/json"
        "fmt"
        "strings"

        "github.com/Checkmarx/kics/v2/pkg/model"
        "github.com/moby/buildkit/frontend/dockerfile/parser"
        "github.com/pkg/errors"
)

// Parser is a Dockerfile parser
type Parser struct {
}

// Resource Separates the list of commands by file
type Resource struct {
        CommandList map[string][]Command `json:"command"`
        Arguments   []Command            `json:"args"`
}

// Command is the struct for each dockerfile command
type Command struct {
        Cmd       string
        SubCmd    string
        Flags     []string
        Value     []string
        Original  string
        StartLine int `json:"_kics_line"`
        EndLine   int
        JSON      bool
}

// Resolve - replace or modifies in-memory content before parsing
func (p *Parser) Resolve(fileContent []byte, _ string, _ bool, _ int) ([]byte, error) <span class="cov1" title="1">{
        return fileContent, nil
}</span>

// Parse - parses dockerfile to Json
func (p *Parser) Parse(_ string, fileContent []byte) ([]model.Document, []int, error) <span class="cov4" title="5">{
        var documents []model.Document
        reader := bytes.NewReader(fileContent)

        parsed, err := parser.Parse(reader)
        if err != nil </span><span class="cov0" title="0">{
                return nil, []int{}, errors.Wrap(err, "failed to parse Dockerfile")
        }</span>

        <span class="cov4" title="5">fromValue := ""
        from := make(map[string][]Command)
        arguments := make([]Command, 0)
        ignoreStruct := newIgnore()

        args := make(map[string]string, 0)
        envs := make(map[string]string, 0)

        for _, child := range parsed.AST.Children </span><span class="cov7" title="27">{
                child.Value = strings.ToLower(child.Value)
                if child.Value == "from" </span><span class="cov4" title="6">{
                        fromValue = strings.TrimPrefix(child.Original, "FROM ")
                }</span>

                <span class="cov7" title="27">if ignoreStruct.getIgnoreComments(child) </span><span class="cov1" title="1">{
                        ignoreStruct.setIgnore(fromValue)
                }</span>

                <span class="cov7" title="27">ignoreStruct.ignoreBlock(child, fromValue)

                cmd := Command{
                        Cmd:       child.Value,
                        Original:  child.Original,
                        Flags:     child.Flags,
                        StartLine: child.StartLine,
                        EndLine:   child.EndLine,
                }

                if child.Next != nil &amp;&amp; len(child.Next.Children) &gt; 0 </span><span class="cov2" title="2">{
                        cmd.SubCmd = strings.ToLower(child.Next.Children[0].Value)
                        child = child.Next.Children[0]
                }</span>

                <span class="cov7" title="27">cmd.JSON = child.Attributes["json"]
                for n := child.Next; n != nil; n = n.Next </span><span class="cov8" title="41">{
                        cmd.Value = append(cmd.Value, n.Value)
                }</span>

                <span class="cov7" title="27">if child.Value != "arg" </span><span class="cov7" title="22">{
                        cmd.Value = resolveArgsAndEnvs(cmd.Value, args)
                }</span> else<span class="cov4" title="5"> {
                        args = saveArgs(args, cmd.Value[0])
                }</span>

                <span class="cov7" title="27">if child.Value != "env" </span><span class="cov7" title="26">{
                        cmd.Value = resolveArgsAndEnvs(cmd.Value, envs)
                }</span> else<span class="cov1" title="1"> {
                        envs = saveEnvs(envs, cmd.Value)
                }</span>

                <span class="cov7" title="27">if fromValue == "" </span><span class="cov3" title="4">{
                        arguments = append(arguments, cmd)
                }</span> else<span class="cov7" title="23"> {
                        from[fromValue] = append(from[fromValue], cmd)
                }</span>
        }

        <span class="cov4" title="5">doc := &amp;model.Document{}
        var resource Resource
        resource.CommandList = from
        resource.Arguments = arguments

        j, err := json.Marshal(resource)
        if err != nil </span><span class="cov0" title="0">{
                return nil, []int{}, errors.Wrap(err, "failed to Marshal Dockerfile")
        }</span>

        <span class="cov4" title="5">if err := json.Unmarshal(j, &amp;doc); err != nil </span><span class="cov0" title="0">{
                return nil, []int{}, errors.Wrap(err, "failed to Unmarshal Dockerfile")
        }</span>

        <span class="cov4" title="5">documents = append(documents, *doc)

        ignoreLines := ignoreStruct.getIgnoreLines()

        return documents, ignoreLines, nil</span>
}

// GetKind returns the kind of the parser
func (p *Parser) GetKind() model.FileKind <span class="cov1" title="1">{
        return model.KindDOCKER
}</span>

// SupportedExtensions returns Dockerfile extensions
func (p *Parser) SupportedExtensions() []string <span class="cov1" title="1">{
        return []string{"Dockerfile", ".dockerfile", ".ubi8", ".debian", "possibleDockerfile"}
}</span>

// SupportedTypes returns types supported by this parser, which are dockerfile
func (p *Parser) SupportedTypes() map[string]bool <span class="cov1" title="1">{
        return map[string]bool{"dockerfile": true}
}</span>

// GetCommentToken return the comment token of Docker - #
func (p *Parser) GetCommentToken() string <span class="cov1" title="1">{
        return "#"
}</span>

// StringifyContent converts original content into string formatted version
func (p *Parser) StringifyContent(content []byte) (string, error) <span class="cov1" title="1">{
        return string(content), nil
}</span>

// GetResolvedFiles returns the list of files that are resolved
func (p *Parser) GetResolvedFiles() map[string]model.ResolvedFile <span class="cov1" title="1">{
        return make(map[string]model.ResolvedFile)
}</span>

func resolveArgsAndEnvs(values []string, args map[string]string) []string <span class="cov9" title="48">{
        for i := range values </span><span class="cov10" title="75">{
                for arg := range args </span><span class="cov6" title="16">{
                        ref1 := fmt.Sprintf("${%s}", arg)
                        values[i] = strings.Replace(values[i], ref1, args[arg], 1)
                        ref2 := fmt.Sprintf("$%s", arg)
                        values[i] = strings.Replace(values[i], ref2, args[arg], 1)
                }</span>
        }

        <span class="cov9" title="48">return values</span>
}

func saveArgs(args map[string]string, argValue string) map[string]string <span class="cov4" title="5">{
        value := strings.Split(argValue, "=")
        if len(value) == 2 </span><span class="cov3" title="3">{
                args[value[0]] = value[1]
        }</span>
        <span class="cov4" title="5">if len(value) &gt; 2 </span><span class="cov1" title="1">{
                // to handle cases like ARG VAR=erereR=E
                args[value[0]] = strings.Join(value[1:], "=")
        }</span>

        <span class="cov4" title="5">return args</span>
}

func saveEnvs(envs map[string]string, envValues []string) map[string]string <span class="cov1" title="1">{
        if len(envValues) == 2 </span><span class="cov1" title="1">{
                envs[envValues[0]] = envValues[1]
        }</span>
        <span class="cov1" title="1">return envs</span>
}
</pre>
		
		<pre class="file" id="file75" style="display: none">package converter

import (
        "strings"

        "github.com/Checkmarx/kics/v2/pkg/model"
        "github.com/Checkmarx/kics/v2/pkg/utils"
        "github.com/emicklei/proto"
)

// JSONProto is a JSON representation of a proto file
type JSONProto struct {
        Syntax           string                      `json:"syntax"`
        PackageName      string                      `json:"package"`
        Messages         map[string]interface{}      `json:"messages"`
        Enum             map[string]interface{}      `json:"enum"`
        Services         map[string]interface{}      `json:"services"`
        Imports          map[string]interface{}      `json:"imports"`
        Options          []Option                    `json:"options"`
        Lines            map[string]model.LineObject `json:"_kics_lines"`
        linesToIgnore    []int                       `json:"-"`
        linesNotToIgnore []int                       `json:"-"`
}

// Service is a JSON representation of a proto service
type Service struct {
        RPC     map[string]RPC              `json:"rpc,omitempty"`
        Options map[string]Option           `json:"options,omitempty"`
        Lines   map[string]model.LineObject `json:"_kics_lines,omitempty"`
}

// Message is a JSON representation of a proto message
type Message struct {
        Field        map[string]*Field           `json:"field,omitempty"`
        Reserved     []*Reserved                 `json:"reserved,omitempty"`
        OneOf        map[string]OneOf            `json:"oneof,omitempty"`
        Enum         map[string]Enum             `json:"enum,omitempty"`
        Map          map[string]*Map             `json:"map,omitempty"`
        InnerMessage map[string]Message          `json:"inner_message,omitempty"`
        Options      map[string]Option           `json:"options,omitempty"`
        Lines        map[string]model.LineObject `json:"_kics_lines,omitempty"`
}

// Map is a JSON representation of a proto map
type Map struct {
        *Field  `json:"field,omitempty"`
        KeyType string                      `json:"key_type,omitempty"`
        Lines   map[string]model.LineObject `json:"_kics_lines,omitempty"`
}

// OneOf is a JSON representation of a proto oneof
type OneOf struct {
        Field   map[string]*Field           `json:"fields,omitempty"`
        Options map[string]Option           `json:"options,omitempty"`
        Lines   map[string]model.LineObject `json:"_kics_lines,omitempty"`
}

// Enum is a JSON representation of a proto enum
type Enum struct {
        Reserved  []*Reserved                 `json:"reserved,omitempty"`
        EnumField map[string]EnumValue        `json:"field,omitempty"`
        Options   map[string]Option           `json:"options,omitempty"`
        Lines     map[string]model.LineObject `json:"_kics_lines,omitempty"`
}

// EnumValue is a JSON representation of a proto enum value
type EnumValue struct {
        Value   int                         `json:"value,omitempty"`
        Options Option                      `json:"options,omitempty"`
        Lines   map[string]model.LineObject `json:"_kics_lines,omitempty"`
}

// Import is a JSON representation of a proto import
type Import struct {
        Kind  string                      `json:"kind,omitempty"`
        Lines map[string]model.LineObject `json:"_kics_lines,omitempty"`
}

// Reserved is a JSON representation of a proto reserved
type Reserved struct {
        Ranges     []proto.Range               `json:"ranges,omitempty"`
        FieldNames []string                    `json:"fieldNames,omitempty"`
        Lines      map[string]model.LineObject `json:"_kics_lines,omitempty"`
}

// Field is a JSON representation of a proto field
type Field struct {
        Type     string                      `json:"type,omitempty"`
        Sequence int                         `json:"sequence,omitempty"`
        Repeated bool                        `json:"repeated,omitempty"`
        Required bool                        `json:"required,omitempty"`
        Optional bool                        `json:"optional,omitempty"`
        Options  []Option                    `json:"options,omitempty"`
        Lines    map[string]model.LineObject `json:"_kics_lines,omitempty"`
}

// RPC is a JSON representation of a proto service RPC
type RPC struct {
        RequestType    string                      `json:"requestType,omitempty"`
        StreamsRequest bool                        `json:"streamsRequest,omitempty"`
        ReturnsType    string                      `json:"returnsType,omitempty"`
        StreamsReturns bool                        `json:"streamsReturns,omitempty"`
        Options        []Option                    `json:"options,omitempty"`
        Lines          map[string]model.LineObject `json:"_kics_lines,omitempty"`
}

// Option is a JSON representation of a proto option
type Option struct {
        Name                string                      `json:"name,omitempty"`
        Constant            OptionLiteral               `json:"constant,omitempty"`
        IsEmbedded          bool                        `json:"isEmbedded,omitempty"`
        AggregatedConstants []*OptionLiteral            `json:"aggregatedConstants,omitempty"`
        Lines               map[string]model.LineObject `json:"_kics_lines,omitempty"`
}

// OptionLiteral is a JSON representation of a proto option literal
type OptionLiteral struct {
        Name       string                      `json:"name,omitempty"`
        Source     string                      `json:"source,omitempty"`
        IsString   bool                        `json:"isString,omitempty"`
        QuoteRune  rune                        `json:"quoteRune,omitempty"`
        Array      []OptionLiteral             `json:"array,omitempty"`
        Map        map[string]OptionLiteral    `json:"map,omitempty"`
        OrderedMap []OptionLiteral             `json:"orderedMap,omitempty"`
        Lines      map[string]model.LineObject `json:"_kics_lines,omitempty"`
}

// newJSONProto creates a new JSONProto struct with default values for all fields
func newJSONProto() *JSONProto <span class="cov5" title="6">{
        return &amp;JSONProto{
                Messages:      make(map[string]interface{}),
                Services:      make(map[string]interface{}),
                Imports:       make(map[string]interface{}),
                Options:       make([]Option, 0),
                Enum:          make(map[string]interface{}),
                Syntax:        "",
                PackageName:   "",
                Lines:         make(map[string]model.LineObject),
                linesToIgnore: make([]int, 0),
        }
}</span>

const kicsLinesKey = "_kics_"

// Convert converts a proto file to a JSONProto struct
func Convert(nodes *proto.Proto) (file *JSONProto, linesIgnore []int) <span class="cov4" title="5">{
        jproto := newJSONProto()
        // handle panic during conversion process
        defer func() </span><span class="cov4" title="5">{
                if r := recover(); r != nil </span><span class="cov0" title="0">{
                        errMessage := "Recovered from panic during conversion of JSONProto " + file.PackageName
                        utils.HandlePanic(r, errMessage)
                }</span>
        }()
        <span class="cov4" title="5">messageLines := make(map[string]model.LineObject)
        enumLines := make(map[string]model.LineObject)
        serviceLines := make(map[string]model.LineObject)
        importLines := make(map[string]model.LineObject)

        defaultArr := make([]map[string]*model.LineObject, 0)

        for _, elem := range nodes.Elements </span><span class="cov8" title="19">{
                switch element := elem.(type) </span>{
                case *proto.Message:<span class="cov4" title="5">
                        jproto.processCommentProto(element.Comment, element.Position.Line, element)
                        jproto.Messages[element.Name] = jproto.convertMessage(element)
                        messageLines[kicsLinesKey+element.Name] = model.LineObject{
                                Line: element.Position.Line,
                                Arr:  make([]map[string]*model.LineObject, 0),
                        }</span>
                case *proto.Service:<span class="cov1" title="1">
                        jproto.processCommentProto(element.Comment, element.Position.Line, element)
                        jproto.convertService(element)
                        serviceLines[kicsLinesKey+element.Name] = model.LineObject{
                                Line: element.Position.Line,
                                Arr:  make([]map[string]*model.LineObject, 0),
                        }</span>
                case *proto.Package:<span class="cov3" title="3">
                        jproto.processCommentProto(element.Comment, element.Position.Line, element)
                        jproto.PackageName = element.Name
                        jproto.Lines["_kics_package"] = model.LineObject{
                                Line: element.Position.Line,
                        }</span>
                case *proto.Import:<span class="cov3" title="3">
                        jproto.processCommentProto(element.Comment, element.Position.Line, element)
                        jproto.Imports[element.Filename] = Import{
                                Kind: element.Kind,
                        }
                        importLines[kicsLinesKey+element.Filename] = model.LineObject{
                                Line: element.Position.Line,
                                Arr:  make([]map[string]*model.LineObject, 0),
                        }</span>
                case *proto.Option:<span class="cov1" title="1">
                        jproto.processCommentProto(element.Comment, element.Position.Line, element)
                        jproto.Options = append(jproto.Options, jproto.convertSingleOption(element))
                        defaultArr = append(defaultArr, map[string]*model.LineObject{
                                element.Name: {
                                        Line: element.Position.Line,
                                },
                        })</span>
                case *proto.Enum:<span class="cov1" title="1">
                        jproto.processCommentProto(element.Comment, element.Position.Line, element)
                        jproto.Enum[element.Name] = jproto.convertEnum(element)
                        enumLines[kicsLinesKey+element.Name] = model.LineObject{
                                Line: element.Position.Line,
                                Arr:  make([]map[string]*model.LineObject, 0),
                        }</span>
                case *proto.Syntax:<span class="cov4" title="5">
                        jproto.processCommentProto(element.Comment, element.Position.Line, element)
                        jproto.Syntax = element.Value
                        jproto.Lines["_kics_syntax"] = model.LineObject{
                                Line: element.Position.Line,
                        }</span>
                }
        }

        // set line information
        <span class="cov4" title="5">jproto.Messages["_kics_lines"] = messageLines
        jproto.Enum["_kics_lines"] = enumLines
        jproto.Services["_kics_lines"] = serviceLines
        jproto.Imports["_kics_lines"] = importLines

        jproto.Lines["kics__default"] = model.LineObject{
                Line: 0,
                Arr:  defaultArr,
        }

        return jproto, model.RemoveDuplicates(jproto.linesToIgnore)</span>
}

// convertMessage converts a proto message to a JSON message
func (j *JSONProto) convertMessage(n *proto.Message) Message <span class="cov5" title="6">{
        message := Message{
                Field:        make(map[string]*Field),
                Reserved:     make([]*Reserved, 0),
                OneOf:        make(map[string]OneOf),
                Enum:         make(map[string]Enum),
                Map:          make(map[string]*Map),
                InnerMessage: make(map[string]Message),
                Options:      make(map[string]Option),
                Lines:        make(map[string]model.LineObject),
        }

        defaultArr := make([]map[string]*model.LineObject, 0)

        for _, field := range n.Elements </span><span class="cov7" title="12">{
                switch field := field.(type) </span>{
                case *proto.NormalField:<span class="cov5" title="6">
                        j.processCommentProto(field.Comment, field.Position.Line, field)
                        message.Lines[kicsLinesKey+field.Name] = model.LineObject{
                                Line: field.Position.Line,
                        }
                        message.Field[field.Name] = &amp;Field{
                                Type:     field.Type,
                                Sequence: field.Sequence,
                                Repeated: field.Repeated,
                                Required: field.Required,
                                Options:  j.convertOption(field.Options),
                                Lines: map[string]model.LineObject{
                                        "_kics__default": {Line: field.Position.Line},
                                },
                        }</span>
                case *proto.Reserved:<span class="cov1" title="1">
                        j.processCommentProto(field.Comment, field.Position.Line, field)
                        message.Reserved = append(message.Reserved, j.convertReserved(field))
                        defaultArr = append(defaultArr, map[string]*model.LineObject{
                                "Reserved": {
                                        Line: field.Position.Line,
                                },
                        })</span>
                case *proto.Oneof:<span class="cov1" title="1">
                        j.processCommentProto(field.Comment, field.Position.Line, field)
                        message.OneOf[field.Name] = j.convertOneOf(field)
                        message.Lines[kicsLinesKey+field.Name] = model.LineObject{
                                Line: field.Position.Line,
                        }</span>
                case *proto.Enum:<span class="cov1" title="1">
                        j.processCommentProto(field.Comment, field.Position.Line, field)
                        message.Enum[field.Name] = j.convertEnum(field)
                        message.Lines[kicsLinesKey+field.Name] = model.LineObject{
                                Line: field.Position.Line,
                        }</span>
                case *proto.MapField:<span class="cov1" title="1">
                        j.processCommentProto(field.Comment, field.Position.Line, field)
                        message.Map[field.Name] = &amp;Map{
                                Field: &amp;Field{
                                        Type:     field.Type,
                                        Sequence: field.Sequence,
                                        Lines: map[string]model.LineObject{
                                                "_kics__default": {Line: field.Position.Line},
                                        },
                                },
                                KeyType: field.KeyType,
                        }
                        message.Lines[kicsLinesKey+field.Name] = model.LineObject{
                                Line: field.Position.Line,
                        }</span>
                case *proto.Message:<span class="cov1" title="1">
                        j.processCommentProto(field.Comment, field.Position.Line, field)
                        message.InnerMessage[field.Name] = j.convertMessage(field)
                        message.Lines[kicsLinesKey+field.Name] = model.LineObject{
                                Line: field.Position.Line,
                        }</span>
                case *proto.Option:<span class="cov1" title="1">
                        j.processCommentProto(field.Comment, field.Position.Line, field)
                        message.Options[field.Name] = j.convertSingleOption(field)
                        message.Lines[kicsLinesKey+field.Name] = model.LineObject{
                                Line: field.Position.Line,
                        }</span>
                }
                <span class="cov7" title="12">continue</span>
        }

        <span class="cov5" title="6">message.Lines["_kics__default"] = model.LineObject{
                Line: n.Position.Line,
                Arr:  defaultArr,
        }

        return message</span>
}

// convertEnum converts a proto enum to a JSON enum
func (j *JSONProto) convertEnum(n *proto.Enum) Enum <span class="cov2" title="2">{
        enum := Enum{
                Reserved:  make([]*Reserved, 0),
                EnumField: make(map[string]EnumValue),
                Options:   make(map[string]Option),
                Lines:     make(map[string]model.LineObject),
        }

        defaultArr := make([]map[string]*model.LineObject, 0)

        for _, elem := range n.Elements </span><span class="cov4" title="5">{
                switch elem := elem.(type) </span>{
                case *proto.EnumField:<span class="cov3" title="3">
                        j.processCommentProto(elem.Comment, elem.Position.Line, elem)
                        enum.EnumField[elem.Name] = EnumValue{
                                Value:   elem.Integer,
                                Options: j.convertSingleOption(elem.ValueOption),
                                Lines: map[string]model.LineObject{
                                        "_kics__default": {Line: elem.Position.Line},
                                },
                        }
                        enum.Lines[kicsLinesKey+elem.Name] = model.LineObject{
                                Line: elem.Position.Line,
                        }</span>
                case *proto.Reserved:<span class="cov1" title="1">
                        j.processCommentProto(elem.Comment, elem.Position.Line, elem)
                        enum.Reserved = append(enum.Reserved, j.convertReserved(elem))
                        defaultArr = append(defaultArr, map[string]*model.LineObject{
                                "Reserved": {
                                        Line: elem.Position.Line,
                                },
                        })</span>
                case *proto.Option:<span class="cov1" title="1">
                        j.processCommentProto(elem.Comment, elem.Position.Line, elem)
                        enum.Options[elem.Name] = j.convertSingleOption(elem)
                        enum.Lines[kicsLinesKey+elem.Name] = model.LineObject{
                                Line: elem.Position.Line,
                        }</span>
                }
                <span class="cov4" title="5">continue</span>
        }

        <span class="cov2" title="2">enum.Lines["_kics__default"] = model.LineObject{
                Line: n.Position.Line,
                Arr:  defaultArr,
        }

        return enum</span>
}

// convertOneOf converts a proto oneof to a JSON oneof
func (j *JSONProto) convertOneOf(n *proto.Oneof) OneOf <span class="cov1" title="1">{
        oneof := OneOf{
                Field:   make(map[string]*Field),
                Options: make(map[string]Option),
                Lines:   make(map[string]model.LineObject),
        }
        oneof.Lines["_kics__default"] = model.LineObject{
                Line: n.Position.Line,
                Arr:  make([]map[string]*model.LineObject, 0),
        }
        for _, elem := range n.Elements </span><span class="cov2" title="2">{
                switch elem := elem.(type) </span>{
                case *proto.OneOfField:<span class="cov2" title="2">
                        j.processCommentProto(elem.Comment, elem.Position.Line, elem)
                        oneof.Field[elem.Name] = &amp;Field{
                                Type:     elem.Type,
                                Sequence: elem.Sequence,
                                Options:  j.convertOption(elem.Options),
                                Lines: map[string]model.LineObject{
                                        "_kics__default": {Line: elem.Position.Line},
                                },
                        }
                        oneof.Lines[kicsLinesKey+elem.Name] = model.LineObject{
                                Line: elem.Position.Line,
                        }</span>
                case *proto.Option:<span class="cov0" title="0">
                        j.processCommentProto(elem.Comment, elem.Position.Line, elem)
                        oneof.Options[elem.Name] = j.convertSingleOption(elem)
                        oneof.Lines[kicsLinesKey+elem.Name] = model.LineObject{
                                Line: elem.Position.Line,
                        }</span>
                }
                <span class="cov2" title="2">continue</span>
        }
        <span class="cov1" title="1">return oneof</span>
}

// convertReserved converts a proto reserved to a JSON reserved
func (j *JSONProto) convertReserved(n *proto.Reserved) *Reserved <span class="cov2" title="2">{
        return &amp;Reserved{
                Ranges:     n.Ranges,
                FieldNames: n.FieldNames,
                Lines: map[string]model.LineObject{
                        "_kics__default": {Line: n.Position.Line},
                },
        }
}</span>

// convertService converts a proto service to a JSON service
func (j *JSONProto) convertService(n *proto.Service) <span class="cov1" title="1">{
        service := Service{
                RPC:     make(map[string]RPC),
                Options: make(map[string]Option),
                Lines:   make(map[string]model.LineObject),
        }

        service.Lines["_kics__default"] = model.LineObject{
                Line: n.Position.Line,
                Arr:  make([]map[string]*model.LineObject, 0),
        }

        for _, rpc := range n.Elements </span><span class="cov1" title="1">{
                switch rpc := rpc.(type) </span>{
                case *proto.RPC:<span class="cov1" title="1">
                        j.processCommentProto(rpc.Comment, rpc.Position.Line, rpc)
                        service.RPC[rpc.Name] = j.convertRPC(rpc)
                        service.Lines[kicsLinesKey+rpc.Name] = model.LineObject{
                                Line: rpc.Position.Line,
                        }</span>
                case *proto.Option:<span class="cov0" title="0">
                        j.processCommentProto(rpc.Comment, rpc.Position.Line, rpc)
                        service.Options[rpc.Name] = j.convertSingleOption(rpc)
                        service.Lines[kicsLinesKey+rpc.Name] = model.LineObject{
                                Line: rpc.Position.Line,
                        }</span>
                }
        }

        <span class="cov1" title="1">j.Services[n.Name] = service</span>
}

// convertOption converts a proto option to a JSON option
func (j *JSONProto) convertOption(n []*proto.Option) []Option <span class="cov6" title="9">{
        if n == nil </span><span class="cov5" title="7">{
                return []Option{}
        }</span>

        <span class="cov2" title="2">options := make([]Option, 0)
        for _, option := range n </span><span class="cov2" title="2">{
                j.processCommentProto(option.Comment, option.Position.Line, option)
                options = append(options, Option{
                        Name:       option.Name,
                        Constant:   j.convertOptionLiteral(&amp;option.Constant),
                        IsEmbedded: option.IsEmbedded,
                        Lines: map[string]model.LineObject{
                                "_kics__default": {Line: option.Position.Line},
                        },
                })
        }</span>
        <span class="cov2" title="2">return options</span>
}

// convertRPC converts a proto rpc to a JSON rpc
func (j *JSONProto) convertRPC(n *proto.RPC) RPC <span class="cov1" title="1">{
        return RPC{
                RequestType:    n.RequestType,
                StreamsRequest: n.StreamsRequest,
                ReturnsType:    n.ReturnsType,
                StreamsReturns: n.StreamsReturns,
                Options:        j.convertOption(n.Options),
                Lines: map[string]model.LineObject{
                        "_kics__default": {Line: n.Position.Line},
                },
        }
}</span>

// convertOptionLiteral converts a proto option literal to a JSON option literal
func (j *JSONProto) convertOptionLiteral(n *proto.Literal) OptionLiteral <span class="cov6" title="8">{
        return OptionLiteral{
                IsString:   n.IsString,
                Source:     n.Source,
                Name:       "",
                QuoteRune:  n.QuoteRune,
                Array:      j.getArrayLiteral(n.Array),
                Map:        j.getMapLiteral(n.Map),
                OrderedMap: j.getLiteralMap(n.OrderedMap),
                Lines: map[string]model.LineObject{
                        "_kics__default": {Line: n.Position.Line},
                },
        }
}</span>

// convertOptionNamedLiteral converts a proto option named literal to a JSON option named literal
func (j *JSONProto) convertOptionNamedLiteral(n *proto.NamedLiteral) OptionLiteral <span class="cov2" title="2">{
        return OptionLiteral{
                IsString:   n.IsString,
                Source:     n.Source,
                Name:       n.Name,
                QuoteRune:  n.QuoteRune,
                Array:      j.getArrayLiteral(n.Array),
                Map:        j.getMapLiteral(n.Map),
                OrderedMap: j.getLiteralMap(n.OrderedMap),
                Lines: map[string]model.LineObject{
                        "_kics__default": {Line: n.Position.Line},
                },
        }
}</span>

// convertSingleOption converts a proto option to a JSON option
func (j *JSONProto) convertSingleOption(n *proto.Option) Option <span class="cov5" title="6">{
        if n == nil </span><span class="cov2" title="2">{
                return Option{}
        }</span>
        <span class="cov4" title="4">return Option{
                Name:       n.Name,
                Constant:   j.convertOptionLiteral(&amp;n.Constant),
                IsEmbedded: n.IsEmbedded,
                Lines: map[string]model.LineObject{
                        "_kics__default": {Line: n.Position.Line},
                },
        }</span>
}

// getArrayLiteral converts a proto array literal to a JSON array literal
func (j *JSONProto) getArrayLiteral(n []*proto.Literal) []OptionLiteral <span class="cov6" title="10">{
        array := make([]OptionLiteral, 0)
        for _, elem := range n </span><span class="cov0" title="0">{
                array = append(array, j.convertOptionLiteral(elem))
        }</span>
        <span class="cov6" title="10">return array</span>
}

// getMapLiteral converts a proto map literal to a JSON map literal
func (j *JSONProto) getMapLiteral(n map[string]*proto.Literal) map[string]OptionLiteral <span class="cov6" title="10">{
        returnMap := make(map[string]OptionLiteral)
        for key, value := range n </span><span class="cov2" title="2">{
                returnMap[key] = j.convertOptionLiteral(value)
        }</span>
        <span class="cov6" title="10">return returnMap</span>
}

// getLiteralMap converts a proto literal map to a JSON literal map
func (j *JSONProto) getLiteralMap(n proto.LiteralMap) []OptionLiteral <span class="cov6" title="10">{
        array := make([]OptionLiteral, 0)
        for _, elem := range n </span><span class="cov2" title="2">{
                array = append(array, j.convertOptionNamedLiteral(elem))
        }</span>
        <span class="cov6" title="10">return array</span>
}

// processCommentProto gathers lines to ignore based on comment commands
func (j *JSONProto) processCommentProto(comment *proto.Comment, lineStart int, element interface{}) <span class="cov10" title="41">{
        // if comment is nil, return
        if comment == nil </span><span class="cov9" title="37">{
                j.linesNotToIgnore = append(j.linesNotToIgnore, lineStart)
                return
        }</span>

        <span class="cov4" title="4">rangeToIgnore := model.Range(comment.Position.Line, comment.Position.Line+(len(comment.Lines)-1))

        // ignore lines that are comments
        linesToIgnore := j.ignoreComment(rangeToIgnore)
        j.linesToIgnore = append(j.linesToIgnore, linesToIgnore...)

        var value model.CommentCommand
        for _, line := range comment.Lines </span><span class="cov4" title="4">{
                comment := strings.ToLower(line)
                if model.KICSCommentRgxp.MatchString(comment) </span><span class="cov3" title="3">{
                        comment = model.KICSCommentRgxp.ReplaceAllString(comment, "")
                        comment = strings.Trim(comment, "\n")
                        commands := strings.Split(strings.Trim(comment, "\r"), " ")
                        value = model.ProcessCommands(commands)
                }</span>
                <span class="cov4" title="4">continue</span>
        }

        <span class="cov4" title="4">lineEnd := getLastElementLine(element, lineStart)
        switch value </span>{
        case model.IgnoreLine:<span class="cov2" title="2">
                j.linesToIgnore = append(j.linesToIgnore, lineStart)</span>
        case model.IgnoreBlock:<span class="cov1" title="1">
                j.linesToIgnore = append(j.linesToIgnore, model.Range(lineStart, lineEnd)...)</span>
        default:<span class="cov1" title="1">
                break</span>
        }
}

// ignoreComment returns a slice of lines to ignore with inline comments removed
func (j *JSONProto) ignoreComment(values []int) []int <span class="cov4" title="4">{
        linesToIgnore := make([]int, 0)
        for _, value := range values </span><span class="cov4" title="4">{
                if isInSlice(value, j.linesNotToIgnore) </span><span class="cov1" title="1">{
                        continue</span>
                }
                <span class="cov3" title="3">linesToIgnore = append(linesToIgnore, value)</span>
        }
        <span class="cov4" title="4">return linesToIgnore</span>
}

// isInSlice checks if a value is in a slice
func isInSlice(value int, slice []int) bool <span class="cov4" title="4">{
        for _, v := range slice </span><span class="cov7" title="17">{
                if v == value </span><span class="cov1" title="1">{
                        return true
                }</span>
        }
        <span class="cov3" title="3">return false</span>
}

// getLastElementLine returns the last line of an element block
func getLastElementLine(v interface{}, parentLine int) int <span class="cov5" title="7">{
        position := 0
        switch t := v.(type) </span>{
        // case proto.Proto:
        //         position = getLastElement(t.Elements[len(t.Elements)-1], t.Position.Line)
        case *proto.Message:<span class="cov1" title="1">
                if len(t.Elements) &gt; 0 </span><span class="cov1" title="1">{
                        position = getLastElementLine(t.Elements[len(t.Elements)-1], t.Position.Line)
                }</span>
        case *proto.Service:<span class="cov0" title="0">
                if len(t.Elements) &gt; 0 </span><span class="cov0" title="0">{
                        position = getLastElementLine(t.Elements[len(t.Elements)-1], t.Position.Line)
                }</span>
        case *proto.EnumField:<span class="cov0" title="0">
                if len(t.Elements) &gt; 0 </span><span class="cov0" title="0">{
                        position = getLastElementLine(t.Elements[len(t.Elements)-1], t.Position.Line)
                }</span>
        case *proto.Enum:<span class="cov0" title="0">
                if len(t.Elements) &gt; 0 </span><span class="cov0" title="0">{
                        position = getLastElementLine(t.Elements[len(t.Elements)-1], t.Position.Line)
                }</span>
        case *proto.Oneof:<span class="cov2" title="2">
                if len(t.Elements) &gt; 0 </span><span class="cov2" title="2">{
                        position = getLastElementLine(t.Elements[len(t.Elements)-1], t.Position.Line)
                }</span>
        case *proto.RPC:<span class="cov0" title="0">
                if len(t.Elements) &gt; 0 </span><span class="cov0" title="0">{
                        position = getLastElementLine(t.Elements[len(t.Elements)-1], t.Position.Line)
                }</span>
        case *proto.Group:<span class="cov0" title="0">
                if len(t.Elements) &gt; 0 </span><span class="cov0" title="0">{
                        position = getLastElementLine(t.Elements[len(t.Elements)-1], t.Position.Line)
                }</span>
        default:<span class="cov4" title="4">
                position = setElementLine(v, parentLine)</span>
        }
        <span class="cov5" title="7">return position</span>
}

// setElementLine sets the last line of an element block
func setElementLine(v interface{}, parentLine int) int <span class="cov4" title="4">{
        position := 0
        switch t := v.(type) </span>{
        case *proto.Syntax:<span class="cov0" title="0">
                position = t.Position.Line</span>
        case *proto.Package:<span class="cov0" title="0">
                position = t.Position.Line</span>
        case *proto.Import:<span class="cov0" title="0">
                position = t.Position.Line</span>
        case *proto.NormalField:<span class="cov1" title="1">
                position = t.Position.Line</span>
        case *proto.Comment:<span class="cov0" title="0">
                position = t.Position.Line</span>
        case *proto.OneOfField:<span class="cov2" title="2">
                position = t.Position.Line</span>
        case *proto.Reserved:<span class="cov1" title="1">
                position = t.Position.Line</span>
        case *proto.MapField:<span class="cov0" title="0">
                position = t.Position.Line</span>
        case *proto.Extensions:<span class="cov0" title="0">
                position = t.Position.Line</span>
        default:<span class="cov0" title="0">
                position = parentLine</span>
        }
        <span class="cov4" title="4">return position</span>
}
</pre>
		
		<pre class="file" id="file76" style="display: none">package grpc

import (
        "bytes"
        "encoding/json"

        "github.com/Checkmarx/kics/v2/pkg/model"
        "github.com/Checkmarx/kics/v2/pkg/parser/grpc/converter"
        "github.com/emicklei/proto"
)

// Parser - parser for Proto files
type Parser struct {
}

// Parse - parses dockerfile to Json
func (p *Parser) Parse(_ string, fileContent []byte) ([]model.Document, []int, error) <span class="cov10" title="2">{
        reader := bytes.NewReader(fileContent)
        parserProto := proto.NewParser(reader)
        nodes, err := parserProto.Parse()
        if err != nil </span><span class="cov0" title="0">{
                return nil, nil, err
        }</span>

        <span class="cov10" title="2">var doc model.Document

        jproto, linesIgnore := converter.Convert(nodes)

        protoBytes, err := json.Marshal(jproto)
        if err != nil </span><span class="cov0" title="0">{
                return nil, nil, err
        }</span>

        <span class="cov10" title="2">err = json.Unmarshal(protoBytes, &amp;doc)
        if err != nil </span><span class="cov0" title="0">{
                return nil, nil, err
        }</span>

        <span class="cov10" title="2">return []model.Document{doc}, linesIgnore, nil</span>
}

// GetKind returns the kind of the parser
func (p *Parser) GetKind() model.FileKind <span class="cov1" title="1">{
        return model.KindPROTO
}</span>

// SupportedExtensions returns Dockerfile extensions
func (p *Parser) SupportedExtensions() []string <span class="cov1" title="1">{
        return []string{".proto"}
}</span>

// SupportedTypes returns types supported by this parser, which are dockerfile
func (p *Parser) SupportedTypes() map[string]bool <span class="cov1" title="1">{
        return map[string]bool{"grpc": true}
}</span>

// GetCommentToken return the comment token of Docker - #
func (p *Parser) GetCommentToken() string <span class="cov1" title="1">{
        return "//"
}</span>

// StringifyContent converts original content into string formatted version
func (p *Parser) StringifyContent(content []byte) (string, error) <span class="cov1" title="1">{
        return string(content), nil
}</span>

// Resolve resolves proto files variables
func (p *Parser) Resolve(fileContent []byte, _ string, _ bool, _ int) ([]byte, error) <span class="cov1" title="1">{
        return fileContent, nil
}</span>

// GetResolvedFiles returns the list of files that are resolved
func (p *Parser) GetResolvedFiles() map[string]model.ResolvedFile <span class="cov1" title="1">{
        return make(map[string]model.ResolvedFile)
}</span>
</pre>
		
		<pre class="file" id="file77" style="display: none">package json

import (
        "bytes"
        "encoding/json"
        "fmt"
        "sort"
        "strings"

        "github.com/Checkmarx/kics/v2/pkg/model"
)

type jsonLine struct {
        LineInfo map[string]model.Document
}

// jsonLineStruct is the struct that keeps important information for the creation of line Information Map
// tmpParent is the parent key of the value we are currently on
// pathArr is an array containing the path elements of the value we are currently on
// noremoveidx keeps information of which elements should not be removed from pathArr on closing delimiters
// lastWasRune keeps information if last Token was a delimiter
// parent is the string path of the element we are currently on
type jsonLineStruct struct {
        tmpParent   string
        pathArr     []string
        lastWasRune bool
        noremoveidx map[int]string
        parent      string
}

type fifo struct {
        name  string // for debugging purposes
        Value []int
}

// initiateJSONLine will create a map, containing line information for every key present in the JSON
func initializeJSONLine(doc []byte) *jsonLine <span class="cov4" title="19">{
        newMap := make(map[string]model.Document)
        dec := json.NewDecoder(bytes.NewReader(doc))

        jstruct := jsonLineStruct{
                tmpParent:   "",
                pathArr:     make([]string, 0),
                lastWasRune: false,
                noremoveidx: make(map[int]string),
                parent:      "",
        }

        line := 1
        prevInputOffset := 0

        // for each token inside JSON
        for </span><span class="cov7" title="198">{
                tok, err := dec.Token()
                if err != nil </span><span class="cov4" title="19">{
                        break</span>
                }

                <span class="cov7" title="179">if v, ok := tok.(json.Delim); ok </span><span class="cov6" title="104">{
                        // token is a delimiter
                        jstruct.delimSetup(v)
                }</span> else<span class="cov6" title="75"> {
                        jstruct.lastWasRune = false
                }</span>

                <span class="cov7" title="179">tokStringRepresentation := ""

                // if token is a string than update temporary father key
                switch t := tok.(type) </span>{
                case string:<span class="cov6" title="63">
                        jstruct.tmpParent = t
                        tokStringRepresentation = t</span>
                case float64:<span class="cov3" title="8">
                        tokStringRepresentation = fmt.Sprint(int(t))
                        jstruct.tmpParent = tokStringRepresentation</span>
                case bool:<span class="cov2" title="4">
                        tokStringRepresentation = fmt.Sprint(t)
                        jstruct.tmpParent = tokStringRepresentation</span>
                case nil:<span class="cov0" title="0">
                        tokStringRepresentation = fmt.Sprint(t)
                        jstruct.tmpParent = tokStringRepresentation</span>
                default:<span class="cov6" title="104">
                        continue</span>
                }

                // get the correct line based on byte offset
                <span class="cov6" title="75">currentInputOffset := int(dec.InputOffset())
                for i := prevInputOffset; i &lt; currentInputOffset; i++ </span><span class="cov10" title="1209">{
                        if doc[i] == byte('\n') </span><span class="cov6" title="70">{
                                line++
                        }</span>
                }
                <span class="cov6" title="75">prevInputOffset = currentInputOffset

                // insert into line information map
                if _, ok := newMap[tokStringRepresentation]; !ok </span><span class="cov6" title="63">{
                        // key info is not in map yet
                        newLineSlice := &amp;fifo{name: tokStringRepresentation}
                        parentMap := make(map[string]interface{})
                        newLineSlice.add(line)
                        parentMap[jstruct.parent] = newLineSlice
                        newMap[tokStringRepresentation] = parentMap
                }</span> else<span class="cov4" title="12"> if v, ok := newMap[tokStringRepresentation][jstruct.parent]; ok </span><span class="cov3" title="8">{
                        // key info is in map with the same path so append is made
                        newLineSlice := &amp;fifo{name: tokStringRepresentation}
                        newLineSlice.add(v.(*fifo).Value...)
                        newLineSlice.add(line)
                        newMap[tokStringRepresentation][jstruct.parent] = newLineSlice
                }</span> else<span class="cov2" title="4"> {
                        // key info is in map with different path
                        newLineSlice := &amp;fifo{name: tokStringRepresentation}
                        newLineSlice.add(line)
                        newMap[tokStringRepresentation][jstruct.parent] = newLineSlice
                }</span>
        }
        <span class="cov4" title="19">return &amp;jsonLine{
                LineInfo: newMap,
        }</span>
}

// delimSetup updates the jsonLineStruct when a json delimiter (ex: { [ ...) is found
func (j *jsonLineStruct) delimSetup(v json.Delim) <span class="cov6" title="104">{
        lenPathArr := len(j.pathArr) - 1
        switch rune(v) </span>{
        case '{', '[':<span class="cov6" title="52">
                // check if last element was a json delimiter
                if !j.lastWasRune </span><span class="cov5" title="46">{
                        j.pathArr = append(j.pathArr, j.tmpParent)
                }</span> else<span class="cov3" title="6"> {
                        // check if temporary parent is in path array, if not last element must be the tempParent
                        // and added to noremoveidx
                        // the next close delimiter should not remove the last element from the pathArr
                        if j.tmpParent != j.pathArr[lenPathArr] </span><span class="cov1" title="2">{
                                j.tmpParent = j.pathArr[lenPathArr]
                                j.noremoveidx[lenPathArr] = j.tmpParent
                        }</span> else<span class="cov2" title="4"> {
                                // the next close delimiter should not remove the last element from the pathArr
                                j.noremoveidx[lenPathArr] = j.tmpParent
                        }</span>
                }
                // update parent path string
                <span class="cov6" title="52">j.parent = strings.Join(j.pathArr, ".")</span>
        case '}', ']':<span class="cov6" title="52">
                j.closeBrackets(lenPathArr)</span>
        }
        <span class="cov6" title="104">j.lastWasRune = true</span>
}

// closeBrackets is what based on the jsonLineStruct information
// will update the parent path and make necessary updates on its structure
func (j *jsonLineStruct) closeBrackets(lenPathArr int) <span class="cov6" title="52">{
        // check if there are elements in the pathArr
        if lenPathArr &gt; 0 </span><span class="cov5" title="33">{
                // check if there are elements in the no noremoveidx
                if v, ok := j.noremoveidx[lenPathArr]; ok </span><span class="cov3" title="6">{
                        // if the last elements in pathArr and noremoveidx differ,
                        // than the last element on pathArr was already closed and can
                        // be removed
                        if j.pathArr[lenPathArr] != v </span><span class="cov0" title="0">{
                                j.pathArr = j.pathArr[:lenPathArr]
                        }</span> else<span class="cov3" title="6"> {
                                // the last element was not closed but should be closed
                                // on the next closing delim
                                // remove from noremoveidx
                                delete(j.noremoveidx, lenPathArr)
                        }</span>
                } else<span class="cov5" title="27"> {
                        // this last element in the pathArr was closed
                        // it can now be removed from the pathArr
                        j.pathArr = j.pathArr[:lenPathArr]
                }</span>
        }
        // update parent string path
        <span class="cov6" title="52">j.parent = strings.Join(j.pathArr, ".")</span>
}

// setLineInfo will set the line information of keys in json based on the line Information map
func (j *jsonLine) setLineInfo(doc map[string]interface{}) map[string]interface{} <span class="cov3" title="10">{
        // set the line info for keys in root level
        doc["_kics_lines"] = j.setLine(doc, 0, "", false)
        return doc
}</span>

// setLine returns the line information for the key containing values
// def is the line of the key
// index is used in case of an array, otherwhise should be 0
// father is the path to the key
func (j *jsonLine) setLine(val map[string]interface{}, def int, father string, pop bool) map[string]*model.LineObject <span class="cov4" title="21">{
        lineMap := make(map[string]*model.LineObject)
        // set the line information of val
        lineMap["_kics__default"] = &amp;model.LineObject{
                Line: def,
                Arr:  []map[string]*model.LineObject{},
        }

        // iterate through the values of the object
        for key, v := range val </span><span class="cov4" title="22">{
                // if the key with father path was not found ignore
                if _, ok2 := j.LineInfo[key][father]; !ok2 </span><span class="cov0" title="0">{
                        continue</span>
                }

                <span class="cov4" title="22">line := j.LineInfo[key][father]

                if len(line.(*fifo).Value) == 0 </span><span class="cov0" title="0">{
                        continue</span>
                }

                <span class="cov4" title="22">lineArr := make([]map[string]*model.LineObject, 0)
                lineNr := line.(*fifo).head()
                if pop </span><span class="cov3" title="5">{
                        lineNr = line.(*fifo).pop()
                }</span>

                <span class="cov4" title="22">switch v := v.(type) </span>{
                // value is an array and must call func setSeqLines to set element lines
                case []interface{}:<span class="cov3" title="6">
                        lineArr = j.setSeqLines(v, lineNr, father, key, lineArr)</span>
                // value is an object and must setLines for each element of the object
                case map[string]interface{}:<span class="cov3" title="8">
                        v["_kics_lines"] = j.setLine(v, lineNr, fmt.Sprintf("%s.%s", father, key), pop)</span>
                default:<span class="cov3" title="8">
                        // value as no childs
                        lineMap[fmt.Sprintf("_kics_%s", key)] = &amp;model.LineObject{
                                Line: lineNr,
                                Arr:  lineArr,
                        }
                        continue</span>
                }

                // set line information of value with its default line and
                // if present array elements line informations
                <span class="cov4" title="14">lineMap[fmt.Sprintf("_kics_%s", key)] = &amp;model.LineObject{
                        Line: lineNr,
                        Arr:  lineArr,
                }</span>
        }
        <span class="cov4" title="21">return lineMap</span>
}

// setSeqLines sets the elements lines information for value of type array
func (j *jsonLine) setSeqLines(v []interface{}, def int, father, key string,
        lineArr []map[string]*model.LineObject) []map[string]*model.LineObject <span class="cov3" title="6">{
        // update father path with key
        fatherKey := father + "." + key

        // iterate over each element of the array
        for _, contentEntry := range v </span><span class="cov4" title="12">{
                defaultLineArr := j.getMapDefaultLine(v, fatherKey)
                if defaultLineArr == -1 </span><span class="cov3" title="9">{
                        defaultLineArr = def
                }</span>
                <span class="cov4" title="12">switch con := contentEntry.(type) </span>{
                // case element is a map/object call func setLine
                case map[string]interface{}:<span class="cov2" title="3">
                        lineArr = append(lineArr, j.setLine(con, defaultLineArr, fatherKey, true))</span>
                // case element is a string
                default:<span class="cov3" title="9">
                        stringedCon := fmt.Sprint(con)
                        // check if element is present in line info map
                        if lineStr, ok2 := j.LineInfo[stringedCon][fmt.Sprintf("%s.%s", father, key)]; ok2 </span><span class="cov3" title="9">{
                                if len(lineStr.(*fifo).Value) == 0 </span><span class="cov0" title="0">{
                                        continue</span>
                                }
                                <span class="cov3" title="9">lineArr = append(lineArr, map[string]*model.LineObject{
                                        "_kics__default": {
                                                Line: lineStr.(*fifo).pop(),
                                        },
                                })</span>
                        }
                }
        }
        <span class="cov3" title="6">return lineArr</span>
}

// must get all and choose the smallest one
func (j *jsonLine) getMapDefaultLine(v []interface{}, father string) int <span class="cov4" title="12">{
        returnNumber := -1
        for _, contentEntry := range v </span><span class="cov5" title="30">{
                linesNumbers := make([]int, 0)
                if c, ok := contentEntry.(map[string]interface{}); ok </span><span class="cov3" title="5">{
                        for key := range c </span><span class="cov3" title="5">{
                                if _, ok2 := j.LineInfo[key][father]; !ok2 </span><span class="cov0" title="0">{
                                        continue</span>
                                }
                                <span class="cov3" title="5">line := j.LineInfo[key][father]
                                if len(line.(*fifo).Value) == 0 </span><span class="cov0" title="0">{
                                        continue</span>
                                }
                                <span class="cov3" title="5">linesNumbers = append(linesNumbers, line.(*fifo).head())</span>
                        }
                        <span class="cov3" title="5">if len(linesNumbers) &gt; 0 </span><span class="cov3" title="5">{
                                sort.Ints(linesNumbers)
                                returnNumber = linesNumbers[0]
                        }</span>
                }
        }
        <span class="cov4" title="12">return returnNumber</span>
}

// SET OF TOOLS TO ASSIST WITH JSON LINE

func (f *fifo) add(elements ...int) <span class="cov6" title="84">{
        f.Value = append(f.Value, elements...)
}</span>

func (f *fifo) pop() int <span class="cov4" title="15">{
        firstElement := f.Value[0]
        f.Value = f.Value[1:]
        return firstElement
}</span>

func (f *fifo) head() int <span class="cov5" title="28">{
        return f.Value[0]
}</span>
</pre>
		
		<pre class="file" id="file78" style="display: none">package json

import (
        "bytes"
        "encoding/json"

        "github.com/Checkmarx/kics/v2/pkg/model"
        "github.com/Checkmarx/kics/v2/pkg/resolver/file"
)

// Parser defines a parser type
type Parser struct {
        shouldIdent   bool
        resolvedFiles map[string]model.ResolvedFile
}

// Resolve - replace or modifies in-memory content before parsing
func (p *Parser) Resolve(fileContent []byte, filename string, resolveReferences bool, maxResolverDepth int) ([]byte, error) <span class="cov1" title="1">{
        // Resolve files passed as arguments with file resolver (e.g. file://)
        res := file.NewResolver(json.Unmarshal, json.Marshal, p.SupportedExtensions())
        resolvedFilesCache := make(map[string]file.ResolvedFile)
        resolved := res.Resolve(fileContent, filename, 0, maxResolverDepth, resolvedFilesCache, resolveReferences)
        p.resolvedFiles = res.ResolvedFiles
        if len(res.ResolvedFiles) == 0 </span><span class="cov1" title="1">{
                return fileContent, nil
        }</span>
        <span class="cov0" title="0">return resolved, nil</span>
}

// Parse parses json file and returns it as a Document
func (p *Parser) Parse(_ string, fileContent []byte) ([]model.Document, []int, error) <span class="cov1" title="1">{
        r := model.Document{}
        err := json.Unmarshal(fileContent, &amp;r)
        if err != nil </span><span class="cov0" title="0">{
                var r []model.Document
                err = json.Unmarshal(fileContent, &amp;r)
                return r, []int{}, err
        }</span>

        <span class="cov1" title="1">jLine := initializeJSONLine(fileContent)
        kicsJSON := jLine.setLineInfo(r)

        // Try to parse JSON as Terraform plan
        kicsPlan, err := parseTFPlan(kicsJSON)
        if err != nil </span><span class="cov1" title="1">{
                // JSON is not a tf plan
                return []model.Document{kicsJSON}, []int{}, nil
        }</span>

        <span class="cov0" title="0">p.shouldIdent = true

        return []model.Document{kicsPlan}, []int{}, nil</span>
}

// SupportedExtensions returns extensions supported by this parser, which is json extension
func (p *Parser) SupportedExtensions() []string <span class="cov10" title="2">{
        return []string{".json"}
}</span>

// GetKind returns JSON constant kind
func (p *Parser) GetKind() model.FileKind <span class="cov1" title="1">{
        return model.KindJSON
}</span>

// SupportedTypes returns types supported by this parser, which are cloudFormation
func (p *Parser) SupportedTypes() map[string]bool <span class="cov1" title="1">{
        return map[string]bool{
                "ansible":              true,
                "cloudformation":       true,
                "openapi":              true,
                "azureresourcemanager": true,
                "terraform":            true,
                "kubernetes":           true,
        }
}</span>

// GetCommentToken return an empty string, since JSON does not have comment token
func (p *Parser) GetCommentToken() string <span class="cov1" title="1">{
        return ""
}</span>

// StringifyContent converts original content into string formatted version
func (p *Parser) StringifyContent(content []byte) (string, error) <span class="cov10" title="2">{
        if p.shouldIdent </span><span class="cov1" title="1">{
                var out bytes.Buffer
                err := json.Indent(&amp;out, content, "", "  ")
                if err != nil </span><span class="cov0" title="0">{
                        return "", err
                }</span>
                <span class="cov1" title="1">return out.String(), nil</span>
        }
        <span class="cov1" title="1">return string(content), nil</span>
}

// GetResolvedFiles returns resolved files
func (p *Parser) GetResolvedFiles() map[string]model.ResolvedFile <span class="cov1" title="1">{
        return p.resolvedFiles
}</span>
</pre>
		
		<pre class="file" id="file79" style="display: none">package json

import (
        "encoding/json"

        "github.com/Checkmarx/kics/v2/pkg/model"
        hcl_plan "github.com/hashicorp/terraform-json"
)

// KicsPlan is an auxiliary structure for parsing tfplans as a KICS Document
type KicsPlan struct {
        Resource map[string]KicsPlanResource `json:"resource"`
}

// KicsPlanResource is an auxiliary structure for parsing tfplans as a KICS Document
type KicsPlanResource map[string]KicsPlanNamedResource

// KicsPlanNamedResource is an auxiliary structure for parsing tfplans as a KICS Document
type KicsPlanNamedResource map[string]interface{}

// parseTFPlan unmarshals Document as a plan so it can be rebuilt with only
// the required information
func parseTFPlan(doc model.Document) (model.Document, error) <span class="cov10" title="3">{
        var plan *hcl_plan.Plan
        b, err := json.Marshal(doc)
        if err != nil </span><span class="cov0" title="0">{
                return model.Document{}, err
        }</span>
        // Unmarshal our Document as a plan so we are able retrieve planned_values
        // in a easier way
        <span class="cov10" title="3">err = json.Unmarshal(b, &amp;plan)
        if err != nil </span><span class="cov6" title="2">{
                // Consider as regular JSON and not tfplan
                return model.Document{}, err
        }</span>

        <span class="cov1" title="1">parsedPlan := readPlan(plan)
        return parsedPlan, nil</span>
}

// readPlan will get the information needed and parse it in a way KICS understands it
func readPlan(plan *hcl_plan.Plan) model.Document <span class="cov1" title="1">{
        kp := KicsPlan{
                Resource: make(map[string]KicsPlanResource),
        }

        kp.readModule(plan.PlannedValues.RootModule)

        doc := model.Document{}

        tmpDocBytes, err := json.Marshal(kp)
        if err != nil </span><span class="cov0" title="0">{
                return model.Document{}
        }</span>
        <span class="cov1" title="1">err = json.Unmarshal(tmpDocBytes, &amp;doc)
        if err != nil </span><span class="cov0" title="0">{
                return model.Document{}
        }</span>

        <span class="cov1" title="1">return doc</span>
}

// readModule will iterate over all planned_value getting the information required
func (kp *KicsPlan) readModule(module *hcl_plan.StateModule) <span class="cov1" title="1">{
        // initialize all the types interfaces
        for _, resource := range module.Resources </span><span class="cov1" title="1">{
                convNamedRes := make(map[string]KicsPlanNamedResource)
                kp.Resource[resource.Type] = convNamedRes
        }</span>
        // fill in all the types interfaces
        <span class="cov1" title="1">for _, resource := range module.Resources </span><span class="cov1" title="1">{
                kp.Resource[resource.Type][resource.Name] = resource.AttributeValues
        }</span>

        <span class="cov1" title="1">for _, childModule := range module.ChildModules </span><span class="cov0" title="0">{
                kp.readModule(childModule)
        }</span>
}
</pre>
		
		<pre class="file" id="file80" style="display: none">package parser

import "github.com/antlr4-go/antlr/v4"

type CustomSyntaxError struct {
        line, column int
        msg          string
}

type CustomErrorListener struct {
        *antlr.DefaultErrorListener
        Errors []*CustomSyntaxError
}

func NewCustomErrorListener() *CustomErrorListener <span class="cov10" title="159">{
        return &amp;CustomErrorListener{
                DefaultErrorListener: antlr.NewDefaultErrorListener(),
                Errors:               make([]*CustomSyntaxError, 0),
        }
}</span>

func (c *CustomErrorListener) HasErrors() bool <span class="cov9" title="155">{
        return len(c.Errors) &gt; 0
}</span>

func (c *CustomErrorListener) SyntaxError(recognizer antlr.Recognizer,
        offendingSymbol interface{}, line, column int, msg string, e antlr.RecognitionException) <span class="cov4" title="8">{
        c.Errors = append(c.Errors, &amp;CustomSyntaxError{
                line:   line,
                column: column,
                msg:    msg,
        })
}</span>
</pre>
		
		<pre class="file" id="file81" style="display: none">// Code generated from JSONFilter.g4 by ANTLR 4.13.1. DO NOT EDIT.

package parser // JSONFilter

import "github.com/antlr4-go/antlr/v4"

type BaseJSONFilterVisitor struct {
        *antlr.BaseParseTreeVisitor
}

func (v *BaseJSONFilterVisitor) VisitAwsjsonfilter(ctx *AwsjsonfilterContext) interface{} <span class="cov0" title="0">{
        return v.VisitChildren(ctx)
}</span>

func (v *BaseJSONFilterVisitor) VisitDotnotation(ctx *DotnotationContext) interface{} <span class="cov0" title="0">{
        return v.VisitChildren(ctx)
}</span>

func (v *BaseJSONFilterVisitor) VisitFilter_expr_parenthesized(ctx *Filter_expr_parenthesizedContext) interface{} <span class="cov0" title="0">{
        return v.VisitChildren(ctx)
}</span>

func (v *BaseJSONFilterVisitor) VisitFilter_expr_and(ctx *Filter_expr_andContext) interface{} <span class="cov0" title="0">{
        return v.VisitChildren(ctx)
}</span>

func (v *BaseJSONFilterVisitor) VisitFilter_expr_exp(ctx *Filter_expr_expContext) interface{} <span class="cov0" title="0">{
        return v.VisitChildren(ctx)
}</span>

func (v *BaseJSONFilterVisitor) VisitFilter_expr_or(ctx *Filter_expr_orContext) interface{} <span class="cov0" title="0">{
        return v.VisitChildren(ctx)
}</span>

func (v *BaseJSONFilterVisitor) VisitExp(ctx *ExpContext) interface{} <span class="cov0" title="0">{
        return v.VisitChildren(ctx)
}</span>

func (v *BaseJSONFilterVisitor) VisitSelector(ctx *SelectorContext) interface{} <span class="cov0" title="0">{
        return v.VisitChildren(ctx)
}</span>

func (v *BaseJSONFilterVisitor) VisitQualifiedidentifier(ctx *QualifiedidentifierContext) interface{} <span class="cov0" title="0">{
        return v.VisitChildren(ctx)
}</span>

func (v *BaseJSONFilterVisitor) VisitMember(ctx *MemberContext) interface{} <span class="cov0" title="0">{
        return v.VisitChildren(ctx)
}</span>

func (v *BaseJSONFilterVisitor) VisitOperator(ctx *OperatorContext) interface{} <span class="cov0" title="0">{
        return v.VisitChildren(ctx)
}</span>

func (v *BaseJSONFilterVisitor) VisitLiteral(ctx *LiteralContext) interface{} <span class="cov0" title="0">{
        return v.VisitChildren(ctx)
}</span>
</pre>
		
		<pre class="file" id="file82" style="display: none">// Code generated from JSONFilter.g4 by ANTLR 4.13.1. DO NOT EDIT.

package parser

import (
        "fmt"
        "github.com/antlr4-go/antlr/v4"
        "sync"
        "unicode"
)

// Suppress unused import error
var _ = fmt.Printf
var _ = sync.Once{}
var _ = unicode.IsLetter

type JSONFilterLexer struct {
        *antlr.BaseLexer
        channelNames []string
        modeNames    []string
        // TODO: EOF string
}

var JSONFilterLexerLexerStaticData struct {
        once                   sync.Once
        serializedATN          []int32
        ChannelNames           []string
        ModeNames              []string
        LiteralNames           []string
        SymbolicNames          []string
        RuleNames              []string
        PredictionContextCache *antlr.PredictionContextCache
        atn                    *antlr.ATN
        decisionToDFA          []*antlr.DFA
}

func jsonfilterlexerLexerInit() <span class="cov2" title="3">{
        staticData := &amp;JSONFilterLexerLexerStaticData
        staticData.ChannelNames = []string{
                "DEFAULT_TOKEN_CHANNEL", "HIDDEN",
        }
        staticData.ModeNames = []string{
                "DEFAULT_MODE",
        }
        staticData.LiteralNames = []string{
                "", "'$.'", "'*'", "'{'", "'}'", "'('", "')'", "'['", "']'", "'.'",
                "'&amp;&amp;'", "'||'", "'='", "'!='", "'&gt;'", "'&lt;'", "'&gt;='", "'&lt;='", "'IS'",
                "'NOT'", "'NULL'", "'EXISTS'", "'TRUE'", "'FALSE'",
        }
        staticData.SymbolicNames = []string{
                "", "SEL_START", "STAR", "LCURLY", "RCURLY", "LPAREN", "RPAREN", "LBRACKET",
                "RBRACKET", "DOT", "AND", "OR", "EQUALS", "NOT_EQUALS", "GT", "LT",
                "GE", "LE", "IS", "NOT", "NULL", "EXISTS", "TRUE", "FALSE", "INDENTIFIER",
                "STRING", "NUMBER", "WS",
        }
        staticData.RuleNames = []string{
                "SEL_START", "STAR", "LCURLY", "RCURLY", "LPAREN", "RPAREN", "LBRACKET",
                "RBRACKET", "DOT", "AND", "OR", "EQUALS", "NOT_EQUALS", "GT", "LT",
                "GE", "LE", "IS", "NOT", "NULL", "EXISTS", "TRUE", "FALSE", "INDENTIFIER",
                "STRING", "ESC", "UNICODE", "HEX", "SAFECODEPOINT", "NUMBER", "INT",
                "EXP", "WS",
        }
        staticData.PredictionContextCache = antlr.NewPredictionContextCache()
        staticData.serializedATN = []int32{
                4, 0, 27, 207, 6, -1, 2, 0, 7, 0, 2, 1, 7, 1, 2, 2, 7, 2, 2, 3, 7, 3, 2,
                4, 7, 4, 2, 5, 7, 5, 2, 6, 7, 6, 2, 7, 7, 7, 2, 8, 7, 8, 2, 9, 7, 9, 2,
                10, 7, 10, 2, 11, 7, 11, 2, 12, 7, 12, 2, 13, 7, 13, 2, 14, 7, 14, 2, 15,
                7, 15, 2, 16, 7, 16, 2, 17, 7, 17, 2, 18, 7, 18, 2, 19, 7, 19, 2, 20, 7,
                20, 2, 21, 7, 21, 2, 22, 7, 22, 2, 23, 7, 23, 2, 24, 7, 24, 2, 25, 7, 25,
                2, 26, 7, 26, 2, 27, 7, 27, 2, 28, 7, 28, 2, 29, 7, 29, 2, 30, 7, 30, 2,
                31, 7, 31, 2, 32, 7, 32, 1, 0, 1, 0, 1, 0, 1, 1, 1, 1, 1, 2, 1, 2, 1, 3,
                1, 3, 1, 4, 1, 4, 1, 5, 1, 5, 1, 6, 1, 6, 1, 7, 1, 7, 1, 8, 1, 8, 1, 9,
                1, 9, 1, 9, 1, 10, 1, 10, 1, 10, 1, 11, 1, 11, 1, 12, 1, 12, 1, 12, 1,
                13, 1, 13, 1, 14, 1, 14, 1, 15, 1, 15, 1, 15, 1, 16, 1, 16, 1, 16, 1, 17,
                1, 17, 1, 17, 1, 18, 1, 18, 1, 18, 1, 18, 1, 19, 1, 19, 1, 19, 1, 19, 1,
                19, 1, 20, 1, 20, 1, 20, 1, 20, 1, 20, 1, 20, 1, 20, 1, 21, 1, 21, 1, 21,
                1, 21, 1, 21, 1, 22, 1, 22, 1, 22, 1, 22, 1, 22, 1, 22, 1, 23, 1, 23, 5,
                23, 140, 8, 23, 10, 23, 12, 23, 143, 9, 23, 1, 24, 1, 24, 1, 24, 5, 24,
                148, 8, 24, 10, 24, 12, 24, 151, 9, 24, 1, 24, 1, 24, 1, 25, 1, 25, 1,
                25, 3, 25, 158, 8, 25, 1, 26, 1, 26, 1, 26, 1, 26, 1, 26, 1, 26, 1, 27,
                1, 27, 1, 28, 1, 28, 1, 29, 3, 29, 171, 8, 29, 1, 29, 1, 29, 1, 29, 4,
                29, 176, 8, 29, 11, 29, 12, 29, 177, 3, 29, 180, 8, 29, 1, 29, 3, 29, 183,
                8, 29, 1, 30, 1, 30, 1, 30, 5, 30, 188, 8, 30, 10, 30, 12, 30, 191, 9,
                30, 3, 30, 193, 8, 30, 1, 31, 1, 31, 3, 31, 197, 8, 31, 1, 31, 1, 31, 1,
                32, 4, 32, 202, 8, 32, 11, 32, 12, 32, 203, 1, 32, 1, 32, 0, 0, 33, 1,
                1, 3, 2, 5, 3, 7, 4, 9, 5, 11, 6, 13, 7, 15, 8, 17, 9, 19, 10, 21, 11,
                23, 12, 25, 13, 27, 14, 29, 15, 31, 16, 33, 17, 35, 18, 37, 19, 39, 20,
                41, 21, 43, 22, 45, 23, 47, 24, 49, 25, 51, 0, 53, 0, 55, 0, 57, 0, 59,
                26, 61, 0, 63, 0, 65, 27, 1, 0, 10, 2, 0, 65, 90, 97, 122, 3, 0, 48, 57,
                65, 90, 97, 122, 8, 0, 34, 34, 47, 47, 92, 92, 98, 98, 102, 102, 110, 110,
                114, 114, 116, 116, 3, 0, 48, 57, 65, 70, 97, 102, 3, 0, 0, 31, 34, 34,
                92, 92, 2, 0, 43, 43, 45, 45, 1, 0, 48, 57, 1, 0, 49, 57, 2, 0, 69, 69,
                101, 101, 3, 0, 9, 10, 13, 13, 32, 32, 212, 0, 1, 1, 0, 0, 0, 0, 3, 1,
                0, 0, 0, 0, 5, 1, 0, 0, 0, 0, 7, 1, 0, 0, 0, 0, 9, 1, 0, 0, 0, 0, 11, 1,
                0, 0, 0, 0, 13, 1, 0, 0, 0, 0, 15, 1, 0, 0, 0, 0, 17, 1, 0, 0, 0, 0, 19,
                1, 0, 0, 0, 0, 21, 1, 0, 0, 0, 0, 23, 1, 0, 0, 0, 0, 25, 1, 0, 0, 0, 0,
                27, 1, 0, 0, 0, 0, 29, 1, 0, 0, 0, 0, 31, 1, 0, 0, 0, 0, 33, 1, 0, 0, 0,
                0, 35, 1, 0, 0, 0, 0, 37, 1, 0, 0, 0, 0, 39, 1, 0, 0, 0, 0, 41, 1, 0, 0,
                0, 0, 43, 1, 0, 0, 0, 0, 45, 1, 0, 0, 0, 0, 47, 1, 0, 0, 0, 0, 49, 1, 0,
                0, 0, 0, 59, 1, 0, 0, 0, 0, 65, 1, 0, 0, 0, 1, 67, 1, 0, 0, 0, 3, 70, 1,
                0, 0, 0, 5, 72, 1, 0, 0, 0, 7, 74, 1, 0, 0, 0, 9, 76, 1, 0, 0, 0, 11, 78,
                1, 0, 0, 0, 13, 80, 1, 0, 0, 0, 15, 82, 1, 0, 0, 0, 17, 84, 1, 0, 0, 0,
                19, 86, 1, 0, 0, 0, 21, 89, 1, 0, 0, 0, 23, 92, 1, 0, 0, 0, 25, 94, 1,
                0, 0, 0, 27, 97, 1, 0, 0, 0, 29, 99, 1, 0, 0, 0, 31, 101, 1, 0, 0, 0, 33,
                104, 1, 0, 0, 0, 35, 107, 1, 0, 0, 0, 37, 110, 1, 0, 0, 0, 39, 114, 1,
                0, 0, 0, 41, 119, 1, 0, 0, 0, 43, 126, 1, 0, 0, 0, 45, 131, 1, 0, 0, 0,
                47, 137, 1, 0, 0, 0, 49, 144, 1, 0, 0, 0, 51, 154, 1, 0, 0, 0, 53, 159,
                1, 0, 0, 0, 55, 165, 1, 0, 0, 0, 57, 167, 1, 0, 0, 0, 59, 170, 1, 0, 0,
                0, 61, 192, 1, 0, 0, 0, 63, 194, 1, 0, 0, 0, 65, 201, 1, 0, 0, 0, 67, 68,
                5, 36, 0, 0, 68, 69, 5, 46, 0, 0, 69, 2, 1, 0, 0, 0, 70, 71, 5, 42, 0,
                0, 71, 4, 1, 0, 0, 0, 72, 73, 5, 123, 0, 0, 73, 6, 1, 0, 0, 0, 74, 75,
                5, 125, 0, 0, 75, 8, 1, 0, 0, 0, 76, 77, 5, 40, 0, 0, 77, 10, 1, 0, 0,
                0, 78, 79, 5, 41, 0, 0, 79, 12, 1, 0, 0, 0, 80, 81, 5, 91, 0, 0, 81, 14,
                1, 0, 0, 0, 82, 83, 5, 93, 0, 0, 83, 16, 1, 0, 0, 0, 84, 85, 5, 46, 0,
                0, 85, 18, 1, 0, 0, 0, 86, 87, 5, 38, 0, 0, 87, 88, 5, 38, 0, 0, 88, 20,
                1, 0, 0, 0, 89, 90, 5, 124, 0, 0, 90, 91, 5, 124, 0, 0, 91, 22, 1, 0, 0,
                0, 92, 93, 5, 61, 0, 0, 93, 24, 1, 0, 0, 0, 94, 95, 5, 33, 0, 0, 95, 96,
                5, 61, 0, 0, 96, 26, 1, 0, 0, 0, 97, 98, 5, 62, 0, 0, 98, 28, 1, 0, 0,
                0, 99, 100, 5, 60, 0, 0, 100, 30, 1, 0, 0, 0, 101, 102, 5, 62, 0, 0, 102,
                103, 5, 61, 0, 0, 103, 32, 1, 0, 0, 0, 104, 105, 5, 60, 0, 0, 105, 106,
                5, 61, 0, 0, 106, 34, 1, 0, 0, 0, 107, 108, 5, 73, 0, 0, 108, 109, 5, 83,
                0, 0, 109, 36, 1, 0, 0, 0, 110, 111, 5, 78, 0, 0, 111, 112, 5, 79, 0, 0,
                112, 113, 5, 84, 0, 0, 113, 38, 1, 0, 0, 0, 114, 115, 5, 78, 0, 0, 115,
                116, 5, 85, 0, 0, 116, 117, 5, 76, 0, 0, 117, 118, 5, 76, 0, 0, 118, 40,
                1, 0, 0, 0, 119, 120, 5, 69, 0, 0, 120, 121, 5, 88, 0, 0, 121, 122, 5,
                73, 0, 0, 122, 123, 5, 83, 0, 0, 123, 124, 5, 84, 0, 0, 124, 125, 5, 83,
                0, 0, 125, 42, 1, 0, 0, 0, 126, 127, 5, 84, 0, 0, 127, 128, 5, 82, 0, 0,
                128, 129, 5, 85, 0, 0, 129, 130, 5, 69, 0, 0, 130, 44, 1, 0, 0, 0, 131,
                132, 5, 70, 0, 0, 132, 133, 5, 65, 0, 0, 133, 134, 5, 76, 0, 0, 134, 135,
                5, 83, 0, 0, 135, 136, 5, 69, 0, 0, 136, 46, 1, 0, 0, 0, 137, 141, 7, 0,
                0, 0, 138, 140, 7, 1, 0, 0, 139, 138, 1, 0, 0, 0, 140, 143, 1, 0, 0, 0,
                141, 139, 1, 0, 0, 0, 141, 142, 1, 0, 0, 0, 142, 48, 1, 0, 0, 0, 143, 141,
                1, 0, 0, 0, 144, 149, 5, 34, 0, 0, 145, 148, 3, 51, 25, 0, 146, 148, 3,
                57, 28, 0, 147, 145, 1, 0, 0, 0, 147, 146, 1, 0, 0, 0, 148, 151, 1, 0,
                0, 0, 149, 147, 1, 0, 0, 0, 149, 150, 1, 0, 0, 0, 150, 152, 1, 0, 0, 0,
                151, 149, 1, 0, 0, 0, 152, 153, 5, 34, 0, 0, 153, 50, 1, 0, 0, 0, 154,
                157, 5, 92, 0, 0, 155, 158, 7, 2, 0, 0, 156, 158, 3, 53, 26, 0, 157, 155,
                1, 0, 0, 0, 157, 156, 1, 0, 0, 0, 158, 52, 1, 0, 0, 0, 159, 160, 5, 117,
                0, 0, 160, 161, 3, 55, 27, 0, 161, 162, 3, 55, 27, 0, 162, 163, 3, 55,
                27, 0, 163, 164, 3, 55, 27, 0, 164, 54, 1, 0, 0, 0, 165, 166, 7, 3, 0,
                0, 166, 56, 1, 0, 0, 0, 167, 168, 8, 4, 0, 0, 168, 58, 1, 0, 0, 0, 169,
                171, 7, 5, 0, 0, 170, 169, 1, 0, 0, 0, 170, 171, 1, 0, 0, 0, 171, 172,
                1, 0, 0, 0, 172, 179, 3, 61, 30, 0, 173, 175, 5, 46, 0, 0, 174, 176, 7,
                6, 0, 0, 175, 174, 1, 0, 0, 0, 176, 177, 1, 0, 0, 0, 177, 175, 1, 0, 0,
                0, 177, 178, 1, 0, 0, 0, 178, 180, 1, 0, 0, 0, 179, 173, 1, 0, 0, 0, 179,
                180, 1, 0, 0, 0, 180, 182, 1, 0, 0, 0, 181, 183, 3, 63, 31, 0, 182, 181,
                1, 0, 0, 0, 182, 183, 1, 0, 0, 0, 183, 60, 1, 0, 0, 0, 184, 193, 5, 48,
                0, 0, 185, 189, 7, 7, 0, 0, 186, 188, 7, 6, 0, 0, 187, 186, 1, 0, 0, 0,
                188, 191, 1, 0, 0, 0, 189, 187, 1, 0, 0, 0, 189, 190, 1, 0, 0, 0, 190,
                193, 1, 0, 0, 0, 191, 189, 1, 0, 0, 0, 192, 184, 1, 0, 0, 0, 192, 185,
                1, 0, 0, 0, 193, 62, 1, 0, 0, 0, 194, 196, 7, 8, 0, 0, 195, 197, 7, 5,
                0, 0, 196, 195, 1, 0, 0, 0, 196, 197, 1, 0, 0, 0, 197, 198, 1, 0, 0, 0,
                198, 199, 3, 61, 30, 0, 199, 64, 1, 0, 0, 0, 200, 202, 7, 9, 0, 0, 201,
                200, 1, 0, 0, 0, 202, 203, 1, 0, 0, 0, 203, 201, 1, 0, 0, 0, 203, 204,
                1, 0, 0, 0, 204, 205, 1, 0, 0, 0, 205, 206, 6, 32, 0, 0, 206, 66, 1, 0,
                0, 0, 13, 0, 141, 147, 149, 157, 170, 177, 179, 182, 189, 192, 196, 203,
                1, 6, 0, 0,
        }
        deserializer := antlr.NewATNDeserializer(nil)
        staticData.atn = deserializer.Deserialize(staticData.serializedATN)
        atn := staticData.atn
        staticData.decisionToDFA = make([]*antlr.DFA, len(atn.DecisionToState))
        decisionToDFA := staticData.decisionToDFA
        for index, state := range atn.DecisionToState </span><span class="cov7" title="39">{
                decisionToDFA[index] = antlr.NewDFA(state, index)
        }</span>
}

// JSONFilterLexerInit initializes any static state used to implement JSONFilterLexer. By default the
// static state used to implement the lexer is lazily initialized during the first call to
// NewJSONFilterLexer(). You can call this function if you wish to initialize the static state ahead
// of time.
func JSONFilterLexerInit() <span class="cov10" title="159">{
        staticData := &amp;JSONFilterLexerLexerStaticData
        staticData.once.Do(jsonfilterlexerLexerInit)
}</span>

// NewJSONFilterLexer produces a new lexer instance for the optional input antlr.CharStream.
func NewJSONFilterLexer(input antlr.CharStream) *JSONFilterLexer <span class="cov10" title="159">{
        JSONFilterLexerInit()
        l := new(JSONFilterLexer)
        l.BaseLexer = antlr.NewBaseLexer(input)
        staticData := &amp;JSONFilterLexerLexerStaticData
        l.Interpreter = antlr.NewLexerATNSimulator(l, staticData.atn, staticData.decisionToDFA, staticData.PredictionContextCache)
        l.channelNames = staticData.ChannelNames
        l.modeNames = staticData.ModeNames
        l.RuleNames = staticData.RuleNames
        l.LiteralNames = staticData.LiteralNames
        l.SymbolicNames = staticData.SymbolicNames
        l.GrammarFileName = "JSONFilter.g4"
        // TODO: l.EOF = antlr.TokenEOF

        return l
}</span>

// JSONFilterLexer tokens.
const (
        JSONFilterLexerSEL_START   = 1
        JSONFilterLexerSTAR        = 2
        JSONFilterLexerLCURLY      = 3
        JSONFilterLexerRCURLY      = 4
        JSONFilterLexerLPAREN      = 5
        JSONFilterLexerRPAREN      = 6
        JSONFilterLexerLBRACKET    = 7
        JSONFilterLexerRBRACKET    = 8
        JSONFilterLexerDOT         = 9
        JSONFilterLexerAND         = 10
        JSONFilterLexerOR          = 11
        JSONFilterLexerEQUALS      = 12
        JSONFilterLexerNOT_EQUALS  = 13
        JSONFilterLexerGT          = 14
        JSONFilterLexerLT          = 15
        JSONFilterLexerGE          = 16
        JSONFilterLexerLE          = 17
        JSONFilterLexerIS          = 18
        JSONFilterLexerNOT         = 19
        JSONFilterLexerNULL        = 20
        JSONFilterLexerEXISTS      = 21
        JSONFilterLexerTRUE        = 22
        JSONFilterLexerFALSE       = 23
        JSONFilterLexerINDENTIFIER = 24
        JSONFilterLexerSTRING      = 25
        JSONFilterLexerNUMBER      = 26
        JSONFilterLexerWS          = 27
)
</pre>
		
		<pre class="file" id="file83" style="display: none">// Code generated from JSONFilter.g4 by ANTLR 4.13.1. DO NOT EDIT.

package parser // JSONFilter

import (
        "fmt"
        "strconv"
        "sync"

        "github.com/antlr4-go/antlr/v4"
)

// Suppress unused import errors
var _ = fmt.Printf
var _ = strconv.Itoa
var _ = sync.Once{}

type JSONFilterParser struct {
        *antlr.BaseParser
}

var JSONFilterParserStaticData struct {
        once                   sync.Once
        serializedATN          []int32
        LiteralNames           []string
        SymbolicNames          []string
        RuleNames              []string
        PredictionContextCache *antlr.PredictionContextCache
        atn                    *antlr.ATN
        decisionToDFA          []*antlr.DFA
}

func jsonfilterParserInit() <span class="cov2" title="3">{
        staticData := &amp;JSONFilterParserStaticData
        staticData.LiteralNames = []string{
                "", "'$.'", "'*'", "'{'", "'}'", "'('", "')'", "'['", "']'", "'.'",
                "'&amp;&amp;'", "'||'", "'='", "'!='", "'&gt;'", "'&lt;'", "'&gt;='", "'&lt;='", "'IS'",
                "'NOT'", "'NULL'", "'EXISTS'", "'TRUE'", "'FALSE'",
        }
        staticData.SymbolicNames = []string{
                "", "SEL_START", "STAR", "LCURLY", "RCURLY", "LPAREN", "RPAREN", "LBRACKET",
                "RBRACKET", "DOT", "AND", "OR", "EQUALS", "NOT_EQUALS", "GT", "LT",
                "GE", "LE", "IS", "NOT", "NULL", "EXISTS", "TRUE", "FALSE", "INDENTIFIER",
                "STRING", "NUMBER", "WS",
        }
        staticData.RuleNames = []string{
                "awsjsonfilter", "dotnotation", "filter_expr", "exp", "selector", "qualifiedidentifier",
                "member", "operator", "literal",
        }
        staticData.PredictionContextCache = antlr.NewPredictionContextCache()
        staticData.serializedATN = []int32{
                4, 1, 27, 90, 2, 0, 7, 0, 2, 1, 7, 1, 2, 2, 7, 2, 2, 3, 7, 3, 2, 4, 7,
                4, 2, 5, 7, 5, 2, 6, 7, 6, 2, 7, 7, 7, 2, 8, 7, 8, 1, 0, 1, 0, 1, 1, 1,
                1, 1, 1, 1, 1, 1, 2, 1, 2, 1, 2, 1, 2, 1, 2, 1, 2, 3, 2, 31, 8, 2, 1, 2,
                1, 2, 1, 2, 1, 2, 1, 2, 1, 2, 5, 2, 39, 8, 2, 10, 2, 12, 2, 42, 9, 2, 1,
                3, 1, 3, 1, 3, 1, 3, 3, 3, 48, 8, 3, 1, 4, 1, 4, 1, 4, 1, 5, 1, 5, 1, 5,
                5, 5, 56, 8, 5, 10, 5, 12, 5, 59, 9, 5, 1, 6, 1, 6, 1, 6, 1, 6, 1, 6, 4,
                6, 66, 8, 6, 11, 6, 12, 6, 67, 3, 6, 70, 8, 6, 1, 7, 1, 7, 1, 8, 1, 8,
                1, 8, 4, 8, 77, 8, 8, 11, 8, 12, 8, 78, 1, 8, 1, 8, 1, 8, 1, 8, 1, 8, 1,
                8, 1, 8, 3, 8, 88, 8, 8, 1, 8, 0, 1, 4, 9, 0, 2, 4, 6, 8, 10, 12, 14, 16,
                0, 2, 1, 0, 12, 19, 2, 0, 2, 2, 26, 26, 95, 0, 18, 1, 0, 0, 0, 2, 20, 1,
                0, 0, 0, 4, 30, 1, 0, 0, 0, 6, 43, 1, 0, 0, 0, 8, 49, 1, 0, 0, 0, 10, 52,
                1, 0, 0, 0, 12, 69, 1, 0, 0, 0, 14, 71, 1, 0, 0, 0, 16, 87, 1, 0, 0, 0,
                18, 19, 3, 2, 1, 0, 19, 1, 1, 0, 0, 0, 20, 21, 5, 3, 0, 0, 21, 22, 3, 4,
                2, 0, 22, 23, 5, 4, 0, 0, 23, 3, 1, 0, 0, 0, 24, 25, 6, 2, -1, 0, 25, 26,
                5, 5, 0, 0, 26, 27, 3, 4, 2, 0, 27, 28, 5, 6, 0, 0, 28, 31, 1, 0, 0, 0,
                29, 31, 3, 6, 3, 0, 30, 24, 1, 0, 0, 0, 30, 29, 1, 0, 0, 0, 31, 40, 1,
                0, 0, 0, 32, 33, 10, 3, 0, 0, 33, 34, 5, 10, 0, 0, 34, 39, 3, 4, 2, 4,
                35, 36, 10, 2, 0, 0, 36, 37, 5, 11, 0, 0, 37, 39, 3, 4, 2, 3, 38, 32, 1,
                0, 0, 0, 38, 35, 1, 0, 0, 0, 39, 42, 1, 0, 0, 0, 40, 38, 1, 0, 0, 0, 40,
                41, 1, 0, 0, 0, 41, 5, 1, 0, 0, 0, 42, 40, 1, 0, 0, 0, 43, 44, 3, 8, 4,
                0, 44, 47, 3, 14, 7, 0, 45, 48, 3, 16, 8, 0, 46, 48, 3, 10, 5, 0, 47, 45,
                1, 0, 0, 0, 47, 46, 1, 0, 0, 0, 48, 7, 1, 0, 0, 0, 49, 50, 5, 1, 0, 0,
                50, 51, 3, 10, 5, 0, 51, 9, 1, 0, 0, 0, 52, 57, 3, 12, 6, 0, 53, 54, 5,
                9, 0, 0, 54, 56, 3, 12, 6, 0, 55, 53, 1, 0, 0, 0, 56, 59, 1, 0, 0, 0, 57,
                55, 1, 0, 0, 0, 57, 58, 1, 0, 0, 0, 58, 11, 1, 0, 0, 0, 59, 57, 1, 0, 0,
                0, 60, 70, 5, 24, 0, 0, 61, 65, 5, 24, 0, 0, 62, 63, 5, 7, 0, 0, 63, 64,
                5, 26, 0, 0, 64, 66, 5, 8, 0, 0, 65, 62, 1, 0, 0, 0, 66, 67, 1, 0, 0, 0,
                67, 65, 1, 0, 0, 0, 67, 68, 1, 0, 0, 0, 68, 70, 1, 0, 0, 0, 69, 60, 1,
                0, 0, 0, 69, 61, 1, 0, 0, 0, 70, 13, 1, 0, 0, 0, 71, 72, 7, 0, 0, 0, 72,
                15, 1, 0, 0, 0, 73, 76, 5, 26, 0, 0, 74, 75, 5, 9, 0, 0, 75, 77, 7, 1,
                0, 0, 76, 74, 1, 0, 0, 0, 77, 78, 1, 0, 0, 0, 78, 76, 1, 0, 0, 0, 78, 79,
                1, 0, 0, 0, 79, 88, 1, 0, 0, 0, 80, 88, 5, 25, 0, 0, 81, 88, 5, 26, 0,
                0, 82, 88, 5, 20, 0, 0, 83, 88, 5, 21, 0, 0, 84, 88, 5, 22, 0, 0, 85, 88,
                5, 23, 0, 0, 86, 88, 5, 24, 0, 0, 87, 73, 1, 0, 0, 0, 87, 80, 1, 0, 0,
                0, 87, 81, 1, 0, 0, 0, 87, 82, 1, 0, 0, 0, 87, 83, 1, 0, 0, 0, 87, 84,
                1, 0, 0, 0, 87, 85, 1, 0, 0, 0, 87, 86, 1, 0, 0, 0, 88, 17, 1, 0, 0, 0,
                9, 30, 38, 40, 47, 57, 67, 69, 78, 87,
        }
        deserializer := antlr.NewATNDeserializer(nil)
        staticData.atn = deserializer.Deserialize(staticData.serializedATN)
        atn := staticData.atn
        staticData.decisionToDFA = make([]*antlr.DFA, len(atn.DecisionToState))
        decisionToDFA := staticData.decisionToDFA
        for index, state := range atn.DecisionToState </span><span class="cov4" title="27">{
                decisionToDFA[index] = antlr.NewDFA(state, index)
        }</span>
}

// JSONFilterParserInit initializes any static state used to implement JSONFilterParser. By default the
// static state used to implement the parser is lazily initialized during the first call to
// NewJSONFilterParser(). You can call this function if you wish to initialize the static state ahead
// of time.
func JSONFilterParserInit() <span class="cov6" title="159">{
        staticData := &amp;JSONFilterParserStaticData
        staticData.once.Do(jsonfilterParserInit)
}</span>

// NewJSONFilterParser produces a new parser instance for the optional input antlr.TokenStream.
func NewJSONFilterParser(input antlr.TokenStream) *JSONFilterParser <span class="cov6" title="159">{
        JSONFilterParserInit()
        this := new(JSONFilterParser)
        this.BaseParser = antlr.NewBaseParser(input)
        staticData := &amp;JSONFilterParserStaticData
        this.Interpreter = antlr.NewParserATNSimulator(this, staticData.atn, staticData.decisionToDFA, staticData.PredictionContextCache)
        this.RuleNames = staticData.RuleNames
        this.LiteralNames = staticData.LiteralNames
        this.SymbolicNames = staticData.SymbolicNames
        this.GrammarFileName = "JSONFilter.g4"

        return this
}</span>

// JSONFilterParser tokens.
const (
        JSONFilterParserEOF         = antlr.TokenEOF
        JSONFilterParserSEL_START   = 1
        JSONFilterParserSTAR        = 2
        JSONFilterParserLCURLY      = 3
        JSONFilterParserRCURLY      = 4
        JSONFilterParserLPAREN      = 5
        JSONFilterParserRPAREN      = 6
        JSONFilterParserLBRACKET    = 7
        JSONFilterParserRBRACKET    = 8
        JSONFilterParserDOT         = 9
        JSONFilterParserAND         = 10
        JSONFilterParserOR          = 11
        JSONFilterParserEQUALS      = 12
        JSONFilterParserNOT_EQUALS  = 13
        JSONFilterParserGT          = 14
        JSONFilterParserLT          = 15
        JSONFilterParserGE          = 16
        JSONFilterParserLE          = 17
        JSONFilterParserIS          = 18
        JSONFilterParserNOT         = 19
        JSONFilterParserNULL        = 20
        JSONFilterParserEXISTS      = 21
        JSONFilterParserTRUE        = 22
        JSONFilterParserFALSE       = 23
        JSONFilterParserINDENTIFIER = 24
        JSONFilterParserSTRING      = 25
        JSONFilterParserNUMBER      = 26
        JSONFilterParserWS          = 27
)

// JSONFilterParser rules.
const (
        JSONFilterParserRULE_awsjsonfilter       = 0
        JSONFilterParserRULE_dotnotation         = 1
        JSONFilterParserRULE_filter_expr         = 2
        JSONFilterParserRULE_exp                 = 3
        JSONFilterParserRULE_selector            = 4
        JSONFilterParserRULE_qualifiedidentifier = 5
        JSONFilterParserRULE_member              = 6
        JSONFilterParserRULE_operator            = 7
        JSONFilterParserRULE_literal             = 8
)

// IAwsjsonfilterContext is an interface to support dynamic dispatch.
type IAwsjsonfilterContext interface {
        antlr.ParserRuleContext

        // GetParser returns the parser.
        GetParser() antlr.Parser

        // Getter signatures
        Dotnotation() IDotnotationContext

        // IsAwsjsonfilterContext differentiates from other interfaces.
        IsAwsjsonfilterContext()
}

type AwsjsonfilterContext struct {
        antlr.BaseParserRuleContext
        parser antlr.Parser
}

func NewEmptyAwsjsonfilterContext() *AwsjsonfilterContext <span class="cov0" title="0">{
        var p = new(AwsjsonfilterContext)
        antlr.InitBaseParserRuleContext(&amp;p.BaseParserRuleContext, nil, -1)
        p.RuleIndex = JSONFilterParserRULE_awsjsonfilter
        return p
}</span>

func InitEmptyAwsjsonfilterContext(p *AwsjsonfilterContext) <span class="cov0" title="0">{
        antlr.InitBaseParserRuleContext(&amp;p.BaseParserRuleContext, nil, -1)
        p.RuleIndex = JSONFilterParserRULE_awsjsonfilter
}</span>

func (*AwsjsonfilterContext) IsAwsjsonfilterContext() {<span class="cov0" title="0">}</span>

func NewAwsjsonfilterContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *AwsjsonfilterContext <span class="cov6" title="159">{
        var p = new(AwsjsonfilterContext)

        antlr.InitBaseParserRuleContext(&amp;p.BaseParserRuleContext, parent, invokingState)

        p.parser = parser
        p.RuleIndex = JSONFilterParserRULE_awsjsonfilter

        return p
}</span>

func (s *AwsjsonfilterContext) GetParser() antlr.Parser <span class="cov0" title="0">{ return s.parser }</span>

func (s *AwsjsonfilterContext) Dotnotation() IDotnotationContext <span class="cov6" title="154">{
        var t antlr.RuleContext
        for _, ctx := range s.GetChildren() </span><span class="cov6" title="154">{
                if _, ok := ctx.(IDotnotationContext); ok </span><span class="cov6" title="154">{
                        t = ctx.(antlr.RuleContext)
                        break</span>
                }
        }

        <span class="cov6" title="154">if t == nil </span><span class="cov0" title="0">{
                return nil
        }</span>

        <span class="cov6" title="154">return t.(IDotnotationContext)</span>
}

func (s *AwsjsonfilterContext) GetRuleContext() antlr.RuleContext <span class="cov0" title="0">{
        return s
}</span>

func (s *AwsjsonfilterContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string <span class="cov0" title="0">{
        return antlr.TreesStringTree(s, ruleNames, recog)
}</span>

func (s *AwsjsonfilterContext) Accept(visitor antlr.ParseTreeVisitor) interface{} <span class="cov6" title="154">{
        switch t := visitor.(type) </span>{
        case JSONFilterVisitor:<span class="cov6" title="154">
                return t.VisitAwsjsonfilter(s)</span>

        default:<span class="cov0" title="0">
                return t.VisitChildren(s)</span>
        }
}

func (p *JSONFilterParser) Awsjsonfilter() (localctx IAwsjsonfilterContext) <span class="cov6" title="159">{
        localctx = NewAwsjsonfilterContext(p, p.GetParserRuleContext(), p.GetState())
        p.EnterRule(localctx, 0, JSONFilterParserRULE_awsjsonfilter)
        p.EnterOuterAlt(localctx, 1)
        </span><span class="cov6" title="159">{
                p.SetState(18)
                p.Dotnotation()
        }</span>

errorExit:
        <span class="cov6" title="159">if p.HasError() </span><span class="cov0" title="0">{
                v := p.GetError()
                localctx.SetException(v)
                p.GetErrorHandler().ReportError(p, v)
                p.GetErrorHandler().Recover(p, v)
                p.SetError(nil)
        }</span>
        <span class="cov6" title="159">p.ExitRule()
        return localctx
        goto errorExit</span> // Trick to prevent compiler error if the label is not used
}

// IDotnotationContext is an interface to support dynamic dispatch.
type IDotnotationContext interface {
        antlr.ParserRuleContext

        // GetParser returns the parser.
        GetParser() antlr.Parser

        // Getter signatures
        LCURLY() antlr.TerminalNode
        Filter_expr() IFilter_exprContext
        RCURLY() antlr.TerminalNode

        // IsDotnotationContext differentiates from other interfaces.
        IsDotnotationContext()
}

type DotnotationContext struct {
        antlr.BaseParserRuleContext
        parser antlr.Parser
}

func NewEmptyDotnotationContext() *DotnotationContext <span class="cov0" title="0">{
        var p = new(DotnotationContext)
        antlr.InitBaseParserRuleContext(&amp;p.BaseParserRuleContext, nil, -1)
        p.RuleIndex = JSONFilterParserRULE_dotnotation
        return p
}</span>

func InitEmptyDotnotationContext(p *DotnotationContext) <span class="cov0" title="0">{
        antlr.InitBaseParserRuleContext(&amp;p.BaseParserRuleContext, nil, -1)
        p.RuleIndex = JSONFilterParserRULE_dotnotation
}</span>

func (*DotnotationContext) IsDotnotationContext() {<span class="cov0" title="0">}</span>

func NewDotnotationContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *DotnotationContext <span class="cov6" title="159">{
        var p = new(DotnotationContext)

        antlr.InitBaseParserRuleContext(&amp;p.BaseParserRuleContext, parent, invokingState)

        p.parser = parser
        p.RuleIndex = JSONFilterParserRULE_dotnotation

        return p
}</span>

func (s *DotnotationContext) GetParser() antlr.Parser <span class="cov0" title="0">{ return s.parser }</span>

func (s *DotnotationContext) LCURLY() antlr.TerminalNode <span class="cov0" title="0">{
        return s.GetToken(JSONFilterParserLCURLY, 0)
}</span>

func (s *DotnotationContext) Filter_expr() IFilter_exprContext <span class="cov6" title="154">{
        var t antlr.RuleContext
        for _, ctx := range s.GetChildren() </span><span class="cov7" title="308">{
                if _, ok := ctx.(IFilter_exprContext); ok </span><span class="cov6" title="154">{
                        t = ctx.(antlr.RuleContext)
                        break</span>
                }
        }

        <span class="cov6" title="154">if t == nil </span><span class="cov0" title="0">{
                return nil
        }</span>

        <span class="cov6" title="154">return t.(IFilter_exprContext)</span>
}

func (s *DotnotationContext) RCURLY() antlr.TerminalNode <span class="cov0" title="0">{
        return s.GetToken(JSONFilterParserRCURLY, 0)
}</span>

func (s *DotnotationContext) GetRuleContext() antlr.RuleContext <span class="cov0" title="0">{
        return s
}</span>

func (s *DotnotationContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string <span class="cov0" title="0">{
        return antlr.TreesStringTree(s, ruleNames, recog)
}</span>

func (s *DotnotationContext) Accept(visitor antlr.ParseTreeVisitor) interface{} <span class="cov6" title="154">{
        switch t := visitor.(type) </span>{
        case JSONFilterVisitor:<span class="cov6" title="154">
                return t.VisitDotnotation(s)</span>

        default:<span class="cov0" title="0">
                return t.VisitChildren(s)</span>
        }
}

func (p *JSONFilterParser) Dotnotation() (localctx IDotnotationContext) <span class="cov6" title="159">{
        localctx = NewDotnotationContext(p, p.GetParserRuleContext(), p.GetState())
        p.EnterRule(localctx, 2, JSONFilterParserRULE_dotnotation)
        p.EnterOuterAlt(localctx, 1)
        </span><span class="cov6" title="159">{
                p.SetState(20)
                p.Match(JSONFilterParserLCURLY)
                if p.HasError() </span><span class="cov1" title="1">{
                        // Recognition error - abort rule
                        goto errorExit</span>
                }
        }
        <span class="cov6" title="158">{
                p.SetState(21)
                p.filter_expr(0)
        }</span>
        <span class="cov6" title="158">{
                p.SetState(22)
                p.Match(JSONFilterParserRCURLY)
                if p.HasError() </span><span class="cov0" title="0">{
                        // Recognition error - abort rule
                        goto errorExit</span>
                }
        }

errorExit:
        <span class="cov6" title="159">if p.HasError() </span><span class="cov1" title="1">{
                v := p.GetError()
                localctx.SetException(v)
                p.GetErrorHandler().ReportError(p, v)
                p.GetErrorHandler().Recover(p, v)
                p.SetError(nil)
        }</span>
        <span class="cov6" title="159">p.ExitRule()
        return localctx
        goto errorExit</span> // Trick to prevent compiler error if the label is not used
}

// IFilter_exprContext is an interface to support dynamic dispatch.
type IFilter_exprContext interface {
        antlr.ParserRuleContext

        // GetParser returns the parser.
        GetParser() antlr.Parser
        // IsFilter_exprContext differentiates from other interfaces.
        IsFilter_exprContext()
}

type Filter_exprContext struct {
        antlr.BaseParserRuleContext
        parser antlr.Parser
}

func NewEmptyFilter_exprContext() *Filter_exprContext <span class="cov0" title="0">{
        var p = new(Filter_exprContext)
        antlr.InitBaseParserRuleContext(&amp;p.BaseParserRuleContext, nil, -1)
        p.RuleIndex = JSONFilterParserRULE_filter_expr
        return p
}</span>

func InitEmptyFilter_exprContext(p *Filter_exprContext) <span class="cov9" title="1979">{
        antlr.InitBaseParserRuleContext(&amp;p.BaseParserRuleContext, nil, -1)
        p.RuleIndex = JSONFilterParserRULE_filter_expr
}</span>

func (*Filter_exprContext) IsFilter_exprContext() {<span class="cov0" title="0">}</span>

func NewFilter_exprContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Filter_exprContext <span class="cov9" title="1980">{
        var p = new(Filter_exprContext)

        antlr.InitBaseParserRuleContext(&amp;p.BaseParserRuleContext, parent, invokingState)

        p.parser = parser
        p.RuleIndex = JSONFilterParserRULE_filter_expr

        return p
}</span>

func (s *Filter_exprContext) GetParser() antlr.Parser <span class="cov0" title="0">{ return s.parser }</span>

func (s *Filter_exprContext) CopyAll(ctx *Filter_exprContext) <span class="cov9" title="1979">{
        s.CopyFrom(&amp;ctx.BaseParserRuleContext)
}</span>

func (s *Filter_exprContext) GetRuleContext() antlr.RuleContext <span class="cov0" title="0">{
        return s
}</span>

func (s *Filter_exprContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string <span class="cov0" title="0">{
        return antlr.TreesStringTree(s, ruleNames, recog)
}</span>

type Filter_expr_parenthesizedContext struct {
        Filter_exprContext
}

func NewFilter_expr_parenthesizedContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *Filter_expr_parenthesizedContext <span class="cov8" title="696">{
        var p = new(Filter_expr_parenthesizedContext)

        InitEmptyFilter_exprContext(&amp;p.Filter_exprContext)
        p.parser = parser
        p.CopyAll(ctx.(*Filter_exprContext))

        return p
}</span>

func (s *Filter_expr_parenthesizedContext) GetRuleContext() antlr.RuleContext <span class="cov0" title="0">{
        return s
}</span>

func (s *Filter_expr_parenthesizedContext) LPAREN() antlr.TerminalNode <span class="cov0" title="0">{
        return s.GetToken(JSONFilterParserLPAREN, 0)
}</span>

func (s *Filter_expr_parenthesizedContext) Filter_expr() IFilter_exprContext <span class="cov8" title="654">{
        var t antlr.RuleContext
        for _, ctx := range s.GetChildren() </span><span class="cov8" title="1308">{
                if _, ok := ctx.(IFilter_exprContext); ok </span><span class="cov8" title="654">{
                        t = ctx.(antlr.RuleContext)
                        break</span>
                }
        }

        <span class="cov8" title="654">if t == nil </span><span class="cov0" title="0">{
                return nil
        }</span>

        <span class="cov8" title="654">return t.(IFilter_exprContext)</span>
}

func (s *Filter_expr_parenthesizedContext) RPAREN() antlr.TerminalNode <span class="cov0" title="0">{
        return s.GetToken(JSONFilterParserRPAREN, 0)
}</span>

func (s *Filter_expr_parenthesizedContext) Accept(visitor antlr.ParseTreeVisitor) interface{} <span class="cov8" title="654">{
        switch t := visitor.(type) </span>{
        case JSONFilterVisitor:<span class="cov8" title="654">
                return t.VisitFilter_expr_parenthesized(s)</span>

        default:<span class="cov0" title="0">
                return t.VisitChildren(s)</span>
        }
}

type Filter_expr_andContext struct {
        Filter_exprContext
        lhs IFilter_exprContext
        rhs IFilter_exprContext
}

func NewFilter_expr_andContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *Filter_expr_andContext <span class="cov5" title="77">{
        var p = new(Filter_expr_andContext)

        InitEmptyFilter_exprContext(&amp;p.Filter_exprContext)
        p.parser = parser
        p.CopyAll(ctx.(*Filter_exprContext))

        return p
}</span>

func (s *Filter_expr_andContext) GetLhs() IFilter_exprContext <span class="cov5" title="75">{ return s.lhs }</span>

func (s *Filter_expr_andContext) GetRhs() IFilter_exprContext <span class="cov5" title="75">{ return s.rhs }</span>

func (s *Filter_expr_andContext) SetLhs(v IFilter_exprContext) <span class="cov0" title="0">{ s.lhs = v }</span>

func (s *Filter_expr_andContext) SetRhs(v IFilter_exprContext) <span class="cov0" title="0">{ s.rhs = v }</span>

func (s *Filter_expr_andContext) GetRuleContext() antlr.RuleContext <span class="cov0" title="0">{
        return s
}</span>

func (s *Filter_expr_andContext) AND() antlr.TerminalNode <span class="cov0" title="0">{
        return s.GetToken(JSONFilterParserAND, 0)
}</span>

func (s *Filter_expr_andContext) AllFilter_expr() []IFilter_exprContext <span class="cov0" title="0">{
        children := s.GetChildren()
        len := 0
        for _, ctx := range children </span><span class="cov0" title="0">{
                if _, ok := ctx.(IFilter_exprContext); ok </span><span class="cov0" title="0">{
                        len++
                }</span>
        }

        <span class="cov0" title="0">tst := make([]IFilter_exprContext, len)
        i := 0
        for _, ctx := range children </span><span class="cov0" title="0">{
                if t, ok := ctx.(IFilter_exprContext); ok </span><span class="cov0" title="0">{
                        tst[i] = t.(IFilter_exprContext)
                        i++
                }</span>
        }

        <span class="cov0" title="0">return tst</span>
}

func (s *Filter_expr_andContext) Filter_expr(i int) IFilter_exprContext <span class="cov0" title="0">{
        var t antlr.RuleContext
        j := 0
        for _, ctx := range s.GetChildren() </span><span class="cov0" title="0">{
                if _, ok := ctx.(IFilter_exprContext); ok </span><span class="cov0" title="0">{
                        if j == i </span><span class="cov0" title="0">{
                                t = ctx.(antlr.RuleContext)
                                break</span>
                        }
                        <span class="cov0" title="0">j++</span>
                }
        }

        <span class="cov0" title="0">if t == nil </span><span class="cov0" title="0">{
                return nil
        }</span>

        <span class="cov0" title="0">return t.(IFilter_exprContext)</span>
}

func (s *Filter_expr_andContext) Accept(visitor antlr.ParseTreeVisitor) interface{} <span class="cov5" title="75">{
        switch t := visitor.(type) </span>{
        case JSONFilterVisitor:<span class="cov5" title="75">
                return t.VisitFilter_expr_and(s)</span>

        default:<span class="cov0" title="0">
                return t.VisitChildren(s)</span>
        }
}

type Filter_expr_expContext struct {
        Filter_exprContext
}

func NewFilter_expr_expContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *Filter_expr_expContext <span class="cov8" title="720">{
        var p = new(Filter_expr_expContext)

        InitEmptyFilter_exprContext(&amp;p.Filter_exprContext)
        p.parser = parser
        p.CopyAll(ctx.(*Filter_exprContext))

        return p
}</span>

func (s *Filter_expr_expContext) GetRuleContext() antlr.RuleContext <span class="cov0" title="0">{
        return s
}</span>

func (s *Filter_expr_expContext) Exp() IExpContext <span class="cov8" title="679">{
        var t antlr.RuleContext
        for _, ctx := range s.GetChildren() </span><span class="cov8" title="679">{
                if _, ok := ctx.(IExpContext); ok </span><span class="cov8" title="679">{
                        t = ctx.(antlr.RuleContext)
                        break</span>
                }
        }

        <span class="cov8" title="679">if t == nil </span><span class="cov0" title="0">{
                return nil
        }</span>

        <span class="cov8" title="679">return t.(IExpContext)</span>
}

func (s *Filter_expr_expContext) Accept(visitor antlr.ParseTreeVisitor) interface{} <span class="cov8" title="679">{
        switch t := visitor.(type) </span>{
        case JSONFilterVisitor:<span class="cov8" title="679">
                return t.VisitFilter_expr_exp(s)</span>

        default:<span class="cov0" title="0">
                return t.VisitChildren(s)</span>
        }
}

type Filter_expr_orContext struct {
        Filter_exprContext
        lhs IFilter_exprContext
        rhs IFilter_exprContext
}

func NewFilter_expr_orContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *Filter_expr_orContext <span class="cov7" title="486">{
        var p = new(Filter_expr_orContext)

        InitEmptyFilter_exprContext(&amp;p.Filter_exprContext)
        p.parser = parser
        p.CopyAll(ctx.(*Filter_exprContext))

        return p
}</span>

func (s *Filter_expr_orContext) GetLhs() IFilter_exprContext <span class="cov7" title="450">{ return s.lhs }</span>

func (s *Filter_expr_orContext) GetRhs() IFilter_exprContext <span class="cov7" title="450">{ return s.rhs }</span>

func (s *Filter_expr_orContext) SetLhs(v IFilter_exprContext) <span class="cov0" title="0">{ s.lhs = v }</span>

func (s *Filter_expr_orContext) SetRhs(v IFilter_exprContext) <span class="cov0" title="0">{ s.rhs = v }</span>

func (s *Filter_expr_orContext) GetRuleContext() antlr.RuleContext <span class="cov0" title="0">{
        return s
}</span>

func (s *Filter_expr_orContext) OR() antlr.TerminalNode <span class="cov0" title="0">{
        return s.GetToken(JSONFilterParserOR, 0)
}</span>

func (s *Filter_expr_orContext) AllFilter_expr() []IFilter_exprContext <span class="cov0" title="0">{
        children := s.GetChildren()
        len := 0
        for _, ctx := range children </span><span class="cov0" title="0">{
                if _, ok := ctx.(IFilter_exprContext); ok </span><span class="cov0" title="0">{
                        len++
                }</span>
        }

        <span class="cov0" title="0">tst := make([]IFilter_exprContext, len)
        i := 0
        for _, ctx := range children </span><span class="cov0" title="0">{
                if t, ok := ctx.(IFilter_exprContext); ok </span><span class="cov0" title="0">{
                        tst[i] = t.(IFilter_exprContext)
                        i++
                }</span>
        }

        <span class="cov0" title="0">return tst</span>
}

func (s *Filter_expr_orContext) Filter_expr(i int) IFilter_exprContext <span class="cov0" title="0">{
        var t antlr.RuleContext
        j := 0
        for _, ctx := range s.GetChildren() </span><span class="cov0" title="0">{
                if _, ok := ctx.(IFilter_exprContext); ok </span><span class="cov0" title="0">{
                        if j == i </span><span class="cov0" title="0">{
                                t = ctx.(antlr.RuleContext)
                                break</span>
                        }
                        <span class="cov0" title="0">j++</span>
                }
        }

        <span class="cov0" title="0">if t == nil </span><span class="cov0" title="0">{
                return nil
        }</span>

        <span class="cov0" title="0">return t.(IFilter_exprContext)</span>
}

func (s *Filter_expr_orContext) Accept(visitor antlr.ParseTreeVisitor) interface{} <span class="cov7" title="450">{
        switch t := visitor.(type) </span>{
        case JSONFilterVisitor:<span class="cov7" title="450">
                return t.VisitFilter_expr_or(s)</span>

        default:<span class="cov0" title="0">
                return t.VisitChildren(s)</span>
        }
}

func (p *JSONFilterParser) Filter_expr() (localctx IFilter_exprContext) <span class="cov0" title="0">{
        return p.filter_expr(0)
}</span>

func (p *JSONFilterParser) filter_expr(_p int) (localctx IFilter_exprContext) <span class="cov8" title="1417">{
        var _parentctx antlr.ParserRuleContext = p.GetParserRuleContext()

        _parentState := p.GetState()
        localctx = NewFilter_exprContext(p, p.GetParserRuleContext(), _parentState)
        var _prevctx IFilter_exprContext = localctx
        var _ antlr.ParserRuleContext = _prevctx // TODO: To prevent unused variable warning.
        _startState := 4
        p.EnterRecursionRule(localctx, 4, JSONFilterParserRULE_filter_expr, _p)
        var _alt int

        p.EnterOuterAlt(localctx, 1)
        p.SetState(30)
        p.GetErrorHandler().Sync(p)
        if p.HasError() </span><span class="cov1" title="1">{
                goto errorExit</span>
        }

        <span class="cov8" title="1416">switch p.GetTokenStream().LA(1) </span>{
        case JSONFilterParserLPAREN:<span class="cov8" title="696">
                localctx = NewFilter_expr_parenthesizedContext(p, localctx)
                p.SetParserRuleContext(localctx)
                _prevctx = localctx

                </span><span class="cov8" title="696">{
                        p.SetState(25)
                        p.Match(JSONFilterParserLPAREN)
                        if p.HasError() </span><span class="cov0" title="0">{
                                // Recognition error - abort rule
                                goto errorExit</span>
                        }
                }
                <span class="cov8" title="696">{
                        p.SetState(26)
                        p.filter_expr(0)
                }</span>
                <span class="cov8" title="696">{
                        p.SetState(27)
                        p.Match(JSONFilterParserRPAREN)
                        if p.HasError() </span><span class="cov0" title="0">{
                                // Recognition error - abort rule
                                goto errorExit</span>
                        }
                }

        case JSONFilterParserSEL_START:<span class="cov8" title="720">
                localctx = NewFilter_expr_expContext(p, localctx)
                p.SetParserRuleContext(localctx)
                _prevctx = localctx
                </span><span class="cov8" title="720">{
                        p.SetState(29)
                        p.Exp()
                }</span>

        default:<span class="cov0" title="0">
                p.SetError(antlr.NewNoViableAltException(p, nil, nil, nil, nil, nil))
                goto errorExit</span>
        }
        <span class="cov8" title="1416">p.GetParserRuleContext().SetStop(p.GetTokenStream().LT(-1))
        p.SetState(40)
        p.GetErrorHandler().Sync(p)
        if p.HasError() </span><span class="cov0" title="0">{
                goto errorExit</span>
        }
        <span class="cov8" title="1416">_alt = p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 2, p.GetParserRuleContext())
        if p.HasError() </span><span class="cov0" title="0">{
                goto errorExit</span>
        }
        <span class="cov8" title="1416">for _alt != 2 &amp;&amp; _alt != antlr.ATNInvalidAltNumber </span><span class="cov7" title="563">{
                if _alt == 1 </span><span class="cov7" title="563">{
                        if p.GetParseListeners() != nil </span><span class="cov7" title="563">{
                                p.TriggerExitRuleEvent()
                        }</span>
                        <span class="cov7" title="563">_prevctx = localctx
                        p.SetState(38)
                        p.GetErrorHandler().Sync(p)
                        if p.HasError() </span><span class="cov0" title="0">{
                                goto errorExit</span>
                        }

                        <span class="cov7" title="563">switch p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 1, p.GetParserRuleContext()) </span>{
                        case 1:<span class="cov5" title="77">
                                localctx = NewFilter_expr_andContext(p, NewFilter_exprContext(p, _parentctx, _parentState))
                                localctx.(*Filter_expr_andContext).lhs = _prevctx

                                p.PushNewRecursionContext(localctx, _startState, JSONFilterParserRULE_filter_expr)
                                p.SetState(32)

                                if !(p.Precpred(p.GetParserRuleContext(), 3)) </span><span class="cov0" title="0">{
                                        p.SetError(antlr.NewFailedPredicateException(p, "p.Precpred(p.GetParserRuleContext(), 3)", ""))
                                        goto errorExit</span>
                                }
                                <span class="cov5" title="77">{
                                        p.SetState(33)
                                        p.Match(JSONFilterParserAND)
                                        if p.HasError() </span><span class="cov0" title="0">{
                                                // Recognition error - abort rule
                                                goto errorExit</span>
                                        }
                                }
                                <span class="cov5" title="77">{
                                        p.SetState(34)

                                        var _x = p.filter_expr(4)

                                        localctx.(*Filter_expr_andContext).rhs = _x
                                }</span>

                        case 2:<span class="cov7" title="486">
                                localctx = NewFilter_expr_orContext(p, NewFilter_exprContext(p, _parentctx, _parentState))
                                localctx.(*Filter_expr_orContext).lhs = _prevctx

                                p.PushNewRecursionContext(localctx, _startState, JSONFilterParserRULE_filter_expr)
                                p.SetState(35)

                                if !(p.Precpred(p.GetParserRuleContext(), 2)) </span><span class="cov0" title="0">{
                                        p.SetError(antlr.NewFailedPredicateException(p, "p.Precpred(p.GetParserRuleContext(), 2)", ""))
                                        goto errorExit</span>
                                }
                                <span class="cov7" title="486">{
                                        p.SetState(36)
                                        p.Match(JSONFilterParserOR)
                                        if p.HasError() </span><span class="cov0" title="0">{
                                                // Recognition error - abort rule
                                                goto errorExit</span>
                                        }
                                }
                                <span class="cov7" title="486">{
                                        p.SetState(37)

                                        var _x = p.filter_expr(3)

                                        localctx.(*Filter_expr_orContext).rhs = _x
                                }</span>

                        case antlr.ATNInvalidAltNumber:<span class="cov0" title="0">
                                goto errorExit</span>
                        }

                }
                <span class="cov7" title="563">p.SetState(42)
                p.GetErrorHandler().Sync(p)
                if p.HasError() </span><span class="cov0" title="0">{
                        goto errorExit</span>
                }
                <span class="cov7" title="563">_alt = p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 2, p.GetParserRuleContext())
                if p.HasError() </span><span class="cov0" title="0">{
                        goto errorExit</span>
                }
        }

errorExit:
        <span class="cov8" title="1417">if p.HasError() </span><span class="cov1" title="1">{
                v := p.GetError()
                localctx.SetException(v)
                p.GetErrorHandler().ReportError(p, v)
                p.GetErrorHandler().Recover(p, v)
                p.SetError(nil)
        }</span>
        <span class="cov8" title="1417">p.UnrollRecursionContexts(_parentctx)
        return localctx
        goto errorExit</span> // Trick to prevent compiler error if the label is not used
}

// IExpContext is an interface to support dynamic dispatch.
type IExpContext interface {
        antlr.ParserRuleContext

        // GetParser returns the parser.
        GetParser() antlr.Parser

        // Getter signatures
        Selector() ISelectorContext
        Operator() IOperatorContext
        Literal() ILiteralContext
        Qualifiedidentifier() IQualifiedidentifierContext

        // IsExpContext differentiates from other interfaces.
        IsExpContext()
}

type ExpContext struct {
        antlr.BaseParserRuleContext
        parser antlr.Parser
}

func NewEmptyExpContext() *ExpContext <span class="cov0" title="0">{
        var p = new(ExpContext)
        antlr.InitBaseParserRuleContext(&amp;p.BaseParserRuleContext, nil, -1)
        p.RuleIndex = JSONFilterParserRULE_exp
        return p
}</span>

func InitEmptyExpContext(p *ExpContext) <span class="cov0" title="0">{
        antlr.InitBaseParserRuleContext(&amp;p.BaseParserRuleContext, nil, -1)
        p.RuleIndex = JSONFilterParserRULE_exp
}</span>

func (*ExpContext) IsExpContext() {<span class="cov0" title="0">}</span>

func NewExpContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *ExpContext <span class="cov8" title="720">{
        var p = new(ExpContext)

        antlr.InitBaseParserRuleContext(&amp;p.BaseParserRuleContext, parent, invokingState)

        p.parser = parser
        p.RuleIndex = JSONFilterParserRULE_exp

        return p
}</span>

func (s *ExpContext) GetParser() antlr.Parser <span class="cov0" title="0">{ return s.parser }</span>

func (s *ExpContext) Selector() ISelectorContext <span class="cov8" title="679">{
        var t antlr.RuleContext
        for _, ctx := range s.GetChildren() </span><span class="cov8" title="679">{
                if _, ok := ctx.(ISelectorContext); ok </span><span class="cov8" title="679">{
                        t = ctx.(antlr.RuleContext)
                        break</span>
                }
        }

        <span class="cov8" title="679">if t == nil </span><span class="cov0" title="0">{
                return nil
        }</span>

        <span class="cov8" title="679">return t.(ISelectorContext)</span>
}

func (s *ExpContext) Operator() IOperatorContext <span class="cov8" title="679">{
        var t antlr.RuleContext
        for _, ctx := range s.GetChildren() </span><span class="cov8" title="1358">{
                if _, ok := ctx.(IOperatorContext); ok </span><span class="cov8" title="679">{
                        t = ctx.(antlr.RuleContext)
                        break</span>
                }
        }

        <span class="cov8" title="679">if t == nil </span><span class="cov0" title="0">{
                return nil
        }</span>

        <span class="cov8" title="679">return t.(IOperatorContext)</span>
}

func (s *ExpContext) Literal() ILiteralContext <span class="cov8" title="1358">{
        var t antlr.RuleContext
        for _, ctx := range s.GetChildren() </span><span class="cov10" title="4074">{
                if _, ok := ctx.(ILiteralContext); ok </span><span class="cov8" title="1358">{
                        t = ctx.(antlr.RuleContext)
                        break</span>
                }
        }

        <span class="cov8" title="1358">if t == nil </span><span class="cov0" title="0">{
                return nil
        }</span>

        <span class="cov8" title="1358">return t.(ILiteralContext)</span>
}

func (s *ExpContext) Qualifiedidentifier() IQualifiedidentifierContext <span class="cov0" title="0">{
        var t antlr.RuleContext
        for _, ctx := range s.GetChildren() </span><span class="cov0" title="0">{
                if _, ok := ctx.(IQualifiedidentifierContext); ok </span><span class="cov0" title="0">{
                        t = ctx.(antlr.RuleContext)
                        break</span>
                }
        }

        <span class="cov0" title="0">if t == nil </span><span class="cov0" title="0">{
                return nil
        }</span>

        <span class="cov0" title="0">return t.(IQualifiedidentifierContext)</span>
}

func (s *ExpContext) GetRuleContext() antlr.RuleContext <span class="cov0" title="0">{
        return s
}</span>

func (s *ExpContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string <span class="cov0" title="0">{
        return antlr.TreesStringTree(s, ruleNames, recog)
}</span>

func (s *ExpContext) Accept(visitor antlr.ParseTreeVisitor) interface{} <span class="cov8" title="679">{
        switch t := visitor.(type) </span>{
        case JSONFilterVisitor:<span class="cov8" title="679">
                return t.VisitExp(s)</span>

        default:<span class="cov0" title="0">
                return t.VisitChildren(s)</span>
        }
}

func (p *JSONFilterParser) Exp() (localctx IExpContext) <span class="cov8" title="720">{
        localctx = NewExpContext(p, p.GetParserRuleContext(), p.GetState())
        p.EnterRule(localctx, 6, JSONFilterParserRULE_exp)
        p.EnterOuterAlt(localctx, 1)
        </span><span class="cov8" title="720">{
                p.SetState(43)
                p.Selector()
        }</span>
        <span class="cov8" title="720">{
                p.SetState(44)
                p.Operator()
        }</span>
        <span class="cov8" title="720">p.SetState(47)
        p.GetErrorHandler().Sync(p)
        if p.HasError() </span><span class="cov0" title="0">{
                goto errorExit</span>
        }

        <span class="cov8" title="720">switch p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 3, p.GetParserRuleContext()) </span>{
        case 1:<span class="cov8" title="720">
                </span><span class="cov8" title="720">{
                        p.SetState(45)
                        p.Literal()
                }</span>

        case 2:<span class="cov0" title="0">
                </span><span class="cov0" title="0">{
                        p.SetState(46)
                        p.Qualifiedidentifier()
                }</span>

        case antlr.ATNInvalidAltNumber:<span class="cov0" title="0">
                goto errorExit</span>
        }

errorExit:
        <span class="cov8" title="720">if p.HasError() </span><span class="cov0" title="0">{
                v := p.GetError()
                localctx.SetException(v)
                p.GetErrorHandler().ReportError(p, v)
                p.GetErrorHandler().Recover(p, v)
                p.SetError(nil)
        }</span>
        <span class="cov8" title="720">p.ExitRule()
        return localctx
        goto errorExit</span> // Trick to prevent compiler error if the label is not used
}

// ISelectorContext is an interface to support dynamic dispatch.
type ISelectorContext interface {
        antlr.ParserRuleContext

        // GetParser returns the parser.
        GetParser() antlr.Parser

        // Getter signatures
        SEL_START() antlr.TerminalNode
        Qualifiedidentifier() IQualifiedidentifierContext

        // IsSelectorContext differentiates from other interfaces.
        IsSelectorContext()
}

type SelectorContext struct {
        antlr.BaseParserRuleContext
        parser antlr.Parser
}

func NewEmptySelectorContext() *SelectorContext <span class="cov0" title="0">{
        var p = new(SelectorContext)
        antlr.InitBaseParserRuleContext(&amp;p.BaseParserRuleContext, nil, -1)
        p.RuleIndex = JSONFilterParserRULE_selector
        return p
}</span>

func InitEmptySelectorContext(p *SelectorContext) <span class="cov0" title="0">{
        antlr.InitBaseParserRuleContext(&amp;p.BaseParserRuleContext, nil, -1)
        p.RuleIndex = JSONFilterParserRULE_selector
}</span>

func (*SelectorContext) IsSelectorContext() {<span class="cov0" title="0">}</span>

func NewSelectorContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *SelectorContext <span class="cov8" title="720">{
        var p = new(SelectorContext)

        antlr.InitBaseParserRuleContext(&amp;p.BaseParserRuleContext, parent, invokingState)

        p.parser = parser
        p.RuleIndex = JSONFilterParserRULE_selector

        return p
}</span>

func (s *SelectorContext) GetParser() antlr.Parser <span class="cov0" title="0">{ return s.parser }</span>

func (s *SelectorContext) SEL_START() antlr.TerminalNode <span class="cov0" title="0">{
        return s.GetToken(JSONFilterParserSEL_START, 0)
}</span>

func (s *SelectorContext) Qualifiedidentifier() IQualifiedidentifierContext <span class="cov0" title="0">{
        var t antlr.RuleContext
        for _, ctx := range s.GetChildren() </span><span class="cov0" title="0">{
                if _, ok := ctx.(IQualifiedidentifierContext); ok </span><span class="cov0" title="0">{
                        t = ctx.(antlr.RuleContext)
                        break</span>
                }
        }

        <span class="cov0" title="0">if t == nil </span><span class="cov0" title="0">{
                return nil
        }</span>

        <span class="cov0" title="0">return t.(IQualifiedidentifierContext)</span>
}

func (s *SelectorContext) GetRuleContext() antlr.RuleContext <span class="cov0" title="0">{
        return s
}</span>

func (s *SelectorContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string <span class="cov0" title="0">{
        return antlr.TreesStringTree(s, ruleNames, recog)
}</span>

func (s *SelectorContext) Accept(visitor antlr.ParseTreeVisitor) interface{} <span class="cov8" title="679">{
        switch t := visitor.(type) </span>{
        case JSONFilterVisitor:<span class="cov8" title="679">
                return t.VisitSelector(s)</span>

        default:<span class="cov0" title="0">
                return t.VisitChildren(s)</span>
        }
}

func (p *JSONFilterParser) Selector() (localctx ISelectorContext) <span class="cov8" title="720">{
        localctx = NewSelectorContext(p, p.GetParserRuleContext(), p.GetState())
        p.EnterRule(localctx, 8, JSONFilterParserRULE_selector)
        p.EnterOuterAlt(localctx, 1)
        </span><span class="cov8" title="720">{
                p.SetState(49)
                p.Match(JSONFilterParserSEL_START)
                if p.HasError() </span><span class="cov0" title="0">{
                        // Recognition error - abort rule
                        goto errorExit</span>
                }
        }
        <span class="cov8" title="720">{
                p.SetState(50)
                p.Qualifiedidentifier()
        }</span>

errorExit:
        <span class="cov8" title="720">if p.HasError() </span><span class="cov0" title="0">{
                v := p.GetError()
                localctx.SetException(v)
                p.GetErrorHandler().ReportError(p, v)
                p.GetErrorHandler().Recover(p, v)
                p.SetError(nil)
        }</span>
        <span class="cov8" title="720">p.ExitRule()
        return localctx
        goto errorExit</span> // Trick to prevent compiler error if the label is not used
}

// IQualifiedidentifierContext is an interface to support dynamic dispatch.
type IQualifiedidentifierContext interface {
        antlr.ParserRuleContext

        // GetParser returns the parser.
        GetParser() antlr.Parser

        // Getter signatures
        AllMember() []IMemberContext
        Member(i int) IMemberContext
        AllDOT() []antlr.TerminalNode
        DOT(i int) antlr.TerminalNode

        // IsQualifiedidentifierContext differentiates from other interfaces.
        IsQualifiedidentifierContext()
}

type QualifiedidentifierContext struct {
        antlr.BaseParserRuleContext
        parser antlr.Parser
}

func NewEmptyQualifiedidentifierContext() *QualifiedidentifierContext <span class="cov0" title="0">{
        var p = new(QualifiedidentifierContext)
        antlr.InitBaseParserRuleContext(&amp;p.BaseParserRuleContext, nil, -1)
        p.RuleIndex = JSONFilterParserRULE_qualifiedidentifier
        return p
}</span>

func InitEmptyQualifiedidentifierContext(p *QualifiedidentifierContext) <span class="cov0" title="0">{
        antlr.InitBaseParserRuleContext(&amp;p.BaseParserRuleContext, nil, -1)
        p.RuleIndex = JSONFilterParserRULE_qualifiedidentifier
}</span>

func (*QualifiedidentifierContext) IsQualifiedidentifierContext() {<span class="cov0" title="0">}</span>

func NewQualifiedidentifierContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *QualifiedidentifierContext <span class="cov8" title="720">{
        var p = new(QualifiedidentifierContext)

        antlr.InitBaseParserRuleContext(&amp;p.BaseParserRuleContext, parent, invokingState)

        p.parser = parser
        p.RuleIndex = JSONFilterParserRULE_qualifiedidentifier

        return p
}</span>

func (s *QualifiedidentifierContext) GetParser() antlr.Parser <span class="cov0" title="0">{ return s.parser }</span>

func (s *QualifiedidentifierContext) AllMember() []IMemberContext <span class="cov0" title="0">{
        children := s.GetChildren()
        len := 0
        for _, ctx := range children </span><span class="cov0" title="0">{
                if _, ok := ctx.(IMemberContext); ok </span><span class="cov0" title="0">{
                        len++
                }</span>
        }

        <span class="cov0" title="0">tst := make([]IMemberContext, len)
        i := 0
        for _, ctx := range children </span><span class="cov0" title="0">{
                if t, ok := ctx.(IMemberContext); ok </span><span class="cov0" title="0">{
                        tst[i] = t.(IMemberContext)
                        i++
                }</span>
        }

        <span class="cov0" title="0">return tst</span>
}

func (s *QualifiedidentifierContext) Member(i int) IMemberContext <span class="cov0" title="0">{
        var t antlr.RuleContext
        j := 0
        for _, ctx := range s.GetChildren() </span><span class="cov0" title="0">{
                if _, ok := ctx.(IMemberContext); ok </span><span class="cov0" title="0">{
                        if j == i </span><span class="cov0" title="0">{
                                t = ctx.(antlr.RuleContext)
                                break</span>
                        }
                        <span class="cov0" title="0">j++</span>
                }
        }

        <span class="cov0" title="0">if t == nil </span><span class="cov0" title="0">{
                return nil
        }</span>

        <span class="cov0" title="0">return t.(IMemberContext)</span>
}

func (s *QualifiedidentifierContext) AllDOT() []antlr.TerminalNode <span class="cov0" title="0">{
        return s.GetTokens(JSONFilterParserDOT)
}</span>

func (s *QualifiedidentifierContext) DOT(i int) antlr.TerminalNode <span class="cov0" title="0">{
        return s.GetToken(JSONFilterParserDOT, i)
}</span>

func (s *QualifiedidentifierContext) GetRuleContext() antlr.RuleContext <span class="cov0" title="0">{
        return s
}</span>

func (s *QualifiedidentifierContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string <span class="cov0" title="0">{
        return antlr.TreesStringTree(s, ruleNames, recog)
}</span>

func (s *QualifiedidentifierContext) Accept(visitor antlr.ParseTreeVisitor) interface{} <span class="cov0" title="0">{
        switch t := visitor.(type) </span>{
        case JSONFilterVisitor:<span class="cov0" title="0">
                return t.VisitQualifiedidentifier(s)</span>

        default:<span class="cov0" title="0">
                return t.VisitChildren(s)</span>
        }
}

func (p *JSONFilterParser) Qualifiedidentifier() (localctx IQualifiedidentifierContext) <span class="cov8" title="720">{
        localctx = NewQualifiedidentifierContext(p, p.GetParserRuleContext(), p.GetState())
        p.EnterRule(localctx, 10, JSONFilterParserRULE_qualifiedidentifier)
        var _alt int

        p.EnterOuterAlt(localctx, 1)
        </span><span class="cov8" title="720">{
                p.SetState(52)
                p.Member()
        }</span>
        <span class="cov8" title="720">p.SetState(57)
        p.GetErrorHandler().Sync(p)
        if p.HasError() </span><span class="cov0" title="0">{
                goto errorExit</span>
        }
        <span class="cov8" title="720">_alt = p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 4, p.GetParserRuleContext())
        if p.HasError() </span><span class="cov0" title="0">{
                goto errorExit</span>
        }
        <span class="cov8" title="720">for _alt != 2 &amp;&amp; _alt != antlr.ATNInvalidAltNumber </span><span class="cov5" title="50">{
                if _alt == 1 </span><span class="cov5" title="50">{
                        </span><span class="cov5" title="50">{
                                p.SetState(53)
                                p.Match(JSONFilterParserDOT)
                                if p.HasError() </span><span class="cov0" title="0">{
                                        // Recognition error - abort rule
                                        goto errorExit</span>
                                }
                        }
                        <span class="cov5" title="50">{
                                p.SetState(54)
                                p.Member()
                        }</span>

                }
                <span class="cov5" title="50">p.SetState(59)
                p.GetErrorHandler().Sync(p)
                if p.HasError() </span><span class="cov0" title="0">{
                        goto errorExit</span>
                }
                <span class="cov5" title="50">_alt = p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 4, p.GetParserRuleContext())
                if p.HasError() </span><span class="cov0" title="0">{
                        goto errorExit</span>
                }
        }

errorExit:
        <span class="cov8" title="720">if p.HasError() </span><span class="cov0" title="0">{
                v := p.GetError()
                localctx.SetException(v)
                p.GetErrorHandler().ReportError(p, v)
                p.GetErrorHandler().Recover(p, v)
                p.SetError(nil)
        }</span>
        <span class="cov8" title="720">p.ExitRule()
        return localctx
        goto errorExit</span> // Trick to prevent compiler error if the label is not used
}

// IMemberContext is an interface to support dynamic dispatch.
type IMemberContext interface {
        antlr.ParserRuleContext

        // GetParser returns the parser.
        GetParser() antlr.Parser

        // Getter signatures
        INDENTIFIER() antlr.TerminalNode
        AllLBRACKET() []antlr.TerminalNode
        LBRACKET(i int) antlr.TerminalNode
        AllNUMBER() []antlr.TerminalNode
        NUMBER(i int) antlr.TerminalNode
        AllRBRACKET() []antlr.TerminalNode
        RBRACKET(i int) antlr.TerminalNode

        // IsMemberContext differentiates from other interfaces.
        IsMemberContext()
}

type MemberContext struct {
        antlr.BaseParserRuleContext
        parser antlr.Parser
}

func NewEmptyMemberContext() *MemberContext <span class="cov0" title="0">{
        var p = new(MemberContext)
        antlr.InitBaseParserRuleContext(&amp;p.BaseParserRuleContext, nil, -1)
        p.RuleIndex = JSONFilterParserRULE_member
        return p
}</span>

func InitEmptyMemberContext(p *MemberContext) <span class="cov0" title="0">{
        antlr.InitBaseParserRuleContext(&amp;p.BaseParserRuleContext, nil, -1)
        p.RuleIndex = JSONFilterParserRULE_member
}</span>

func (*MemberContext) IsMemberContext() {<span class="cov0" title="0">}</span>

func NewMemberContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *MemberContext <span class="cov8" title="770">{
        var p = new(MemberContext)

        antlr.InitBaseParserRuleContext(&amp;p.BaseParserRuleContext, parent, invokingState)

        p.parser = parser
        p.RuleIndex = JSONFilterParserRULE_member

        return p
}</span>

func (s *MemberContext) GetParser() antlr.Parser <span class="cov0" title="0">{ return s.parser }</span>

func (s *MemberContext) INDENTIFIER() antlr.TerminalNode <span class="cov0" title="0">{
        return s.GetToken(JSONFilterParserINDENTIFIER, 0)
}</span>

func (s *MemberContext) AllLBRACKET() []antlr.TerminalNode <span class="cov0" title="0">{
        return s.GetTokens(JSONFilterParserLBRACKET)
}</span>

func (s *MemberContext) LBRACKET(i int) antlr.TerminalNode <span class="cov0" title="0">{
        return s.GetToken(JSONFilterParserLBRACKET, i)
}</span>

func (s *MemberContext) AllNUMBER() []antlr.TerminalNode <span class="cov0" title="0">{
        return s.GetTokens(JSONFilterParserNUMBER)
}</span>

func (s *MemberContext) NUMBER(i int) antlr.TerminalNode <span class="cov0" title="0">{
        return s.GetToken(JSONFilterParserNUMBER, i)
}</span>

func (s *MemberContext) AllRBRACKET() []antlr.TerminalNode <span class="cov0" title="0">{
        return s.GetTokens(JSONFilterParserRBRACKET)
}</span>

func (s *MemberContext) RBRACKET(i int) antlr.TerminalNode <span class="cov0" title="0">{
        return s.GetToken(JSONFilterParserRBRACKET, i)
}</span>

func (s *MemberContext) GetRuleContext() antlr.RuleContext <span class="cov0" title="0">{
        return s
}</span>

func (s *MemberContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string <span class="cov0" title="0">{
        return antlr.TreesStringTree(s, ruleNames, recog)
}</span>

func (s *MemberContext) Accept(visitor antlr.ParseTreeVisitor) interface{} <span class="cov0" title="0">{
        switch t := visitor.(type) </span>{
        case JSONFilterVisitor:<span class="cov0" title="0">
                return t.VisitMember(s)</span>

        default:<span class="cov0" title="0">
                return t.VisitChildren(s)</span>
        }
}

func (p *JSONFilterParser) Member() (localctx IMemberContext) <span class="cov8" title="770">{
        localctx = NewMemberContext(p, p.GetParserRuleContext(), p.GetState())
        p.EnterRule(localctx, 12, JSONFilterParserRULE_member)
        var _alt int

        p.SetState(69)
        p.GetErrorHandler().Sync(p)
        if p.HasError() </span><span class="cov0" title="0">{
                goto errorExit</span>
        }

        <span class="cov8" title="770">switch p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 6, p.GetParserRuleContext()) </span>{
        case 1:<span class="cov8" title="761">
                p.EnterOuterAlt(localctx, 1)
                </span><span class="cov8" title="761">{
                        p.SetState(60)
                        p.Match(JSONFilterParserINDENTIFIER)
                        if p.HasError() </span><span class="cov0" title="0">{
                                // Recognition error - abort rule
                                goto errorExit</span>
                        }
                }

        case 2:<span class="cov3" title="9">
                p.EnterOuterAlt(localctx, 2)
                </span><span class="cov3" title="9">{
                        p.SetState(61)
                        p.Match(JSONFilterParserINDENTIFIER)
                        if p.HasError() </span><span class="cov0" title="0">{
                                // Recognition error - abort rule
                                goto errorExit</span>
                        }
                }
                <span class="cov3" title="9">p.SetState(65)
                p.GetErrorHandler().Sync(p)
                if p.HasError() </span><span class="cov0" title="0">{
                        goto errorExit</span>
                }
                <span class="cov3" title="9">_alt = 1
                for ok := true; ok; ok = _alt != 2 &amp;&amp; _alt != antlr.ATNInvalidAltNumber </span><span class="cov3" title="11">{
                        switch _alt </span>{
                        case 1:<span class="cov3" title="11">
                                </span><span class="cov3" title="11">{
                                        p.SetState(62)
                                        p.Match(JSONFilterParserLBRACKET)
                                        if p.HasError() </span><span class="cov0" title="0">{
                                                // Recognition error - abort rule
                                                goto errorExit</span>
                                        }
                                }
                                <span class="cov3" title="11">{
                                        p.SetState(63)
                                        p.Match(JSONFilterParserNUMBER)
                                        if p.HasError() </span><span class="cov0" title="0">{
                                                // Recognition error - abort rule
                                                goto errorExit</span>
                                        }
                                }
                                <span class="cov3" title="11">{
                                        p.SetState(64)
                                        p.Match(JSONFilterParserRBRACKET)
                                        if p.HasError() </span><span class="cov0" title="0">{
                                                // Recognition error - abort rule
                                                goto errorExit</span>
                                        }
                                }

                        default:<span class="cov0" title="0">
                                p.SetError(antlr.NewNoViableAltException(p, nil, nil, nil, nil, nil))
                                goto errorExit</span>
                        }

                        <span class="cov3" title="11">p.SetState(67)
                        p.GetErrorHandler().Sync(p)
                        _alt = p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 5, p.GetParserRuleContext())
                        if p.HasError() </span><span class="cov0" title="0">{
                                goto errorExit</span>
                        }
                }

        case antlr.ATNInvalidAltNumber:<span class="cov0" title="0">
                goto errorExit</span>
        }

errorExit:
        <span class="cov8" title="770">if p.HasError() </span><span class="cov0" title="0">{
                v := p.GetError()
                localctx.SetException(v)
                p.GetErrorHandler().ReportError(p, v)
                p.GetErrorHandler().Recover(p, v)
                p.SetError(nil)
        }</span>
        <span class="cov8" title="770">p.ExitRule()
        return localctx
        goto errorExit</span> // Trick to prevent compiler error if the label is not used
}

// IOperatorContext is an interface to support dynamic dispatch.
type IOperatorContext interface {
        antlr.ParserRuleContext

        // GetParser returns the parser.
        GetParser() antlr.Parser

        // Getter signatures
        EQUALS() antlr.TerminalNode
        NOT_EQUALS() antlr.TerminalNode
        IS() antlr.TerminalNode
        NOT() antlr.TerminalNode
        GT() antlr.TerminalNode
        LT() antlr.TerminalNode
        GE() antlr.TerminalNode
        LE() antlr.TerminalNode

        // IsOperatorContext differentiates from other interfaces.
        IsOperatorContext()
}

type OperatorContext struct {
        antlr.BaseParserRuleContext
        parser antlr.Parser
}

func NewEmptyOperatorContext() *OperatorContext <span class="cov0" title="0">{
        var p = new(OperatorContext)
        antlr.InitBaseParserRuleContext(&amp;p.BaseParserRuleContext, nil, -1)
        p.RuleIndex = JSONFilterParserRULE_operator
        return p
}</span>

func InitEmptyOperatorContext(p *OperatorContext) <span class="cov0" title="0">{
        antlr.InitBaseParserRuleContext(&amp;p.BaseParserRuleContext, nil, -1)
        p.RuleIndex = JSONFilterParserRULE_operator
}</span>

func (*OperatorContext) IsOperatorContext() {<span class="cov0" title="0">}</span>

func NewOperatorContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *OperatorContext <span class="cov8" title="720">{
        var p = new(OperatorContext)

        antlr.InitBaseParserRuleContext(&amp;p.BaseParserRuleContext, parent, invokingState)

        p.parser = parser
        p.RuleIndex = JSONFilterParserRULE_operator

        return p
}</span>

func (s *OperatorContext) GetParser() antlr.Parser <span class="cov0" title="0">{ return s.parser }</span>

func (s *OperatorContext) EQUALS() antlr.TerminalNode <span class="cov0" title="0">{
        return s.GetToken(JSONFilterParserEQUALS, 0)
}</span>

func (s *OperatorContext) NOT_EQUALS() antlr.TerminalNode <span class="cov0" title="0">{
        return s.GetToken(JSONFilterParserNOT_EQUALS, 0)
}</span>

func (s *OperatorContext) IS() antlr.TerminalNode <span class="cov0" title="0">{
        return s.GetToken(JSONFilterParserIS, 0)
}</span>

func (s *OperatorContext) NOT() antlr.TerminalNode <span class="cov0" title="0">{
        return s.GetToken(JSONFilterParserNOT, 0)
}</span>

func (s *OperatorContext) GT() antlr.TerminalNode <span class="cov0" title="0">{
        return s.GetToken(JSONFilterParserGT, 0)
}</span>

func (s *OperatorContext) LT() antlr.TerminalNode <span class="cov0" title="0">{
        return s.GetToken(JSONFilterParserLT, 0)
}</span>

func (s *OperatorContext) GE() antlr.TerminalNode <span class="cov0" title="0">{
        return s.GetToken(JSONFilterParserGE, 0)
}</span>

func (s *OperatorContext) LE() antlr.TerminalNode <span class="cov0" title="0">{
        return s.GetToken(JSONFilterParserLE, 0)
}</span>

func (s *OperatorContext) GetRuleContext() antlr.RuleContext <span class="cov0" title="0">{
        return s
}</span>

func (s *OperatorContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string <span class="cov0" title="0">{
        return antlr.TreesStringTree(s, ruleNames, recog)
}</span>

func (s *OperatorContext) Accept(visitor antlr.ParseTreeVisitor) interface{} <span class="cov8" title="679">{
        switch t := visitor.(type) </span>{
        case JSONFilterVisitor:<span class="cov8" title="679">
                return t.VisitOperator(s)</span>

        default:<span class="cov0" title="0">
                return t.VisitChildren(s)</span>
        }
}

func (p *JSONFilterParser) Operator() (localctx IOperatorContext) <span class="cov8" title="720">{
        localctx = NewOperatorContext(p, p.GetParserRuleContext(), p.GetState())
        p.EnterRule(localctx, 14, JSONFilterParserRULE_operator)
        var _la int

        p.EnterOuterAlt(localctx, 1)
        </span><span class="cov8" title="720">{
                p.SetState(71)
                _la = p.GetTokenStream().LA(1)

                if !((int64(_la) &amp; ^0x3f) == 0 &amp;&amp; ((int64(1)&lt;&lt;_la)&amp;1044480) != 0) </span><span class="cov1" title="1">{
                        p.GetErrorHandler().RecoverInline(p)
                }</span> else<span class="cov8" title="719"> {
                        p.GetErrorHandler().ReportMatch(p)
                        p.Consume()
                }</span>
        }

errorExit:
        <span class="cov8" title="720">if p.HasError() </span><span class="cov0" title="0">{
                v := p.GetError()
                localctx.SetException(v)
                p.GetErrorHandler().ReportError(p, v)
                p.GetErrorHandler().Recover(p, v)
                p.SetError(nil)
        }</span>
        <span class="cov8" title="720">p.ExitRule()
        return localctx
        goto errorExit</span> // Trick to prevent compiler error if the label is not used
}

// ILiteralContext is an interface to support dynamic dispatch.
type ILiteralContext interface {
        antlr.ParserRuleContext

        // GetParser returns the parser.
        GetParser() antlr.Parser

        // Getter signatures
        AllNUMBER() []antlr.TerminalNode
        NUMBER(i int) antlr.TerminalNode
        AllDOT() []antlr.TerminalNode
        DOT(i int) antlr.TerminalNode
        AllSTAR() []antlr.TerminalNode
        STAR(i int) antlr.TerminalNode
        STRING() antlr.TerminalNode
        NULL() antlr.TerminalNode
        EXISTS() antlr.TerminalNode
        TRUE() antlr.TerminalNode
        FALSE() antlr.TerminalNode
        INDENTIFIER() antlr.TerminalNode

        // IsLiteralContext differentiates from other interfaces.
        IsLiteralContext()
}

type LiteralContext struct {
        antlr.BaseParserRuleContext
        parser antlr.Parser
}

func NewEmptyLiteralContext() *LiteralContext <span class="cov0" title="0">{
        var p = new(LiteralContext)
        antlr.InitBaseParserRuleContext(&amp;p.BaseParserRuleContext, nil, -1)
        p.RuleIndex = JSONFilterParserRULE_literal
        return p
}</span>

func InitEmptyLiteralContext(p *LiteralContext) <span class="cov0" title="0">{
        antlr.InitBaseParserRuleContext(&amp;p.BaseParserRuleContext, nil, -1)
        p.RuleIndex = JSONFilterParserRULE_literal
}</span>

func (*LiteralContext) IsLiteralContext() {<span class="cov0" title="0">}</span>

func NewLiteralContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *LiteralContext <span class="cov8" title="720">{
        var p = new(LiteralContext)

        antlr.InitBaseParserRuleContext(&amp;p.BaseParserRuleContext, parent, invokingState)

        p.parser = parser
        p.RuleIndex = JSONFilterParserRULE_literal

        return p
}</span>

func (s *LiteralContext) GetParser() antlr.Parser <span class="cov0" title="0">{ return s.parser }</span>

func (s *LiteralContext) AllNUMBER() []antlr.TerminalNode <span class="cov0" title="0">{
        return s.GetTokens(JSONFilterParserNUMBER)
}</span>

func (s *LiteralContext) NUMBER(i int) antlr.TerminalNode <span class="cov0" title="0">{
        return s.GetToken(JSONFilterParserNUMBER, i)
}</span>

func (s *LiteralContext) AllDOT() []antlr.TerminalNode <span class="cov0" title="0">{
        return s.GetTokens(JSONFilterParserDOT)
}</span>

func (s *LiteralContext) DOT(i int) antlr.TerminalNode <span class="cov0" title="0">{
        return s.GetToken(JSONFilterParserDOT, i)
}</span>

func (s *LiteralContext) AllSTAR() []antlr.TerminalNode <span class="cov0" title="0">{
        return s.GetTokens(JSONFilterParserSTAR)
}</span>

func (s *LiteralContext) STAR(i int) antlr.TerminalNode <span class="cov0" title="0">{
        return s.GetToken(JSONFilterParserSTAR, i)
}</span>

func (s *LiteralContext) STRING() antlr.TerminalNode <span class="cov0" title="0">{
        return s.GetToken(JSONFilterParserSTRING, 0)
}</span>

func (s *LiteralContext) NULL() antlr.TerminalNode <span class="cov0" title="0">{
        return s.GetToken(JSONFilterParserNULL, 0)
}</span>

func (s *LiteralContext) EXISTS() antlr.TerminalNode <span class="cov0" title="0">{
        return s.GetToken(JSONFilterParserEXISTS, 0)
}</span>

func (s *LiteralContext) TRUE() antlr.TerminalNode <span class="cov0" title="0">{
        return s.GetToken(JSONFilterParserTRUE, 0)
}</span>

func (s *LiteralContext) FALSE() antlr.TerminalNode <span class="cov0" title="0">{
        return s.GetToken(JSONFilterParserFALSE, 0)
}</span>

func (s *LiteralContext) INDENTIFIER() antlr.TerminalNode <span class="cov0" title="0">{
        return s.GetToken(JSONFilterParserINDENTIFIER, 0)
}</span>

func (s *LiteralContext) GetRuleContext() antlr.RuleContext <span class="cov0" title="0">{
        return s
}</span>

func (s *LiteralContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string <span class="cov0" title="0">{
        return antlr.TreesStringTree(s, ruleNames, recog)
}</span>

func (s *LiteralContext) Accept(visitor antlr.ParseTreeVisitor) interface{} <span class="cov8" title="679">{
        switch t := visitor.(type) </span>{
        case JSONFilterVisitor:<span class="cov8" title="679">
                return t.VisitLiteral(s)</span>

        default:<span class="cov0" title="0">
                return t.VisitChildren(s)</span>
        }
}

func (p *JSONFilterParser) Literal() (localctx ILiteralContext) <span class="cov8" title="720">{
        localctx = NewLiteralContext(p, p.GetParserRuleContext(), p.GetState())
        p.EnterRule(localctx, 16, JSONFilterParserRULE_literal)
        var _la int

        var _alt int

        p.SetState(87)
        p.GetErrorHandler().Sync(p)
        if p.HasError() </span><span class="cov0" title="0">{
                goto errorExit</span>
        }

        <span class="cov8" title="720">switch p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 8, p.GetParserRuleContext()) </span>{
        case 1:<span class="cov1" title="2">
                p.EnterOuterAlt(localctx, 1)
                </span><span class="cov1" title="2">{
                        p.SetState(73)
                        p.Match(JSONFilterParserNUMBER)
                        if p.HasError() </span><span class="cov0" title="0">{
                                // Recognition error - abort rule
                                goto errorExit</span>
                        }
                }
                <span class="cov1" title="2">p.SetState(76)
                p.GetErrorHandler().Sync(p)
                if p.HasError() </span><span class="cov0" title="0">{
                        goto errorExit</span>
                }
                <span class="cov1" title="2">_alt = 1
                for ok := true; ok; ok = _alt != 2 &amp;&amp; _alt != antlr.ATNInvalidAltNumber </span><span class="cov1" title="2">{
                        switch _alt </span>{
                        case 1:<span class="cov1" title="2">
                                </span><span class="cov1" title="2">{
                                        p.SetState(74)
                                        p.Match(JSONFilterParserDOT)
                                        if p.HasError() </span><span class="cov0" title="0">{
                                                // Recognition error - abort rule
                                                goto errorExit</span>
                                        }
                                }
                                <span class="cov1" title="2">{
                                        p.SetState(75)
                                        _la = p.GetTokenStream().LA(1)

                                        if !(_la == JSONFilterParserSTAR || _la == JSONFilterParserNUMBER) </span><span class="cov0" title="0">{
                                                p.GetErrorHandler().RecoverInline(p)
                                        }</span> else<span class="cov1" title="2"> {
                                                p.GetErrorHandler().ReportMatch(p)
                                                p.Consume()
                                        }</span>
                                }

                        default:<span class="cov0" title="0">
                                p.SetError(antlr.NewNoViableAltException(p, nil, nil, nil, nil, nil))
                                goto errorExit</span>
                        }

                        <span class="cov1" title="2">p.SetState(78)
                        p.GetErrorHandler().Sync(p)
                        _alt = p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 7, p.GetParserRuleContext())
                        if p.HasError() </span><span class="cov0" title="0">{
                                goto errorExit</span>
                        }
                }

        case 2:<span class="cov6" title="168">
                p.EnterOuterAlt(localctx, 2)
                </span><span class="cov6" title="168">{
                        p.SetState(80)
                        p.Match(JSONFilterParserSTRING)
                        if p.HasError() </span><span class="cov0" title="0">{
                                // Recognition error - abort rule
                                goto errorExit</span>
                        }
                }

        case 3:<span class="cov2" title="3">
                p.EnterOuterAlt(localctx, 3)
                </span><span class="cov2" title="3">{
                        p.SetState(81)
                        p.Match(JSONFilterParserNUMBER)
                        if p.HasError() </span><span class="cov0" title="0">{
                                // Recognition error - abort rule
                                goto errorExit</span>
                        }
                }

        case 4:<span class="cov1" title="1">
                p.EnterOuterAlt(localctx, 4)
                </span><span class="cov1" title="1">{
                        p.SetState(82)
                        p.Match(JSONFilterParserNULL)
                        if p.HasError() </span><span class="cov0" title="0">{
                                // Recognition error - abort rule
                                goto errorExit</span>
                        }
                }

        case 5:<span class="cov3" title="8">
                p.EnterOuterAlt(localctx, 5)
                </span><span class="cov3" title="8">{
                        p.SetState(83)
                        p.Match(JSONFilterParserEXISTS)
                        if p.HasError() </span><span class="cov0" title="0">{
                                // Recognition error - abort rule
                                goto errorExit</span>
                        }
                }

        case 6:<span class="cov1" title="1">
                p.EnterOuterAlt(localctx, 6)
                </span><span class="cov1" title="1">{
                        p.SetState(84)
                        p.Match(JSONFilterParserTRUE)
                        if p.HasError() </span><span class="cov0" title="0">{
                                // Recognition error - abort rule
                                goto errorExit</span>
                        }
                }

        case 7:<span class="cov0" title="0">
                p.EnterOuterAlt(localctx, 7)
                </span><span class="cov0" title="0">{
                        p.SetState(85)
                        p.Match(JSONFilterParserFALSE)
                        if p.HasError() </span><span class="cov0" title="0">{
                                // Recognition error - abort rule
                                goto errorExit</span>
                        }
                }

        case 8:<span class="cov7" title="537">
                p.EnterOuterAlt(localctx, 8)
                </span><span class="cov7" title="537">{
                        p.SetState(86)
                        p.Match(JSONFilterParserINDENTIFIER)
                        if p.HasError() </span><span class="cov0" title="0">{
                                // Recognition error - abort rule
                                goto errorExit</span>
                        }
                }

        case antlr.ATNInvalidAltNumber:<span class="cov0" title="0">
                goto errorExit</span>
        }

errorExit:
        <span class="cov8" title="720">if p.HasError() </span><span class="cov0" title="0">{
                v := p.GetError()
                localctx.SetException(v)
                p.GetErrorHandler().ReportError(p, v)
                p.GetErrorHandler().Recover(p, v)
                p.SetError(nil)
        }</span>
        <span class="cov8" title="720">p.ExitRule()
        return localctx
        goto errorExit</span> // Trick to prevent compiler error if the label is not used
}

func (p *JSONFilterParser) Sempred(localctx antlr.RuleContext, ruleIndex, predIndex int) bool <span class="cov0" title="0">{
        switch ruleIndex </span>{
        case 2:<span class="cov0" title="0">
                var t *Filter_exprContext = nil
                if localctx != nil </span><span class="cov0" title="0">{
                        t = localctx.(*Filter_exprContext)
                }</span>
                <span class="cov0" title="0">return p.Filter_expr_Sempred(t, predIndex)</span>

        default:<span class="cov0" title="0">
                panic("No predicate with index: " + fmt.Sprint(ruleIndex))</span>
        }
}

func (p *JSONFilterParser) Filter_expr_Sempred(localctx antlr.RuleContext, predIndex int) bool <span class="cov0" title="0">{
        switch predIndex </span>{
        case 0:<span class="cov0" title="0">
                return p.Precpred(p.GetParserRuleContext(), 3)</span>

        case 1:<span class="cov0" title="0">
                return p.Precpred(p.GetParserRuleContext(), 2)</span>

        default:<span class="cov0" title="0">
                panic("No predicate with index: " + fmt.Sprint(predIndex))</span>
        }
}
</pre>
		
		<pre class="file" id="file84" style="display: none">package parser // JSONFilter

import (
        "github.com/antlr4-go/antlr/v4"
)

const (
        AND = "&amp;&amp;"
        OR  = "||"
)

type AWSJSONFilter struct {
        FilterExpression interface{} `json:"_kics_filter_expr"`
}

type FilterExp struct {
        Op    interface{} `json:"_op"`
        Left  interface{} `json:"_left"`
        Right interface{} `json:"_right"`
}

type FilterSelector struct {
        Selector interface{} `json:"_selector"`
        Op       interface{} `json:"_op"`
        Value    interface{} `json:"_value"`
}

type JSONFilterTreeVisitor struct {
        *antlr.BaseParseTreeVisitor
}

func NewJSONFilterPrinterVisitor() *JSONFilterTreeVisitor <span class="cov6" title="156">{
        return &amp;JSONFilterTreeVisitor{
                &amp;antlr.BaseParseTreeVisitor{},
        }
}</span>

func (v *JSONFilterTreeVisitor) VisitAll(tree antlr.ParseTree) AWSJSONFilter <span class="cov6" title="154">{
        return AWSJSONFilter{
                FilterExpression: v.Visit(tree),
        }
}</span>

func (v *JSONFilterTreeVisitor) Visit(tree antlr.ParseTree) interface{} <span class="cov10" title="4882">{
        return tree.Accept(v)
}</span>

func (v *JSONFilterTreeVisitor) VisitChildren(node antlr.RuleNode) interface{} <span class="cov0" title="0">{
        children := node.GetChildren()
        for _, child := range children </span><span class="cov0" title="0">{
                child.(antlr.ParseTree).Accept(v)
        }</span>
        <span class="cov0" title="0">return nil</span>
}

func (v *JSONFilterTreeVisitor) VisitAwsjsonfilter(ctx *AwsjsonfilterContext) interface{} <span class="cov6" title="154">{
        return v.Visit(ctx.Dotnotation())
}</span>

func (v *JSONFilterTreeVisitor) VisitDotnotation(ctx *DotnotationContext) interface{} <span class="cov6" title="154">{
        return v.Visit(ctx.Filter_expr())
}</span>

func (v *JSONFilterTreeVisitor) VisitFilter_expr_parenthesized(ctx *Filter_expr_parenthesizedContext) interface{} <span class="cov7" title="654">{
        return v.Visit(ctx.Filter_expr())
}</span>

func (v *JSONFilterTreeVisitor) VisitFilter_expr_and(ctx *Filter_expr_andContext) interface{} <span class="cov5" title="75">{
        return FilterExp{
                Op:    AND,
                Left:  v.Visit(ctx.GetLhs()),
                Right: v.Visit(ctx.GetRhs()),
        }
}</span>

func (v *JSONFilterTreeVisitor) VisitFilter_expr_exp(ctx *Filter_expr_expContext) interface{} <span class="cov7" title="679">{
        return v.Visit(ctx.Exp())
}</span>

func (v *JSONFilterTreeVisitor) VisitFilter_expr_or(ctx *Filter_expr_orContext) interface{} <span class="cov7" title="450">{
        return FilterExp{
                Op:    OR,
                Left:  v.Visit(ctx.GetLhs()),
                Right: v.Visit(ctx.GetRhs()),
        }
}</span>

func (v *JSONFilterTreeVisitor) VisitQualifiedidentifier(ctx *QualifiedidentifierContext) interface{} <span class="cov0" title="0">{
        return v.VisitChildren(ctx)
}</span>

func (v *JSONFilterTreeVisitor) VisitExp(ctx *ExpContext) interface{} <span class="cov7" title="679">{
        var value interface{}
        if ctx.Literal() != nil </span><span class="cov7" title="679">{
                value = v.Visit(ctx.Literal())
        }</span> else<span class="cov0" title="0"> {
                value = v.Visit(ctx.Qualifiedidentifier())
        }</span>
        <span class="cov7" title="679">selector := FilterSelector{
                Selector: v.Visit(ctx.Selector()),
                Op:       v.Visit(ctx.Operator()),
                Value:    value,
        }

        return selector</span>
}

func (v *JSONFilterTreeVisitor) VisitSelector(ctx *SelectorContext) interface{} <span class="cov7" title="679">{
        return ctx.GetText()
}</span>

func (v *JSONFilterTreeVisitor) VisitMember(ctx *MemberContext) interface{} <span class="cov0" title="0">{
        return ctx.GetText()
}</span>

func (v *JSONFilterTreeVisitor) VisitOperator(ctx *OperatorContext) interface{} <span class="cov7" title="679">{
        return ctx.GetText()
}</span>

func (v *JSONFilterTreeVisitor) VisitLiteral(ctx *LiteralContext) interface{} <span class="cov7" title="679">{
        return ctx.GetText()
}</span>
</pre>
		
		<pre class="file" id="file85" style="display: none">package parser

import (
        "bytes"
        "errors"
        "os"
        "strings"

        "github.com/Checkmarx/kics/v2/pkg/model"
        "github.com/Checkmarx/kics/v2/pkg/utils"
        "github.com/rs/zerolog/log"
)

type kindParser interface {
        GetKind() model.FileKind
        GetCommentToken() string
        SupportedExtensions() []string
        SupportedTypes() map[string]bool
        Parse(filePath string, fileContent []byte) ([]model.Document, []int, error)
        Resolve(fileContent []byte, filename string, _ bool, _ int) ([]byte, error)
        StringifyContent(content []byte) (string, error)
        GetResolvedFiles() map[string]model.ResolvedFile
}

// Builder is a representation of parsers that will be construct
type Builder struct {
        parsers []kindParser
}

// NewBuilder creates a new Builder's reference
func NewBuilder() *Builder <span class="cov4" title="5">{
        log.Debug().Msg("parser.NewBuilder()")
        return &amp;Builder{}
}</span>

// Add is a function that adds a new parser to the caller and returns it
func (b *Builder) Add(p kindParser) *Builder <span class="cov6" title="11">{
        b.parsers = append(b.parsers, p)
        return b
}</span>

// Build prepares parsers and associates a parser to its extension and returns it
func (b *Builder) Build(types, cloudProviders []string) ([]*Parser, error) <span class="cov4" title="5">{
        parserSlice := make([]*Parser, 0, len(b.parsers))
        for _, parser := range b.parsers </span><span class="cov6" title="11">{
                supportedTypes := parser.SupportedTypes()
                if contains(types, supportedTypes) </span><span class="cov6" title="11">{
                        extensions := make(model.Extensions, len(b.parsers))
                        var platforms []string
                        for _, ext := range parser.SupportedExtensions() </span><span class="cov9" title="31">{
                                extensions[ext] = struct{}{}
                        }</span>
                        <span class="cov6" title="11">for key := range supportedTypes </span><span class="cov10" title="46">{
                                platforms = append(platforms, key)
                        }</span>
                        <span class="cov6" title="11">parserSlice = append(parserSlice, &amp;Parser{
                                parsers:    parser,
                                extensions: extensions,
                                Platform:   platforms,
                        })</span>
                }
        }

        <span class="cov4" title="5">return parserSlice, nil</span>
}

// ErrNotSupportedFile represents an error when a file is not supported by KICS
var ErrNotSupportedFile = errors.New("unsupported file to parse")

// Parser is a struct that associates a parser to its supported extensions
type Parser struct {
        parsers    kindParser
        extensions model.Extensions
        Platform   []string
}

// ParsedDocument is a struct containing data retrieved from parsing
type ParsedDocument struct {
        Docs          []model.Document
        Kind          model.FileKind
        Content       string
        IgnoreLines   []int
        CountLines    int
        ResolvedFiles map[string]model.ResolvedFile
        IsMinified    bool
}

// CommentsCommands gets commands on comments in the file beginning, before the code starts
func (c *Parser) CommentsCommands(filePath string, fileContent []byte) model.CommentsCommands <span class="cov1" title="1">{
        if c.isValidExtension(filePath) </span><span class="cov1" title="1">{
                commentsCommands := make(model.CommentsCommands)
                commentToken := c.parsers.GetCommentToken()
                if commentToken != "" </span><span class="cov1" title="1">{
                        lines := strings.Split(string(fileContent), "\n")
                        for _, line := range lines </span><span class="cov4" title="4">{
                                line = strings.TrimSpace(line)
                                if line == "" </span><span class="cov1" title="1">{
                                        continue</span>
                                }
                                <span class="cov3" title="3">if strings.HasSuffix(filePath, ".yaml") &amp;&amp; strings.HasPrefix(line, "---") </span><span class="cov0" title="0">{
                                        continue</span>
                                }

                                <span class="cov3" title="3">if !strings.HasPrefix(line, commentToken) </span><span class="cov1" title="1">{
                                        break</span>
                                }

                                <span class="cov2" title="2">fields := strings.Fields(strings.TrimSpace(strings.TrimPrefix(line, commentToken)))
                                if len(fields) &gt; 1 &amp;&amp; fields[0] == "kics-scan" &amp;&amp; fields[1] != "" </span><span class="cov2" title="2">{
                                        commandParameters := strings.SplitN(fields[1], "=", 2)
                                        if len(commandParameters) &gt; 1 </span><span class="cov1" title="1">{
                                                commentsCommands[commandParameters[0]] = commandParameters[1]
                                        }</span> else<span class="cov1" title="1"> {
                                                commentsCommands[commandParameters[0]] = ""
                                        }</span>
                                }
                        }
                }
                <span class="cov1" title="1">return commentsCommands</span>
        }
        <span class="cov0" title="0">return nil</span>
}

// Parse executes a parser on the fileContent and returns the file content as a Document, the file kind and
// an error, if an error has occurred
func (c *Parser) Parse(
        filePath string,
        fileContent []byte,
        openAPIResolveReferences, isMinified bool,
        maxResolverDepth int) (ParsedDocument, error) <span class="cov3" title="3">{
        fileContent = utils.DecryptAnsibleVault(fileContent, os.Getenv("ANSIBLE_VAULT_PASSWORD_FILE"))

        if c.isValidExtension(filePath) </span><span class="cov3" title="3">{
                resolved, err := c.parsers.Resolve(fileContent, filePath, openAPIResolveReferences, maxResolverDepth)
                if err != nil </span><span class="cov0" title="0">{
                        return ParsedDocument{}, err
                }</span>
                <span class="cov3" title="3">obj, igLines, err := c.parsers.Parse(filePath, resolved)
                if err != nil </span><span class="cov0" title="0">{
                        return ParsedDocument{}, err
                }</span>

                <span class="cov3" title="3">cont, err := c.parsers.StringifyContent(fileContent)
                if err != nil </span><span class="cov0" title="0">{
                        log.Error().Msgf("failed to stringify original content: %s", err)
                        cont = string(fileContent)
                }</span>

                <span class="cov3" title="3">return ParsedDocument{
                        Docs:          obj,
                        Kind:          c.parsers.GetKind(),
                        Content:       cont,
                        IgnoreLines:   igLines,
                        CountLines:    bytes.Count(resolved, []byte{'\n'}) + 1,
                        ResolvedFiles: c.parsers.GetResolvedFiles(),
                        IsMinified:    isMinified,
                }, nil</span>
        }
        <span class="cov0" title="0">return ParsedDocument{
                Docs:        nil,
                Kind:        "break",
                Content:     "",
                IgnoreLines: []int{},
        }, ErrNotSupportedFile</span>
}

// SupportedExtensions returns extensions supported by KICS
func (c *Parser) SupportedExtensions() model.Extensions <span class="cov4" title="4">{
        return c.extensions
}</span>

func contains(types []string, supportedTypes map[string]bool) bool <span class="cov7" title="13">{
        if types[0] == "" </span><span class="cov6" title="11">{
                return true
        }</span>

        <span class="cov2" title="2">for _, t := range types </span><span class="cov2" title="2">{
                if _, ok := supportedTypes[strings.ToLower(t)]; ok </span><span class="cov1" title="1">{
                        return true
                }</span>
        }

        <span class="cov1" title="1">return false</span>
}

func (c *Parser) isValidExtension(filePath string) bool <span class="cov5" title="7">{
        ext, _ := utils.GetExtension(filePath)
        _, ok := c.extensions[ext]
        return ok
}</span>
</pre>
		
		<pre class="file" id="file86" style="display: none">package comment

import (
        "strings"

        "github.com/Checkmarx/kics/v2/pkg/model"
        "github.com/hashicorp/hcl/v2"
        "github.com/hashicorp/hcl/v2/hclsyntax"
)

// comment is a comment token
type comment hclsyntax.Token

// position returns the position of the comment
func (c *comment) position() hcl.Pos <span class="cov5" title="16">{
        return hcl.Pos{Line: c.Range.End.Line + 1, Column: c.Range.End.Column, Byte: c.Range.End.Byte}
}</span>

// value returns the value of a comment
func (c *comment) value() (value model.CommentCommand) <span class="cov4" title="10">{
        comment := strings.ToLower(string(c.Bytes))
        // check if we are working with kics command
        if model.KICSCommentRgxp.MatchString(comment) </span><span class="cov4" title="8">{
                comment = model.KICSCommentRgxp.ReplaceAllString(comment, "")
                comment = strings.Trim(comment, "\n")
                commands := strings.Split(strings.Trim(comment, "\r"), " ")
                value = model.ProcessCommands(commands)
                return
        }</span>
        <span class="cov2" title="2">return model.CommentCommand(comment)</span>
}

// Ignore is a map of commands to ignore
type Ignore map[model.CommentCommand][]hcl.Pos

// Build builds the Ignore map
func (i *Ignore) build(ignoreLine, ignoreBlock, ignoreComment []hcl.Pos) <span class="cov4" title="9">{
        ignoreStruct := map[model.CommentCommand][]hcl.Pos{
                model.IgnoreLine:    ignoreLine,
                model.IgnoreBlock:   ignoreBlock,
                model.IgnoreComment: ignoreComment,
        }

        *i = ignoreStruct
}</span>

// ///////////////////////////
//     LINES TO IGNORE      //
// ///////////////////////////

// GetIgnoreLines returns the lines to ignore from a comment
func GetIgnoreLines(ignore Ignore, body *hclsyntax.Body) (lines []int) <span class="cov3" title="5">{
        lines = make([]int, 0)
        for _, position := range ignore[model.IgnoreBlock] </span><span class="cov3" title="4">{
                lines = append(lines, checkBlock(body, position)...)
        }</span>
        <span class="cov3" title="5">lines = append(lines, getLinesFromPos(ignore[model.IgnoreLine])...)
        lines = append(lines, getLinesFromPos(ignore[model.IgnoreComment])...)
        return</span>
}

// getLinesFromPos will return a list of lines from a list of positions
func getLinesFromPos(positions []hcl.Pos) (lines []int) <span class="cov4" title="10">{
        lines = make([]int, 0)
        for _, position := range positions </span><span class="cov3" title="4">{
                lines = append(lines, position.Line)
        }</span>
        <span class="cov4" title="10">return</span>
}

// checkBlock checks if the position is inside a block and returns the lines to ignore
func checkBlock(body *hclsyntax.Body, position hcl.Pos) (lines []int) <span class="cov3" title="4">{
        lines = make([]int, 0)
        blocks := body.BlocksAtPos(position)

        for _, block := range blocks </span><span class="cov2" title="2">{
                lines = append(lines, getLinesFromBlock(block, position)...)
        }</span>
        <span class="cov3" title="4">return</span>
}

// getLinesFromBlock returns the lines to ignore from a block
func getLinesFromBlock(block *hcl.Block, position hcl.Pos) (lines []int) <span class="cov2" title="2">{
        lines = make([]int, 0)
        if checkBlockRange(block, position) </span><span class="cov1" title="1">{
                rangeBlock := block.Body.(*hclsyntax.Body).Range()
                lines = append(lines, model.Range(rangeBlock.Start.Line, rangeBlock.End.Line)...)
        }</span> else<span class="cov1" title="1"> {
                // check in attributes
                attribute := block.Body.(*hclsyntax.Body).AttributeAtPos(position)
                lines = append(lines, getLinesFromAttr(attribute)...)
        }</span>
        <span class="cov2" title="2">return</span>
}

// getLinesFromAttr returns the lines to ignore from an attribute
func getLinesFromAttr(atr *hcl.Attribute) (lines []int) <span class="cov1" title="1">{
        lines = make([]int, 0)
        if atr == nil </span><span class="cov0" title="0">{
                return
        }</span>

        <span class="cov1" title="1">lines = append(lines, model.Range(atr.Range.Start.Line, atr.Range.End.Line)...)
        return</span>
}

// checkBlockRange checks if the position is inside a block
func checkBlockRange(block *hcl.Block, position hcl.Pos) bool <span class="cov2" title="2">{
        return block.TypeRange.End == position
}</span>

// ///////////////////////////
//     COMMENT PARSER       //
// ///////////////////////////

// ParseComments parses the comments and returns the kics commands
func ParseComments(src []byte, filename string) (Ignore, error) <span class="cov4" title="9">{
        comments, diags := hclsyntax.LexConfig(src, filename, hcl.Pos{Line: 0, Column: 0})
        if diags != nil &amp;&amp; diags.HasErrors() </span><span class="cov0" title="0">{
                return Ignore{}, diags.Errs()[0]
        }</span>

        <span class="cov4" title="9">ig := processTokens(comments)

        return ig, nil</span>
}

// processTokens goes over the tokens and returns the kics commands
func processTokens(tokens hclsyntax.Tokens) (ig Ignore) <span class="cov4" title="9">{
        ignoreLines := make([]hcl.Pos, 0)
        ignoreBlocks := make([]hcl.Pos, 0)
        ignoreComments := make([]hcl.Pos, 0)
        for i := range tokens </span><span class="cov10" title="311">{
                // token is not a comment
                if tokens[i].Type != hclsyntax.TokenComment || i+1 &gt; len(tokens) </span><span class="cov9" title="298">{
                        continue</span>
                }
                // case: CONFIGURATION = X # comment
                <span class="cov5" title="13">if i &gt; 0 &amp;&amp; tokens[i-1].Range.Start.Line == tokens[i].Range.Start.Line </span><span class="cov2" title="3">{
                        continue</span>
                }
                <span class="cov4" title="10">ignoreLines, ignoreBlocks, ignoreComments = processComment((*comment)(&amp;tokens[i]),
                        (*comment)(&amp;tokens[i+1]), ignoreLines, ignoreBlocks, ignoreComments)</span>
        }
        <span class="cov4" title="9">ig = make(map[model.CommentCommand][]hcl.Pos)
        ig.build(ignoreLines, ignoreBlocks, ignoreComments)
        return ig</span>
}

// processComment analyzes the comment to determine which type of kics command the comment is
func processComment(comment *comment, tokenToIgnore *comment,
        ignoreLine, ignoreBlock, ignoreComments []hcl.Pos) (ignoreLineR, ignoreBlockR, ignoreCommentsR []hcl.Pos) <span class="cov4" title="10">{
        ignoreLineR = ignoreLine
        ignoreBlockR = ignoreBlock
        ignoreCommentsR = ignoreComments

        switch comment.value() </span>{
        case model.IgnoreLine:<span class="cov2" title="2">
                // comment is of type kics ignore-line
                ignoreLineR = append(ignoreLineR, tokenToIgnore.position(), hcl.Pos{Line: comment.position().Line - 1})</span>
        case model.IgnoreBlock:<span class="cov3" title="4">
                // comment is of type kics ignore-block
                ignoreBlockR = append(ignoreBlockR, tokenToIgnore.position(), hcl.Pos{Line: comment.position().Line - 1})</span>
        default:<span class="cov3" title="4">
                // comment is not of type kics ignore
                ignoreCommentsR = append(ignoreCommentsR, hcl.Pos{Line: comment.position().Line - 1})
                return</span>
        }

        <span class="cov3" title="6">return</span>
}
</pre>
		
		<pre class="file" id="file87" style="display: none">package converter

import (
        "fmt"
        "strconv"
        "strings"

        sentryReport "github.com/Checkmarx/kics/v2/internal/sentry"
        "github.com/Checkmarx/kics/v2/pkg/model"
        "github.com/Checkmarx/kics/v2/pkg/parser/terraform/functions"
        "github.com/hashicorp/hcl/v2"
        "github.com/hashicorp/hcl/v2/hclsyntax"
        "github.com/rs/zerolog/log"
        "github.com/zclconf/go-cty/cty"
        ctyconvert "github.com/zclconf/go-cty/cty/convert"
        ctyjson "github.com/zclconf/go-cty/cty/json"
)

// VariableMap represents a set of terraform input variables
type VariableMap map[string]cty.Value

var inputVarMap = make(VariableMap)

// This file is attributed to https://github.com/tmccombs/hcl2json.
// convertBlock() is manipulated for combining the both blocks and labels for one given resource.

// DefaultConverted an hcl File to a toJson serializable object
// This assumes that the body is a hclsyntax.Body
var DefaultConverted = func(file *hcl.File, inputVariables VariableMap) (model.Document, error) <span class="cov4" title="6">{
        inputVarMap = inputVariables
        c := converter{bytes: file.Bytes}
        body, err := c.convertBody(file.Body.(*hclsyntax.Body), 0)

        if err != nil </span><span class="cov0" title="0">{
                sentryReport.ReportSentry(&amp;sentryReport.Report{
                        Location: "var DefaultConverted",
                        Err:      err,
                        Kind:     model.KindTerraform,
                        Message:  "Failed to convert body in terraform parser",
                }, false)
                if er, ok := err.(*hcl.Diagnostic); ok &amp;&amp; er.Subject != nil </span><span class="cov0" title="0">{
                        return nil, err
                }</span>

                <span class="cov0" title="0">return nil, err</span>
        }

        <span class="cov4" title="6">return body, nil</span>
}

type converter struct {
        bytes []byte
}

const kicsLinesKey = "_kics_"

func (c *converter) rangeSource(r hcl.Range) string <span class="cov8" title="37">{
        return string(c.bytes[r.Start.Byte:r.End.Byte])
}</span>

func (c *converter) convertBody(body *hclsyntax.Body, defLine int) (model.Document, error) <span class="cov8" title="28">{
        var err error
        var v string
        countValue := body.Attributes["count"]
        count := -1

        if countValue != nil </span><span class="cov0" title="0">{
                value, err := countValue.Expr.Value(nil)
                if err == nil </span><span class="cov0" title="0">{
                        switch value.Type() </span>{
                        case cty.String:<span class="cov0" title="0">
                                v = value.AsString()</span>
                        case cty.Number:<span class="cov0" title="0">
                                v = value.AsBigFloat().String()</span>
                        }

                        <span class="cov0" title="0">intValue, err := strconv.Atoi(v)
                        if err == nil </span><span class="cov0" title="0">{
                                count = intValue
                        }</span>
                }
        }

        <span class="cov8" title="28">if count == 0 </span><span class="cov0" title="0">{
                return nil, nil
        }</span>

        <span class="cov8" title="28">out := make(model.Document)
        kicsS := make(map[string]model.LineObject)
        // set kics line for the body
        kicsS["_kics__default"] = model.LineObject{
                Line: defLine,
        }

        if body.Attributes != nil </span><span class="cov8" title="28">{
                for key, value := range body.Attributes </span><span class="cov8" title="36">{
                        out[key], err = c.convertExpression(value.Expr)
                        // set kics line for the body value
                        kicsS[kicsLinesKey+key] = model.LineObject{
                                Line: value.SrcRange.Start.Line,
                                Arr:  c.getArrLines(value.Expr),
                        }
                        if err != nil </span><span class="cov0" title="0">{
                                sentryReport.ReportSentry(&amp;sentryReport.Report{
                                        Location: "func convertBody",
                                        Err:      err,
                                        Kind:     model.KindTerraform,
                                        Message:  "Failed to convert Expression in terraform parser",
                                }, false)
                                return nil, err
                        }</span>
                }
        }

        <span class="cov8" title="28">for _, block := range body.Blocks </span><span class="cov7" title="18">{
                // set kics line for block
                kicsS[kicsLinesKey+block.Type] = model.LineObject{
                        Line: block.TypeRange.Start.Line,
                }
                err = c.convertBlock(block, out, block.TypeRange.Start.Line)
                if err != nil </span><span class="cov0" title="0">{
                        sentryReport.ReportSentry(&amp;sentryReport.Report{
                                Location: "func convertBody",
                                Err:      err,
                                Kind:     model.KindTerraform,
                                Message:  "Failed to convert block in terraform parser",
                        }, false)
                        return nil, err
                }</span>
        }

        <span class="cov8" title="28">out["_kics_lines"] = kicsS

        return out, nil</span>
}

// getArrLines will get line information for the array elements
func (c *converter) getArrLines(expr hclsyntax.Expression) []map[string]*model.LineObject <span class="cov8" title="36">{
        arr := make([]map[string]*model.LineObject, 0)
        if v, ok := expr.(*hclsyntax.TupleConsExpr); ok </span><span class="cov3" title="3">{
                for _, ex := range v.Exprs </span><span class="cov5" title="8">{
                        arrEx := make(map[string]*model.LineObject)
                        // set default line of array
                        arrEx["_kics__default"] = &amp;model.LineObject{
                                Line: ex.Range().Start.Line,
                        }
                        switch valType := ex.(type) </span>{
                        case *hclsyntax.ObjectConsExpr:<span class="cov3" title="3">
                                arrEx["_kics__default"] = &amp;model.LineObject{
                                        Line: ex.Range().Start.Line + 1,
                                }
                                // set lines for array elements
                                for _, item := range valType.Items </span><span class="cov4" title="6">{
                                        key, err := c.convertKey(item.KeyExpr)
                                        if err != nil </span><span class="cov0" title="0">{
                                                sentryReport.ReportSentry(&amp;sentryReport.Report{
                                                        Location: "func getArrLines",
                                                        Err:      err,
                                                        Kind:     model.KindTerraform,
                                                        Message:  "Failed to convert key in terraform parser",
                                                }, false)
                                                return nil
                                        }</span>
                                        <span class="cov4" title="6">arrEx[kicsLinesKey+key] = &amp;model.LineObject{
                                                Line: item.KeyExpr.Range().Start.Line,
                                        }</span>
                                }
                        case *hclsyntax.TupleConsExpr:<span class="cov0" title="0">
                                // set lines for array elements if type is different than array, map/object
                                arrEx["_kics__default"] = &amp;model.LineObject{
                                        Arr: c.getArrLines(valType),
                                }</span>
                        }

                        <span class="cov5" title="8">arr = append(arr, arrEx)</span>
                }
        }
        <span class="cov8" title="36">return arr</span>
}

func (c *converter) convertBlock(block *hclsyntax.Block, out model.Document, defLine int) error <span class="cov7" title="18">{
        var key = block.Type
        value, err := c.convertBody(block.Body, defLine)

        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>

        <span class="cov7" title="18">if value == nil </span><span class="cov0" title="0">{
                return nil
        }</span>

        <span class="cov7" title="18">for _, label := range block.Labels </span><span class="cov7" title="16">{
                if inner, exists := out[key]; exists </span><span class="cov2" title="2">{
                        var ok bool
                        out, ok = inner.(model.Document)
                        if !ok </span><span class="cov0" title="0">{
                                return fmt.Errorf("unable to convert Block to JSON: %v.%v", block.Type, strings.Join(block.Labels, "."))
                        }</span>
                } else<span class="cov6" title="14"> {
                        obj := make(model.Document)
                        out[key] = obj
                        out = obj
                }</span>
                <span class="cov7" title="16">key = label</span>
        }

        <span class="cov7" title="18">if current, exists := out[key]; exists </span><span class="cov3" title="3">{
                if list, ok := current.([]interface{}); ok </span><span class="cov1" title="1">{
                        out[key] = append(list, value)
                }</span> else<span class="cov2" title="2"> {
                        out[key] = []interface{}{current, value}
                }</span>
        } else<span class="cov6" title="15"> {
                out[key] = value
        }</span>

        <span class="cov7" title="18">return nil</span>
}

func (c *converter) convertExpression(expr hclsyntax.Expression) (interface{}, error) <span class="cov10" title="64">{
        // assume it is hcl syntax (because, um, it is)
        switch value := expr.(type) </span>{
        case *hclsyntax.LiteralValueExpr:<span class="cov5" title="10">
                return ctyjson.SimpleJSONValue{Value: value.Val}, nil</span>
        case *hclsyntax.TemplateExpr:<span class="cov7" title="24">
                return c.convertTemplate(value)</span>
        case *hclsyntax.TemplateWrapExpr:<span class="cov2" title="2">
                return c.convertExpression(value.Wrapped)</span>
        case *hclsyntax.TupleConsExpr:<span class="cov3" title="3">
                list := make([]interface{}, 0)
                for _, ex := range value.Exprs </span><span class="cov5" title="8">{
                        elem, err := c.convertExpression(ex)
                        if err != nil </span><span class="cov0" title="0">{
                                sentryReport.ReportSentry(&amp;sentryReport.Report{
                                        Location: "func convertExpression",
                                        Err:      err,
                                        Kind:     model.KindTerraform,
                                        Message:  "Failed to convert expression in terraform parser",
                                }, false)
                                return nil, err
                        }</span>
                        <span class="cov5" title="8">list = append(list, elem)</span>
                }
                <span class="cov3" title="3">return list, nil</span>
        case *hclsyntax.ObjectConsExpr:<span class="cov4" title="5">
                return c.objectConsExpr(value)</span>
        case *hclsyntax.FunctionCallExpr:<span class="cov4" title="6">
                return c.evalFunction(expr)</span>
        case *hclsyntax.ConditionalExpr:<span class="cov1" title="1">
                expressionEvaluated, err := expr.Value(&amp;hcl.EvalContext{
                        Variables: inputVarMap,
                        Functions: functions.TerraformFuncs,
                })
                if err != nil </span><span class="cov1" title="1">{
                        return c.wrapExpr(expr)
                }</span>
                <span class="cov0" title="0">return ctyjson.SimpleJSONValue{Value: expressionEvaluated}, nil</span>
        default:<span class="cov6" title="13">
                // try to evaluate with variables and functions
                valueConverted, _ := expr.Value(&amp;hcl.EvalContext{
                        Variables: inputVarMap,
                        Functions: functions.TerraformFuncs,
                })
                if !checkDynamicKnownTypes(valueConverted) </span><span class="cov4" title="6">{
                        return ctyjson.SimpleJSONValue{Value: valueConverted}, nil
                }</span>
                <span class="cov5" title="7">return c.wrapExpr(expr)</span>
        }
}

func checkValue(val cty.Value) bool <span class="cov4" title="4">{
        if val.Type().HasDynamicTypes() || !val.IsKnown() </span><span class="cov2" title="2">{
                return true
        }</span>
        <span class="cov2" title="2">if !val.Type().IsPrimitiveType() &amp;&amp; checkDynamicKnownTypes(val) </span><span class="cov2" title="2">{
                return true
        }</span>
        <span class="cov0" title="0">return false</span>
}

func checkDynamicKnownTypes(valueConverted cty.Value) bool <span class="cov6" title="15">{
        if !valueConverted.Type().HasDynamicTypes() &amp;&amp; valueConverted.IsKnown() </span><span class="cov5" title="10">{
                if valueConverted.Type().FriendlyName() == "tuple" </span><span class="cov2" title="2">{
                        for _, val := range valueConverted.AsValueSlice() </span><span class="cov2" title="2">{
                                if checkValue(val) </span><span class="cov2" title="2">{
                                        return true
                                }</span>
                        }
                }
                <span class="cov5" title="8">if valueConverted.Type().FriendlyName() == "object" </span><span class="cov2" title="2">{
                        for _, val := range valueConverted.AsValueMap() </span><span class="cov2" title="2">{
                                if checkValue(val) </span><span class="cov2" title="2">{
                                        return true
                                }</span>
                        }
                }
                <span class="cov4" title="6">return false</span>
        }
        <span class="cov4" title="5">return true</span>
}

func (c *converter) objectConsExpr(value *hclsyntax.ObjectConsExpr) (model.Document, error) <span class="cov4" title="5">{
        m := make(model.Document)
        for _, item := range value.Items </span><span class="cov7" title="18">{
                key, err := c.convertKey(item.KeyExpr)
                if err != nil </span><span class="cov0" title="0">{
                        sentryReport.ReportSentry(&amp;sentryReport.Report{
                                Location: "func objectConsExpr",
                                Err:      err,
                                Kind:     model.KindTerraform,
                                Message:  "Failed to convert key in terraform parser",
                        }, false)
                        return nil, err
                }</span>
                <span class="cov7" title="18">m[key], err = c.convertExpression(item.ValueExpr)
                if err != nil </span><span class="cov0" title="0">{
                        sentryReport.ReportSentry(&amp;sentryReport.Report{
                                Location: "func objectConsExpr",
                                Err:      err,
                                Kind:     model.KindTerraform,
                                Message:  "Failed to convert expression in terraform parser",
                        }, false)
                        return nil, err
                }</span>
        }
        <span class="cov4" title="5">return m, nil</span>
}

func (c *converter) convertKey(keyExpr hclsyntax.Expression) (string, error) <span class="cov7" title="24">{
        // a key should never have dynamic input
        if k, isKeyExpr := keyExpr.(*hclsyntax.ObjectConsKeyExpr); isKeyExpr </span><span class="cov7" title="24">{
                keyExpr = k.Wrapped
                if _, isTraversal := keyExpr.(*hclsyntax.ScopeTraversalExpr); isTraversal </span><span class="cov7" title="20">{
                        return c.rangeSource(keyExpr.Range()), nil
                }</span>
        }
        <span class="cov4" title="4">return c.convertStringPart(keyExpr)</span>
}

func (c *converter) convertTemplate(t *hclsyntax.TemplateExpr) (string, error) <span class="cov8" title="32">{
        if t.IsStringLiteral() </span><span class="cov7" title="25">{
                // safe because the value is just the string
                v, err := t.Value(nil)
                if err != nil </span><span class="cov0" title="0">{
                        return "", err
                }</span>
                <span class="cov7" title="25">return v.AsString(), nil</span>
        }
        <span class="cov5" title="7">builder := &amp;strings.Builder{}
        for _, part := range t.Parts </span><span class="cov7" title="19">{
                s, err := c.convertStringPart(part)
                if err != nil </span><span class="cov0" title="0">{
                        sentryReport.ReportSentry(&amp;sentryReport.Report{
                                Location: "func convertTemplate",
                                Err:      err,
                                Kind:     model.KindTerraform,
                                Message:  "Failed to convert string part in terraform parser",
                        }, false)
                        return "", err
                }</span>
                <span class="cov7" title="19">builder.WriteString(s)</span>
        }

        <span class="cov5" title="7">s := builder.String()

        builder.Reset()
        builder = nil

        return s, nil</span>
}

func (c *converter) convertStringPart(expr hclsyntax.Expression) (string, error) <span class="cov8" title="29">{
        switch v := expr.(type) </span>{
        case *hclsyntax.LiteralValueExpr:<span class="cov6" title="11">
                s, err := ctyconvert.Convert(v.Val, cty.String)
                if err != nil </span><span class="cov0" title="0">{
                        sentryReport.ReportSentry(&amp;sentryReport.Report{
                                Location: "func convertStringPart",
                                Err:      err,
                                Kind:     model.KindTerraform,
                                Message:  "Failed to cty convert in terraform parser",
                        }, false)
                        return "", err
                }</span>
                <span class="cov6" title="11">return s.AsString(), nil</span>
        case *hclsyntax.TemplateExpr:<span class="cov5" title="8">
                return c.convertTemplate(v)</span>
        case *hclsyntax.TemplateWrapExpr:<span class="cov1" title="1">
                return c.convertStringPart(v.Wrapped)</span>
        case *hclsyntax.ConditionalExpr:<span class="cov2" title="2">
                return c.convertTemplateConditional(v)</span>
        case *hclsyntax.TemplateJoinExpr:<span class="cov1" title="1">
                return c.convertTemplateFor(v.Tuple.(*hclsyntax.ForExpr))</span>
        case *hclsyntax.ParenthesesExpr:<span class="cov0" title="0">
                return c.convertStringPart(v.Expression)</span>
        default:<span class="cov4" title="6">
                // try to evaluate with variables
                valueConverted, _ := expr.Value(&amp;hcl.EvalContext{
                        Variables: inputVarMap,
                })
                if valueConverted.Type().FriendlyName() == "string" </span><span class="cov1" title="1">{
                        return valueConverted.AsString(), nil
                }</span>
                // treating as an embedded expression
                <span class="cov4" title="5">return c.wrapExpr(expr)</span>
        }
}

func (c *converter) convertTemplateConditional(expr *hclsyntax.ConditionalExpr) (string, error) <span class="cov2" title="2">{
        builder := &amp;strings.Builder{}
        builder.WriteString("%{if ")
        builder.WriteString(c.rangeSource(expr.Condition.Range()))
        builder.WriteString("}")
        trueResult, err := c.convertStringPart(expr.TrueResult)
        if err != nil </span><span class="cov0" title="0">{
                sentryReport.ReportSentry(&amp;sentryReport.Report{
                        Location: "func convertTemplateConditional",
                        Err:      err,
                        Kind:     model.KindTerraform,
                        Message:  "Failed to convert string part terraform parser",
                }, false)
                return "", nil
        }</span>
        <span class="cov2" title="2">builder.WriteString(trueResult)
        falseResult, err := c.convertStringPart(expr.FalseResult)
        if err != nil </span><span class="cov0" title="0">{
                sentryReport.ReportSentry(&amp;sentryReport.Report{
                        Location: "func convertTemplateConditional",
                        Err:      err,
                        Kind:     model.KindTerraform,
                        Message:  "Failed to convert string part terraform parser",
                }, false)
                return "", nil
        }</span>
        <span class="cov2" title="2">if falseResult != "" </span><span class="cov1" title="1">{
                builder.WriteString("%{else}")
                builder.WriteString(falseResult)
        }</span>
        <span class="cov2" title="2">builder.WriteString("%{endif}")

        s := builder.String()

        builder.Reset()
        builder = nil

        return s, nil</span>
}

func (c *converter) convertTemplateFor(expr *hclsyntax.ForExpr) (string, error) <span class="cov1" title="1">{
        builder := &amp;strings.Builder{}
        builder.WriteString("%{for ")
        if expr.KeyVar != "" </span><span class="cov0" title="0">{
                builder.WriteString(expr.KeyVar)
                builder.WriteString(", ")
        }</span>
        <span class="cov1" title="1">builder.WriteString(expr.ValVar)
        builder.WriteString(" in ")
        builder.WriteString(c.rangeSource(expr.CollExpr.Range()))
        builder.WriteString("}")
        templ, err := c.convertStringPart(expr.ValExpr)
        if err != nil </span><span class="cov0" title="0">{
                sentryReport.ReportSentry(&amp;sentryReport.Report{
                        Location: "func convertTemplateFor",
                        Err:      err,
                        Kind:     model.KindTerraform,
                        Message:  "Failed to convert string part terraform parser",
                }, false)
                return "", err
        }</span>
        <span class="cov1" title="1">builder.WriteString(templ)
        builder.WriteString("%{endfor}")

        s := builder.String()

        builder.Reset()
        builder = nil
        return s, nil</span>
}

func (c *converter) wrapExpr(expr hclsyntax.Expression) (string, error) <span class="cov6" title="13">{
        expression := c.rangeSource(expr.Range())
        if strings.HasPrefix(expression, "var.") </span><span class="cov3" title="3">{
                log.Trace().Msgf("Variable ${%s} value not found", expression)
        }</span>
        <span class="cov6" title="13">return "${" + expression + "}", nil</span>
}

func (c *converter) evalFunction(expression hclsyntax.Expression) (interface{}, error) <span class="cov4" title="6">{
        expressionEvaluated, err := expression.Value(&amp;hcl.EvalContext{
                Variables: inputVarMap,
                Functions: functions.TerraformFuncs,
        })
        if err != nil </span><span class="cov1" title="1">{
                for _, expressionError := range err </span><span class="cov1" title="1">{
                        if expressionError.Summary == "Unknown variable" </span><span class="cov1" title="1">{
                                jsonPath := c.rangeSource(expressionError.Expression.Range())
                                rootKey := strings.Split(jsonPath, ".")[0]
                                if strings.Contains(jsonPath, ".") </span><span class="cov1" title="1">{
                                        jsonCtyValue, convertErr := createEntryInputVar(strings.Split(jsonPath, ".")[1:], jsonPath)
                                        if convertErr != nil </span><span class="cov0" title="0">{
                                                return c.wrapExpr(expression)
                                        }</span>
                                        <span class="cov1" title="1">inputVarMap[rootKey] = jsonCtyValue</span>
                                } else<span class="cov0" title="0"> {
                                        inputVarMap[rootKey] = cty.StringVal(jsonPath)
                                }</span>
                        }
                }
                <span class="cov1" title="1">expressionEvaluated, err = expression.Value(&amp;hcl.EvalContext{
                        Variables: inputVarMap,
                        Functions: functions.TerraformFuncs,
                })
                if err != nil </span><span class="cov0" title="0">{
                        return c.wrapExpr(expression)
                }</span>
        }
        <span class="cov4" title="6">if !expressionEvaluated.HasWhollyKnownType() </span><span class="cov0" title="0">{
                // in some cases, the expression is evaluated with no error but the type is unknown.
                // this causes the json marshaling of the Document later on to fail with an error, and the entire scan fails.
                // Therefore, we prefer to wrap it as a string and continue the scan.
                return c.wrapExpr(expression)
        }</span>
        <span class="cov4" title="6">return ctyjson.SimpleJSONValue{Value: expressionEvaluated}, nil</span>
}

func createEntryInputVar(path []string, defaultValue string) (cty.Value, error) <span class="cov1" title="1">{
        mapJSON := "{"
        closeMap := "}"
        for idx, key := range path </span><span class="cov1" title="1">{
                if idx+1 &lt; len(path) </span><span class="cov0" title="0">{
                        mapJSON += fmt.Sprintf("%q:{", key)
                        closeMap += "}"
                }</span> else<span class="cov1" title="1"> {
                        mapJSON += fmt.Sprintf("%q: %q", key, defaultValue)
                }</span>
        }
        <span class="cov1" title="1">mapJSON += closeMap
        jsonType, err := ctyjson.ImpliedType([]byte(mapJSON))
        if err != nil </span><span class="cov0" title="0">{
                return cty.NilVal, err
        }</span>
        <span class="cov1" title="1">value, err := ctyjson.Unmarshal([]byte(mapJSON), jsonType)
        if err != nil </span><span class="cov0" title="0">{
                return cty.NilVal, err
        }</span>
        <span class="cov1" title="1">return value, nil</span>
}
</pre>
		
		<pre class="file" id="file88" style="display: none">package terraform

import (
        "bytes"
        "encoding/json"
        "path/filepath"
        "sync"

        "github.com/Checkmarx/kics/v2/pkg/builder/engine"
        "github.com/Checkmarx/kics/v2/pkg/parser/terraform/functions"
        "github.com/hashicorp/hcl/v2"
        "github.com/hashicorp/hcl/v2/hcldec"
        "github.com/hashicorp/hcl/v2/hclsyntax"
        "github.com/rs/zerolog/log"
        "github.com/zclconf/go-cty/cty"
        "github.com/zclconf/go-cty/cty/gocty"
        ctyjson "github.com/zclconf/go-cty/cty/json"
)

type dataSourcePolicyCondition struct {
        Test     string   `json:"test,omitempty"`
        Variable string   `json:"variable,omitempty"`
        Values   []string `json:"values,omitempty"`
}

type dataSourcePolicyPrincipal struct {
        Type        string   `json:"type,omitempty"`
        Identifiers []string `json:"identifiers,omitempty"`
}

type dataSourcePolicyStatement struct {
        Actions       []string                  `json:"actions"`
        Condition     dataSourcePolicyCondition `json:"condition"`
        Effect        string                    `json:"effect"`
        NotActions    []string                  `json:"not_actions"`
        NotPrincipals dataSourcePolicyPrincipal `json:"not_principals"`
        NotResources  []string                  `json:"not_resources"`
        Principals    dataSourcePolicyPrincipal `json:"principals"`
        Resources     []string                  `json:"resources"`
        Sid           string                    `json:"sid"`
}

type dataSourcePolicy struct {
        ID        string                      `json:"id"`
        Statement []dataSourcePolicyStatement `json:"statement"`
        Version   string                      `json:"version"`
}

type dataSource struct {
        Value dataSourcePolicy `json:"value"`
}

type convertedPolicyCondition map[string]map[string][]string
type convertedPolicyPrincipal map[string][]string

type convertedPolicyStatement struct {
        Actions       []string                 `json:"Actions,omitempty"`
        Condition     convertedPolicyCondition `json:"Condition,omitempty"`
        Effect        string                   `json:"Effect,omitempty"`
        NotActions    []string                 `json:"Not_actions,omitempty"`
        NotPrincipals convertedPolicyPrincipal `json:"Not_principals,omitempty"`
        NotResources  []string                 `json:"Not_resources,omitempty"`
        Principals    convertedPolicyPrincipal `json:"Principals,omitempty"`
        Resources     []string                 `json:"Resources,omitempty"`
        Sid           string                   `json:"Sid,omitempty"`
}

type convertedPolicy struct {
        ID        string                     `json:"Id,omitempty"`
        Statement []convertedPolicyStatement `json:"Statement,omitempty"`
        Version   string                     `json:"Version,omitempty"`
}

var mutexData = &amp;sync.Mutex{}

func getDataSourcePolicy(currentPath string) <span class="cov5" title="3">{
        tfFiles, err := filepath.Glob(filepath.Join(currentPath, "*.tf"))
        if err != nil </span><span class="cov0" title="0">{
                log.Error().Msg("Error getting .tf files to parse data source")
                return
        }</span>
        <span class="cov5" title="3">if len(tfFiles) == 0 </span><span class="cov1" title="1">{
                return
        }</span>
        <span class="cov4" title="2">jsonMap := make(map[string]map[string]string)
        for _, tfFile := range tfFiles </span><span class="cov7" title="4">{
                parsedFile, parseErr := parseFile(tfFile, true)
                if parseErr != nil </span><span class="cov0" title="0">{
                        log.Debug().Msgf("Error trying to parse file %s for data source.", tfFile)
                        continue</span>
                }
                <span class="cov7" title="4">body, ok := parsedFile.Body.(*hclsyntax.Body)
                if !ok </span><span class="cov0" title="0">{
                        continue</span>
                }
                <span class="cov7" title="4">for _, block := range body.Blocks </span><span class="cov10" title="8">{
                        if block.Type == "data" &amp;&amp; block.Labels[0] == "aws_iam_policy_document" &amp;&amp; len(block.Labels) &gt; 1 </span><span class="cov7" title="4">{
                                policyJSON := parseDataSourceBody(block.Body)
                                jsonMap[block.Labels[1]] = map[string]string{
                                        "json": policyJSON,
                                }
                        }</span>
                }
        }
        <span class="cov4" title="2">policyResource := map[string]map[string]map[string]string{
                "aws_iam_policy_document": jsonMap,
        }
        data, err := gocty.ToCtyValue(policyResource, cty.Map(cty.Map(cty.Map(cty.String))))
        if err != nil </span><span class="cov0" title="0">{
                log.Error().Msgf("Error trying to convert policy to cty value: %s", err)
                return
        }</span>

        <span class="cov4" title="2">mutexData.Lock()
        inputVariableMap["data"] = data
        mutexData.Unlock()</span>
}

func decodeDataSourcePolicy(value cty.Value) dataSourcePolicy <span class="cov7" title="4">{
        jsonified, err := ctyjson.Marshal(value, cty.DynamicPseudoType)
        if err != nil </span><span class="cov0" title="0">{
                log.Error().Msgf("Error trying to decode data source block: %s", err)
                return dataSourcePolicy{}
        }</span>
        <span class="cov7" title="4">var data dataSource
        err = json.Unmarshal(jsonified, &amp;data)
        if err != nil </span><span class="cov0" title="0">{
                log.Error().Msgf("Error trying to encode data source json: %s", err)
                return dataSourcePolicy{}
        }</span>
        <span class="cov7" title="4">return data.Value</span>
}

func getPrincipalSpec() *hcldec.ObjectSpec <span class="cov10" title="8">{
        return &amp;hcldec.ObjectSpec{
                "type": &amp;hcldec.AttrSpec{
                        Name:     "type",
                        Type:     cty.String,
                        Required: false,
                },
                "identifiers": &amp;hcldec.AttrSpec{
                        Name:     "identifiers",
                        Type:     cty.List(cty.String),
                        Required: false,
                },
        }
}</span>

func getConditionalSpec() *hcldec.ObjectSpec <span class="cov7" title="4">{
        return &amp;hcldec.ObjectSpec{
                "test": &amp;hcldec.AttrSpec{
                        Name:     "test",
                        Type:     cty.String,
                        Required: false,
                },
                "variable": &amp;hcldec.AttrSpec{
                        Name:     "variable",
                        Type:     cty.String,
                        Required: false,
                },
                "values": &amp;hcldec.AttrSpec{
                        Name:     "values",
                        Type:     cty.List(cty.String),
                        Required: false,
                },
        }
}</span>

func getStatementSpec() *hcldec.BlockListSpec <span class="cov7" title="4">{
        return &amp;hcldec.BlockListSpec{
                TypeName: "statement",
                Nested: &amp;hcldec.ObjectSpec{
                        "sid": &amp;hcldec.AttrSpec{
                                Name:     "sid",
                                Type:     cty.String,
                                Required: false,
                        },
                        "effect": &amp;hcldec.AttrSpec{
                                Name:     "effect",
                                Type:     cty.String,
                                Required: false,
                        },
                        "actions": &amp;hcldec.AttrSpec{
                                Name:     "actions",
                                Type:     cty.List(cty.String),
                                Required: false,
                        },
                        "not_actions": &amp;hcldec.AttrSpec{
                                Name:     "not_actions",
                                Type:     cty.List(cty.String),
                                Required: false,
                        },
                        "resources": &amp;hcldec.AttrSpec{
                                Name:     "resources",
                                Type:     cty.List(cty.String),
                                Required: false,
                        },
                        "not_resources": &amp;hcldec.AttrSpec{
                                Name:     "not_resources",
                                Type:     cty.List(cty.String),
                                Required: false,
                        },
                        "principals": &amp;hcldec.BlockSpec{
                                TypeName: "principals",
                                Nested:   getPrincipalSpec(),
                        },
                        "not_principals": &amp;hcldec.BlockSpec{
                                TypeName: "not_principals",
                                Nested:   getPrincipalSpec(),
                        },
                        "condition": &amp;hcldec.BlockSpec{
                                TypeName: "condition",
                                Nested:   getConditionalSpec(),
                        },
                },
        }
}</span>

func parseDataSourceBody(body *hclsyntax.Body) string <span class="cov7" title="4">{
        dataSourceSpec := &amp;hcldec.ObjectSpec{
                "id": &amp;hcldec.AttrSpec{
                        Name:     "id",
                        Type:     cty.String,
                        Required: false,
                },
                "version": &amp;hcldec.AttrSpec{
                        Name:     "version",
                        Type:     cty.String,
                        Required: false,
                },
                "statement": getStatementSpec(),
        }

        resolveDataResources(body)

        target, decodeErrs := hcldec.Decode(body, dataSourceSpec, &amp;hcl.EvalContext{
                Variables: inputVariableMap,
                Functions: functions.TerraformFuncs,
        })

        // check decode errors
        for _, decErr := range decodeErrs </span><span class="cov0" title="0">{
                if decErr.Summary != "Unknown variable" </span><span class="cov0" title="0">{
                        log.Debug().Msgf("Error trying to eval data source block: %s", decErr.Summary)
                        return ""
                }</span>
                <span class="cov0" title="0">log.Debug().Msg("Dismissed Error when decoding policy: Found unknown variable")</span>
        }

        <span class="cov7" title="4">dataSourceJSON := decodeDataSourcePolicy(target)
        convertedDataSource := convertedPolicy{
                ID:      dataSourceJSON.ID,
                Version: dataSourceJSON.Version,
        }
        statements := make([]convertedPolicyStatement, len(dataSourceJSON.Statement))
        for idx := range dataSourceJSON.Statement </span><span class="cov10" title="8">{
                var convertedCondition convertedPolicyCondition
                if dataSourceJSON.Statement[idx].Condition.Variable != "" </span><span class="cov4" title="2">{
                        convertedCondition = convertedPolicyCondition{
                                dataSourceJSON.Statement[idx].Condition.Test: map[string][]string{
                                        dataSourceJSON.Statement[idx].Condition.Variable: dataSourceJSON.Statement[idx].Condition.Values,
                                },
                        }
                }</span>
                <span class="cov10" title="8">var convertedPrincipal convertedPolicyPrincipal
                if dataSourceJSON.Statement[idx].Principals.Type != "" </span><span class="cov4" title="2">{
                        convertedPrincipal = convertedPolicyPrincipal{
                                dataSourceJSON.Statement[idx].Principals.Type: dataSourceJSON.Statement[idx].Principals.Identifiers,
                        }
                }</span>
                <span class="cov10" title="8">var convertedNotPrincipal convertedPolicyPrincipal
                if dataSourceJSON.Statement[idx].NotPrincipals.Type != "" </span><span class="cov0" title="0">{
                        convertedNotPrincipal = convertedPolicyPrincipal{
                                dataSourceJSON.Statement[idx].NotPrincipals.Type: dataSourceJSON.Statement[idx].NotPrincipals.Identifiers,
                        }
                }</span>

                <span class="cov10" title="8">convertedStatement := convertedPolicyStatement{
                        Actions:       dataSourceJSON.Statement[idx].Actions,
                        Effect:        dataSourceJSON.Statement[idx].Effect,
                        NotActions:    dataSourceJSON.Statement[idx].NotActions,
                        NotResources:  dataSourceJSON.Statement[idx].NotResources,
                        Resources:     dataSourceJSON.Statement[idx].Resources,
                        Sid:           dataSourceJSON.Statement[idx].Sid,
                        Condition:     convertedCondition,
                        NotPrincipals: convertedNotPrincipal,
                        Principals:    convertedPrincipal,
                }
                statements[idx] = convertedStatement</span>
        }
        <span class="cov7" title="4">convertedDataSource.Statement = statements
        buffer := &amp;bytes.Buffer{}
        encoder := json.NewEncoder(buffer)
        encoder.SetEscapeHTML(false)
        err := encoder.Encode(convertedDataSource)
        if err != nil </span><span class="cov0" title="0">{
                log.Error().Msgf("Error trying to encoding data source json: %s", err)
                return ""
        }</span>
        <span class="cov7" title="4">return buffer.String()</span>
}

// resolveDataResources resolves the data resources expressions into LiteralValueExpr
func resolveDataResources(body *hclsyntax.Body) <span class="cov7" title="4">{
        for _, block := range body.Blocks </span><span class="cov10" title="8">{
                if resources, ok := block.Body.Attributes["resources"]; ok &amp;&amp;
                        block.Type == "statement" </span><span class="cov8" title="6">{
                        resolveTuple(resources.Expr)
                }</span>
        }
}

func resolveTuple(expr hclsyntax.Expression) <span class="cov8" title="6">{
        e := engine.Engine{}
        if v, ok := expr.(*hclsyntax.TupleConsExpr); ok </span><span class="cov8" title="6">{
                for i, ex := range v.Exprs </span><span class="cov10" title="8">{
                        striExpr, err := e.ExpToString(ex)

                        if err != nil </span><span class="cov0" title="0">{
                                log.Error().Msgf("Error trying to ExpToString: %s", err)
                        }</span>

                        <span class="cov10" title="8">v.Exprs[i] = &amp;hclsyntax.LiteralValueExpr{
                                Val:      cty.StringVal(striExpr),
                                SrcRange: v.Exprs[i].Range(),
                        }</span>
                }
        }
}
</pre>
		
		<pre class="file" id="file89" style="display: none">package functions

import (
        "encoding/base64"

        "github.com/zclconf/go-cty/cty"
        "github.com/zclconf/go-cty/cty/function"
        "github.com/zclconf/go-cty/cty/function/stdlib"
)

// Base64EncodeFunc - https://www.terraform.io/docs/language/functions/base64encode.html
var Base64EncodeFunc = function.New(&amp;function.Spec{
        Params: []function.Parameter{
                {
                        Name:             "val",
                        Type:             cty.DynamicPseudoType,
                        AllowDynamicType: true,
                        AllowNull:        true,
                },
        },
        Type: function.StaticReturnType(cty.String),
        Impl: func(args []cty.Value, retType cty.Type) (cty.Value, error) <span class="cov10" title="9">{
                val := args[0]
                if !val.IsWhollyKnown() </span><span class="cov0" title="0">{
                        // We can't serialize unknowns, so if the value is unknown or
                        // contains any _nested_ unknowns then our result must be
                        // unknown.
                        return cty.UnknownVal(retType), nil
                }</span>

                <span class="cov10" title="9">if val.IsNull() </span><span class="cov0" title="0">{
                        return cty.StringVal("null"), nil
                }</span>

                <span class="cov10" title="9">encoded := base64.StdEncoding.EncodeToString([]byte(val.AsString()))

                return cty.StringVal(encoded), nil</span>
        },
})

// TerraformFuncs contains all functions, if KICS has to override a function
// it should create a file in this package and add/change this function key here
var TerraformFuncs = map[string]function.Function{
        "abs":             stdlib.AbsoluteFunc,
        "base64encode":    Base64EncodeFunc,
        "ceil":            stdlib.CeilFunc,
        "chomp":           stdlib.ChompFunc,
        "coalescelist":    stdlib.CoalesceListFunc,
        "compact":         stdlib.CompactFunc,
        "concat":          stdlib.ConcatFunc,
        "contains":        stdlib.ContainsFunc,
        "csvdecode":       stdlib.CSVDecodeFunc,
        "distinct":        stdlib.DistinctFunc,
        "element":         stdlib.ElementFunc,
        "chunklist":       stdlib.ChunklistFunc,
        "flatten":         stdlib.FlattenFunc,
        "floor":           stdlib.FloorFunc,
        "format":          stdlib.FormatFunc,
        "formatdate":      stdlib.FormatDateFunc,
        "formatlist":      stdlib.FormatListFunc,
        "indent":          stdlib.IndentFunc,
        "join":            stdlib.JoinFunc,
        "jsondecode":      stdlib.JSONDecodeFunc,
        "jsonencode":      stdlib.JSONEncodeFunc,
        "keys":            stdlib.KeysFunc,
        "log":             stdlib.LogFunc,
        "lower":           stdlib.LowerFunc,
        "max":             stdlib.MaxFunc,
        "merge":           stdlib.MergeFunc,
        "min":             stdlib.MinFunc,
        "parseint":        stdlib.ParseIntFunc,
        "pow":             stdlib.PowFunc,
        "range":           stdlib.RangeFunc,
        "regex":           stdlib.RegexFunc,
        "regexall":        stdlib.RegexAllFunc,
        "reverse":         stdlib.ReverseListFunc,
        "setintersection": stdlib.SetIntersectionFunc,
        "setproduct":      stdlib.SetProductFunc,
        "setsubtract":     stdlib.SetSubtractFunc,
        "setunion":        stdlib.SetUnionFunc,
        "signum":          stdlib.SignumFunc,
        "slice":           stdlib.SliceFunc,
        "sort":            stdlib.SortFunc,
        "split":           stdlib.SplitFunc,
        "strrev":          stdlib.ReverseFunc,
        "substr":          stdlib.SubstrFunc,
        "timeadd":         stdlib.TimeAddFunc,
        "title":           stdlib.TitleFunc,
        "trim":            stdlib.TrimFunc,
        "trimprefix":      stdlib.TrimPrefixFunc,
        "trimspace":       stdlib.TrimSpaceFunc,
        "trimsuffix":      stdlib.TrimSuffixFunc,
        "upper":           stdlib.UpperFunc,
        "values":          stdlib.ValuesFunc,
        "zipmap":          stdlib.ZipmapFunc,
}
</pre>
		
		<pre class="file" id="file90" style="display: none">package terraform

import (
        "os"
        "path/filepath"
        "regexp"

        "github.com/Checkmarx/kics/v2/pkg/model"
        "github.com/Checkmarx/kics/v2/pkg/parser/terraform/comment"
        "github.com/Checkmarx/kics/v2/pkg/parser/terraform/converter"
        "github.com/Checkmarx/kics/v2/pkg/parser/utils"
        masterUtils "github.com/Checkmarx/kics/v2/pkg/utils"
        "github.com/hashicorp/hcl/v2"
        "github.com/hashicorp/hcl/v2/hclsyntax"
        "github.com/pkg/errors"
        "github.com/rs/zerolog/log"
        ctyjson "github.com/zclconf/go-cty/cty/json"
)

// RetriesDefaultValue is default number of times a parser will retry to execute
const RetriesDefaultValue = 50

// Converter returns content json, error line, error
type Converter func(file *hcl.File, inputVariables converter.VariableMap) (model.Document, error)

// Parser struct that contains the function to parse file and the number of retries if something goes wrong
type Parser struct {
        convertFunc       Converter
        numOfRetries      int
        terraformVarsPath string
}

// NewDefault initializes a parser with Parser default values
func NewDefault() *Parser <span class="cov5" title="5">{
        return &amp;Parser{
                numOfRetries: RetriesDefaultValue,
                convertFunc:  converter.DefaultConverted,
        }
}</span>

// NewDefaultWithVarsPath initializes a parser with the default values using a variables path
func NewDefaultWithVarsPath(terraformVarsPath string) *Parser <span class="cov0" title="0">{
        parser := NewDefault()
        parser.terraformVarsPath = terraformVarsPath
        return parser
}</span>

// Resolve - replace or modifies in-memory content before parsing
func (p *Parser) Resolve(fileContent []byte, filename string, _ bool, _ int) ([]byte, error) <span class="cov1" title="1">{
        // handle panic during resolve process
        defer func() </span><span class="cov1" title="1">{
                if r := recover(); r != nil </span><span class="cov0" title="0">{
                        errMessage := "Recovered from panic during resolve of file " + filename
                        masterUtils.HandlePanic(r, errMessage)
                }</span>
        }()
        <span class="cov1" title="1">getInputVariables(filepath.Dir(filename), string(fileContent), p.terraformVarsPath)
        getDataSourcePolicy(filepath.Dir(filename))
        return fileContent, nil</span>
}

func processContent(elements model.Document, content, path string) <span class="cov1" title="1">{
        var certInfo map[string]interface{}
        if content != "" </span><span class="cov1" title="1">{
                certInfo = utils.AddCertificateInfo(path, content)
                if certInfo != nil </span><span class="cov1" title="1">{
                        elements["certificate_body"] = certInfo
                }</span>
        }
}

func processElements(elements model.Document, path string) <span class="cov2" title="2">{
        for k, v3 := range elements </span><span class="cov7" title="9">{ // resource elements
                if k != "certificate_body" </span><span class="cov7" title="9">{
                        continue</span>
                }
                <span class="cov0" title="0">switch value := v3.(type) </span>{
                case string:<span class="cov0" title="0">
                        content := utils.CheckCertificate(value)
                        processContent(elements, content, path)</span>
                case ctyjson.SimpleJSONValue:<span class="cov0" title="0">
                        content := utils.CheckCertificate(value.Value.AsString())
                        processContent(elements, content, path)</span>
                }
        }
}

func processResourcesElements(resourcesElements model.Document, path string) error <span class="cov4" title="4">{
        for _, v2 := range resourcesElements </span><span class="cov8" title="14">{
                switch t := v2.(type) </span>{
                case []interface{}:<span class="cov0" title="0">
                        return errors.New("failed to process resources")</span>
                case interface{}:<span class="cov8" title="14">
                        if elements, ok := t.(model.Document); ok </span><span class="cov2" title="2">{
                                processElements(elements, path)
                        }</span>
                }
        }
        <span class="cov4" title="4">return nil</span>
}

func processResources(doc model.Document, path string) error <span class="cov4" title="3">{
        var resourcesElements model.Document

        defer func() </span><span class="cov4" title="3">{
                if r := recover(); r != nil </span><span class="cov0" title="0">{
                        errMessage := "Recovered from panic during process of resources in file " + path
                        masterUtils.HandlePanic(r, errMessage)
                }</span>
        }()

        <span class="cov4" title="3">for _, resources := range doc </span><span class="cov4" title="3">{
                switch t := resources.(type) </span>{
                case []interface{}:<span class="cov1" title="1"> // support the case of nameless resources - where we get a list of resources
                        for _, value := range t </span><span class="cov2" title="2">{
                                resourcesElements = value.(model.Document)
                                err := processResourcesElements(resourcesElements, path)
                                if err != nil </span><span class="cov0" title="0">{
                                        return err
                                }</span>
                        }

                case interface{}:<span class="cov2" title="2">
                        resourcesElements = t.(model.Document)
                        err := processResourcesElements(resourcesElements, path)
                        if err != nil </span><span class="cov0" title="0">{
                                return err
                        }</span>
                }
        }
        <span class="cov4" title="3">return nil</span>
}

func addExtraInfo(json []model.Document, path string) ([]model.Document, error) <span class="cov4" title="4">{
        // handle panic during resource processing
        defer func() </span><span class="cov4" title="4">{
                if r := recover(); r != nil </span><span class="cov0" title="0">{
                        errMessage := "Recovered from panic during resource processing for file " + path
                        masterUtils.HandlePanic(r, errMessage)
                }</span>
        }()
        <span class="cov4" title="4">for _, documents := range json </span><span class="cov4" title="4">{ // iterate over documents
                if resources, ok := documents["resource"].(model.Document); ok </span><span class="cov4" title="3">{
                        err := processResources(resources, path)
                        if err != nil </span><span class="cov0" title="0">{
                                return []model.Document{}, err
                        }</span>
                }
        }

        <span class="cov4" title="4">return json, nil</span>
}

func parseFile(filename string, shouldReplaceDataSource bool) (*hcl.File, error) <span class="cov10" title="26">{
        file, err := os.ReadFile(filename)
        if err != nil </span><span class="cov4" title="3">{
                return nil, err
        }</span>
        <span class="cov9" title="23">if shouldReplaceDataSource </span><span class="cov5" title="5">{
                replaceDataIdentifiers := regexp.MustCompile(`(data\.[A-Za-z0-9._-]+)`)
                file = []byte(replaceDataIdentifiers.ReplaceAllString(string(file), "\"$1\""))
        }</span>
        <span class="cov9" title="23">parsedFile, _ := hclsyntax.ParseConfig(file, filename, hcl.Pos{Line: 1, Column: 1})

        return parsedFile, nil</span>
}

// Parse execute parser for the content in a file
func (p *Parser) Parse(path string, content []byte) ([]model.Document, []int, error) <span class="cov5" title="5">{
        file, diagnostics := hclsyntax.ParseConfig(content, filepath.Base(path), hcl.Pos{Byte: 0, Line: 1, Column: 1})
        defer func() </span><span class="cov5" title="5">{
                if r := recover(); r != nil </span><span class="cov1" title="1">{
                        errMessage := "Recovered from panic during parsing of file " + path
                        masterUtils.HandlePanic(r, errMessage)
                }</span>
        }()
        <span class="cov5" title="5">if diagnostics != nil &amp;&amp; diagnostics.HasErrors() &amp;&amp; len(diagnostics.Errs()) &gt; 0 </span><span class="cov0" title="0">{
                err := diagnostics.Errs()[0]
                return nil, []int{}, err
        }</span>

        <span class="cov5" title="5">ignore, err := comment.ParseComments(content, path)
        if err != nil </span><span class="cov0" title="0">{
                log.Err(err).Msg("failed to parse comments")
        }</span>

        <span class="cov5" title="5">linesToIgnore := comment.GetIgnoreLines(ignore, file.Body.(*hclsyntax.Body))

        fc, parseErr := p.convertFunc(file, inputVariableMap)
        json, err := addExtraInfo([]model.Document{fc}, path)
        if err != nil </span><span class="cov0" title="0">{
                return json, []int{}, errors.Wrap(err, "failed terraform parse")
        }</span>

        <span class="cov4" title="4">return json, linesToIgnore, errors.Wrap(parseErr, "failed terraform parse")</span>
}

// SupportedExtensions returns Terraform extensions
func (p *Parser) SupportedExtensions() []string <span class="cov1" title="1">{
        return []string{".tf", ".tfvars"}
}</span>

// SupportedTypes returns types supported by this parser, which are terraform
func (p *Parser) SupportedTypes() map[string]bool <span class="cov1" title="1">{
        return map[string]bool{"terraform": true}
}</span>

// GetKind returns Terraform kind parser
func (p *Parser) GetKind() model.FileKind <span class="cov1" title="1">{
        return model.KindTerraform
}</span>

// GetCommentToken return the comment token of Terraform - #
func (p *Parser) GetCommentToken() string <span class="cov1" title="1">{
        return "#"
}</span>

// StringifyContent converts original content into string formatted version
func (p *Parser) StringifyContent(content []byte) (string, error) <span class="cov1" title="1">{
        return string(content), nil
}</span>

// GetResolvedFiles returns the files that are resolved
func (p *Parser) GetResolvedFiles() map[string]model.ResolvedFile <span class="cov1" title="1">{
        return make(map[string]model.ResolvedFile)
}</span>
</pre>
		
		<pre class="file" id="file91" style="display: none">package terraform

import (
        "fmt"
        "os"
        "path/filepath"
        "regexp"
        "strings"

        "github.com/Checkmarx/kics/v2/pkg/parser/terraform/converter"
        "github.com/hashicorp/hcl/v2"
        "github.com/hashicorp/hcl/v2/hclsyntax"
        "github.com/rs/zerolog/log"
        "github.com/zclconf/go-cty/cty"
)

var inputVariableMap = make(converter.VariableMap)

func mergeMaps(baseMap, newItems converter.VariableMap) <span class="cov10" title="11">{
        for key, value := range newItems </span><span class="cov10" title="11">{
                baseMap[key] = value
        }</span>
}

func setInputVariablesDefaultValues(filename string) (converter.VariableMap, error) <span class="cov9" title="10">{
        parsedFile, err := parseFile(filename, false)
        if err != nil || parsedFile == nil </span><span class="cov1" title="1">{
                return nil, err
        }</span>
        <span class="cov9" title="9">content, _, _ := parsedFile.Body.PartialContent(&amp;hcl.BodySchema{
                Blocks: []hcl.BlockHeaderSchema{
                        {
                                Type:       "variable",
                                LabelNames: []string{"name"},
                        },
                },
        })

        defaultValuesMap := make(converter.VariableMap)
        for _, block := range content.Blocks </span><span class="cov9" title="9">{
                if len(block.Labels) == 0 || block.Labels[0] == "" </span><span class="cov3" title="2">{
                        continue</span>
                }
                <span class="cov8" title="7">attr, _ := block.Body.JustAttributes()
                if len(attr) == 0 </span><span class="cov3" title="2">{
                        continue</span>
                }
                <span class="cov7" title="5">if defaultValue, exists := attr["default"]; exists </span><span class="cov7" title="5">{
                        defaultVar, _ := defaultValue.Expr.Value(nil)
                        defaultValuesMap[block.Labels[0]] = defaultVar
                }</span>
        }
        <span class="cov9" title="9">return defaultValuesMap, nil</span>
}

func checkTfvarsValid(f *hcl.File, filename string) error <span class="cov8" title="7">{
        content, _, _ := f.Body.PartialContent(&amp;hcl.BodySchema{
                Blocks: []hcl.BlockHeaderSchema{
                        {
                                Type:       "variable",
                                LabelNames: []string{"name"},
                        },
                },
        })
        if len(content.Blocks) &gt; 0 </span><span class="cov3" title="2">{
                return fmt.Errorf("failed to get variables from %s, .tfvars file is used to assing values not to declare new variables", filename)
        }</span>
        <span class="cov7" title="5">return nil</span>
}

func getInputVariablesFromFile(filename string) (converter.VariableMap, error) <span class="cov8" title="8">{
        parsedFile, err := parseFile(filename, false)
        if err != nil || parsedFile == nil </span><span class="cov1" title="1">{
                return nil, err
        }</span>
        <span class="cov8" title="7">err = checkTfvarsValid(parsedFile, filename)
        if err != nil </span><span class="cov3" title="2">{
                return nil, err
        }</span>

        <span class="cov7" title="5">attrs := parsedFile.Body.(*hclsyntax.Body).Attributes
        variables := make(converter.VariableMap)
        for name, attr := range attrs </span><span class="cov10" title="11">{
                value, _ := attr.Expr.Value(&amp;hcl.EvalContext{})
                variables[name] = value
        }</span>
        <span class="cov7" title="5">return variables, nil</span>
}

func getInputVariables(currentPath, fileContent, terraformVarsPath string) <span class="cov6" title="4">{
        variablesMap := make(converter.VariableMap)
        tfFiles, err := filepath.Glob(filepath.Join(currentPath, "*.tf"))
        if err != nil </span><span class="cov0" title="0">{
                log.Error().Msg("Error getting .tf files")
        }</span>
        <span class="cov6" title="4">for _, tfFile := range tfFiles </span><span class="cov7" title="6">{
                variables, errDefaultValues := setInputVariablesDefaultValues(tfFile)
                if errDefaultValues != nil </span><span class="cov0" title="0">{
                        log.Error().Msgf("Error getting default values from %s", tfFile)
                        log.Err(errDefaultValues)
                        continue</span>
                }
                <span class="cov7" title="6">mergeMaps(variablesMap, variables)</span>
        }
        <span class="cov6" title="4">tfVarsFiles, err := filepath.Glob(filepath.Join(currentPath, "*.auto.tfvars"))
        if err != nil </span><span class="cov0" title="0">{
                log.Error().Msg("Error getting .auto.tfvars files")
        }</span>

        <span class="cov6" title="4">_, err = os.Stat(filepath.Join(currentPath, "terraform.tfvars"))
        if err != nil </span><span class="cov5" title="3">{
                log.Trace().Msgf("terraform.tfvars not found on %s", currentPath)
        }</span> else<span class="cov1" title="1"> {
                tfVarsFiles = append(tfVarsFiles, filepath.Join(currentPath, "terraform.tfvars"))
        }</span>

        <span class="cov6" title="4">for _, tfVarsFile := range tfVarsFiles </span><span class="cov5" title="3">{
                variables, errInputVariables := getInputVariablesFromFile(tfVarsFile)
                if errInputVariables != nil </span><span class="cov1" title="1">{
                        log.Error().Msgf("Error getting values from %s", tfVarsFile)
                        log.Err(errInputVariables)
                        continue</span>
                }
                <span class="cov3" title="2">mergeMaps(variablesMap, variables)</span>
        }

        // If the flag is empty let's look for the value in the first written line of the file
        <span class="cov6" title="4">if terraformVarsPath == "" </span><span class="cov3" title="2">{
                terraformVarsPathRegex := regexp.MustCompile(`(?m)^\s*// kics_terraform_vars: ([\w/\\.:-]+)\r?\n`)
                terraformVarsPathMatch := terraformVarsPathRegex.FindStringSubmatch(fileContent)
                if terraformVarsPathMatch != nil </span><span class="cov0" title="0">{
                        // There is a path tp the variables file in the file so that will be the path to the variables tf file
                        terraformVarsPath = terraformVarsPathMatch[1]
                        // If the path contains ":" assume its a global path
                        if !strings.Contains(terraformVarsPath, ":") </span><span class="cov0" title="0">{
                                // If not then add the current folder path before so that the comment path can be relative
                                terraformVarsPath = filepath.Join(currentPath, terraformVarsPath)
                        }</span>
                }
        }

        // If the terraformVarsPath is empty, this means that it is not in the flag
        // and it is not in the first written line of the file
        <span class="cov6" title="4">if terraformVarsPath != "" </span><span class="cov3" title="2">{
                _, err = os.Stat(terraformVarsPath)
                if err != nil </span><span class="cov0" title="0">{
                        log.Trace().Msgf("%s file not found", terraformVarsPath)
                }</span> else<span class="cov3" title="2"> {
                        variables, errInputVariables := getInputVariablesFromFile(terraformVarsPath)
                        if errInputVariables != nil </span><span class="cov0" title="0">{
                                log.Error().Msgf("Error getting values from %s", terraformVarsPath)
                                log.Err(errInputVariables)
                        }</span> else<span class="cov3" title="2"> {
                                mergeMaps(variablesMap, variables)
                        }</span>
                }
        }

        <span class="cov6" title="4">inputVariableMap["var"] = cty.ObjectVal(variablesMap)</span>
}
</pre>
		
		<pre class="file" id="file92" style="display: none">package utils

import (
        "crypto/rsa"
        "crypto/x509"
        "encoding/pem"
        "errors"
        "os"
        "path/filepath"
        "regexp"

        "github.com/rs/zerolog/log"
)

type certInfo struct {
        date        [3]int
        rsaKeyBytes int
}

// CheckCertificate verifies if the attribute 'certificate_body' refers a file
func CheckCertificate(content string) string <span class="cov1" title="1">{
        var re = regexp.MustCompile(`[0-9a-zA-Z-/\\_.]+\.pem`)

        match := re.FindString(content)

        return match
}</span>

func getCertificateInfo(filePath string) (certInfo, error) <span class="cov10" title="2">{
        certPEM, err := os.ReadFile(filePath)

        if err != nil </span><span class="cov0" title="0">{
                return certInfo{}, err
        }</span>

        <span class="cov10" title="2">block, _ := pem.Decode(certPEM)
        if block == nil </span><span class="cov0" title="0">{
                return certInfo{}, errors.New("failed to parse the certificate PEM")
        }</span>
        <span class="cov10" title="2">cert, err := x509.ParseCertificate(block.Bytes)
        if err != nil </span><span class="cov0" title="0">{
                return certInfo{}, err
        }</span>

        <span class="cov10" title="2">var certDate [3]int
        certDate[0] = cert.NotAfter.Year()
        certDate[1] = int(cert.NotAfter.Month())
        certDate[2] = cert.NotAfter.Day()

        var rsaBytes int

        switch t := cert.PublicKey.(type) </span>{
        case *rsa.PublicKey:<span class="cov10" title="2">
                _ = t
                rsaBytes = cert.PublicKey.(*rsa.PublicKey).Size()</span>
        default:<span class="cov0" title="0">
                rsaBytes = -1</span>
        }

        <span class="cov10" title="2">return certInfo{date: certDate, rsaKeyBytes: rsaBytes}, nil</span>
}

// AddCertificateInfo gets and adds certificate information of a certificate file
func AddCertificateInfo(path, content string) map[string]interface{} <span class="cov1" title="1">{
        var filePath string

        _, err := os.Stat(content)

        if err != nil </span><span class="cov1" title="1">{ // content is not a full valid path or is an incomplete path
                log.Trace().Msgf("path to the certificate content is not a valid: %s", content)
                filePath = filepath.Join(filepath.Dir(path), content)
        }</span> else<span class="cov0" title="0"> { // content is a full valid path
                filePath = content
        }</span>

        <span class="cov1" title="1">date, err := getCertificateInfo(filePath)

        if err == nil </span><span class="cov1" title="1">{
                attributes := make(map[string]interface{})
                attributes["file"] = filePath
                attributes["expiration_date"] = date.date

                if date.rsaKeyBytes != -1 </span><span class="cov1" title="1">{
                        attributes["rsa_key_bytes"] = date.rsaKeyBytes
                }</span>

                <span class="cov1" title="1">return attributes</span>
        }

        <span class="cov0" title="0">log.Error().Msgf("Failed to get certificate path %s: %s", filePath, err)

        return nil</span>
}
</pre>
		
		<pre class="file" id="file93" style="display: none">package json

import (
        "bytes"

        "github.com/Checkmarx/kics/v2/pkg/parser/utils"

        "github.com/Checkmarx/kics/v2/pkg/model"
        "github.com/Checkmarx/kics/v2/pkg/resolver/file"
        "github.com/pkg/errors"
        "github.com/rs/zerolog/log"
        "gopkg.in/yaml.v3"
)

// Parser defines a parser type
type Parser struct {
        resolvedFiles map[string]model.ResolvedFile
}

// Resolve - replace or modifies in-memory content before parsing
func (p *Parser) Resolve(fileContent []byte, filename string, resolveReferences bool, maxResolverDepth int) ([]byte, error) <span class="cov1" title="1">{
        // Resolve files passed as arguments with file resolver (e.g. file://)
        res := file.NewResolver(yaml.Unmarshal, yaml.Marshal, p.SupportedExtensions())
        resolvedFilesCache := make(map[string]file.ResolvedFile)
        resolved := res.Resolve(fileContent, filename, 0, maxResolverDepth, resolvedFilesCache, resolveReferences)
        p.resolvedFiles = res.ResolvedFiles
        if len(res.ResolvedFiles) == 0 </span><span class="cov1" title="1">{
                return fileContent, nil
        }</span>

        <span class="cov0" title="0">return resolved, nil</span>
}

// Parse parses yaml/yml file and returns it as a Document
func (p *Parser) Parse(filePath string, fileContent []byte) ([]model.Document, []int, error) <span class="cov6" title="6">{
        model.NewIgnore.Reset()
        var documents []model.Document
        dec := yaml.NewDecoder(bytes.NewReader(fileContent))

        doc := emptyDocument()
        for dec.Decode(doc) == nil </span><span class="cov6" title="5">{
                if len(*doc) &gt; 0 </span><span class="cov6" title="5">{
                        documents = append(documents, *doc)
                }</span>

                <span class="cov6" title="5">doc = emptyDocument()</span>
        }

        <span class="cov6" title="6">if len(documents) == 0 </span><span class="cov3" title="2">{
                return nil, []int{}, errors.Wrap(errors.New("invalid yaml"), "failed to parse yaml")
        }</span>

        <span class="cov5" title="4">linesToIgnore := model.NewIgnore.GetLines()

        return convertKeysToString(addExtraInfo(documents, filePath)), linesToIgnore, nil</span>
}

// convertKeysToString goes through every document to convert map[interface{}]interface{}
// to map[string]interface{}
func convertKeysToString(docs []model.Document) []model.Document <span class="cov5" title="4">{
        documents := make([]model.Document, 0, len(docs))
        for _, doc := range docs </span><span class="cov6" title="5">{
                for key, value := range doc </span><span class="cov8" title="11">{
                        doc[key] = convert(value)
                }</span>
                <span class="cov6" title="5">documents = append(documents, doc)</span>
        }
        <span class="cov5" title="4">return documents</span>
}

// convert goes recursively through the keys in the given value and converts nested maps type of map[interface{}]interface{}
// to map[string]interface{}
func convert(value interface{}) interface{} <span class="cov10" title="15">{
        switch t := value.(type) </span>{
        case map[interface{}]interface{}:<span class="cov0" title="0">
                mapStr := map[string]interface{}{}
                for key, val := range t </span><span class="cov0" title="0">{
                        if t, ok := key.(string); ok </span><span class="cov0" title="0">{
                                mapStr[t] = convert(val)
                        }</span>
                }
                <span class="cov0" title="0">return mapStr</span>
        case []interface{}:<span class="cov4" title="3">
                for key, val := range t </span><span class="cov5" title="4">{
                        t[key] = convert(val)
                }</span>
        case model.Document:<span class="cov0" title="0">
                for key, val := range t </span><span class="cov0" title="0">{
                        t[key] = convert(val)
                }</span>
        }
        <span class="cov10" title="15">return value</span>
}

// SupportedExtensions returns extensions supported by this parser, which are yaml and yml extension
func (p *Parser) SupportedExtensions() []string <span class="cov3" title="2">{
        return []string{".yaml", ".yml"}
}</span>

// SupportedTypes returns types supported by this parser, which are ansible, cloudFormation, k8s
func (p *Parser) SupportedTypes() map[string]bool <span class="cov1" title="1">{
        return map[string]bool{
                "ansible":                 true,
                "cloudformation":          true,
                "kubernetes":              true,
                "crossplane":              true,
                "knative":                 true,
                "openapi":                 true,
                "googledeploymentmanager": true,
                "dockercompose":           true,
                "pulumi":                  true,
                "serverlessfw":            true,
                "cicd":                    true,
        }
}</span>

// GetKind returns YAML constant kind
func (p *Parser) GetKind() model.FileKind <span class="cov1" title="1">{
        return model.KindYAML
}</span>

func processCertContent(elements map[string]interface{}, content, filePath string) <span class="cov1" title="1">{
        var certInfo map[string]interface{}
        if content != "" </span><span class="cov1" title="1">{
                certInfo = utils.AddCertificateInfo(filePath, content)
                if certInfo != nil </span><span class="cov1" title="1">{
                        elements["certificate"] = certInfo
                }</span>
        }
}

func processElements(elements map[string]interface{}, filePath string) <span class="cov3" title="2">{
        if elements["certificate"] != nil </span><span class="cov1" title="1">{
                processCertContent(elements, utils.CheckCertificate(elements["certificate"].(string)), filePath)
        }</span>
}

func addExtraInfo(documents []model.Document, filePath string) []model.Document <span class="cov5" title="4">{
        for _, documentPlaybooks := range documents </span><span class="cov6" title="5">{ // iterate over documents
                if playbooks, ok := documentPlaybooks["playbooks"]; ok </span><span class="cov1" title="1">{
                        processPlaybooks(playbooks, filePath)
                }</span>
        }

        <span class="cov5" title="4">return documents</span>
}

func processPlaybooks(playbooks interface{}, filePath string) <span class="cov1" title="1">{
        sliceResources, ok := playbooks.([]interface{})
        if !ok </span><span class="cov0" title="0">{ // prevent panic if playbooks is not a slice
                log.Warn().Msgf("Failed to parse playbooks: %s", filePath)
                return
        }</span>
        <span class="cov1" title="1">for _, resources := range sliceResources </span><span class="cov1" title="1">{ // iterate over playbooks
                processPlaybooksElements(resources, filePath)
        }</span>
}

func processPlaybooksElements(resources interface{}, filePath string) <span class="cov1" title="1">{
        mapResources, ok := resources.(map[string]interface{})
        if !ok </span><span class="cov0" title="0">{
                log.Warn().Msgf("Failed to parse playbooks elements: %s", filePath)
                return
        }</span>
        <span class="cov1" title="1">for _, value := range mapResources </span><span class="cov3" title="2">{
                mapValue, ok := value.(map[string]interface{})
                if !ok </span><span class="cov1" title="1">{
                        continue</span>
                }
                <span class="cov1" title="1">processElements(mapValue, filePath)</span>
        }
}

// GetCommentToken return the comment token of YAML - #
func (p *Parser) GetCommentToken() string <span class="cov1" title="1">{
        return "#"
}</span>

// StringifyContent converts original content into string formatted version
func (p *Parser) StringifyContent(content []byte) (string, error) <span class="cov1" title="1">{
        return string(content), nil
}</span>

func emptyDocument() *model.Document <span class="cov8" title="11">{
        return &amp;model.Document{}
}</span>

// GetResolvedFiles returns resolved files
func (p *Parser) GetResolvedFiles() map[string]model.ResolvedFile <span class="cov1" title="1">{
        return p.resolvedFiles
}</span>
</pre>
		
		<pre class="file" id="file94" style="display: none">package printer

import (
        "io"
        "os"
        "path/filepath"
        "strings"

        consoleHelpers "github.com/Checkmarx/kics/v2/internal/console/helpers"
        "github.com/Checkmarx/kics/v2/internal/constants"
        "github.com/gookit/color"
        "github.com/pkg/errors"
        "github.com/rs/zerolog"
        "github.com/rs/zerolog/log"
)

// NoColor - disables ASCII color codes
func NoColor(opt interface{}, changed bool) error <span class="cov4" title="2">{
        noColor := opt.(bool)
        if noColor </span><span class="cov1" title="1">{
                color.Disable()
                consoleLogger.NoColor = true
        }</span>
        <span class="cov4" title="2">return nil</span>
}

// Verbose - redirects log entries to stdout
func Verbose(opt interface{}, changed bool) error <span class="cov4" title="2">{
        verbose := opt.(bool)
        if verbose </span><span class="cov1" title="1">{
                consoleLogger = zerolog.ConsoleWriter{Out: os.Stdout}
                outConsoleLogger = os.Stdout
        }</span>
        <span class="cov4" title="2">return nil</span>
}

// Silent - disables stdout output
func Silent(opt interface{}) error <span class="cov1" title="1">{
        silent := opt.(bool)
        if silent </span><span class="cov0" title="0">{
                color.SetOutput(io.Discard)
                os.Stdout = nil
                log.Logger = log.Output(zerolog.MultiLevelWriter(io.Discard, outFileLogger.(io.Writer)))
        }</span>
        <span class="cov1" title="1">return nil</span>
}

// CI - enable only log messages to CLI output
func CI(opt interface{}) error <span class="cov4" title="2">{
        ci := opt.(bool)
        if ci </span><span class="cov1" title="1">{
                color.SetOutput(io.Discard)
                log.Logger = log.Output(zerolog.MultiLevelWriter(outConsoleLogger, outFileLogger.(io.Writer)))
                os.Stdout = nil
        }</span>
        <span class="cov4" title="2">return nil</span>
}

// LogFormat - configures the logs format (JSON,pretty).
func LogFormat(logFormat string) error <span class="cov7" title="4">{
        if logFormat == constants.LogFormatJSON </span><span class="cov1" title="1">{
                log.Logger = log.Output(zerolog.MultiLevelWriter(outConsoleLogger, loggerFile.(io.Writer)))
                outFileLogger = loggerFile
                outConsoleLogger = os.Stdout
        }</span> else<span class="cov6" title="3"> if logFormat == constants.LogFormatPretty </span><span class="cov4" title="2">{
                fileLogger = consoleHelpers.CustomConsoleWriter(&amp;zerolog.ConsoleWriter{Out: loggerFile.(io.Writer), NoColor: true})
                log.Logger = log.Output(zerolog.MultiLevelWriter(consoleLogger, fileLogger))
                outFileLogger = fileLogger
                outConsoleLogger = zerolog.ConsoleWriter{Out: os.Stdout, NoColor: true}
        }</span> else<span class="cov1" title="1"> {
                return errors.New("invalid log format")
        }</span>
        <span class="cov6" title="3">return nil</span>
}

// LogPath - sets the log files location
func LogPath(opt interface{}, changed bool) error <span class="cov6" title="3">{
        logPath := opt.(string)
        var err error
        if !changed </span><span class="cov1" title="1">{
                if loggerFile == nil </span><span class="cov0" title="0">{
                        loggerFile = io.Discard
                        return nil
                }</span>
                <span class="cov1" title="1">return nil</span>
        }
        <span class="cov4" title="2">if logPath == "" </span><span class="cov1" title="1">{
                logPath, err = constants.GetDefaultLogPath()
                if err != nil </span><span class="cov0" title="0">{
                        return err
                }</span>
        } else<span class="cov1" title="1"> if filepath.Dir(logPath) != "." </span><span class="cov1" title="1">{
                if createErr := os.MkdirAll(filepath.Dir(logPath), os.ModePerm); createErr != nil </span><span class="cov0" title="0">{
                        return createErr
                }</span>
        }

        <span class="cov4" title="2">loggerFile, err = os.OpenFile(logPath, os.O_CREATE|os.O_WRONLY, os.ModePerm)
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>
        <span class="cov4" title="2">return nil</span>
}

// LogFile - enables write to log file
func LogFile(opt interface{}, changed bool) error <span class="cov4" title="2">{
        logFile := opt.(bool)
        if logFile </span><span class="cov1" title="1">{
                logPath, err := constants.GetDefaultLogPath()
                if err != nil </span><span class="cov0" title="0">{
                        return err
                }</span>
                <span class="cov1" title="1">loggerFile, err = os.OpenFile(filepath.Clean(logPath), os.O_CREATE|os.O_WRONLY, os.ModePerm)
                if err != nil </span><span class="cov0" title="0">{
                        return err
                }</span>
                <span class="cov1" title="1">fileLogger = consoleHelpers.CustomConsoleWriter(&amp;zerolog.ConsoleWriter{Out: loggerFile.(io.Writer), NoColor: true})</span>
        }
        <span class="cov4" title="2">return nil</span>
}

// LogLevel - sets log level
func LogLevel(opt interface{}, changed bool) error <span class="cov10" title="7">{
        logLevel := opt.(string)
        switch strings.ToUpper(logLevel) </span>{
        case "TRACE":<span class="cov1" title="1">
                zerolog.SetGlobalLevel(zerolog.TraceLevel)</span>
        case "DEBUG":<span class="cov1" title="1">
                zerolog.SetGlobalLevel(zerolog.DebugLevel)</span>
        case "INFO":<span class="cov4" title="2">
                zerolog.SetGlobalLevel(zerolog.InfoLevel)</span>
        case "WARN":<span class="cov1" title="1">
                zerolog.SetGlobalLevel(zerolog.WarnLevel)</span>
        case "ERROR":<span class="cov1" title="1">
                zerolog.SetGlobalLevel(zerolog.ErrorLevel)</span>
        case "FATAL":<span class="cov1" title="1">
                zerolog.SetGlobalLevel(zerolog.FatalLevel)</span>
        }
        <span class="cov10" title="7">return nil</span>
}

type LogSink struct {
        logs []string
}

func NewLogger(logs *LogSink) zerolog.Logger <span class="cov4" title="2">{
        if logs == nil </span><span class="cov0" title="0">{
                return log.Logger
        }</span>
        <span class="cov4" title="2">return zerolog.New(logs)</span>
}

func (l *LogSink) Write(p []byte) (n int, err error) <span class="cov4" title="2">{
        l.logs = append(l.logs, string(p))
        return len(p), nil
}</span>

func (l *LogSink) Index(i int) string <span class="cov4" title="2">{
        return l.logs[i]
}</span>
</pre>
		
		<pre class="file" id="file95" style="display: none">package printer

import (
        "fmt"
        "io"
        "sort"
        "strconv"
        "strings"

        "github.com/Checkmarx/kics/v2/pkg/utils"

        consoleFlags "github.com/Checkmarx/kics/v2/internal/console/flags"
        "github.com/Checkmarx/kics/v2/pkg/model"
        "github.com/gookit/color"
        "github.com/rs/zerolog"
        "github.com/rs/zerolog/log"
        "github.com/spf13/pflag"
)

const (
        charsLimitPerLine = 255
)

var (
        optionsMap = map[string]func(opt interface{}, changed bool) error{
                consoleFlags.CIFlag: func(opt interface{}, changed bool) error <span class="cov1" title="1">{
                        return nil
                }</span>,
                consoleFlags.LogFileFlag:  LogFile,
                consoleFlags.LogLevelFlag: LogLevel,
                consoleFlags.LogPathFlag:  LogPath,
                consoleFlags.SilentFlag: func(opt interface{}, changed bool) error <span class="cov1" title="1">{
                        return nil
                }</span>,
                consoleFlags.VerboseFlag: Verbose,
                consoleFlags.LogFormatFlag: func(opt interface{}, changed bool) error <span class="cov1" title="1">{
                        return nil
                }</span>,
                consoleFlags.NoColorFlag: NoColor,
        }

        optionsOrderMap = map[int]string{
                1: consoleFlags.CIFlag,
                2: consoleFlags.LogFileFlag,
                3: consoleFlags.LogLevelFlag,
                4: consoleFlags.LogPathFlag,
                5: consoleFlags.SilentFlag,
                6: consoleFlags.VerboseFlag,
                7: consoleFlags.LogFormatFlag,
                8: consoleFlags.NoColorFlag,
        }

        consoleLogger = zerolog.ConsoleWriter{Out: io.Discard}
        fileLogger    = zerolog.ConsoleWriter{Out: io.Discard}

        outFileLogger    interface{}
        outConsoleLogger = io.Discard

        loggerFile  interface{}
        initialized bool
)

// Printer wil print console output with colors
// Medium is for medium sevevity results
// High is for high sevevity results
// Low is for low sevevity results
// Info is for info sevevity results
// Success is for successful prints
// Line is the color to print the line with the vulnerability
// minVersion is a bool that if true will print the results output in a minimum version
type Printer struct {
        Critical            color.RGBColor
        Medium              color.RGBColor
        High                color.RGBColor
        Low                 color.RGBColor
        Info                color.RGBColor
        Success             color.RGBColor
        Line                color.RGBColor
        VersionMessage      color.RGBColor
        ContributionMessage color.RGBColor
        minimal             bool
}

// WordWrap Wraps text at the specified number of words
func WordWrap(s, indentation string, limit int) string <span class="cov3" title="3">{
        if strings.TrimSpace(s) == "" </span><span class="cov1" title="1">{
                return s
        }</span>

        <span class="cov2" title="2">wordSlice := strings.Fields(s)
        var result string

        for len(wordSlice) &gt;= 1 </span><span class="cov3" title="3">{
                result = result + indentation + strings.Join(wordSlice[:limit], " ") + "\r\n"

                wordSlice = wordSlice[limit:]
                if len(wordSlice) &lt; limit </span><span class="cov2" title="2">{
                        limit = len(wordSlice)
                }</span>
        }
        <span class="cov2" title="2">return result</span>
}

// PrintResult prints on output the summary results
func PrintResult(summary *model.Summary, printer *Printer, usingCustomQueries bool) error <span class="cov5" title="10">{
        log.Debug().Msg("helpers.PrintResult()")
        fmt.Printf("\n\n")
        for index := range summary.Queries </span><span class="cov7" title="24">{
                idx := len(summary.Queries) - index - 1
                if summary.Queries[idx].Severity == model.SeverityTrace </span><span class="cov0" title="0">{
                        continue</span>
                }

                <span class="cov7" title="24">fmt.Printf(
                        "%s, Severity: %s, Results: %d\n",
                        printer.PrintBySev(summary.Queries[idx].QueryName, string(summary.Queries[idx].Severity)),
                        printer.PrintBySev(string(summary.Queries[idx].Severity), string(summary.Queries[idx].Severity)),
                        len(summary.Queries[idx].Files),
                )

                if summary.Queries[idx].Experimental </span><span class="cov2" title="2">{
                        fmt.Println("Note: this is an experimental query")
                }</span>

                <span class="cov7" title="24">if !printer.minimal </span><span class="cov5" title="12">{
                        if summary.Queries[idx].CISDescriptionID != "" </span><span class="cov0" title="0">{
                                fmt.Printf("%s %s\n", printer.Bold("Description ID:"), summary.Queries[idx].CISDescriptionIDFormatted)
                                fmt.Printf("%s %s\n", printer.Bold("Title:"), summary.Queries[idx].CISDescriptionTitle)
                                fmt.Printf("%s %s\n", printer.Bold("Description:"), summary.Queries[idx].CISDescriptionTextFormatted)
                        }</span> else<span class="cov5" title="12"> {
                                fmt.Printf("%s %s\n", printer.Bold("Description:"), summary.Queries[idx].Description)
                        }</span>
                        <span class="cov5" title="12">fmt.Printf("%s %s\n", printer.Bold("Platform:"), summary.Queries[idx].Platform)

                        if summary.Queries[idx].CWE != "" </span><span class="cov2" title="2">{
                                fmt.Printf("%s %s\n", printer.Bold("CWE:"), summary.Queries[idx].CWE)
                        }</span>

                        // checks if should print queries URL DOCS based on the use of custom queries and invalid ids
                        <span class="cov5" title="12">if !usingCustomQueries &amp;&amp; validQueryID(summary.Queries[idx].QueryID) </span><span class="cov5" title="8">{
                                queryURLId := summary.Queries[idx].QueryID
                                queryURLPlatform := strings.ToLower(summary.Queries[idx].Platform)

                                if queryURLPlatform == "common" &amp;&amp; strings.Contains(strings.ToLower(summary.Queries[idx].QueryName), "passwords and secrets") </span><span class="cov1" title="1">{
                                        queryURLId = "a88baa34-e2ad-44ea-ad6f-8cac87bc7c71"
                                }</span>

                                <span class="cov5" title="8">fmt.Printf("%s %s\n\n",
                                        printer.Bold("Learn more about this vulnerability:"),
                                        fmt.Sprintf("https://docs.kics.io/latest/queries/%s-queries/%s%s",
                                                queryURLPlatform,
                                                normalizeURLCloudProvider(summary.Queries[idx].CloudProvider),
                                                queryURLId))</span>
                        }
                }
                <span class="cov7" title="24">printFiles(&amp;summary.Queries[idx], printer)</span>
        }
        <span class="cov5" title="10">fmt.Printf("\nResults Summary:\n")
        printSeverityCounter(model.SeverityCritical, summary.SeveritySummary.SeverityCounters[model.SeverityCritical], printer.Critical)
        printSeverityCounter(model.SeverityHigh, summary.SeveritySummary.SeverityCounters[model.SeverityHigh], printer.High)
        printSeverityCounter(model.SeverityMedium, summary.SeveritySummary.SeverityCounters[model.SeverityMedium], printer.Medium)
        printSeverityCounter(model.SeverityLow, summary.SeveritySummary.SeverityCounters[model.SeverityLow], printer.Low)
        printSeverityCounter(model.SeverityInfo, summary.SeveritySummary.SeverityCounters[model.SeverityInfo], printer.Info)
        fmt.Printf("TOTAL: %d\n\n", summary.SeveritySummary.TotalCounter)

        log.Info().Msgf("Scanned Files: %d", summary.ScannedFiles)
        log.Info().Msgf("Parsed Files: %d", summary.ParsedFiles)
        log.Info().Msgf("Scanned Lines: %d", summary.ScannedFilesLines)
        log.Info().Msgf("Parsed Lines: %d", summary.ParsedFilesLines)
        log.Info().Msgf("Ignored Lines: %d", summary.IgnoredFilesLines)
        log.Info().Msgf("Queries loaded: %d", summary.TotalQueries)
        log.Info().Msgf("Queries failed to execute: %d", summary.FailedToExecuteQueries)
        log.Info().Msg("Inspector stopped")

        return nil</span>
}

func printSeverityCounter(severity string, counter int, printColor color.RGBColor) <span class="cov8" title="50">{
        fmt.Printf("%s: %d\n", printColor.Sprint(severity), counter)
}</span>

func printFiles(query *model.QueryResult, printer *Printer) <span class="cov7" title="24">{
        for fileIdx := range query.Files </span><span class="cov8" title="34">{
                fmt.Printf("\t%s %s:%s\n", printer.PrintBySev(fmt.Sprintf("[%d]:", fileIdx+1), string(query.Severity)),
                        query.Files[fileIdx].FileName, printer.Success.Sprint(query.Files[fileIdx].Line))
                if !printer.minimal </span><span class="cov6" title="17">{
                        fmt.Println()
                        for _, line := range *query.Files[fileIdx].VulnLines </span><span class="cov0" title="0">{
                                if len(line.Line) &gt; charsLimitPerLine </span><span class="cov0" title="0">{
                                        line.Line = line.Line[:charsLimitPerLine]
                                }</span>
                                <span class="cov0" title="0">if line.Position == query.Files[fileIdx].Line </span><span class="cov0" title="0">{
                                        printer.Line.Printf("\t\t%03d: %s\n", line.Position, line.Line)
                                }</span> else<span class="cov0" title="0"> {
                                        fmt.Printf("\t\t%03d: %s\n", line.Position, line.Line)
                                }</span>
                        }
                        <span class="cov6" title="17">fmt.Print("\n\n")</span>
                }
        }
}

// SetupPrinter - configures stdout and log options with given FlagSet
func SetupPrinter(flags *pflag.FlagSet) error <span class="cov1" title="1">{
        err := validateFlags()
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>

        <span class="cov1" title="1">keys := make([]int, 0, len(optionsOrderMap))
        for k := range optionsOrderMap </span><span class="cov5" title="8">{
                keys = append(keys, k)
        }</span>

        <span class="cov1" title="1">sort.Ints(keys)

        for _, key := range keys </span><span class="cov5" title="8">{
                f := flags.Lookup(optionsOrderMap[key])
                switch f.Value.Type() </span>{
                case "string":<span class="cov3" title="3">
                        value := f.Value.String()
                        err = optionsMap[optionsOrderMap[key]](value, f.Changed)
                        if err != nil </span><span class="cov0" title="0">{
                                return err
                        }</span>
                case "bool":<span class="cov4" title="5">
                        value, errBool := strconv.ParseBool(f.Value.String())
                        if errBool != nil </span><span class="cov0" title="0">{
                                return err
                        }</span>
                        <span class="cov4" title="5">err = optionsMap[optionsOrderMap[key]](value, f.Changed)
                        if err != nil </span><span class="cov0" title="0">{
                                return err
                        }</span>
                }
        }

        // LogFormat needs to be the last option
        <span class="cov1" title="1">logFormat := strings.ToLower(consoleFlags.GetStrFlag(consoleFlags.LogFormatFlag))
        err = LogFormat(logFormat)
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>

        <span class="cov1" title="1">err = Silent(consoleFlags.GetBoolFlag(consoleFlags.SilentFlag))
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>

        <span class="cov1" title="1">err = CI(consoleFlags.GetBoolFlag(consoleFlags.CIFlag))
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>
        <span class="cov1" title="1">initialized = true
        return nil</span>
}

// IsInitialized returns true if printer is ready, false otherwise
func IsInitialized() bool <span class="cov1" title="1">{
        return initialized
}</span>

// NewPrinter initializes a new Printer
func NewPrinter(minimal bool) *Printer <span class="cov5" title="11">{
        return &amp;Printer{
                Critical:            color.HEX("#ff0000"),
                Medium:              color.HEX("#ff7213"),
                High:                color.HEX("#bb2124"),
                Low:                 color.HEX("#edd57e"),
                Success:             color.HEX("#22bb33"),
                Info:                color.HEX("#5bc0de"),
                Line:                color.HEX("#f0ad4e"),
                VersionMessage:      color.HEX("#ff9913"),
                ContributionMessage: color.HEX("ffe313"),
                minimal:             minimal,
        }
}</span>

// PrintBySev will print the output with the specific severity color given the severity of the result
func (p *Printer) PrintBySev(content, sev string) string <span class="cov10" title="88">{
        switch strings.ToUpper(sev) </span>{
        case model.SeverityCritical:<span class="cov6" title="13">
                return p.Critical.Sprintf(content)</span>
        case model.SeverityHigh:<span class="cov8" title="47">
                return p.High.Sprintf(content)</span>
        case model.SeverityMedium:<span class="cov6" title="19">
                return p.Medium.Sprintf(content)</span>
        case model.SeverityLow:<span class="cov4" title="7">
                return p.Low.Sprintf(content)</span>
        case model.SeverityInfo:<span class="cov1" title="1">
                return p.Info.Sprintf(content)</span>
        }
        <span class="cov1" title="1">return content</span>
}

// Bold returns the output in a bold format
func (p *Printer) Bold(content string) string <span class="cov8" title="34">{
        return color.Bold.Sprintf(content)
}</span>

func validQueryID(queryID string) bool <span class="cov5" title="8">{
        if queryID == "" </span><span class="cov0" title="0">{
                return false
        }</span> else<span class="cov5" title="8"> if queryID != "" </span><span class="cov5" title="8">{
                return utils.ValidateUUID(queryID)
        }</span>
        <span class="cov0" title="0">return true</span>
}

func normalizeURLCloudProvider(cloudProvider string) string <span class="cov5" title="8">{
        cloudProvider = strings.ToLower(cloudProvider)
        if cloudProvider == "common" </span><span class="cov2" title="2">{
                cloudProvider = ""
        }</span> else<span class="cov4" title="6"> if cloudProvider != "" </span><span class="cov2" title="2">{
                cloudProvider += "/"
        }</span>
        <span class="cov5" title="8">return cloudProvider</span>
}
</pre>
		
		<pre class="file" id="file96" style="display: none">package printer

import (
        "time"

        consoleFlags "github.com/Checkmarx/kics/v2/internal/console/flags"
        "github.com/rs/zerolog"
)

func validateFlags() error <span class="cov1" title="1">{
        verboseFlag := consoleFlags.GetBoolFlag(consoleFlags.VerboseFlag)
        silentFlag := consoleFlags.GetBoolFlag(consoleFlags.SilentFlag)
        ciFlag := consoleFlags.GetBoolFlag(consoleFlags.CIFlag)

        if silentFlag &amp;&amp; verboseFlag </span><span class="cov0" title="0">{
                return consoleFlags.FormatNewError(consoleFlags.SilentFlag, consoleFlags.VerboseFlag)
        }</span>

        <span class="cov1" title="1">if verboseFlag &amp;&amp; ciFlag </span><span class="cov0" title="0">{
                return consoleFlags.FormatNewError(consoleFlags.VerboseFlag, consoleFlags.CIFlag)
        }</span>

        <span class="cov1" title="1">if silentFlag &amp;&amp; ciFlag </span><span class="cov0" title="0">{
                return consoleFlags.FormatNewError(consoleFlags.SilentFlag, consoleFlags.CIFlag)
        }</span>
        <span class="cov1" title="1">return nil</span>
}

// PrintScanDuration prints the scan duration
func PrintScanDuration(logger *zerolog.Logger, elapsed time.Duration) <span class="cov10" title="2">{
        if consoleFlags.GetBoolFlag(consoleFlags.CIFlag) </span><span class="cov1" title="1">{
                elapsedStrFormat := "Scan duration: %vms\n"
                (*logger).Info().Msgf(elapsedStrFormat, elapsed.Milliseconds())
        }</span> else<span class="cov1" title="1"> {
                elapsedStrFormat := "Scan duration: %v\n"
                (*logger).Info().Msgf(elapsedStrFormat, elapsed)
        }</span>
}
</pre>
		
		<pre class="file" id="file97" style="display: none">package circle

import (
        "fmt"
        "io"
        "time"

        "github.com/Checkmarx/kics/v2/internal/constants"
        "github.com/cheggaaa/pb/v3"
)

const (
        barWidth     = 0
        sleepTimeout = 100
)

// ProgressBar is a struct that holds the required fields for
// a Circle Progress Bar
type ProgressBar struct {
        label string
        pBar  *pb.ProgressBar
        close func() error
}

// NewProgressBar creates a new instance of a Circle Progress Bar
func NewProgressBar(label string, silent bool) ProgressBar <span class="cov10" title="3">{
        newPb := pb.New64(constants.MaxInteger)
        tmp := fmt.Sprintf(`{{ %q }} {{(cycle . "\\" "-" "|" "/" "-" "|" )}}`, label)
        newPb.SetWidth(barWidth)
        newPb.SetTemplateString(tmp)
        if silent </span><span class="cov1" title="1">{
                newPb.SetWriter(io.Discard)
        }</span>
        <span class="cov10" title="3">newPb.Start()

        return ProgressBar{
                label: label,
                pBar:  newPb,
                close: func() error </span><span class="cov1" title="1">{
                        newPb.Finish()
                        return nil
                }</span>,
        }
}

// Start initializes the Circle Progress Bar
func (p ProgressBar) Start() <span class="cov1" title="1">{
        for </span><span class="cov1" title="1">{ // increment until the Close func is called
                p.pBar.Increment()
                // lower cpu usage from infinite loop
                time.Sleep(time.Millisecond * sleepTimeout)
        }</span>
}

// Close stops the Circle Progress Bar and
// changes the template to done
func (p ProgressBar) Close() error <span class="cov1" title="1">{
        p.pBar.SetTemplateString(fmt.Sprintf("%sDone", p.label))
        return p.close()
}</span>
</pre>
		
		<pre class="file" id="file98" style="display: none">package counter

import (
        "io"
        "sync"

        "github.com/cheggaaa/pb/v3"
        "github.com/rs/zerolog/log"
)

// ProgressBar is a struct that holds the required fields for
// a Counter Progress Bar
type ProgressBar struct {
        label           string
        total           int64
        currentProgress int64
        progress        chan int64
        pBar            *pb.ProgressBar
        close           func() error
        wg              *sync.WaitGroup
}

const (
        barWidth = 80
)

// NewProgressBar creates a new instance of a Counter Progress Bar
func NewProgressBar(label string, total int64, progress chan int64, wg *sync.WaitGroup, silent bool) ProgressBar <span class="cov3" title="2">{
        newPb := pb.New64(total)
        newPb.SetMaxWidth(barWidth)
        newPb.Set("prefix", label)
        newPb.SetTemplateString(`{{string . "prefix"}}{{bar . }} {{percent . }}`)
        if silent </span><span class="cov1" title="1">{
                newPb.SetWriter(io.Discard)
        }</span>
        <span class="cov3" title="2">newPb.Start()

        return ProgressBar{
                label:    label,
                total:    total,
                progress: progress,
                pBar:     newPb,
                wg:       wg,
                close: func() error </span><span class="cov0" title="0">{
                        newPb.Finish()
                        return nil
                }</span>,
        }
}

// Start initializes the Counter Progress Bar
func (p ProgressBar) Start() <span class="cov3" title="2">{
        defer func() </span><span class="cov0" title="0">{
                err := p.Close()
                if err != nil </span><span class="cov0" title="0">{
                        log.Error().Msgf("failed to stop progress bar %v", err)
                }</span>
                <span class="cov0" title="0">p.wg.Done()</span>
        }()

        <span class="cov3" title="2">for </span><span class="cov10" title="20">{
                newProgress, ok := &lt;-p.progress
                p.currentProgress += newProgress
                p.pBar.Increment()
                if !ok || p.currentProgress &gt;= p.pBar.Total() </span><span class="cov0" title="0">{
                        break</span>
                }
        }
}

// Close stops the Counter Progress Bar
func (p ProgressBar) Close() error <span class="cov0" title="0">{ return p.close() }</span>
</pre>
		
		<pre class="file" id="file99" style="display: none">package progress

import (
        "sync"

        "github.com/Checkmarx/kics/v2/pkg/progress/circle"
        "github.com/Checkmarx/kics/v2/pkg/progress/counter"
)

// PBar is the interface for the types of available progress bars (Circle ,Counter)
// Start initializes the Progress Bar execution
// Close stops the Progress Bar execution
type PBar interface {
        Start()
        Close() error
}

// PbBuilder is the struct that contains the progress bar Builders
// Silent is set to true when all progress bars should be silent
type PbBuilder struct {
        Silent bool
}

// InitializePbBuilder creates an instace of a PbBuilder
func InitializePbBuilder(noProgress, ci, silentFlag bool) *PbBuilder <span class="cov10" title="2">{
        pbbuilder := PbBuilder{
                Silent: false,
        }
        if noProgress || ci || silentFlag </span><span class="cov1" title="1">{
                pbbuilder = PbBuilder{
                        Silent: true,
                }
        }</span>
        <span class="cov10" title="2">return &amp;pbbuilder</span>
}

// BuildCounter builds and returns a Counter Progress Bar
func (i *PbBuilder) BuildCounter(label string, total int, wg *sync.WaitGroup, progressChannel chan int64) PBar <span class="cov1" title="1">{
        return counter.NewProgressBar(label, int64(total), progressChannel, wg, i.Silent)
}</span>

// BuildCircle builds and returns a Circle Progress Bar
func (i *PbBuilder) BuildCircle(label string) PBar <span class="cov1" title="1">{
        return circle.NewProgressBar(label, i.Silent)
}</span>
</pre>
		
		<pre class="file" id="file100" style="display: none">package remediation

import (
        "encoding/json"
        "os"
        "path/filepath"
        "sort"
        "strings"

        "github.com/rs/zerolog/log"
)

// Report includes all query results
type Report struct {
        Queries []Query `json:"queries"`
}

// Query includes all the files that presents a result related to the queryID
type Query struct {
        Files   []File `json:"files"`
        QueryID string `json:"query_id"`
}

// File presents the result information related to the file
type File struct {
        FilePath        string `json:"file_name"`
        Line            int    `json:"line"`
        Remediation     string `json:"remediation"`
        RemediationType string `json:"remediation_type"`
        SimilarityID    string `json:"similarity_id"`
        SearchKey       string `json:"search_key"`
        ExpectedValue   string `json:"expected_value"`
        ActualValue     string `json:"actual_value"`
}

// Remediation presents all the relevant information for the fix
type Remediation struct {
        Line          int
        Remediation   string
        SimilarityID  string
        QueryID       string
        SearchKey     string
        ExpectedValue string
        ActualValue   string
}

// Set includes all the replacements and additions related to a file
type Set struct {
        Replacement []Remediation
        Addition    []Remediation
}

// RemediateFile remediationSets the replacements first and secondly, the additions sorted down
func (s *Summary) RemediateFile(filePath string, remediationSet Set, openAPIResolveReferences bool, maxResolverDepth int) error <span class="cov10" title="4">{
        filepath.Clean(filePath)
        content, err := os.ReadFile(filePath)

        if err != nil </span><span class="cov0" title="0">{
                log.Error().Msgf("failed to read file: %s", err)
                return err
        }</span>

        <span class="cov10" title="4">lines := strings.Split(string(content), "\n")

        // do replacements first
        if len(remediationSet.Replacement) &gt; 0 </span><span class="cov8" title="3">{
                for i := range remediationSet.Replacement </span><span class="cov8" title="3">{
                        r := remediationSet.Replacement[i]
                        remediatedLines := replacement(&amp;r, lines)
                        if len(remediatedLines) &gt; 0 &amp;&amp; willRemediate(remediatedLines, filePath, &amp;r, openAPIResolveReferences, maxResolverDepth) </span><span class="cov5" title="2">{
                                lines = s.writeRemediation(remediatedLines, lines, filePath, r.SimilarityID)
                        }</span>
                }
        }

        // do additions after
        <span class="cov10" title="4">if len(remediationSet.Addition) &gt; 0 </span><span class="cov1" title="1">{
                // descending order
                sort.Slice(remediationSet.Addition, func(i, j int) bool </span><span class="cov0" title="0">{
                        return remediationSet.Addition[i].Line &gt; remediationSet.Addition[j].Line
                }</span>)

                <span class="cov1" title="1">for i := range remediationSet.Addition </span><span class="cov1" title="1">{
                        a := remediationSet.Addition[i]
                        remediatedLines := addition(&amp;a, &amp;lines)
                        if len(remediatedLines) &gt; 0 &amp;&amp; willRemediate(remediatedLines, filePath, &amp;a, openAPIResolveReferences, maxResolverDepth) </span><span class="cov1" title="1">{
                                lines = s.writeRemediation(remediatedLines, lines, filePath, a.SimilarityID)
                        }</span>
                }
        }

        <span class="cov10" title="4">return nil</span>
}

// ReplacementInfo presents the relevant information to do the replacement
type ReplacementInfo struct {
        Before string `json:"before"`
        After  string `json:"after"`
}

func replacement(r *Remediation, lines []string) []string <span class="cov8" title="3">{
        originalLine := lines[r.Line-1]

        var replacement ReplacementInfo
        err := json.Unmarshal([]byte(r.Remediation), &amp;replacement)

        if err != nil || replacement == (ReplacementInfo{}) </span><span class="cov0" title="0">{
                return []string{}
        }</span>

        <span class="cov8" title="3">remediated := strings.Replace(lines[r.Line-1], replacement.Before, replacement.After, 1)

        if originalLine == remediated </span><span class="cov1" title="1">{
                log.Info().Msgf("remediation '%s' is already done", r.SimilarityID)
                return []string{}
        }</span>

        // replace the original line with remediation
        <span class="cov5" title="2">lines[r.Line-1] = remediated

        return lines</span>
}

func addition(r *Remediation, lines *[]string) []string <span class="cov1" title="1">{
        fatherNumberLine := r.Line - 1

        if len(*lines) &lt;= fatherNumberLine+1 </span><span class="cov0" title="0">{
                return []string{}
        }</span>

        <span class="cov1" title="1">firstLine := strings.Split(r.Remediation, "\n")[0]

        if strings.TrimSpace((*lines)[fatherNumberLine+1]) == strings.TrimSpace(firstLine) </span><span class="cov0" title="0">{
                log.Info().Msgf("remediation '%s' is already done", r.SimilarityID)
                return []string{}
        }</span>

        <span class="cov1" title="1">begin := make([]string, len(*lines))
        end := make([]string, len(*lines))

        copy(begin, *lines)
        copy(end, *lines)

        begin = begin[:fatherNumberLine+1]
        end = end[fatherNumberLine+1:]

        before := getBefore((*lines)[fatherNumberLine+1])

        remediation := begin
        remediation = append(remediation, before+r.Remediation)
        remediation = append(remediation, end...)

        return remediation</span>
}

func (s *Summary) writeRemediation(remediatedLines, lines []string, filePath, similarityID string) []string <span class="cov8" title="3">{
        remediated := []byte(strings.Join(remediatedLines, "\n"))

        if err := os.WriteFile(filePath, remediated, os.ModePerm); err != nil </span><span class="cov0" title="0">{
                log.Error().Msgf("failed to write file: %s", err)
                return lines
        }</span>

        <span class="cov8" title="3">log.Info().Msgf("file '%s' was remediated with '%s'", filePath, similarityID)
        s.ActualRemediationDoneNumber++

        return remediatedLines</span>
}
</pre>
		
		<pre class="file" id="file101" style="display: none">package remediation

import (
        "context"
        "encoding/json"
        "errors"
        "time"

        "github.com/Checkmarx/kics/v2/pkg/engine"
        "github.com/Checkmarx/kics/v2/pkg/kics"
        "github.com/Checkmarx/kics/v2/pkg/minified"
        "github.com/Checkmarx/kics/v2/pkg/model"
        "github.com/Checkmarx/kics/v2/pkg/scan"
        "github.com/open-policy-agent/opa/topdown"

        "github.com/Checkmarx/kics/v2/internal/console/flags"
        "github.com/Checkmarx/kics/v2/internal/tracker"
        "github.com/Checkmarx/kics/v2/pkg/engine/source"
        "github.com/Checkmarx/kics/v2/pkg/parser"
        buildahParser "github.com/Checkmarx/kics/v2/pkg/parser/buildah"
        dockerParser "github.com/Checkmarx/kics/v2/pkg/parser/docker"
        protoParser "github.com/Checkmarx/kics/v2/pkg/parser/grpc"
        jsonParser "github.com/Checkmarx/kics/v2/pkg/parser/json"
        terraformParser "github.com/Checkmarx/kics/v2/pkg/parser/terraform"
        yamlParser "github.com/Checkmarx/kics/v2/pkg/parser/yaml"
        "github.com/Checkmarx/kics/v2/pkg/utils"
        "github.com/open-policy-agent/opa/rego"
        "github.com/rs/zerolog/log"
)

type runQueryInfo struct {
        payload   model.Documents
        query     *engine.PreparedQuery
        inspector *engine.Inspector
        tmpFile   string
        files     model.FileMetadatas
}

// scanTmpFile scans a temporary file against a specific query
func scanTmpFile(
        tmpFile, queryID string,
        remediated []byte,
        openAPIResolveReferences bool,
        maxResolverDepth int) ([]model.Vulnerability, error) <span class="cov10" title="3">{
        // get payload
        files, err := getPayload(tmpFile, remediated, openAPIResolveReferences, maxResolverDepth)

        if err != nil </span><span class="cov0" title="0">{
                log.Err(err)
                return []model.Vulnerability{}, err
        }</span>

        <span class="cov10" title="3">if len(files) == 0 </span><span class="cov0" title="0">{
                log.Error().Msg("failed to get payload")
                return []model.Vulnerability{}, errors.New("failed to get payload")
        }</span>

        <span class="cov10" title="3">payload := files.Combine(false)

        // init scan
        inspector, err := initScan(queryID)

        if err != nil </span><span class="cov0" title="0">{
                log.Err(err)
                return []model.Vulnerability{}, err
        }</span>

        // load query
        <span class="cov10" title="3">query, err := loadQuery(inspector, queryID)

        if err != nil </span><span class="cov0" title="0">{
                log.Err(err)
                return []model.Vulnerability{}, err
        }</span>

        // run query
        <span class="cov10" title="3">info := &amp;runQueryInfo{
                payload:   payload,
                query:     query,
                inspector: inspector,
                tmpFile:   tmpFile,
                files:     files,
        }

        return runQuery(info), nil</span>
}

// getPayload gets the payload of a file
func getPayload(filePath string, content []byte, openAPIResolveReferences bool, maxResolverDepth int) (model.FileMetadatas, error) <span class="cov10" title="3">{
        ext, _ := utils.GetExtension(filePath)
        var p []*parser.Parser
        var err error

        switch ext </span>{
        case ".dockerfile", "Dockerfile", "possibleDockerfile", ".ubi8", ".debian":<span class="cov0" title="0">
                p, err = parser.NewBuilder().Add(&amp;dockerParser.Parser{}).Build([]string{""}, []string{""})</span>

        case ".tf":<span class="cov10" title="3">
                p, err = parser.NewBuilder().Add(terraformParser.NewDefault()).Build([]string{""}, []string{""})</span>

        case ".proto":<span class="cov0" title="0">
                p, err = parser.NewBuilder().Add(&amp;protoParser.Parser{}).Build([]string{""}, []string{""})</span>

        case ".yaml", ".yml":<span class="cov0" title="0">
                p, err = parser.NewBuilder().Add(&amp;yamlParser.Parser{}).Build([]string{""}, []string{""})</span>

        case ".json":<span class="cov0" title="0">
                p, err = parser.NewBuilder().Add(&amp;jsonParser.Parser{}).Build([]string{""}, []string{""})</span>

        case ".sh":<span class="cov0" title="0">
                p, err = parser.NewBuilder().Add(&amp;buildahParser.Parser{}).Build([]string{""}, []string{""})</span>
        }

        <span class="cov10" title="3">if err != nil </span><span class="cov0" title="0">{
                log.Error().Msgf("failed to get parser: %s", err)
                return model.FileMetadatas{}, err
        }</span>

        <span class="cov10" title="3">if len(p) == 0 </span><span class="cov0" title="0">{
                log.Info().Msg("failed to get parser")
                return model.FileMetadatas{}, errors.New("failed to get parser")
        }</span>

        <span class="cov10" title="3">isMinified := minified.IsMinified(filePath, content)
        documents, er := p[0].Parse(filePath, content, openAPIResolveReferences, isMinified, maxResolverDepth)

        if er != nil </span><span class="cov0" title="0">{
                log.Error().Msgf("failed to parse file '%s': %s", filePath, er)
                return model.FileMetadatas{}, er
        }</span>

        <span class="cov10" title="3">var files model.FileMetadatas

        for _, document := range documents.Docs </span><span class="cov10" title="3">{
                _, err = json.Marshal(document)
                if err != nil </span><span class="cov0" title="0">{
                        continue</span>
                }

                <span class="cov10" title="3">file := model.FileMetadata{
                        FilePath:          filePath,
                        Document:          kics.PrepareScanDocument(document, documents.Kind),
                        LineInfoDocument:  document,
                        Commands:          p[0].CommentsCommands(filePath, content),
                        OriginalData:      string(content),
                        LinesOriginalData: utils.SplitLines(string(content)),
                        IsMinified:        documents.IsMinified,
                }

                files = append(files, file)</span>
        }

        <span class="cov10" title="3">return files, nil</span>
}

// runQuery runs a query and returns its results
func runQuery(r *runQueryInfo) []model.Vulnerability <span class="cov10" title="3">{
        queryExecTimeout := time.Duration(flags.GetIntFlag(flags.QueryExecTimeoutFlag)) * time.Second

        timeoutCtx, cancel := context.WithTimeout(context.Background(), queryExecTimeout)
        defer cancel()

        options := []rego.EvalOption{rego.EvalInput(r.payload)}

        results, err := r.query.OpaQuery.Eval(timeoutCtx, options...)

        if err != nil </span><span class="cov0" title="0">{
                if topdown.IsCancel(err) </span><span class="cov0" title="0">{
                        log.Err(err)
                }</span>

                <span class="cov0" title="0">log.Err(err)</span>
        }

        <span class="cov10" title="3">ctx := context.Background()

        queryCtx := &amp;engine.QueryContext{
                Ctx:           ctx,
                Query:         r.query,
                BaseScanPaths: []string{r.tmpFile},
                Files:         r.files.ToMap(),
        }

        timeoutCtxToDecode, cancelDecode := context.WithTimeout(context.Background(), queryExecTimeout)
        defer cancelDecode()
        decoded, err := r.inspector.DecodeQueryResults(queryCtx, timeoutCtxToDecode, results)

        if err != nil </span><span class="cov0" title="0">{
                log.Err(err)
        }</span>

        <span class="cov10" title="3">return decoded</span>
}

func initScan(queryID string) (*engine.Inspector, error) <span class="cov10" title="3">{
        scanParams := &amp;scan.Parameters{
                QueriesPath:         flags.GetMultiStrFlag(flags.QueriesPath),
                Platform:            flags.GetMultiStrFlag(flags.TypeFlag),
                CloudProvider:       flags.GetMultiStrFlag(flags.CloudProviderFlag),
                LibrariesPath:       flags.GetStrFlag(flags.LibrariesPath),
                PreviewLines:        flags.GetIntFlag(flags.PreviewLinesFlag),
                QueryExecTimeout:    flags.GetIntFlag(flags.QueryExecTimeoutFlag),
                ExperimentalQueries: flags.GetBoolFlag(flags.ExperimentalQueriesFlag),
        }

        c := &amp;scan.Client{
                ScanParams: scanParams,
        }

        _, err := c.GetQueryPath()
        if err != nil </span><span class="cov0" title="0">{
                log.Err(err)
                return &amp;engine.Inspector{}, err
        }</span>

        <span class="cov10" title="3">queriesSource := source.NewFilesystemSource(
                c.ScanParams.QueriesPath,
                c.ScanParams.Platform,
                c.ScanParams.CloudProvider,
                c.ScanParams.LibrariesPath,
                c.ScanParams.ExperimentalQueries)

        includeQueries := source.IncludeQueries{
                ByIDs: []string{queryID},
        }

        queryFilter := source.QueryInspectorParameters{
                IncludeQueries: includeQueries,
        }

        t, err := tracker.NewTracker(c.ScanParams.PreviewLines)
        if err != nil </span><span class="cov0" title="0">{
                log.Err(err)
                return &amp;engine.Inspector{}, err
        }</span>

        <span class="cov10" title="3">ctx := context.Background()

        inspector, err := engine.NewInspector(ctx,
                queriesSource,
                engine.DefaultVulnerabilityBuilder,
                t,
                &amp;queryFilter,
                make(map[string]bool),
                c.ScanParams.QueryExecTimeout,
                c.ScanParams.UseOldSeverities,
                false,
                c.ScanParams.ParallelScanFlag,
                c.ScanParams.KicsComputeNewSimID,
        )

        return inspector, err</span>
}

func loadQuery(inspector *engine.Inspector, queryID string) (*engine.PreparedQuery, error) <span class="cov10" title="3">{
        if len(inspector.QueryLoader.QueriesMetadata) == 1 </span><span class="cov10" title="3">{
                queryOpa, err := inspector.QueryLoader.LoadQuery(context.Background(), &amp;inspector.QueryLoader.QueriesMetadata[0])

                if err != nil </span><span class="cov0" title="0">{
                        log.Err(err)
                        return &amp;engine.PreparedQuery{}, err
                }</span>

                <span class="cov10" title="3">query := &amp;engine.PreparedQuery{
                        OpaQuery: *queryOpa,
                        Metadata: inspector.QueryLoader.QueriesMetadata[0],
                }

                return query, nil</span>
        }

        <span class="cov0" title="0">return &amp;engine.PreparedQuery{}, errors.New("unable to load query" + queryID)</span>
}
</pre>
		
		<pre class="file" id="file102" style="display: none">package remediation

import (
        "os"
        "path/filepath"
        "regexp"
        "strings"

        "github.com/Checkmarx/kics/v2/pkg/model"
        "github.com/Checkmarx/kics/v2/pkg/utils"
        "github.com/rs/zerolog/log"
)

// Summary represents the information about the number of selected remediation and remediation done
type Summary struct {
        SelectedRemediationNumber   int
        ActualRemediationDoneNumber int
}

// GetRemediationSets collects all the replacements and additions per file
func (s *Summary) GetRemediationSets(results Report, include []string) map[string]interface{} <span class="cov4" title="2">{
        remediationSets := make(map[string]interface{})

        vulns := getVulns(results)

        if len(vulns) &gt; 0 </span><span class="cov4" title="2">{
                remediationSets = s.GetRemediationSetsFromVulns(vulns, include)
        }</span>

        <span class="cov4" title="2">return remediationSets</span>
}

func shouldRemediate(file *File, include []string) bool <span class="cov8" title="4">{
        if file.Remediation != "" &amp;&amp;
                file.RemediationType != "" &amp;&amp;
                (include[0] == "all" || utils.Contains(file.SimilarityID, include)) &amp;&amp;
                filepath.Ext(file.FilePath) == ".tf" </span><span class="cov7" title="3">{ // temporary
                return true
        }</span>

        <span class="cov1" title="1">return false</span>
}

func getBefore(line string) string <span class="cov1" title="1">{
        re := regexp.MustCompile(`^[\s-]*`)
        before := re.FindAll([]byte(line), -1)

        return string(before[0])
}</span>

// willRemediate verifies if the remediation actually removes the result
func willRemediate(
        remediated []string,
        originalFileName string,
        remediation *Remediation,
        openAPIResolveReferences bool,
        maxResolverDepth int) bool <span class="cov7" title="3">{
        filepath.Clean(originalFileName)
        // create temporary file
        tmpFile := filepath.Join(os.TempDir(), "temporary-remediation-"+utils.NextRandom()+"-"+filepath.Base(originalFileName))
        f, err := os.OpenFile(tmpFile, os.O_WRONLY|os.O_CREATE|os.O_TRUNC, os.ModePerm)

        if err != nil </span><span class="cov0" title="0">{
                log.Error().Msgf("failed to open temporary file for remediation '%s': %s", remediation.SimilarityID, err)
                return false
        }</span>

        <span class="cov7" title="3">content := []byte(strings.Join(remediated, "\n"))

        defer func(f *os.File) </span><span class="cov7" title="3">{
                err = f.Close()
                if err != nil </span><span class="cov0" title="0">{
                        log.Err(err).Msgf("failed to close file: %s", tmpFile)
                }</span>
        }(f)

        <span class="cov7" title="3">if _, err = f.Write(content); err != nil </span><span class="cov0" title="0">{
                log.Error().Msgf("failed to write temporary file for remediation '%s': %s", remediation.SimilarityID, err)
                return false
        }</span>

        // scan the temporary file to verify if the remediation removed the result
        <span class="cov7" title="3">results, err := scanTmpFile(tmpFile, remediation.QueryID, content, openAPIResolveReferences, maxResolverDepth)

        if err != nil </span><span class="cov0" title="0">{
                log.Error().Msgf("failed to get results of query %s: %s", remediation.QueryID, err)
                return false
        }</span>

        <span class="cov7" title="3">err = os.Remove(tmpFile)

        if err != nil </span><span class="cov0" title="0">{
                log.Err(err)
        }</span>

        <span class="cov7" title="3">return removedResult(results, remediation)</span>
}

func removedResult(results []model.Vulnerability, remediation *Remediation) bool <span class="cov7" title="3">{
        for i := range results </span><span class="cov4" title="2">{
                result := results[i]

                if result.SearchKey == remediation.SearchKey &amp;&amp;
                        result.KeyActualValue == remediation.ActualValue &amp;&amp;
                        result.KeyExpectedValue == remediation.ExpectedValue </span><span class="cov0" title="0">{
                        log.Info().Msgf("failed to remediate '%s'", remediation.SimilarityID)
                        return false
                }</span>
        }
        <span class="cov7" title="3">return true</span>
}

// CreateTempFile creates a temporary file with the content as the file pointed in the filePathCopyFrom
func CreateTempFile(filePathCopyFrom, tmpFilePath string) string <span class="cov10" title="5">{
        filepath.Clean(filePathCopyFrom)
        filepath.Clean(tmpFilePath)
        f, err := os.OpenFile(tmpFilePath, os.O_WRONLY|os.O_CREATE|os.O_TRUNC, os.ModePerm)

        if err != nil </span><span class="cov0" title="0">{
                log.Error().Msgf("failed to open file '%s': %s", tmpFilePath, err)
                return ""
        }</span>

        <span class="cov10" title="5">content, err := os.ReadFile(filePathCopyFrom)

        defer func(f *os.File) </span><span class="cov10" title="5">{
                err = f.Close()
                if err != nil </span><span class="cov0" title="0">{
                        log.Err(err).Msgf("failed to close file: %s", tmpFilePath)
                }</span>
        }(f)

        <span class="cov10" title="5">if err != nil </span><span class="cov0" title="0">{
                log.Error().Msgf("failed to read file '%s': %s", filePathCopyFrom, err)
                return ""
        }</span>

        <span class="cov10" title="5">if _, err = f.Write(content); err != nil </span><span class="cov0" title="0">{
                log.Error().Msgf("failed to write file '%s': %s", tmpFilePath, err)
                return ""
        }</span>

        <span class="cov10" title="5">return tmpFilePath</span>
}

// GetRemediationSetsFromVulns collects all the replacements and additions per file from []model.Vulnerability
func (s *Summary) GetRemediationSetsFromVulns(vulnerabilities []model.Vulnerability, include []string) map[string]interface{} <span class="cov4" title="2">{
        remediationSets := make(map[string]interface{})

        for i := range vulnerabilities </span><span class="cov8" title="4">{
                vuln := vulnerabilities[i]

                file := File{
                        FilePath:        vuln.FileName,
                        Line:            vuln.Line,
                        Remediation:     vuln.Remediation,
                        RemediationType: vuln.RemediationType,
                        SimilarityID:    vuln.SimilarityID,
                }

                var remediationSet Set

                if shouldRemediate(&amp;file, include) </span><span class="cov7" title="3">{
                        s.SelectedRemediationNumber++
                        r := &amp;Remediation{
                                Line:          file.Line,
                                Remediation:   file.Remediation,
                                SimilarityID:  file.SimilarityID,
                                QueryID:       vuln.QueryID,
                                SearchKey:     vuln.SearchKey,
                                ExpectedValue: vuln.KeyExpectedValue,
                                ActualValue:   vuln.KeyActualValue,
                        }

                        if file.RemediationType == "replacement" </span><span class="cov4" title="2">{
                                remediationSet.Replacement = append(remediationSet.Replacement, *r)
                        }</span>

                        <span class="cov7" title="3">if file.RemediationType == "addition" </span><span class="cov1" title="1">{
                                remediationSet.Addition = append(remediationSet.Addition, *r)
                        }</span>

                        <span class="cov7" title="3">if _, ok := remediationSets[file.FilePath]; !ok </span><span class="cov4" title="2">{
                                remediationSets[file.FilePath] = remediationSet
                                continue</span>
                        }

                        <span class="cov1" title="1">updatedRemediationSet := remediationSets[file.FilePath].(Set)

                        updatedRemediationSet.Addition = append(updatedRemediationSet.Addition, remediationSet.Addition...)
                        updatedRemediationSet.Replacement = append(updatedRemediationSet.Replacement, remediationSet.Replacement...)

                        remediationSets[file.FilePath] = updatedRemediationSet</span>
                }
        }
        <span class="cov4" title="2">return remediationSets</span>
}

func getVulns(results Report) []model.Vulnerability <span class="cov4" title="2">{
        vulns := []model.Vulnerability{}
        for i := range results.Queries </span><span class="cov8" title="4">{
                query := results.Queries[i]

                for j := range query.Files </span><span class="cov8" title="4">{
                        file := query.Files[j]
                        vuln := &amp;model.Vulnerability{
                                FileName:         file.FilePath,
                                Line:             file.Line,
                                Remediation:      file.Remediation,
                                RemediationType:  file.RemediationType,
                                SimilarityID:     file.SimilarityID,
                                QueryID:          query.QueryID,
                                SearchKey:        file.SearchKey,
                                KeyExpectedValue: file.ExpectedValue,
                                KeyActualValue:   file.ActualValue,
                        }

                        vulns = append(vulns, *vuln)
                }</span>
        }
        <span class="cov4" title="2">return vulns</span>
}
</pre>
		
		<pre class="file" id="file103" style="display: none">package report

import (
        "strings"

        reportModel "github.com/Checkmarx/kics/v2/pkg/report/model"
)

// PrintASFFReport prints the ASFF report in the given path and filename with the given body
func PrintASFFReport(path, filename string, body interface{}) error <span class="cov10" title="3">{
        if !strings.HasPrefix(filename, "asff-") </span><span class="cov10" title="3">{
                filename = "asff-" + filename
        }</span>
        <span class="cov10" title="3">if body != "" </span><span class="cov10" title="3">{
                summary, err := getSummary(body)
                if err != nil </span><span class="cov0" title="0">{
                        return err
                }</span>

                <span class="cov10" title="3">body = reportModel.BuildASFF(&amp;summary)</span>
        }

        <span class="cov10" title="3">return ExportJSONReport(path, filename, body)</span>
}
</pre>
		
		<pre class="file" id="file104" style="display: none">package report

import (
        "strings"

        reportModel "github.com/Checkmarx/kics/v2/pkg/report/model"
)

// PrintCodeClimateReport prints the code climate report in the given path and filename with the given body
func PrintCodeClimateReport(path, filename string, body interface{}) error <span class="cov10" title="3">{
        if !strings.HasPrefix(filename, "codeclimate") </span><span class="cov10" title="3">{
                filename = "codeclimate-" + filename
        }</span>

        <span class="cov10" title="3">if body != "" </span><span class="cov10" title="3">{
                summary, err := getSummary(body)
                if err != nil </span><span class="cov0" title="0">{
                        return err
                }</span>

                <span class="cov10" title="3">body = reportModel.BuildCodeClimateReport(&amp;summary)</span>
        }

        <span class="cov10" title="3">return ExportJSONReport(path, filename, body)</span>
}
</pre>
		
		<pre class="file" id="file105" style="display: none">package report

import (
        "encoding/json"
        "encoding/xml"
        "fmt"
        "html/template"
        "os"
        "path/filepath"
        "strconv"
        "strings"
        "time"

        "github.com/Checkmarx/kics/v2/pkg/model"
        reportModel "github.com/Checkmarx/kics/v2/pkg/report/model"
        "github.com/gocarina/gocsv"
        "github.com/rs/zerolog/log"
)

var (
        stringsSeverity = map[string]model.Severity{
                "critical": model.AllSeverities[0],
                "high":     model.AllSeverities[1],
                "medium":   model.AllSeverities[2],
                "low":      model.AllSeverities[3],
                "info":     model.AllSeverities[4],
        }

        templateFuncs = template.FuncMap{
                "lower":          strings.ToLower,
                "sprintf":        fmt.Sprintf,
                "severity":       getSeverities,
                "getCurrentTime": getCurrentTime,
                "trimSpaces":     trimSpaces,
                "toString":       toString,
        }
)

func toString(value interface{}) string <span class="cov3" title="3">{
        switch v := value.(type) </span>{
        case string:<span class="cov0" title="0">
                return v</span>
        case int:<span class="cov0" title="0">
                return strconv.Itoa(v)</span>
        default:<span class="cov3" title="3">
                return fmt.Sprintf("%v", v)</span>
        }
}

func trimSpaces(value string) string <span class="cov0" title="0">{
        return strings.TrimPrefix(value, " ")
}</span>

func getSeverities(severity string) model.Severity <span class="cov7" title="15">{
        return stringsSeverity[severity]
}</span>

func getCurrentTime() string <span class="cov3" title="3">{
        dt := time.Now()
        return dt.Format("01/02/2006 15:04")
}</span>

func fileCreationReport(path, filename string) <span class="cov10" title="33">{
        log.Info().Str("fileName", filename).Msgf("Results saved to file %s", path)
}</span>

func closeFile(path, filename string, file *os.File) <span class="cov9" title="29">{
        err := file.Close()
        if err != nil </span><span class="cov0" title="0">{
                log.Err(err).Msgf("Failed to close file %s", path)
        }</span>

        <span class="cov9" title="29">fileCreationReport(path, filename)</span>
}

func getPlatforms(queries model.QueryResultSlice) string <span class="cov6" title="7">{
        platforms := make([]string, 0)
        alreadyAdded := make(map[string]string)
        for idx := range queries </span><span class="cov6" title="7">{
                if _, ok := alreadyAdded[queries[idx].Platform]; !ok </span><span class="cov6" title="7">{
                        alreadyAdded[queries[idx].Platform] = ""
                        platforms = append(platforms, queries[idx].Platform)
                }</span>
        }
        <span class="cov6" title="7">return strings.Join(platforms, ", ")</span>
}

// ExportJSONReport - encodes a given body to a JSON file in a given filepath
func ExportJSONReport(path, filename string, body interface{}) error <span class="cov8" title="17">{
        if !strings.Contains(filename, ".") </span><span class="cov6" title="9">{
                filename += jsonExtension
        }</span>
        <span class="cov8" title="17">fullPath := filepath.Join(path, filename)

        f, err := os.OpenFile(filepath.Clean(fullPath), os.O_WRONLY|os.O_CREATE|os.O_TRUNC, os.ModePerm)
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>

        <span class="cov8" title="17">defer closeFile(fullPath, filename, f)

        encoder := json.NewEncoder(f)
        encoder.SetIndent("", "\t")

        return encoder.Encode(body)</span>
}

func getSummary(body interface{}) (sum model.Summary, err error) <span class="cov9" title="26">{
        var summary model.Summary
        result, err := json.Marshal(body)
        if err != nil </span><span class="cov0" title="0">{
                return model.Summary{}, err
        }</span>
        <span class="cov9" title="26">if err := json.Unmarshal(result, &amp;summary); err != nil </span><span class="cov0" title="0">{
                return model.Summary{}, err
        }</span>

        <span class="cov9" title="26">return summary, nil</span>
}

func exportXMLReport(path, filename string, body interface{}) error <span class="cov5" title="6">{
        if !strings.HasSuffix(filename, ".xml") </span><span class="cov5" title="6">{
                filename += ".xml"
        }</span>

        <span class="cov5" title="6">fullPath := filepath.Join(path, filename)
        f, err := os.OpenFile(filepath.Clean(fullPath), os.O_WRONLY|os.O_CREATE|os.O_TRUNC, os.ModePerm)
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>
        <span class="cov5" title="6">defer closeFile(fullPath, filename, f)
        if _, err = f.WriteString(xml.Header); err != nil </span><span class="cov0" title="0">{
                log.Debug().Err(err).Msg("Failed to write XML header")
        }</span>
        <span class="cov5" title="6">encoder := xml.NewEncoder(f)
        encoder.Indent("", "\t")

        return encoder.Encode(body)</span>
}

func exportCSVReport(path, filename string, body []reportModel.CSVReport) error <span class="cov3" title="3">{
        fullPath := filepath.Join(path, filename)
        f, err := os.OpenFile(filepath.Clean(fullPath), os.O_WRONLY|os.O_CREATE|os.O_TRUNC, os.ModePerm)
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>

        <span class="cov3" title="3">defer closeFile(fullPath, filename, f)

        return gocsv.MarshalFile(&amp;body, f)</span>
}
</pre>
		
		<pre class="file" id="file106" style="display: none">package report

import (
        "strings"

        reportModel "github.com/Checkmarx/kics/v2/pkg/report/model"
)

// PrintCSVReport prints the CSV report in the given path and filename with the given body
func PrintCSVReport(path, filename string, body interface{}) error <span class="cov10" title="3">{
        if !strings.HasSuffix(filename, ".csv") </span><span class="cov10" title="3">{
                filename += ".csv"
        }</span>

        <span class="cov10" title="3">var report []reportModel.CSVReport
        if body != "" </span><span class="cov10" title="3">{
                summary, err := getSummary(body)
                if err != nil </span><span class="cov0" title="0">{
                        return err
                }</span>

                <span class="cov10" title="3">report = reportModel.BuildCSVReport(&amp;summary)</span>
        }

        <span class="cov10" title="3">return exportCSVReport(path, filename, report)</span>
}
</pre>
		
		<pre class="file" id="file107" style="display: none">package report

import (
        "strings"

        "github.com/Checkmarx/kics/v2/pkg/model"
        reportModel "github.com/Checkmarx/kics/v2/pkg/report/model"
)

// PrintCycloneDxReport prints the CycloneDX report in the given path and filename with the given body
func PrintCycloneDxReport(path, filename string, body interface{}) error <span class="cov10" title="3">{
        filePaths := make(map[string]string)

        if !strings.HasPrefix(filename, "cyclonedx-") </span><span class="cov10" title="3">{
                filename = "cyclonedx-" + filename
        }</span>

        <span class="cov10" title="3">if body != "" </span><span class="cov10" title="3">{
                if s, ok := body.(*model.Summary); ok </span><span class="cov0" title="0">{
                        filePaths = s.FilePaths
                }</span>
                <span class="cov10" title="3">summary, err := getSummary(body)
                if err != nil </span><span class="cov0" title="0">{
                        return err
                }</span>

                <span class="cov10" title="3">body = reportModel.BuildCycloneDxReport(&amp;summary, filePaths)</span>
        }

        <span class="cov10" title="3">return exportXMLReport(path, filename, body)</span>
}
</pre>
		
		<pre class="file" id="file108" style="display: none">package report

import (
        "strings"

        reportModel "github.com/Checkmarx/kics/v2/pkg/report/model"
)

// PrintGitlabSASTReport creates a report file on sarif format
func PrintGitlabSASTReport(path, filename string, body interface{}) error <span class="cov7" title="3">{
        filename = strings.ReplaceAll(filename, ".glsast", "")
        if !strings.HasSuffix(filename, jsonExtension) </span><span class="cov7" title="3">{
                filename += jsonExtension
        }</span>
        <span class="cov7" title="3">if !strings.HasPrefix(filename, "gl-sast-") </span><span class="cov7" title="3">{
                filename = "gl-sast-" + filename
        }</span>
        <span class="cov7" title="3">if body != "" </span><span class="cov7" title="3">{
                summary, err := getSummary(body)
                if err != nil </span><span class="cov0" title="0">{
                        return err
                }</span>

                <span class="cov7" title="3">gitlabSASTReport := reportModel.NewGitlabSASTReport(summary.Times.Start, summary.Times.End)

                for idxQuery := range summary.Queries </span><span class="cov7" title="3">{
                        for idxFile := range summary.Queries[idxQuery].Files </span><span class="cov10" title="5">{
                                gitlabSASTReport.BuildGitlabSASTVulnerability(&amp;summary.Queries[idxQuery], &amp;summary.Queries[idxQuery].Files[idxFile])
                        }</span>
                }
                <span class="cov7" title="3">body = gitlabSASTReport</span>
        }

        <span class="cov7" title="3">return ExportJSONReport(path, filename, body)</span>
}
</pre>
		
		<pre class="file" id="file109" style="display: none">package report

import (
        "bytes"
        _ "embed" // used for embedding report static files
        "html/template"
        "os"
        "path/filepath"
        "strings"

        "github.com/Checkmarx/kics/v2/internal/constants"
        "github.com/rs/zerolog/log"
        "github.com/tdewolff/minify/v2"
        minifyCSS "github.com/tdewolff/minify/v2/css"
        minifyHtml "github.com/tdewolff/minify/v2/html"
        minifyJS "github.com/tdewolff/minify/v2/js"
)

var (
        //go:embed template/html/report.tmpl
        htmlTemplate string
        //go:embed template/html/report.css
        cssTemplate string
        //go:embed template/html/report.js
        jsTemplate string
        //go:embed template/html/github.svg
        githubSVG string
        //go:embed template/html/info.svg
        infoSVG string
        //go:embed template/html/vulnerability_fill.svg
        vulnerabilityFillSVG string
        //go:embed template/html/vulnerability_out.svg
        vulnerabilityOutSVG string
)

const (
        textHTML = "text/html"
)

var svgMap = map[string]string{
        "github.svg":             githubSVG,
        "info.svg":               infoSVG,
        "vulnerability_fill.svg": vulnerabilityFillSVG,
        "vulnerability_out.svg":  vulnerabilityOutSVG,
}

func includeSVG(name string) template.HTML <span class="cov10" title="23">{
        return template.HTML(svgMap[name]) //nolint
}</span>

func includeCSS(name string) template.HTML <span class="cov4" title="3">{
        minifier := minify.New()
        minifier.AddFunc("text/css", minifyCSS.Minify)
        cssMinified, err := minifier.String("text/css", cssTemplate)
        if err != nil </span><span class="cov0" title="0">{
                return ""
        }</span>
        <span class="cov4" title="3">return template.HTML("&lt;style&gt;" + cssMinified + "&lt;/style&gt;")</span> //nolint
}

func includeJS(name string) template.HTML <span class="cov4" title="3">{
        minifier := minify.New()
        minifier.AddFunc("text/javascript", minifyJS.Minify)
        jsMinified, err := minifier.String("text/javascript", jsTemplate)
        if err != nil </span><span class="cov0" title="0">{
                return ""
        }</span>
        <span class="cov4" title="3">return template.HTML("&lt;script&gt;" + jsMinified + "&lt;/script&gt;")</span> //nolint
}

func getPaths(paths []string) string <span class="cov4" title="3">{
        return strings.Join(paths, ", ")
}</span>

func getVersion() string <span class="cov4" title="3">{
        return constants.Version
}</span>

// PrintHTMLReport creates a report file on HTML format
func PrintHTMLReport(path, filename string, body interface{}) error <span class="cov4" title="3">{
        if !strings.HasSuffix(filename, ".html") </span><span class="cov4" title="3">{
                filename += ".html"
        }</span>

        <span class="cov4" title="3">templateFuncs["includeSVG"] = includeSVG
        templateFuncs["includeCSS"] = includeCSS
        templateFuncs["includeJS"] = includeJS
        templateFuncs["getPaths"] = getPaths
        templateFuncs["getPlatforms"] = getPlatforms
        templateFuncs["getVersion"] = getVersion

        fullPath := filepath.Join(path, filename)
        t := template.Must(template.New("report.tmpl").Funcs(templateFuncs).Parse(htmlTemplate))

        f, err := os.OpenFile(filepath.Clean(fullPath), os.O_WRONLY|os.O_CREATE|os.O_TRUNC, os.ModePerm)
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>
        <span class="cov4" title="3">defer closeFile(fullPath, filename, f)
        var buffer bytes.Buffer

        err = t.Execute(&amp;buffer, body)
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>
        <span class="cov4" title="3">minifier := minify.New()
        minifier.AddFunc(textHTML, minifyHtml.Minify)
        minifier.Add(textHTML, &amp;minifyHtml.Minifier{
                KeepDocumentTags: true,
                KeepEndTags:      true,
                KeepQuotes:       true,
        })

        minifierWriter := minifier.Writer(textHTML, f)
        defer func() </span><span class="cov4" title="3">{
                if closeErr := minifierWriter.Close(); closeErr != nil </span><span class="cov0" title="0">{
                        log.Err(closeErr).Msg("Error closing file")
                }</span>
        }()

        <span class="cov4" title="3">_, err = minifierWriter.Write(buffer.Bytes())
        return err</span>
}
</pre>
		
		<pre class="file" id="file110" style="display: none">package report

import "github.com/Checkmarx/kics/v2/internal/constants"

const jsonExtension = ".json"

// PrintJSONReport prints on JSON file the summary results
func PrintJSONReport(path, filename string, body interface{}) error <span class="cov10" title="3">{
        if body != "" </span><span class="cov10" title="3">{
                summary, err := getSummary(body)
                if err != nil </span><span class="cov0" title="0">{
                        return err
                }</span>
                <span class="cov10" title="3">for idx := range summary.Queries </span><span class="cov10" title="3">{
                        summary.Queries[idx].CISBenchmarkName = ""
                        summary.Queries[idx].CISBenchmarkVersion = ""
                        summary.Queries[idx].CISDescriptionID = ""
                        summary.Queries[idx].CISDescriptionText = ""
                        summary.Queries[idx].CISRationaleText = ""
                }</span>
                <span class="cov10" title="3">summary.Version = constants.Version
                body = summary</span>
        }

        <span class="cov10" title="3">return ExportJSONReport(path, filename, body)</span>
}
</pre>
		
		<pre class="file" id="file111" style="display: none">package report

import (
        "strings"

        "github.com/Checkmarx/kics/v2/pkg/model"
        reportModel "github.com/Checkmarx/kics/v2/pkg/report/model"
)

// PrintJUnitReport prints the JUnit report in the given path and filename with the given body
func PrintJUnitReport(path, filename string, body interface{}) error <span class="cov10" title="3">{
        if !strings.HasPrefix(filename, "junit-") </span><span class="cov10" title="3">{
                filename = "junit-" + filename
        }</span>

        <span class="cov10" title="3">summary := model.Summary{}

        if body != "" </span><span class="cov10" title="3">{
                var err error
                summary, err = getSummary(body)
                if err != nil </span><span class="cov0" title="0">{
                        return err
                }</span>
        }

        <span class="cov10" title="3">jUnitReport := reportModel.NewJUnitReport(summary.Times.End.Sub(summary.Times.Start).String())
        for idx := range summary.Queries </span><span class="cov10" title="3">{
                jUnitReport.GenerateTestEntry(&amp;summary.Queries[idx])
        }</span>

        <span class="cov10" title="3">jUnitReport.FinishReport()

        return exportXMLReport(path, filename, jUnitReport)</span>
}
</pre>
		
		<pre class="file" id="file112" style="display: none">package model

import (
        "fmt"
        "os"
        "strings"
        "time"

        "github.com/Checkmarx/kics/v2/pkg/model"
        "github.com/aws/aws-sdk-go-v2/aws"
        "github.com/rs/zerolog/log"
)

// AwsAccountInfo contains all the relevant information of the user AWS account
type AwsAccountInfo struct {
        AwsAccountID string
        AwsRegion    string
}

// AwsSecurityFinding contains all the relevant information to build a finding
type AwsSecurityFinding struct {
        AwsAccountID  string `json:"AwsAccountId"`
        Compliance    Compliance
        CreatedAt     string
        Description   string
        GeneratorID   string `json:"GeneratorId"`
        ID            string `json:"Id"`
        ProductArn    string
        Remediation   Remediation
        Resources     []Resource
        SchemaVersion string
        Severity      Severity
        Title         string
        Types         []string
        UpdatedAt     string
        CWE           string
}

// AsffRecommendation includes the recommendation to avoid the finding
type AsffRecommendation struct {
        Text string
}

// Remediation contains the recommendation
type Remediation struct {
        Recommendation AsffRecommendation
}

// Resource contains the ID and the type of the target resource
type Resource struct {
        ID   string `json:"Id"`
        Type string
}

// Severity contains the original severity (KICS severity) and the label severity (ASFF severity)
type Severity struct {
        Original string
        Label    string
}

// Compliance contains the status of the finding
type Compliance struct {
        Status string
}

// BuildASFF builds the ASFF report
func BuildASFF(summary *model.Summary) []AwsSecurityFinding <span class="cov6" title="3">{
        findings := []AwsSecurityFinding{}

        awsAccountInfo := getAwsAccountInfo()

        if awsAccountInfo.incompleteAwsAccountInfo() </span><span class="cov0" title="0">{
                variables := "AWS_ACCOUNT_ID, AWS_REGION"
                log.Debug().Msg(fmt.Sprintf("failed to get AWS account information: check your environment variables (%s)", variables))
        }</span>

        <span class="cov6" title="3">for idx := range summary.Queries </span><span class="cov6" title="3">{
                query := summary.Queries[idx]

                findingPerQuery := awsAccountInfo.getFindingsPerQuery(&amp;query)
                findings = append(findings, findingPerQuery...)
        }</span>

        <span class="cov6" title="3">return findings</span>
}

func (a *AwsAccountInfo) getFindingsPerQuery(query *model.QueryResult) []AwsSecurityFinding <span class="cov6" title="3">{
        var findings []AwsSecurityFinding
        if query.CloudProvider == "AWS" </span><span class="cov6" title="3">{
                for i := range query.Files </span><span class="cov6" title="3">{
                        finding := a.getFinding(query, &amp;query.Files[i])
                        findings = append(findings, finding)
                }</span>
        }

        <span class="cov6" title="3">return findings</span>
}

func (a *AwsAccountInfo) getFinding(query *model.QueryResult, file *model.VulnerableFile) AwsSecurityFinding <span class="cov6" title="3">{
        awsAccountID := a.AwsAccountID
        awsRegion := a.AwsRegion

        timeFormatted := time.Now().Format(time.RFC3339)

        arn := "arn:aws:securityhub:%s:%s:product/%s/default"
        arn = fmt.Sprintf(arn, awsRegion, awsAccountID, awsAccountID)

        severity := string(query.Severity)
        if severity == "INFO" </span><span class="cov0" title="0">{
                severity = "INFORMATIONAL"
        }</span>

        <span class="cov6" title="3">finding := AwsSecurityFinding{
                AwsAccountID: *aws.String(awsAccountID),
                CreatedAt:    *aws.String(timeFormatted),
                Description:  *aws.String(getDescription(query, "asff")),
                GeneratorID:  *aws.String(query.QueryID),
                ID:           *aws.String(fmt.Sprintf("%s/%s/%s", awsRegion, awsAccountID, file.SimilarityID)),
                ProductArn:   *aws.String(arn),
                Resources: []Resource{
                        {
                                ID:   *aws.String(query.QueryID),
                                Type: *aws.String("Other"),
                        },
                },
                SchemaVersion: *aws.String("2018-10-08"),
                Severity: Severity{
                        Original: *aws.String(string(query.Severity)),
                        Label:    *aws.String(severity),
                },
                Title:     *aws.String(query.QueryName),
                Types:     []string{*aws.String("Software and Configuration Checks/Vulnerabilities/KICS")},
                UpdatedAt: *aws.String(timeFormatted),

                Remediation: Remediation{
                        Recommendation: AsffRecommendation{
                                Text: *aws.String(fmt.Sprintf(
                                        "Problem found on '%s' file in line %d. Expected value: %s. Actual value: %s.",
                                        file.FileName,
                                        file.Line,
                                        strings.TrimRight(file.KeyExpectedValue, "."),
                                        strings.TrimRight(file.KeyActualValue, "."),
                                )),
                        },
                },
                Compliance: Compliance{Status: *aws.String("FAILED")},
                CWE:        *aws.String(query.CWE),
        }

        return finding</span>
}

func getEnv(env string) string <span class="cov10" title="6">{
        if os.Getenv(env) != "" </span><span class="cov0" title="0">{
                return os.Getenv(env)
        }</span>

        <span class="cov10" title="6">return env</span>
}

func getAwsAccountInfo() *AwsAccountInfo <span class="cov6" title="3">{
        awsAccountInfo := AwsAccountInfo{
                AwsAccountID: getEnv("AWS_ACCOUNT_ID"),
                AwsRegion:    getEnv("AWS_REGION"),
        }

        return &amp;awsAccountInfo
}</span>

func (a *AwsAccountInfo) incompleteAwsAccountInfo() bool <span class="cov6" title="3">{
        if a.AwsAccountID == "" || a.AwsRegion == "" </span><span class="cov0" title="0">{
                return true
        }</span>

        <span class="cov6" title="3">return false</span>
}
</pre>
		
		<pre class="file" id="file113" style="display: none">package model

import "github.com/Checkmarx/kics/v2/pkg/model"

type lines struct {
        Begin int `json:"begin"`
}

type location struct {
        Path  string `json:"path"`
        Lines lines  `json:"lines"`
}

// CodeClimateReport struct contains all the info to create the code climate report
type CodeClimateReport struct {
        Type        string   `json:"type"`
        CheckName   string   `json:"check_name"`
        CWE         string   `json:"cwe,omitempty"`
        Description string   `json:"description"`
        Categories  []string `json:"categories"`
        Location    location `json:"location"`
        Severity    string   `json:"severity"`
        Fingerprint string   `json:"fingerprint"`
}

var severityMap = map[string]string{
        model.SeverityTrace:    "info",
        model.SeverityInfo:     "info",
        model.SeverityLow:      "minor",
        model.SeverityMedium:   "major",
        model.SeverityHigh:     "critical",
        model.SeverityCritical: "blocker",
}

// BuildCodeClimateReport builds the code climate report
func BuildCodeClimateReport(summary *model.Summary) []CodeClimateReport <span class="cov7" title="3">{
        var codeClimateReport []CodeClimateReport

        for i := range summary.Queries </span><span class="cov7" title="3">{
                for j := range summary.Queries[i].Files </span><span class="cov10" title="5">{
                        codeClimateReport = append(codeClimateReport, CodeClimateReport{
                                Type:        "issue",
                                CheckName:   summary.Queries[i].QueryName,
                                CWE:         summary.Queries[i].CWE,
                                Description: summary.Queries[i].Description,
                                Categories:  []string{"Security"},
                                Location: location{
                                        Path:  summary.Queries[i].Files[j].FileName,
                                        Lines: lines{Begin: summary.Queries[i].Files[j].Line},
                                },
                                Severity:    severityMap[string(summary.Queries[i].Severity)],
                                Fingerprint: summary.Queries[i].Files[j].SimilarityID,
                        })
                }</span>
        }

        <span class="cov7" title="3">return codeClimateReport</span>
}
</pre>
		
		<pre class="file" id="file114" style="display: none">package model

import "github.com/Checkmarx/kics/v2/pkg/model"

// CSVReport struct contains all the info to create the csv report
type CSVReport struct {
        QueryName                   string `csv:"query_name"`
        QueryID                     string `csv:"query_id"`
        QueryURI                    string `csv:"query_uri"`
        Severity                    string `csv:"severity"`
        Platform                    string `csv:"platform"`
        CWE                         string `csv:"cwe,omitempty"`
        CloudProvider               string `csv:"cloud_provider"`
        Category                    string `csv:"category"`
        DescriptionID               string `csv:"description_id"`
        Description                 string `csv:"description"`
        CISDescriptionIDFormatted   string `csv:"cis_description_id"`
        CISDescriptionTitle         string `csv:"cis_description_title"`
        CISDescriptionTextFormatted string `csv:"cis_description_text"`
        FileName                    string `csv:"file_name"`
        SimilarityID                string `csv:"similarity_id"`
        Line                        int    `csv:"line"`
        IssueType                   string `csv:"issue_type"`
        SearchKey                   string `csv:"search_key"`
        SearchLine                  int    `csv:"search_line"`
        SearchValue                 string `csv:"search_value"`
        ExpectedValue               string `csv:"expected_value"`
        ActualValue                 string `csv:"actual_value"`
}

// BuildCSVReport builds the CSV report
func BuildCSVReport(summary *model.Summary) []CSVReport <span class="cov7" title="3">{
        csvReport := []CSVReport{}

        for i := range summary.Queries </span><span class="cov7" title="3">{
                for j := range summary.Queries[i].Files </span><span class="cov10" title="5">{
                        csvReport = append(csvReport, CSVReport{
                                QueryName:                   summary.Queries[i].QueryName,
                                QueryID:                     summary.Queries[i].QueryID,
                                QueryURI:                    summary.Queries[i].QueryURI,
                                Severity:                    string(summary.Queries[i].Severity),
                                Platform:                    summary.Queries[i].Platform,
                                CWE:                         summary.Queries[i].CWE,
                                CloudProvider:               summary.Queries[i].CloudProvider,
                                Category:                    summary.Queries[i].Category,
                                DescriptionID:               summary.Queries[i].DescriptionID,
                                Description:                 summary.Queries[i].Description,
                                CISDescriptionIDFormatted:   summary.Queries[i].CISDescriptionIDFormatted,
                                CISDescriptionTitle:         summary.Queries[i].CISDescriptionTitle,
                                CISDescriptionTextFormatted: summary.Queries[i].CISDescriptionTextFormatted,
                                FileName:                    summary.Queries[i].Files[j].FileName,
                                SimilarityID:                summary.Queries[i].Files[j].SimilarityID,
                                Line:                        summary.Queries[i].Files[j].Line,
                                IssueType:                   string(summary.Queries[i].Files[j].IssueType),
                                SearchKey:                   summary.Queries[i].Files[j].SearchKey,
                                SearchLine:                  summary.Queries[i].Files[j].SearchLine,
                                SearchValue:                 summary.Queries[i].Files[j].SearchValue,
                                ExpectedValue:               summary.Queries[i].Files[j].KeyExpectedValue,
                                ActualValue:                 summary.Queries[i].Files[j].KeyActualValue,
                        })
                }</span>
        }

        <span class="cov7" title="3">return csvReport</span>
}
</pre>
		
		<pre class="file" id="file115" style="display: none">package model

import (
        "crypto/sha256"
        "encoding/hex"
        "encoding/xml"
        "fmt"
        "os"
        "path/filepath"
        "strings"
        "time"

        "github.com/Checkmarx/kics/v2/internal/constants"
        "github.com/Checkmarx/kics/v2/pkg/model"
        "github.com/google/uuid"
        "github.com/rs/zerolog/log"
)

var cycloneDxSeverityLevelEquivalence = map[model.Severity]string{
        "INFO":     "None",
        "LOW":      "Low",
        "MEDIUM":   "Medium",
        "HIGH":     "High",
        "CRITICAL": "Critical",
}

// CycloneDxReport includes all the properties considered relevant for the CycloneDX Report
type CycloneDxReport struct {
        XMLName xml.Name `xml:"bom"`

        // bom tag information
        XMLNS        string `xml:"xmlns,attr"`
        SerialNumber string `xml:"serialNumber,attr"`
        XMLNSV       string `xml:"xmlns:v,attr"`
        Version      int    `xml:"version,attr"`

        // bom body information
        Metadata   *Metadata  `xml:"metadata"`
        Components Components `xml:"components"`
}

// Metadata includes the relevant additional information about the CycloneDX report
type Metadata struct {
        Timestamp string  `xml:"timestamp"`  // the timestamp when the CycloneDX report is created
        Tools     *[]Tool `xml:"tools&gt;tool"` // array of tools used to create the CycloneDX report
}

// Tool includes the information about the tool used to create the CycloneDX report
type Tool struct {
        Vendor  string `xml:"vendor"`
        Name    string `xml:"name"`
        Version string `xml:"version"`
}

// Components is a list of components
type Components struct {
        Components []Component `xml:"component"`
}

// Component includes the CycloneDX component structure properties considered relevant
type Component struct {
        // component tag information
        Type   string `xml:"type,attr"`
        BomRef string `xml:"bom-ref,attr"`

        // component body information
        Name            string          `xml:"name"`
        Version         string          `xml:"version"`
        Hashes          []Hash          `xml:"hashes&gt;hash"`
        Purl            string          `xml:"purl"`
        Vulnerabilities []Vulnerability `xml:"v:vulnerabilities&gt;v:vulnerability"`
}

// Hash includes the algorithm used in the HASH function and the output of it (content)
type Hash struct {
        Alg     string `xml:"alg,attr"`
        Content string `xml:",chardata"`
}

// Vulnerability includes all the relevant information about the vulnerability
type Vulnerability struct {
        // vulnerability tag information
        Ref string `xml:"ref,attr"`

        // vulnerability body information
        ID              string           `xml:"v:id"`
        CWE             string           `xml:"v:cwe"`
        Source          Source           `xml:"v:source"`
        Ratings         []Rating         `xml:"v:ratings&gt;v:rating"`
        Description     string           `xml:"v:description"`
        Recommendations []Recommendation `xml:"v:recommendations&gt;v:recommendation"`
}

// Source includes information about the origin where the vulnerability was reported
type Source struct {
        Name string `xml:"name"`
        URL  string `xml:"url"`
}

// Rating includes the severity of the vulnerability and the method used to classify it
type Rating struct {
        Severity string `xml:"v:severity"`
        Method   string `xml:"v:method"`
}

// Recommendation describes how the vulnerability should be avoided
type Recommendation struct {
        Recommendation string `xml:""`
}

func match(fileNames []model.VulnerableFile, fileName string) bool <span class="cov7" title="5">{
        for i := range fileNames </span><span class="cov5" title="3">{
                if fileNames[i].FileName == fileName </span><span class="cov1" title="1">{
                        return true
                }</span>
        }
        <span class="cov7" title="4">return false</span>
}

func getAllFiles(summary *model.Summary) []model.VulnerableFile <span class="cov5" title="3">{
        var fileNames []model.VulnerableFile
        for i := range summary.Queries </span><span class="cov7" title="4">{
                files := summary.Queries[i].Files
                for idx := range files </span><span class="cov7" title="5">{
                        if !match(fileNames, files[idx].FileName) </span><span class="cov7" title="4">{
                                fileNames = append(fileNames, files[idx])
                        }</span>
                }
        }
        <span class="cov5" title="3">return fileNames</span>
}

func generateSha256(filePath string, filePaths map[string]string) string <span class="cov7" title="4">{
        file := filePaths[filePath]
        content, err := os.ReadFile(filepath.Clean(file))

        if err != nil </span><span class="cov0" title="0">{
                log.Trace().Msgf("failed to read %s", file)
                return ""
        }</span>

        <span class="cov7" title="4">hashSum := sha256.Sum256(content)
        return hex.EncodeToString(hashSum[:])</span>
}

func getPurl(filePath, version string) string <span class="cov7" title="4">{
        return fmt.Sprintf("pkg:generic/%s@%s", filePath, version)
}</span>

func getDescription(query *model.QueryResult, format string) string <span class="cov10" title="8">{
        queryDescription := query.Description

        if query.CISDescriptionTextFormatted != "" </span><span class="cov1" title="1">{
                queryDescription = query.CISDescriptionTextFormatted
        }</span>

        <span class="cov10" title="8">if format == "asff" </span><span class="cov5" title="3">{
                return queryDescription
        }</span>

        <span class="cov7" title="5">description := fmt.Sprintf("[%s].[%s]: %s", query.Platform, query.QueryName, queryDescription)

        return description</span>
}

func getVulnerabilitiesByFile(query *model.QueryResult, fileName, purl string) []Vulnerability <span class="cov8" title="6">{
        vulns := make([]Vulnerability, 0)
        for idx := range query.Files </span><span class="cov10" title="8">{
                file := query.Files[idx]
                if fileName == file.FileName </span><span class="cov7" title="5">{
                        vuln := Vulnerability{
                                Ref: purl + query.QueryID,
                                ID:  query.QueryID,
                                CWE: query.CWE,
                                Source: Source{
                                        Name: "KICS",
                                        URL:  "https://kics.io/",
                                },
                                Ratings: []Rating{
                                        {
                                                Severity: cycloneDxSeverityLevelEquivalence[query.Severity],
                                                Method:   "Other",
                                        },
                                },
                                Description: getDescription(query, "cyclonedx"),
                                Recommendations: []Recommendation{
                                        {
                                                Recommendation: fmt.Sprintf(
                                                        "Problem found in line %d. Expected value: %s. Actual value: %s.",
                                                        file.Line,
                                                        strings.TrimRight(file.KeyExpectedValue, "."),
                                                        strings.TrimRight(file.KeyActualValue, "."),
                                                ),
                                        },
                                },
                        }
                        vulns = append(vulns, vuln)
                }</span>
        }
        <span class="cov8" title="6">return vulns</span>
}

func getVulnerabilities(fileName, purl string, summary *model.Summary) []Vulnerability <span class="cov7" title="4">{
        vulns := make([]Vulnerability, 0)
        for i := range summary.Queries </span><span class="cov8" title="6">{
                query := summary.Queries[i]
                vulns = append(vulns, getVulnerabilitiesByFile(&amp;query, fileName, purl)...)
        }</span>
        <span class="cov7" title="4">return vulns</span>
}

// InitCycloneDxReport inits the CycloneDx report with no components (consequently, no vulnerabilities)
func InitCycloneDxReport() *CycloneDxReport <span class="cov7" title="4">{
        metadata := Metadata{
                Timestamp: time.Now().Format(time.RFC3339),
                Tools: &amp;[]Tool{
                        {
                                Vendor:  "Checkmarx",
                                Name:    "KICS",
                                Version: constants.Version,
                        },
                },
        }

        return &amp;CycloneDxReport{
                XMLNS:        "http://cyclonedx.org/schema/bom/1.5",
                XMLNSV:       "http://cyclonedx.org/schema/ext/vulnerability/1.0",
                SerialNumber: "urn:uuid:" + uuid.New().String(),
                Version:      1,
                Metadata:     &amp;metadata,
        }
}</span>

// BuildCycloneDxReport builds the CycloneDX report
func BuildCycloneDxReport(summary *model.Summary, filePaths map[string]string) *CycloneDxReport <span class="cov5" title="3">{
        var component Component
        var vuln []Vulnerability
        var version, sha, purl, filePath string

        bom := InitCycloneDxReport()
        files := getAllFiles(summary)

        for i := range files </span><span class="cov7" title="4">{
                filePath = strings.Replace(files[i].FileName, "\\", "/", -1)
                sha = generateSha256(files[i].FileName, filePaths)

                index := 12
                if len(sha) &lt; index </span><span class="cov0" title="0">{
                        log.Trace().Msgf("failed to generate SHA-256 for %s", filePath)
                        continue</span>
                }

                <span class="cov7" title="4">version = fmt.Sprintf("0.0.0-%s", sha[0:12])
                purl = getPurl(filePath, version)
                vuln = getVulnerabilities(files[i].FileName, purl, summary)

                component = Component{
                        Type:    "file",
                        BomRef:  purl,
                        Name:    filePath,
                        Version: version,
                        Purl:    purl,
                        Hashes: []Hash{
                                {
                                        Alg:     "SHA-256",
                                        Content: sha,
                                },
                        },
                        Vulnerabilities: vuln,
                }

                bom.Components.Components = append(bom.Components.Components, component)</span>
        }

        <span class="cov5" title="3">return bom</span>
}
</pre>
		
		<pre class="file" id="file116" style="display: none">package model

import (
        "fmt"
        "strings"
        "time"

        "github.com/Checkmarx/kics/v2/internal/constants"
        "github.com/Checkmarx/kics/v2/pkg/model"
        "golang.org/x/text/cases"
        "golang.org/x/text/language"
)

const timeFormat = "2006-01-02T15:04:05" // YYYY-MM-DDTHH:MM:SS a.k.a ISO8601

type gitlabSASTReport struct {
        Schema          string                    `json:"schema"`
        SchemaVersion   string                    `json:"version"`
        Scan            gitlabSASTScan            `json:"scan"`
        Vulnerabilities []gitlabSASTVulnerability `json:"vulnerabilities"`
}

type gitlabSASTScan struct {
        Analyzer  gitlabSASTAnalyzer `json:"analyzer"`
        StartTime string             `json:"start_time"`
        EndTime   string             `json:"end_time"`
        Status    string             `json:"status"`
        Scantype  string             `json:"type"`
        Scanner   gitlabSASTScanner  `json:"scanner"`
}

type gitlabSASTScanner struct {
        ID      string                  `json:"id"`
        Name    string                  `json:"name"`
        URL     string                  `json:"url"`
        Version string                  `json:"version"`
        Vendor  gitlabSASTScannerVendor `json:"vendor"`
}

type gitlabSASTScannerVendor struct {
        Name string `json:"name"`
}

type gitlabSASTVulnerabilityDetails map[string]interface{}

type gitlabSASTVulnerability struct {
        ID          string                              `json:"id"`
        Severity    string                              `json:"severity"`
        Name        string                              `json:"name"`
        CWE         string                              `json:"cwe,omitempty"`
        Links       []gitlabSASTVulnerabilityLink       `json:"links"`
        Location    gitlabSASTVulnerabilityLocation     `json:"location"`
        Identifiers []gitlabSASTVulnerabilityIdentifier `json:"identifiers"`
        Details     gitlabSASTVulnerabilityDetails      `json:"details,omitempty"`
}

type gitlabSASTVulnerabilityLink struct {
        URL string `json:"url"`
}

type gitlabSASTVulnerabilityLocation struct {
        File  string `json:"file"`
        Start int    `json:"start_line"`
        End   int    `json:"end_line"`
}

type gitlabSASTVulnerabilityIdentifier struct {
        IdentifierType string `json:"type"`
        Name           string `json:"name"`
        URL            string `json:"url"`
        Value          string `json:"value"`
}

type gitlabSASTAnalyzer struct {
        ID      string                  `json:"id"`
        Name    string                  `json:"name"`
        Version string                  `json:"version"`
        Vendor  gitlabSASTScannerVendor `json:"vendor"`
}

// GitlabSASTReport represents a usable gitlab sast report reference
type GitlabSASTReport interface {
        BuildGitlabSASTVulnerability(issue *model.QueryResult, file *model.VulnerableFile)
}

// NewGitlabSASTReport initializes a new instance of GitlabSASTReport to be used
func NewGitlabSASTReport(start, end time.Time) GitlabSASTReport <span class="cov10" title="5">{
        return &amp;gitlabSASTReport{
                Schema:          "https://gitlab.com/gitlab-org/security-products/security-report-schemas/-/raw/v15.0.6/dist/sast-report-format.json",
                SchemaVersion:   "15.0.6",
                Scan:            initGitlabSASTScan(start, end),
                Vulnerabilities: make([]gitlabSASTVulnerability, 0),
        }
}</span>

func initGitlabSASTScan(start, end time.Time) gitlabSASTScan <span class="cov10" title="5">{
        return gitlabSASTScan{
                Analyzer: gitlabSASTAnalyzer{
                        ID:      "keeping-infrastructure-as-code-secure",
                        Name:    constants.Fullname,
                        Version: constants.Version,
                        Vendor: gitlabSASTScannerVendor{
                                Name: "Checkmarx",
                        },
                },
                Status:    "success",
                Scantype:  "sast",
                StartTime: start.Format(timeFormat),
                EndTime:   end.Format(timeFormat),
                Scanner: gitlabSASTScanner{
                        ID:   "keeping-infrastructure-as-code-secure",
                        Name: constants.Fullname,
                        URL:  constants.URL,
                        Vendor: gitlabSASTScannerVendor{
                                Name: "Checkmarx",
                        },
                        Version: constants.Version,
                },
        }
}</span>

// BuildGitlabSASTVulnerability adds a new vulnerability struct to vulnerability slice
func (glsr *gitlabSASTReport) BuildGitlabSASTVulnerability(issue *model.QueryResult, file *model.VulnerableFile) <span class="cov8" title="4">{
        if len(issue.Files) &gt; 0 </span><span class="cov7" title="3">{
                vulnerability := gitlabSASTVulnerability{
                        ID:       file.SimilarityID,
                        Severity: cases.Title(language.Und).String(strings.ToLower(string(issue.Severity))),
                        Name:     issue.QueryName,
                        CWE:      issue.CWE,
                        Links: []gitlabSASTVulnerabilityLink{
                                {
                                        URL: issue.QueryURI,
                                },
                        },
                        Location: gitlabSASTVulnerabilityLocation{
                                File:  file.FileName,
                                Start: file.Line,
                                End:   file.Line,
                        },
                        Identifiers: []gitlabSASTVulnerabilityIdentifier{
                                {
                                        IdentifierType: "kics",
                                        Name:           constants.Fullname,
                                        URL:            fmt.Sprintf("https://docs.kics.io/latest/queries/%s-queries", strings.ToLower(issue.Platform)),
                                        Value:          issue.QueryID,
                                },
                        },
                }
                if issue.CISDescriptionID != "" </span><span class="cov0" title="0">{
                        vulnerability.Details = gitlabSASTVulnerabilityDetails{
                                "cisTitle": issue.CISDescriptionTitle,
                                "cisId":    issue.CISDescriptionIDFormatted,
                        }
                }</span>
                <span class="cov7" title="3">glsr.Vulnerabilities = append(glsr.Vulnerabilities, vulnerability)</span>
        }
}
</pre>
		
		<pre class="file" id="file117" style="display: none">package model

import (
        "encoding/xml"
        "fmt"
        "strings"

        "github.com/Checkmarx/kics/v2/internal/constants"
        "github.com/Checkmarx/kics/v2/pkg/model"
)

type junitTestSuites struct {
        XMLName    xml.Name         `xml:"testsuites"`
        Name       string           `xml:"name,attr"`
        Time       string           `xml:"time,attr"`
        Failures   string           `xml:"failures,attr"`
        TestSuites []junitTestSuite `xml:"testsuite"`
}

type junitTestSuite struct {
        XMLName   xml.Name        `xml:"testsuite"`
        Name      string          `xml:"name,attr"`
        Failures  string          `xml:"failures,attr"`
        Tests     string          `xml:"tests,attr"`
        TestCases []junitTestCase `xml:"testcase"`
        failCount int
}

type junitTestCase struct {
        XMLName   xml.Name       `xml:"testcase"`
        CWE       string         `xml:"cwe,attr,omitempty"`
        Name      string         `xml:"name,attr"`
        ClassName string         `xml:"classname,attr"`
        Failures  []junitFailure `xml:"failure"`
}

type junitFailure struct {
        XMLName xml.Name `xml:"failure"`
        Type    string   `xml:"type,attr"`    // Query name
        Message string   `xml:"message,attr"` // File name + line number
}

// JUnitReport is a JUnit report representation
type JUnitReport interface {
        GenerateTestEntry(query *model.QueryResult)
        FinishReport()
}

// NewJUnitReport creates a new JUnit report instance
func NewJUnitReport(time string) JUnitReport <span class="cov10" title="5">{
        return &amp;junitTestSuites{
                Name:       fmt.Sprintf("KICS %s", constants.Version),
                Time:       time,
                Failures:   "",
                TestSuites: []junitTestSuite{},
        }
}</span>

// GenerateTestEntry generates a new test entry for failed tests on KICS scan
func (jUnit *junitTestSuites) GenerateTestEntry(query *model.QueryResult) <span class="cov7" title="3">{
        queryDescription := query.Description
        if query.CISDescriptionTextFormatted != "" </span><span class="cov0" title="0">{
                queryDescription = query.CISDescriptionTextFormatted
        }</span>

        <span class="cov7" title="3">failedTestCases := []junitTestCase{}

        for idx := range query.Files </span><span class="cov7" title="3">{
                failedTestCase := junitTestCase{
                        Name:      fmt.Sprintf("%s: %s file in line %d", query.QueryName, query.Files[idx].FileName, query.Files[idx].Line),
                        ClassName: query.Platform,
                        CWE:       query.CWE,
                        Failures:  []junitFailure{},
                }

                failedTest := junitFailure{
                        Type: queryDescription,
                        Message: fmt.Sprintf(
                                "[Severity: %s, Query description: %s] Problem found on '%s' file in line %d. Expected value: %s. Actual value: %s.",
                                query.Severity,
                                queryDescription,
                                query.Files[idx].FileName,
                                query.Files[idx].Line,
                                strings.TrimRight(query.Files[idx].KeyExpectedValue, "."),
                                strings.TrimRight(query.Files[idx].KeyActualValue, "."),
                        ),
                }

                failedTestCase.Failures = append(failedTestCase.Failures, failedTest)
                failedTestCases = append(failedTestCases, failedTestCase)
        }</span>

        <span class="cov7" title="3">newTestSuite := junitTestSuite{
                Name:      query.Platform,
                Failures:  "",
                Tests:     "",
                failCount: len(query.Files),
                TestCases: failedTestCases,
        }

        jUnit.TestSuites = append(jUnit.TestSuites, newTestSuite)</span>
}

// FinishReport finishes the report, adding the total number of failed tests for each platform and the total number of failed tests
func (jUnit *junitTestSuites) FinishReport() <span class="cov8" title="4">{
        failsCount := 0
        for idx := range jUnit.TestSuites </span><span class="cov7" title="3">{
                failsCount += jUnit.TestSuites[idx].failCount
                jUnit.TestSuites[idx].Failures = fmt.Sprintf("%d", jUnit.TestSuites[idx].failCount)
                jUnit.TestSuites[idx].Tests = fmt.Sprintf("%d", jUnit.TestSuites[idx].failCount)
        }</span>
        <span class="cov8" title="4">jUnit.Failures = fmt.Sprintf("%d", failsCount)</span>
}
</pre>
		
		<pre class="file" id="file118" style="display: none">package model

import (
        "encoding/csv"
        "encoding/json"
        "os"
        "path/filepath"

        "github.com/Checkmarx/kics/v2/internal/constants"
        "github.com/Checkmarx/kics/v2/pkg/model"
        "github.com/google/uuid"
        "github.com/rs/zerolog/log"
)

var categoriesNotFound = make(map[string]bool)

var severityLevelEquivalence = map[model.Severity]string{
        "INFO":     "none",
        "LOW":      "note",
        "MEDIUM":   "warning",
        "HIGH":     "error",
        "CRITICAL": "error",
}

var targetTemplate = sarifDescriptorReference{
        ToolComponent: sarifComponentReference{
                ComponentReferenceGUID:  "58cdcc6f-fe41-4724-bfb3-131a93df4c3f",
                ComponentReferenceName:  "Categories",
                ComponentReferenceIndex: 0,
        },
}

var cweTemplate = cweDescriptorReference{
        ToolComponent: cweComponentReference{
                ComponentReferenceGUID: "1489b0c4-d7ce-4d31-af66-6382a01202e3",
                ComponentReferenceName: "CWE",
        },
}

type sarifProperties map[string]interface{}

type ruleMetadata struct {
        queryID          string
        queryName        string
        queryDescription string
        queryURI         string
        queryCategory    string
        queryCwe         string
        severity         model.Severity
}

type ruleCISMetadata struct {
        descriptionText string
        id              string
        title           string
}

type sarifMessage struct {
        Text              string          `json:"text"`
        MessageProperties sarifProperties `json:"properties,omitempty"`
}

type sarifComponentReference struct {
        ComponentReferenceName  string `json:"name,omitempty"`
        ComponentReferenceGUID  string `json:"guid,omitempty"`
        ComponentReferenceIndex int    `json:"index,omitempty"`
}

type cweComponentReference struct {
        ComponentReferenceGUID string `json:"guid"`
        ComponentReferenceName string `json:"name"`
}

type sarifDescriptorReference struct {
        ReferenceID    string                  `json:"id,omitempty"`
        ReferenceGUID  string                  `json:"guid,omitempty"`
        ReferenceIndex int                     `json:"index,omitempty"`
        ToolComponent  sarifComponentReference `json:"toolComponent,omitempty"`
}

type cweMessage struct {
        Text string `json:"text"`
}

type cweCsv struct {
        CweID            string     `json:"id"`
        FullDescription  cweMessage `json:"fullDescription"`
        ShortDescription cweMessage `json:"shortDescription"`
        GUID             string     `json:"guid"`
        HelpURI          string     `json:"helpUri"`
}

type cweDescriptorReference struct {
        ReferenceID   string                `json:"id"`
        ReferenceGUID string                `json:"guid"`
        ToolComponent cweComponentReference `json:"toolComponent"`
}

type sarifConfiguration struct {
        Level string `json:"level"`
}

type sarifRelationship struct {
        Relationship sarifDescriptorReference `json:"target,omitempty"`
}

type sarifRule struct {
        RuleID               string              `json:"id"`
        RuleName             string              `json:"name"`
        RuleShortDescription sarifMessage        `json:"shortDescription"`
        RuleFullDescription  sarifMessage        `json:"fullDescription"`
        DefaultConfiguration sarifConfiguration  `json:"defaultConfiguration"`
        HelpURI              string              `json:"helpUri"`
        Relationships        []sarifRelationship `json:"relationships,omitempty"`
        RuleProperties       sarifProperties     `json:"properties,omitempty"`
}

type sarifDriver struct {
        ToolName     string      `json:"name"`
        ToolVersion  string      `json:"version"`
        ToolFullName string      `json:"fullName"`
        ToolURI      string      `json:"informationUri"`
        Rules        []sarifRule `json:"rules"`
}

type sarifTool struct {
        Driver sarifDriver `json:"driver"`
}

type sarifRegion struct {
        StartLine int `json:"startLine"`
}

type sarifArtifactLocation struct {
        ArtifactURI string `json:"uri"`
}

type sarifPhysicalLocation struct {
        ArtifactLocation sarifArtifactLocation `json:"artifactLocation"`
        Region           sarifRegion           `json:"region"`
}

type sarifLocation struct {
        PhysicalLocation sarifPhysicalLocation `json:"physicalLocation"`
}

type sarifResult struct {
        ResultRuleID    string          `json:"ruleId"`
        ResultRuleIndex int             `json:"ruleIndex"`
        ResultKind      string          `json:"kind"`
        ResultMessage   sarifMessage    `json:"message"`
        ResultLocations []sarifLocation `json:"locations"`
}

type taxonomyDefinitions struct {
        DefinitionGUID             string     `json:"guid,omitempty"`
        DefinitionName             string     `json:"name,omitempty"`
        DefinitionID               string     `json:"id"`
        DefinitionShortDescription cweMessage `json:"shortDescription"`
        DefinitionFullDescription  cweMessage `json:"fullDescription"`
        HelpURI                    string     `json:"helpUri,omitempty"`
}

type cweTaxonomiesWrapper struct {
        Taxonomies sarifTaxonomy `json:"taxonomies"`
}

type sarifTaxonomy struct {
        TaxonomyGUID                              string                `json:"guid"`
        TaxonomyName                              string                `json:"name"`
        TaxonomyFullDescription                   sarifMessage          `json:"fullDescription,omitempty"`
        TaxonomyShortDescription                  sarifMessage          `json:"shortDescription"`
        TaxonomyDownloadURI                       string                `json:"downloadUri,omitempty"`
        TaxonomyInformationURI                    string                `json:"informationUri,omitempty"`
        TaxonomyIsComprehensive                   bool                  `json:"isComprehensive,omitempty"`
        TaxonomyLanguage                          string                `json:"language,omitempty"`
        TaxonomyMinRequiredLocDataSemanticVersion string                `json:"minimumRequiredLocalizedDataSemanticVersion,omitempty"`
        TaxonomyOrganization                      string                `json:"organization,omitempty"`
        TaxonomyRealeaseDateUtc                   string                `json:"releaseDateUtc,omitempty"`
        TaxonomyDefinitions                       []taxonomyDefinitions `json:"taxa"`
}

// SarifRun - sarifRun is a component of the SARIF report
type SarifRun struct {
        Tool       sarifTool       `json:"tool"`
        Results    []sarifResult   `json:"results"`
        Taxonomies []sarifTaxonomy `json:"taxonomies"`
}

// SarifReport represents a usable sarif report reference
type SarifReport interface {
        BuildSarifIssue(issue *model.QueryResult) string
        RebuildTaxonomies(cwes []string, guids map[string]string)
        GetGUIDFromRelationships(idx int, cweID string) string
}

type sarifReport struct {
        Schema       string     `json:"$schema"`
        SarifVersion string     `json:"version"`
        Runs         []SarifRun `json:"runs"`
}

func initSarifTool() sarifTool <span class="cov3" title="5">{
        return sarifTool{
                Driver: sarifDriver{
                        ToolName:     "KICS",
                        ToolVersion:  constants.Version,
                        ToolFullName: constants.Fullname,
                        ToolURI:      constants.URL,
                        Rules:        make([]sarifRule, 0),
                },
        }
}</span>

func initSarifCategories() []taxonomyDefinitions <span class="cov3" title="5">{
        allCategories := []taxonomyDefinitions{noCategory}
        for _, category := range categories </span><span class="cov7" title="75">{
                allCategories = append(allCategories, category)
        }</span>
        <span class="cov3" title="5">return allCategories</span>
}

// initCweCategories is responsible for building the CWE taxa field, inside taxonomies
func initCweCategories(cweIDs []string, guids map[string]string) []taxonomyDefinitions <span class="cov1" title="1">{
        absPath, err := filepath.Abs(".")
        if err != nil </span><span class="cov0" title="0">{
                return []taxonomyDefinitions{}
        }</span>

        <span class="cov1" title="1">cweCSVPath := filepath.Join(absPath, "assets", "cwe_csv", "Software-Development-CWE.csv")
        cweCsvList, err := readCWECsvInfo(cweCSVPath)
        if err != nil </span><span class="cov0" title="0">{
                return []taxonomyDefinitions{}
        }</span>

        <span class="cov1" title="1">var taxonomyList []taxonomyDefinitions
        for _, cweID := range cweIDs </span><span class="cov2" title="2">{
                var matchingCweEntry cweCsv

                for _, cweEntry := range cweCsvList </span><span class="cov3" title="7">{
                        if cweEntry.CweID == cweID </span><span class="cov2" title="2">{
                                matchingCweEntry = cweEntry
                                break</span>
                        }
                }

                <span class="cov2" title="2">if matchingCweEntry.CweID == "" </span><span class="cov0" title="0">{
                        continue</span>
                }

                <span class="cov2" title="2">guid, exists := guids[cweID]
                if !exists </span><span class="cov0" title="0">{
                        continue</span>
                }

                <span class="cov2" title="2">taxonomy := taxonomyDefinitions{
                        DefinitionID:               matchingCweEntry.CweID,
                        DefinitionGUID:             guid,
                        DefinitionFullDescription:  matchingCweEntry.FullDescription,
                        DefinitionShortDescription: matchingCweEntry.ShortDescription,
                        HelpURI:                    matchingCweEntry.HelpURI,
                }
                taxonomyList = append(taxonomyList, taxonomy)</span>
        }

        <span class="cov1" title="1">return taxonomyList</span>
}

func initSarifTaxonomies() []sarifTaxonomy <span class="cov3" title="5">{
        var taxonomies []sarifTaxonomy
        // Categories

        if targetTemplate.ToolComponent.ComponentReferenceName == "Categories" </span><span class="cov3" title="5">{
                categories := sarifTaxonomy{
                        TaxonomyGUID: targetTemplate.ToolComponent.ComponentReferenceGUID,
                        TaxonomyName: targetTemplate.ToolComponent.ComponentReferenceName,
                        TaxonomyShortDescription: sarifMessage{
                                Text: "Vulnerabilities categories",
                        },
                        TaxonomyFullDescription: sarifMessage{
                                Text: "This taxonomy contains the types an issue can assume",
                        },
                        TaxonomyDefinitions: initSarifCategories(),
                }
                taxonomies = append(taxonomies, categories)
        }</span>

        <span class="cov3" title="5">cweInfoPath := filepath.Join(".", "assets", "cwe_csv", "cwe_taxonomies_latest.json")

        if cweTemplate.ToolComponent.ComponentReferenceName == "CWE" </span><span class="cov3" title="5">{
                cweInfo, err := readCWEInfo(cweInfoPath)
                if err != nil </span><span class="cov3" title="5">{
                        return taxonomies
                }</span>
                <span class="cov0" title="0">cweTaxonomy := sarifTaxonomy{
                        TaxonomyGUID:                              cweInfo.TaxonomyGUID,
                        TaxonomyName:                              cweInfo.TaxonomyName,
                        TaxonomyInformationURI:                    cweInfo.TaxonomyInformationURI,
                        TaxonomyIsComprehensive:                   cweInfo.TaxonomyIsComprehensive,
                        TaxonomyLanguage:                          cweInfo.TaxonomyLanguage,
                        TaxonomyOrganization:                      cweInfo.TaxonomyOrganization,
                        TaxonomyRealeaseDateUtc:                   cweInfo.TaxonomyRealeaseDateUtc,
                        TaxonomyMinRequiredLocDataSemanticVersion: cweInfo.TaxonomyMinRequiredLocDataSemanticVersion,
                        TaxonomyDownloadURI:                       cweInfo.TaxonomyDownloadURI,
                        TaxonomyFullDescription:                   sarifMessage{Text: cweInfo.TaxonomyFullDescription.Text},
                        TaxonomyShortDescription:                  sarifMessage{Text: cweInfo.TaxonomyShortDescription.Text},
                        TaxonomyDefinitions:                       []taxonomyDefinitions{},
                }
                taxonomies = append(taxonomies, cweTaxonomy)</span>
        }

        <span class="cov0" title="0">return taxonomies</span>
}

func initSarifRun() []SarifRun <span class="cov3" title="5">{
        return []SarifRun{
                {
                        Tool:       initSarifTool(),
                        Results:    make([]sarifResult, 0),
                        Taxonomies: initSarifTaxonomies(),
                },
        }
}</span>

// NewSarifReport creates and start a new sarif report with default values respecting SARIF schema 2.1.0
func NewSarifReport() SarifReport <span class="cov3" title="4">{
        return &amp;sarifReport{
                Schema:       "https://raw.githubusercontent.com/oasis-tcs/sarif-spec/master/Schemata/sarif-schema-2.1.0.json",
                SarifVersion: "2.1.0",
                Runs:         initSarifRun(),
        }
}</span>

func (sr *sarifReport) findSarifCategory(category string) int <span class="cov2" title="3">{
        for idx, taxonomy := range sr.Runs[0].Taxonomies[0].TaxonomyDefinitions </span><span class="cov6" title="48">{
                if taxonomy.DefinitionName == category </span><span class="cov0" title="0">{
                        return idx
                }</span>
        }
        <span class="cov2" title="3">return 0</span>
}

// readCWEInfo is responsible for reading the CWE taxonomy info from the json file
func readCWEInfo(filePath string) (sarifTaxonomy, error) <span class="cov4" title="8">{
        var wrapper cweTaxonomiesWrapper
        fileContent, err := os.ReadFile(filepath.Clean(filePath))
        if err != nil </span><span class="cov4" title="8">{
                return sarifTaxonomy{}, err
        }</span>

        <span class="cov0" title="0">err = json.Unmarshal(fileContent, &amp;wrapper)
        if err != nil </span><span class="cov0" title="0">{
                return sarifTaxonomy{}, err
        }</span>

        <span class="cov0" title="0">return wrapper.Taxonomies, nil</span>
}

func generateGUID() string <span class="cov10" title="400">{
        id := uuid.New()
        return id.String()
}</span>

// readCWECsvInfo is responsible for reading the CWE taxonomy info from the corresponding csv file
func readCWECsvInfo(filePath string) ([]cweCsv, error) <span class="cov1" title="1">{
        file, err := os.Open(filepath.Clean(filePath))
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov1" title="1">defer file.Close()

        reader := csv.NewReader(file)
        reader.FieldsPerRecord = -1 // Note: -1 means records may have a variable number of fields in the csv file
        records, err := reader.ReadAll()

        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>

        <span class="cov1" title="1">var cweEntries []cweCsv
        numRecords := 23

        for _, record := range records </span><span class="cov10" title="400">{
                if len(record) &gt;= numRecords </span><span class="cov10" title="400">{
                        cweEntry := cweCsv{
                                CweID: record[0],
                                FullDescription: cweMessage{
                                        Text: record[5],
                                },
                                ShortDescription: cweMessage{
                                        Text: record[4],
                                },
                                GUID:    generateGUID(),
                                HelpURI: "https://cwe.mitre.org/data/definitions/" + record[0] + ".html",
                        }

                        // Check if Extended Description is empty, fill it with Description if so
                        if cweEntry.FullDescription.Text == "" </span><span class="cov7" title="98">{
                                cweEntry.FullDescription.Text = record[4]
                        }</span>

                        <span class="cov10" title="400">cweEntries = append(cweEntries, cweEntry)</span>
                }
        }

        <span class="cov1" title="1">return cweEntries, nil</span>
}

// buildCweCategory builds the CWE category in taxonomies, with info from CWE and CSV
func (sr *sarifReport) buildCweCategory(cweID string) sarifDescriptorReference <span class="cov2" title="3">{
        absPath, err := filepath.Abs(".")
        if err != nil </span><span class="cov0" title="0">{
                return sarifDescriptorReference{}
        }</span>

        <span class="cov2" title="3">cweInfoPath := filepath.Join(absPath, "assets", "cwe_csv", "cwe_taxonomies_latest.json")
        cweCSVPath := filepath.Join(absPath, "assets", "cwe_csv", "Software-Development-CWE.csv")

        cweInfo, err := readCWEInfo(cweInfoPath)
        if err != nil </span><span class="cov2" title="3">{
                return sarifDescriptorReference{}
        }</span>

        <span class="cov0" title="0">_ = cweInfo

        cweCsvList, err := readCWECsvInfo(cweCSVPath)
        if err != nil </span><span class="cov0" title="0">{
                return sarifDescriptorReference{}
        }</span>

        <span class="cov0" title="0">var matchingCweEntry cweCsv
        for _, cweEntry := range cweCsvList </span><span class="cov0" title="0">{
                if cweEntry.CweID == cweID </span><span class="cov0" title="0">{
                        matchingCweEntry = cweEntry
                        break</span>
                }
        }

        <span class="cov0" title="0">if matchingCweEntry.CweID == "" </span><span class="cov0" title="0">{
                return sarifDescriptorReference{}
        }</span>

        <span class="cov0" title="0">newGUID := generateGUID()

        cwe := sarifDescriptorReference{
                ReferenceID:   matchingCweEntry.CweID,
                ReferenceGUID: newGUID,
                ToolComponent: sarifComponentReference{
                        ComponentReferenceGUID: "1489b0c4-d7ce-4d31-af66-6382a01202e3",
                        ComponentReferenceName: "CWE",
                },
        }

        return cwe</span>
}

func (sr *sarifReport) buildSarifCategory(category string) sarifDescriptorReference <span class="cov2" title="3">{
        target := targetTemplate
        categoryIndex := sr.findSarifCategory(category)

        if categoryIndex &gt;= 0 </span><span class="cov2" title="3">{
                taxonomy := sr.Runs[0].Taxonomies[0].TaxonomyDefinitions[categoryIndex]

                target.ReferenceID = taxonomy.DefinitionID
        }</span>
        <span class="cov2" title="3">target.ReferenceIndex = categoryIndex

        if categoryIndex == -1 </span><span class="cov0" title="0">{
                if _, exists := categoriesNotFound[category]; !exists </span><span class="cov0" title="0">{
                        log.Warn().Msgf("Category %s not found.", category)
                        categoriesNotFound[category] = true
                }</span>
        }

        <span class="cov2" title="3">return target</span>
}

func (sr *sarifReport) findSarifRuleIndex(ruleID string) int <span class="cov2" title="3">{
        for idx := range sr.Runs[0].Tool.Driver.Rules </span><span class="cov1" title="1">{
                if sr.Runs[0].Tool.Driver.Rules[idx].RuleID == ruleID </span><span class="cov0" title="0">{
                        return idx
                }</span>
        }
        <span class="cov2" title="3">return -1</span>
}

func (sr *sarifReport) buildSarifRule(queryMetadata *ruleMetadata, cisMetadata ruleCISMetadata) int <span class="cov2" title="3">{
        index := sr.findSarifRuleIndex(queryMetadata.queryID)

        if index &lt; 0 </span><span class="cov2" title="3">{
                helpURI := "https://docs.kics.io/"
                if queryMetadata.queryURI != "" </span><span class="cov2" title="3">{
                        helpURI = queryMetadata.queryURI
                }</span>

                <span class="cov2" title="3">target := sr.buildSarifCategory(queryMetadata.queryCategory)
                cwe := sr.buildCweCategory(queryMetadata.queryCwe)

                var relationships []sarifRelationship

                if cwe.ReferenceID != "" </span><span class="cov0" title="0">{
                        relationships = []sarifRelationship{
                                {Relationship: target},
                                {Relationship: cwe},
                        }
                }</span> else<span class="cov2" title="3"> {
                        relationships = []sarifRelationship{
                                {Relationship: target},
                        }
                }</span>

                <span class="cov2" title="3">rule := sarifRule{
                        RuleID:               queryMetadata.queryID,
                        RuleName:             queryMetadata.queryName,
                        RuleShortDescription: sarifMessage{Text: queryMetadata.queryName},
                        RuleFullDescription:  sarifMessage{Text: queryMetadata.queryDescription},
                        DefaultConfiguration: sarifConfiguration{Level: severityLevelEquivalence[queryMetadata.severity]},
                        Relationships:        relationships,
                        HelpURI:              helpURI,
                        RuleProperties:       nil,
                }
                if cisMetadata.id != "" </span><span class="cov0" title="0">{
                        rule.RuleFullDescription.Text = cisMetadata.descriptionText
                        rule.RuleProperties = sarifProperties{
                                "cisId":    cisMetadata.id,
                                "cisTitle": cisMetadata.title,
                        }
                }</span>

                <span class="cov2" title="3">sr.Runs[0].Tool.Driver.Rules = append(sr.Runs[0].Tool.Driver.Rules, rule)
                index = len(sr.Runs[0].Tool.Driver.Rules) - 1</span>
        }
        <span class="cov2" title="3">return index</span>
}

// GetGUIDFromRelationships gets the GUID from the relationship for each CWE item
func (sr *sarifReport) GetGUIDFromRelationships(idx int, cweID string) string <span class="cov0" title="0">{
        if len(sr.Runs) &gt; 0 </span><span class="cov0" title="0">{
                if len(sr.Runs[0].Tool.Driver.Rules) &gt; 0 </span><span class="cov0" title="0">{
                        relationships := sr.Runs[0].Tool.Driver.Rules[idx].Relationships
                        for _, relationship := range relationships </span><span class="cov0" title="0">{
                                target := relationship.Relationship

                                if target.ReferenceID == cweID </span><span class="cov0" title="0">{
                                        return target.ReferenceGUID
                                }</span>
                        }
                }
        }

        <span class="cov0" title="0">return ""</span>
}

// RebuildTaxonomies builds the taxonomies with the CWEs and the GUIDs coming from each relationships field
func (sr *sarifReport) RebuildTaxonomies(cwes []string, guids map[string]string) <span class="cov0" title="0">{
        if len(cwes) &gt; 0 </span><span class="cov0" title="0">{
                result := initCweCategories(cwes, guids)
                if len(sr.Runs) &gt; 0 </span><span class="cov0" title="0">{
                        if len(sr.Runs[0].Taxonomies) == 2 </span><span class="cov0" title="0">{
                                sr.Runs[0].Taxonomies[1].TaxonomyDefinitions = result
                        }</span>
                }
        }
}

// BuildSarifIssue creates a new entries in Results (one for each file) and new entry in Rules and Taxonomy if necessary
func (sr *sarifReport) BuildSarifIssue(issue *model.QueryResult) string <span class="cov3" title="4">{
        if len(issue.Files) &gt; 0 </span><span class="cov2" title="3">{
                metadata := ruleMetadata{
                        queryID:          issue.QueryID,
                        queryName:        issue.QueryName,
                        queryDescription: issue.Description,
                        queryURI:         issue.QueryURI,
                        queryCategory:    issue.Category,
                        queryCwe:         issue.CWE,
                        severity:         issue.Severity,
                }
                cisDescriptions := ruleCISMetadata{
                        id:              issue.CISDescriptionIDFormatted,
                        title:           issue.CISDescriptionTitle,
                        descriptionText: issue.CISDescriptionTextFormatted,
                }
                ruleIndex := sr.buildSarifRule(&amp;metadata, cisDescriptions)

                kind := "fail"
                if severityLevelEquivalence[issue.Severity] == "none" </span><span class="cov1" title="1">{
                        kind = "informational"
                }</span>
                <span class="cov2" title="3">for idx := range issue.Files </span><span class="cov2" title="3">{
                        line := issue.Files[idx].Line
                        if line &lt; 1 </span><span class="cov1" title="1">{
                                line = 1
                        }</span>
                        <span class="cov2" title="3">result := sarifResult{
                                ResultRuleID:    issue.QueryID,
                                ResultRuleIndex: ruleIndex,
                                ResultKind:      kind,
                                ResultMessage: sarifMessage{
                                        Text: issue.Files[idx].KeyActualValue,
                                        MessageProperties: sarifProperties{
                                                "platform": issue.Platform,
                                        },
                                },
                                ResultLocations: []sarifLocation{
                                        {
                                                PhysicalLocation: sarifPhysicalLocation{
                                                        ArtifactLocation: sarifArtifactLocation{ArtifactURI: issue.Files[idx].FileName},
                                                        Region:           sarifRegion{StartLine: line},
                                                },
                                        },
                                },
                        }
                        sr.Runs[0].Results = append(sr.Runs[0].Results, result)</span>
                }
                <span class="cov2" title="3">return issue.CWE</span>
        }
        <span class="cov1" title="1">return ""</span>
}
</pre>
		
		<pre class="file" id="file119" style="display: none">package model

const categoryIdentifier = "CAT"

var noCategory = taxonomyDefinitions{
        DefinitionID:               categoryIdentifier + "000",
        DefinitionName:             "Undefined Category",
        DefinitionShortDescription: cweMessage{Text: "Category is not defined"},
        DefinitionFullDescription:  cweMessage{Text: "Category is not defined"},
}

func createSarifCategory(identifier, name, description string) taxonomyDefinitions <span class="cov10" title="15">{
        return taxonomyDefinitions{
                DefinitionID:   identifier,
                DefinitionName: name,
                DefinitionShortDescription: cweMessage{
                        Text: description,
                },
                DefinitionFullDescription: cweMessage{
                        Text: description,
                },
        }
}</span>

var categories = map[string]taxonomyDefinitions{
        "Access Control": createSarifCategory(categoryIdentifier+"001", "Access Control", "Service permission and identity management"),
        "Availability":   createSarifCategory(categoryIdentifier+"002", "Availability", "Reliability and Scalability"),
        "Backup":         createSarifCategory(categoryIdentifier+"003", "Backup", "Survivability and Recovery"),
        "Best Practices": createSarifCategory(categoryIdentifier+"004", "Best Practices", "Metadata management"),
        "Build Process": createSarifCategory(
                categoryIdentifier+"005",
                "Build Process",
                "Insecure configurations when building/deploying",
        ),
        "Encryption": createSarifCategory(categoryIdentifier+"006", "Encryption", "Data Security and Encryption configuration"),
        "Insecure Configurations": createSarifCategory(
                categoryIdentifier+"007",
                "Insecure Configurations",
                "Configurations which expose the application unnecessarily",
        ),
        "Insecure Defaults": createSarifCategory(
                categoryIdentifier+"008",
                "Insecure Defaults",
                "Configurations that are insecure by default",
        ),
        "Networking and Firewall": createSarifCategory(
                categoryIdentifier+"009",
                "Networking and Firewall",
                "Network port exposure and firewall configuration",
        ),
        "Observability": createSarifCategory(categoryIdentifier+"010", "Observability", "Logging and Monitoring"),
        "Resource Management": createSarifCategory(
                categoryIdentifier+"011",
                "Resource Management",
                "Resource and privilege limit configuration",
        ),
        "Secret Management": createSarifCategory(categoryIdentifier+"012", "Secret Management", "Secret and Key management"),
        "Supply-Chain":      createSarifCategory(categoryIdentifier+"013", "Supply-Chain", "Dependency version management"),
        "Structure and Semantics": createSarifCategory(
                categoryIdentifier+"014",
                "Structure and Semantics",
                "Malformed document structure or inadequate semantics",
        ),
        "Bill Of Materials": createSarifCategory(categoryIdentifier+"015", "Bill Of Materials", "List of resources provisioned"),
}
</pre>
		
		<pre class="file" id="file120" style="display: none">package model

import (
        "github.com/Checkmarx/kics/v2/internal/constants"
        "github.com/Checkmarx/kics/v2/pkg/model"
)

// severitySonarQubeEquivalence maps the severity of the KICS to the SonarQube equivalent
var severitySonarQubeEquivalence = map[model.Severity]string{
        "INFO":     "INFO",
        "LOW":      "MINOR",
        "MEDIUM":   "MAJOR",
        "HIGH":     "CRITICAL",
        "CRITICAL": "BLOCKER",
}

// categorySonarQubeEquivalence maps the category to the SonarQube equivalent
var categorySonarQubeEquivalence = map[string]string{
        "Access Control":          "VULNERABILITY",
        "Availability":            "VULNERABILITY",
        "Backup":                  "VULNERABILITY",
        "Best Practices":          "CODE_SMELL",
        "Build Process":           "VULNERABILITY",
        "Encryption":              "VULNERABILITY",
        "Insecure Configurations": "CODE_SMELL",
        "Insecure Defaults":       "CODE_SMELL",
        "Networking and Firewall": "VULNERABILITY",
        "Observability":           "VULNERABILITY",
        "Resource Management":     "VULNERABILITY",
        "Secret Management":       "VULNERABILITY",
        "Supply-Chain":            "VULNERABILITY",
        "Structure and Semantics": "CODE_SMELL",
}

// SonarQubeReportBuilder is the builder for the SonarQubeReport struct
type SonarQubeReportBuilder struct {
        version string
        report  *SonarQubeReport
}

// SonarQubeReport is a list of issues for SonarQube Report
type SonarQubeReport struct {
        Issues []Issue `json:"issues"`
}

// Issue is a single issue for SonarQube Report
type Issue struct {
        EngineID           string      `json:"engineId"`
        RuleID             string      `json:"ruleId"`
        Severity           string      `json:"severity"`
        CWE                string      `json:"cwe,omitempty"`
        Type               string      `json:"type"`
        PrimaryLocation    *Location   `json:"primaryLocation"`
        SecondaryLocations []*Location `json:"secondaryLocations,omitempty"`
}

// Location is the location for the vulnerability in the SonarQube Report
type Location struct {
        Message   string `json:"message"`
        FilePath  string `json:"filePath"`
        TextRange *Range `json:"textRange"`
}

// Range is the range for the vulnerability in the SonarQube Report
type Range struct {
        StartLine int `json:"startLine"`
}

// NewSonarQubeRepory creates a new SonarQubeReportBuilder instance
func NewSonarQubeRepory() *SonarQubeReportBuilder <span class="cov1" title="1">{
        return &amp;SonarQubeReportBuilder{
                version: "KICS " + constants.Version,
                report: &amp;SonarQubeReport{
                        Issues: make([]Issue, 0),
                },
        }
}</span>

// BuildReport builds the SonarQubeReport from the given QueryResults
func (s *SonarQubeReportBuilder) BuildReport(summary *model.Summary) *SonarQubeReport <span class="cov7" title="3">{
        for i := range summary.Queries </span><span class="cov7" title="3">{
                s.buildIssue(&amp;summary.Queries[i])
        }</span>
        <span class="cov7" title="3">return s.report</span>
}

// buildIssue builds the issue from the given QueryResult and adds it to the SonarQubeReport
func (s *SonarQubeReportBuilder) buildIssue(query *model.QueryResult) <span class="cov7" title="3">{
        issue := Issue{
                EngineID:           s.version,
                RuleID:             query.QueryID,
                Severity:           severitySonarQubeEquivalence[query.Severity],
                CWE:                query.CWE,
                Type:               categorySonarQubeEquivalence[query.Category],
                PrimaryLocation:    buildLocation(0, query),
                SecondaryLocations: buildSecondaryLocation(query),
        }
        s.report.Issues = append(s.report.Issues, issue)
}</span>

// buildSecondaryLocation builds the secondary location for the SonarQube Report
func buildSecondaryLocation(query *model.QueryResult) []*Location <span class="cov7" title="3">{
        locations := make([]*Location, 0)
        for i := range query.Files[1:] </span><span class="cov4" title="2">{
                locations = append(locations, buildLocation(i+1, query))
        }</span>
        <span class="cov7" title="3">return locations</span>
}

// buildLocation builds the location for the SonarQube Report
func buildLocation(index int, query *model.QueryResult) *Location <span class="cov10" title="5">{
        message := query.Description
        if query.CISDescriptionID != "" </span><span class="cov0" title="0">{
                message = query.CISDescriptionID
        }</span>
        <span class="cov10" title="5">return &amp;Location{
                Message:  message,
                FilePath: query.Files[index].FileName,
                TextRange: &amp;Range{
                        StartLine: query.Files[index].Line,
                },
        }</span>
}
</pre>
		
		<pre class="file" id="file121" style="display: none">package report

import (
        _ "embed" // used for embedding report static files
        "fmt"
        "path/filepath"
        "time"

        "github.com/Checkmarx/kics/v2/internal/constants"
        "github.com/Checkmarx/kics/v2/pkg/model"
        "github.com/johnfercher/maroto/pkg/color"
        "github.com/johnfercher/maroto/pkg/consts"
        "github.com/johnfercher/maroto/pkg/pdf"
        "github.com/johnfercher/maroto/pkg/props"
        "github.com/rs/zerolog/log"
)

const (
        defaultTextSize = 8
        smallTextSize   = 6
        pgMarginLeft    = 10
        pgMarginTop     = 15
        pgMarginRight   = 10
        rowXSmall       = 3
        rowSmall        = 4
        rowMedium       = 5
        rowLarge        = 8
        rowXLarge       = 15
        colOne          = 1
        colTwo          = 2
        colThree        = 3
        colFour         = 4
        colFive         = 5
        colSix          = 6
        colEight        = 8
        colNine         = 9
        colTen          = 10
        colFullPage     = 12
        colRuneSlitter  = 20
        textSize        = 10
)

var (
        grayColor = getGrayColor()
        //go:embed assets/vuln
        vulnImageBase64 string
        //go:embed assets/checkmarx-logo
        checkmarxLogo string
)

func createQueryEntryMetadataField(m pdf.Maroto, label, value string, textSize int) <span class="cov9" title="16">{
        m.Col(colTwo, func() </span><span class="cov9" title="16">{
                m.Text(label, props.Text{
                        Size:        float64(textSize),
                        Align:       consts.Left,
                        Extrapolate: false,
                })
        }</span>)
        <span class="cov9" title="16">m.Col(colTwo, func() </span><span class="cov9" title="16">{
                m.Text(value, props.Text{
                        Size:        float64(textSize),
                        Align:       consts.Left,
                        Extrapolate: false,
                })
        }</span>)
}

func createQueriesTable(m pdf.Maroto, queries []model.QueryResult) error <span class="cov5" title="4">{
        for i := range queries </span><span class="cov5" title="4">{
                m.SetBackgroundColor(color.NewWhite())
                queryName := queries[i].QueryName
                resultsCount := fmt.Sprint(len(queries[i].Files))
                severity := string(queries[i].Severity)
                platform := queries[i].Platform
                cwe := queries[i].CWE
                category := queries[i].Category
                description := queries[i].Description
                var err error
                m.Row(rowLarge, func() </span><span class="cov5" title="4">{
                        m.Col(colOne, func() </span><span class="cov5" title="4">{
                                err = m.Base64Image(vulnImageBase64, consts.Png, props.Rect{
                                        Center:  false,
                                        Percent: 50,
                                        Left:    2,
                                })
                        }</span>)
                        <span class="cov5" title="4">m.Col(colNine, func() </span><span class="cov5" title="4">{
                                m.Text(queryName, props.Text{
                                        Size:        11,
                                        Style:       consts.Bold,
                                        Align:       consts.Left,
                                        Extrapolate: false,
                                })
                        }</span>)
                        <span class="cov5" title="4">m.Col(colOne, func() </span><span class="cov5" title="4">{
                                m.Text("Results", props.Text{
                                        Size:        8,
                                        Style:       consts.Bold,
                                        Align:       consts.Right,
                                        Extrapolate: false,
                                })
                        }</span>)
                        <span class="cov5" title="4">m.Col(colOne, func() </span><span class="cov5" title="4">{
                                m.Text(resultsCount, props.Text{
                                        Size:        8,
                                        Style:       consts.Bold,
                                        Align:       consts.Right,
                                        Extrapolate: false,
                                })
                        }</span>)
                })
                <span class="cov5" title="4">if err != nil </span><span class="cov0" title="0">{
                        return err
                }</span>
                <span class="cov5" title="4">m.Row(colFive, func() </span><span class="cov5" title="4">{
                        createQueryEntryMetadataField(m, "Severity", severity, textSize)
                }</span>)
                <span class="cov5" title="4">m.Row(colThree, func() </span><span class="cov5" title="4">{
                        createQueryEntryMetadataField(m, "Platform", platform, defaultTextSize)
                }</span>)
                <span class="cov5" title="4">m.Row(colFour, func() </span><span class="cov5" title="4">{
                        createQueryEntryMetadataField(m, "Cwe", cwe, defaultTextSize)
                }</span>)
                <span class="cov5" title="4">m.Row(colSix, func() </span><span class="cov5" title="4">{
                        createQueryEntryMetadataField(m, "Category", category, defaultTextSize)
                }</span>)
                <span class="cov5" title="4">if queries[i].CISDescriptionID != "" </span><span class="cov0" title="0">{
                        createCISRows(m, &amp;queries[i])
                }</span> else<span class="cov5" title="4"> {
                        createDescription(m, description)
                }</span>
                <span class="cov5" title="4">createResultsTable(m, &amp;queries[i])</span>
        }
        <span class="cov5" title="4">return nil</span>
}

func createDescription(m pdf.Maroto, description string) <span class="cov5" title="4">{
        m.Row(colFive, func() </span><span class="cov5" title="4">{
                m.Col(colTwo, func() </span><span class="cov5" title="4">{
                        m.Text("Description", props.Text{
                                Size:        float64(textSize),
                                Align:       consts.Left,
                                Style:       consts.Bold,
                                Extrapolate: false,
                        })
                }</span>)
        })
        <span class="cov5" title="4">m.Row(getRowLength(description), func() </span><span class="cov5" title="4">{
                m.Col(colFullPage, func() </span><span class="cov5" title="4">{
                        m.Text(description, props.Text{
                                Size:        float64(defaultTextSize),
                                Align:       consts.Left,
                                Extrapolate: false,
                        })
                }</span>)
        })
        <span class="cov5" title="4">m.Row(colFive, func() </span><span class="cov5" title="4">{
                m.ColSpace(0)
        }</span>)
}

func createCISRows(m pdf.Maroto, query *model.QueryResult) <span class="cov0" title="0">{
        cisID := query.CISDescriptionIDFormatted
        description := query.CISDescriptionTextFormatted
        title := query.CISDescriptionTitle

        m.Row(colFive, func() </span><span class="cov0" title="0">{
                m.Col(colTwo, func() </span><span class="cov0" title="0">{
                        m.Text("Description ID", props.Text{
                                Size:        float64(defaultTextSize),
                                Align:       consts.Left,
                                Style:       consts.Bold,
                                Extrapolate: false,
                        })
                }</span>)
                <span class="cov0" title="0">m.Col(colEight, func() </span><span class="cov0" title="0">{
                        m.Text(cisID, props.Text{
                                Size:        float64(defaultTextSize),
                                Align:       consts.Left,
                                Extrapolate: false,
                        })
                }</span>)
        })
        <span class="cov0" title="0">m.Row(colFive, func() </span><span class="cov0" title="0">{
                m.Col(colTwo, func() </span><span class="cov0" title="0">{
                        m.Text("Title", props.Text{
                                Size:        float64(defaultTextSize),
                                Align:       consts.Left,
                                Style:       consts.Bold,
                                Extrapolate: false,
                        })
                }</span>)
                <span class="cov0" title="0">m.Col(colEight, func() </span><span class="cov0" title="0">{
                        m.Text(title, props.Text{
                                Size:        float64(defaultTextSize),
                                Align:       consts.Left,
                                Extrapolate: false,
                        })
                }</span>)
        })
        <span class="cov0" title="0">createDescription(m, description)</span>
}

func getRowLength(value string) float64 <span class="cov5" title="4">{
        length := float64(len(value))
        x := 2.5
        result := ((length / x) / colRuneSlitter) + 1
        return result
}</span>

func createResultsTable(m pdf.Maroto, query *model.QueryResult) <span class="cov5" title="4">{
        for idx := range query.Files </span><span class="cov6" title="7">{
                if idx%2 == 0 </span><span class="cov5" title="4">{
                        m.SetBackgroundColor(grayColor)
                }</span> else<span class="cov4" title="3"> {
                        m.SetBackgroundColor(color.NewWhite())
                }</span>

                <span class="cov6" title="7">filePath := query.Files[idx].FileName
                fileLine := fmt.Sprintf("%s:%s", filePath, fmt.Sprint(query.Files[idx].Line))
                m.Row(colFive, func() </span><span class="cov6" title="7">{
                        m.Col(colFullPage, func() </span><span class="cov6" title="7">{
                                m.Text(fileLine, props.Text{
                                        Size:        defaultTextSize,
                                        Align:       consts.Left,
                                        Extrapolate: false,
                                })
                        }</span>)
                })
                <span class="cov6" title="7">expectedValue := fmt.Sprintf("Expected: %s", query.Files[idx].KeyExpectedValue)
                m.Row(colFive, func() </span><span class="cov6" title="7">{
                        m.Col(colFullPage, func() </span><span class="cov6" title="7">{
                                m.Text(expectedValue, props.Text{
                                        Size:        smallTextSize,
                                        Align:       consts.Left,
                                        Extrapolate: false,
                                })
                        }</span>)
                })
        }
        <span class="cov5" title="4">m.SetBackgroundColor(color.NewWhite())
        m.Line(1.0)</span>
}

func createHeaderArea(m pdf.Maroto) <span class="cov5" title="4">{
        m.Row(rowLarge, func() </span><span class="cov5" title="4">{
                m.Col(colSix, func() </span><span class="cov5" title="4">{
                        _ = m.Base64Image(checkmarxLogo, consts.Png, props.Rect{})
                }</span>)
        })
        <span class="cov5" title="4">m.Row(colFive, func() </span><span class="cov5" title="4">{
                m.ColSpace(0)
        }</span>)
        <span class="cov5" title="4">m.SetBackgroundColor(getPurpleColor())
        m.Row(rowXLarge, func() </span><span class="cov5" title="4">{
                m.Col(colSix, func() </span><span class="cov5" title="4">{
                        m.Text(" KICS REPORT", props.Text{
                                Size:        25,
                                Style:       consts.Bold,
                                Align:       consts.Left,
                                Extrapolate: false,
                                Color:       color.NewWhite(),
                        })
                }</span>)
                <span class="cov5" title="4">m.Col(colSix, func() </span><span class="cov5" title="4">{
                        m.Text(fmt.Sprintf("%s ", constants.Version), props.Text{
                                Size:        25,
                                Style:       consts.Bold,
                                Align:       consts.Right,
                                Extrapolate: false,
                                Color:       color.NewWhite(),
                        })
                }</span>)
        })
        <span class="cov5" title="4">m.SetBackgroundColor(color.NewWhite())
        m.Row(rowXSmall, func() </span><span class="cov5" title="4">{
                m.ColSpace(colFullPage)
        }</span>)
}

func createFooterArea(m pdf.Maroto) <span class="cov7" title="8">{
        m.Row(rowMedium, func() </span><span class="cov5" title="4">{
                m.Col(colOne, func() </span><span class="cov5" title="4">{
                        m.Text("https://kics.io")
                }</span>)
        })
}

// PrintPdfReport creates a report file on the PDF format
func PrintPdfReport(path, filename string, body interface{}) error <span class="cov5" title="4">{
        startTime := time.Now()
        log.Info().Msg("Started generating pdf report")

        summary := body.(*model.Summary)

        m := pdf.NewMaroto(consts.Portrait, consts.A4)
        m.SetPageMargins(pgMarginLeft, pgMarginTop, pgMarginRight)

        m.SetFirstPageNb(1)
        m.SetAliasNbPages("{total}")

        m.RegisterHeader(func() </span><span class="cov5" title="4">{
                createHeaderArea(m)
        }</span>)
        <span class="cov5" title="4">m.RegisterFooter(func() </span><span class="cov7" title="8">{
                createFooterArea(m)
        }</span>)

        <span class="cov5" title="4">m.SetBackgroundColor(color.NewWhite())

        createFirstPageHeader(m, summary)

        m.Line(1.0)

        err := createQueriesTable(m, summary.Queries)
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>

        <span class="cov5" title="4">err = m.OutputFileAndClose(filepath.Join(path, fmt.Sprintf("%s.pdf", filename)))
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>

        <span class="cov5" title="4">log.Info().Msgf("Generate report duration: %v", time.Since(startTime))

        fileCreationReport(filepath.Join(path, filename+".pdf"), filename)

        return err</span>
}

func createDateField(m pdf.Maroto, label string, scanTime time.Time) <span class="cov7" title="8">{
        m.Row(colFour, func() </span><span class="cov7" title="8">{
                m.Col(colTwo, func() </span><span class="cov7" title="8">{
                        m.Text(label, props.Text{
                                Size:        defaultTextSize,
                                Align:       consts.Left,
                                Extrapolate: false,
                        })
                }</span>)
                <span class="cov7" title="8">m.Col(colTwo, func() </span><span class="cov7" title="8">{
                        m.Text(scanTime.Format("15:04:05, Jan 02 2006"), props.Text{
                                Size:        defaultTextSize,
                                Align:       consts.Left,
                                Extrapolate: false,
                        })
                }</span>)
        })
}

func createDateArea(m pdf.Maroto, summary *model.Summary) <span class="cov5" title="4">{
        createDateField(m, "START TIME", summary.Start)
        createDateField(m, "END TIME", summary.End)
}</span>

func createPlatformsArea(m pdf.Maroto, summary *model.Summary) <span class="cov5" title="4">{
        m.Row(rowSmall, func() </span><span class="cov5" title="4">{
                m.Col(colTwo, func() </span><span class="cov5" title="4">{
                        m.Text("PLATFORMS", props.Text{
                                Size:        defaultTextSize,
                                Align:       consts.Left,
                                Extrapolate: false,
                        })
                }</span>)
                <span class="cov5" title="4">m.Col(colTen, func() </span><span class="cov5" title="4">{
                        m.Text(getPlatforms(summary.Queries), props.Text{
                                Size:        defaultTextSize,
                                Align:       consts.Left,
                                Extrapolate: false,
                        })
                }</span>)
        })
}

func createSummaryResultsField(m pdf.Maroto, label, value string, mColor color.Color) <span class="cov10" title="20">{
        m.Col(colOne, func() </span><span class="cov10" title="20">{
                m.Text(label, props.Text{
                        Size:        defaultTextSize,
                        Align:       consts.Left,
                        Style:       consts.Bold,
                        Extrapolate: false,
                        Color:       mColor,
                })
        }</span>)
        <span class="cov10" title="20">m.Col(colOne, func() </span><span class="cov10" title="20">{
                m.Text(value, props.Text{
                        Size:        defaultTextSize,
                        Align:       consts.Left,
                        Style:       consts.Bold,
                        Extrapolate: false,
                        Color:       mColor,
                })
        }</span>)
}

func createSummaryArea(m pdf.Maroto, summary *model.Summary) <span class="cov5" title="4">{
        criticalSeverityCount := fmt.Sprint(summary.SeverityCounters["CRITICAL"])
        highSeverityCount := fmt.Sprint(summary.SeverityCounters["HIGH"])
        mediumSeverityCount := fmt.Sprint(summary.SeverityCounters["MEDIUM"])
        lowSeverityCount := fmt.Sprint(summary.SeverityCounters["LOW"])
        infoSeverityCount := fmt.Sprint(summary.SeverityCounters["INFO"])
        totalCount := fmt.Sprint(summary.TotalCounter)

        m.Row(rowMedium, func() </span><span class="cov5" title="4">{
                createSummaryResultsField(m, "CRITICAL", criticalSeverityCount, getPureRedColor())
                createSummaryResultsField(m, "HIGH", highSeverityCount, getRedColor())
                createSummaryResultsField(m, "MEDIUM", mediumSeverityCount, getOrangeColor())
                createSummaryResultsField(m, "LOW", lowSeverityCount, getYellowColor())
                createSummaryResultsField(m, "INFO", infoSeverityCount, getBlueColor())

                m.ColSpace(colOne)

                m.Col(colOne, func() </span><span class="cov5" title="4">{
                        m.Text("TOTAL", props.Text{
                                Size:        defaultTextSize,
                                Right:       10.0,
                                Align:       consts.Right,
                                Style:       consts.Bold,
                                Extrapolate: false,
                        })
                }</span>)
                <span class="cov5" title="4">m.Col(colOne, func() </span><span class="cov5" title="4">{
                        m.Text(totalCount, props.Text{
                                Size:        defaultTextSize,
                                Align:       consts.Left,
                                Style:       consts.Bold,
                                Extrapolate: false,
                        })
                }</span>)
        })
}

func createFirstPageHeader(m pdf.Maroto, summary *model.Summary) <span class="cov5" title="4">{
        createSummaryArea(m, summary)
        createPlatformsArea(m, summary)
        createDateArea(m, summary)
        m.Row(rowSmall, func() </span><span class="cov5" title="4">{
                m.Col(colTwo, func() </span><span class="cov5" title="4">{
                        m.Text("SCANNED PATHS:", props.Text{
                                Size:        defaultTextSize,
                                Align:       consts.Left,
                                Extrapolate: false,
                        })
                }</span>)
        })
        <span class="cov5" title="4">for i := range summary.ScannedPaths </span><span class="cov5" title="4">{
                scannedPaths := summary.ScannedPaths[i]
                m.Row(rowSmall, func() </span><span class="cov5" title="4">{
                        m.Col(colFullPage, func() </span><span class="cov5" title="4">{
                                m.Text(fmt.Sprintf("- %s", scannedPaths), props.Text{
                                        Size:        defaultTextSize,
                                        Align:       consts.Left,
                                        Extrapolate: true,
                                })
                        }</span>)
                })
        }
        <span class="cov5" title="4">m.Row(rowXSmall, func() </span><span class="cov5" title="4">{
                m.ColSpace(colFullPage)
        }</span>)
}

func getGrayColor() color.Color <span class="cov1" title="1">{
        return color.Color{
                Red:   200,
                Green: 200,
                Blue:  200,
        }
}</span>

func getPureRedColor() color.Color <span class="cov5" title="4">{
        return color.Color{
                Red:   250,
                Green: 0,
                Blue:  0,
        }
}</span>

func getRedColor() color.Color <span class="cov5" title="4">{
        return color.Color{
                Red:   200,
                Green: 0,
                Blue:  0,
        }
}</span>

func getYellowColor() color.Color <span class="cov5" title="4">{
        return color.Color{
                Red:   206,
                Green: 182,
                Blue:  26,
        }
}</span>

func getOrangeColor() color.Color <span class="cov5" title="4">{
        return color.Color{
                Red:   255,
                Green: 165,
                Blue:  0,
        }
}</span>

func getBlueColor() color.Color <span class="cov5" title="4">{
        return color.Color{
                Red:   0,
                Green: 0,
                Blue:  200,
        }
}</span>

func getPurpleColor() color.Color <span class="cov5" title="4">{
        return color.Color{
                Red:   80,
                Green: 62,
                Blue:  158,
        }
}</span>
</pre>
		
		<pre class="file" id="file122" style="display: none">package report

import (
        "strings"

        reportModel "github.com/Checkmarx/kics/v2/pkg/report/model"
)

// PrintSarifReport creates a report file on sarif format, fetching the ID and GUID from relationships to be inputted to taxonomies field
func PrintSarifReport(path, filename string, body interface{}) error <span class="cov10" title="2">{
        if !strings.HasSuffix(filename, ".sarif") </span><span class="cov10" title="2">{
                filename += ".sarif"
        }</span>
        <span class="cov10" title="2">if body != "" </span><span class="cov10" title="2">{
                summary, err := getSummary(body)
                if err != nil </span><span class="cov0" title="0">{
                        return err
                }</span>

                <span class="cov10" title="2">sarifReport := reportModel.NewSarifReport()
                auxID := []string{}
                auxGUID := map[string]string{}
                for idx := range summary.Queries </span><span class="cov10" title="2">{
                        x := sarifReport.BuildSarifIssue(&amp;summary.Queries[idx])
                        if x != "" </span><span class="cov0" title="0">{
                                auxID = append(auxID, x)
                                guid := sarifReport.GetGUIDFromRelationships(idx, x)
                                auxGUID[x] = guid
                        }</span>
                }
                <span class="cov10" title="2">sarifReport.RebuildTaxonomies(auxID, auxGUID)
                body = sarifReport</span>
        }

        <span class="cov10" title="2">return ExportJSONReport(path, filename, body)</span>
}
</pre>
		
		<pre class="file" id="file123" style="display: none">package report

import (
        "strings"

        reportModel "github.com/Checkmarx/kics/v2/pkg/report/model"
)

// PrintSonarQubeReport prints the SonarQube report in the given path and filename with the given body
func PrintSonarQubeReport(path, filename string, body interface{}) error <span class="cov10" title="3">{
        if !strings.HasSuffix(filename, ".json") </span><span class="cov10" title="3">{
                filename += ".json"
        }</span>

        <span class="cov10" title="3">if !strings.HasPrefix(filename, "sonarqube-") </span><span class="cov10" title="3">{
                filename = "sonarqube-" + filename
        }</span>

        <span class="cov10" title="3">if body != "" </span><span class="cov10" title="3">{
                summary, err := getSummary(body)
                if err != nil </span><span class="cov0" title="0">{
                        return err
                }</span>

                <span class="cov10" title="3">SonarQubeReport := reportModel.NewSonarQubeRepory()
                body = SonarQubeReport.BuildReport(&amp;summary)</span>
        }

        <span class="cov10" title="3">return ExportJSONReport(path, filename, body)</span>
}
</pre>
		
		<pre class="file" id="file124" style="display: none">package file

import (
        "encoding/json"
        "errors"
        "fmt"
        "io"
        "os"
        "path/filepath"
        "regexp"
        "strconv"
        "strings"

        "github.com/Checkmarx/kics/v2/pkg/analyzer"
        "github.com/Checkmarx/kics/v2/pkg/model"
        "github.com/Checkmarx/kics/v2/pkg/utils"
        "github.com/rs/zerolog/log"
        "gopkg.in/yaml.v3"
)

// ResolvedFile - used for caching the already resolved files
type ResolvedFile struct {
        fileContent        []byte
        resolvedFileObject any
}

// Resolver - replace or modifies in-memory content before parsing
type Resolver struct {
        unmarshler    func(fileContent []byte, v any) error
        marshler      func(v any) ([]byte, error)
        ResolvedFiles map[string]model.ResolvedFile
        Extension     []string
}

// NewResolver returns a new Resolver
func NewResolver(
        unmarshler func(fileContent []byte, v any) error,
        marshler func(v any) ([]byte, error),
        ext []string) *Resolver <span class="cov4" title="7">{
        return &amp;Resolver{
                unmarshler:    unmarshler,
                marshler:      marshler,
                ResolvedFiles: make(map[string]model.ResolvedFile),
                Extension:     ext,
        }
}</span>

func isOpenAPI(fileContent []byte) bool <span class="cov5" title="15">{
        regexToRun :=
                []*regexp.Regexp{analyzer.OpenAPIRegexInfo,
                        analyzer.OpenAPIRegexPath,
                        analyzer.OpenAPIRegex}
        for _, regex := range regexToRun </span><span class="cov6" title="22">{
                if !regex.Match(fileContent) </span><span class="cov5" title="12">{
                        return false
                }</span>
        }
        <span class="cov2" title="3">return true</span>
}

// Resolve - replace or modifies in-memory content before parsing
func (r *Resolver) Resolve(fileContent []byte, path string,
        resolveCount, maxResolverDepth int, resolvedFilesCache map[string]ResolvedFile,
        resolveReferences bool) []byte <span class="cov6" title="21">{
        // handle panic during resolve process
        defer func() </span><span class="cov6" title="21">{
                if r := recover(); r != nil </span><span class="cov0" title="0">{
                        err := fmt.Errorf("panic: %v", r)
                        log.Err(err).Msg("Recovered from panic during resolve of file " + path)
                }</span>
        }()

        <span class="cov6" title="21">if !resolveReferences &amp;&amp; isOpenAPI(fileContent) </span><span class="cov1" title="1">{
                return fileContent
        }</span>

        <span class="cov6" title="20">if utils.Contains(filepath.Ext(path), []string{".yml", ".yaml"}) </span><span class="cov5" title="16">{
                return r.yamlResolve(fileContent, path, resolveCount, maxResolverDepth, resolvedFilesCache, resolveReferences)
        }</span>
        <span class="cov3" title="4">var obj any
        err := r.unmarshler(fileContent, &amp;obj)
        if err != nil </span><span class="cov0" title="0">{
                return fileContent
        }</span>

        // resolve the paths
        <span class="cov3" title="4">obj, _ = r.walk(fileContent, obj, obj, path, resolveCount, maxResolverDepth, resolvedFilesCache, false, resolveReferences)

        b, err := json.MarshalIndent(obj, "", "")
        if err == nil </span><span class="cov3" title="4">{
                return b
        }</span>

        <span class="cov0" title="0">return fileContent</span>
}

func (r *Resolver) walk(
        originalFileContent []byte,
        fullObject interface{},
        value any,
        path string,
        resolveCount, maxResolverDepth int,
        resolvedFilesCache map[string]ResolvedFile,
        refBool, resolveReferences bool) (any, bool) <span class="cov7" title="37">{
        // go over the value and replace paths with the real content
        switch typedValue := value.(type) </span>{
        case string:<span class="cov5" title="13">
                if filepath.Base(path) != typedValue </span><span class="cov5" title="13">{
                        return r.resolvePath(
                                originalFileContent, fullObject, typedValue, path, resolveCount,
                                maxResolverDepth, resolvedFilesCache, refBool, resolveReferences)
                }</span>
                <span class="cov0" title="0">return value, false</span>
        case []any:<span class="cov1" title="1">
                for i, v := range typedValue </span><span class="cov1" title="1">{
                        typedValue[i], _ = r.walk(
                                originalFileContent, fullObject, v, path, resolveCount,
                                maxResolverDepth, resolvedFilesCache, refBool, resolveReferences)
                }</span>
                <span class="cov1" title="1">return typedValue, false</span>
        case map[string]any:<span class="cov6" title="23">
                return r.handleMap(
                        originalFileContent, fullObject, typedValue, path, resolveCount,
                        maxResolverDepth, resolvedFilesCache, resolveReferences)</span>
        default:<span class="cov0" title="0">
                return value, false</span>
        }
}

func (r *Resolver) handleMap(
        originalFileContent []byte,
        fullObject interface{},
        value map[string]interface{},
        path string,
        resolveCount, maxResolverDepth int,
        resolvedFilesCache map[string]ResolvedFile,
        resolveReferences bool,
) (any, bool) <span class="cov6" title="23">{
        for k, v := range value </span><span class="cov6" title="32">{
                isRef := strings.Contains(strings.ToLower(k), "$ref")
                val, res := r.walk(originalFileContent, fullObject, v, path, resolveCount, maxResolverDepth, resolvedFilesCache, isRef, resolveReferences)
                // check if it is a ref then add new details
                if valMap, ok := val.(map[string]interface{}); (ok || !res) &amp;&amp; isRef </span><span class="cov2" title="3">{
                        // Create RefMetadata and add it to the resolved value map
                        if valMap == nil </span><span class="cov0" title="0">{
                                valMap = make(map[string]interface{})
                        }</span>
                        <span class="cov2" title="3">valMap["RefMetadata"] = make(map[string]interface{})
                        valMap["RefMetadata"].(map[string]interface{})["$ref"] = v
                        valMap["RefMetadata"].(map[string]interface{})["alone"] = len(value) == 1
                        return valMap, false</span>
                }
                <span class="cov6" title="29">if isRef &amp;&amp; res </span><span class="cov0" title="0">{
                        return val, false
                }</span>
                <span class="cov6" title="29">value[k] = val</span>
        }
        <span class="cov6" title="20">return value, false</span>
}

func (r *Resolver) yamlResolve(fileContent []byte, path string,
        resolveCount, maxResolverDepth int, resolvedFilesCache map[string]ResolvedFile,
        resolveReferences bool) []byte <span class="cov5" title="16">{
        var obj yaml.Node
        err := r.unmarshler(fileContent, &amp;obj)
        if err != nil </span><span class="cov0" title="0">{
                return fileContent
        }</span>

        <span class="cov5" title="16">fullObjectCopy := obj

        // resolve the paths
        obj, _ = r.yamlWalk(
                fileContent, &amp;fullObjectCopy, &amp;obj, path, resolveCount,
                maxResolverDepth, resolvedFilesCache, false, resolveReferences, false)

        if obj.Kind == 1 &amp;&amp; len(obj.Content) == 1 </span><span class="cov5" title="16">{
                obj = *obj.Content[0]
        }</span>

        <span class="cov5" title="16">b, err := r.marshler(obj)
        if err != nil </span><span class="cov0" title="0">{
                return fileContent
        }</span>

        <span class="cov5" title="16">return b</span>
}

func (r *Resolver) yamlWalk(
        originalFileContent []byte,
        fullObject *yaml.Node,
        value *yaml.Node,
        path string,
        resolveCount, maxResolverDepth int,
        resolvedFilesCache map[string]ResolvedFile,
        refBool, resolveReferences, ansibleVars bool) (yaml.Node, bool) <span class="cov10" title="186">{
        // go over the value and replace paths with the real content
        switch value.Kind </span>{
        case yaml.ScalarNode:<span class="cov9" title="120">
                if filepath.Base(path) != value.Value </span><span class="cov9" title="120">{
                        return r.resolveYamlPath(originalFileContent, fullObject,
                                value, path,
                                resolveCount, maxResolverDepth, resolvedFilesCache,
                                refBool, resolveReferences, ansibleVars)
                }</span>
                <span class="cov0" title="0">return *value, false</span>
        default:<span class="cov8" title="66">
                refBool := false
                ansibleVars := false
                for i := range value.Content </span><span class="cov9" title="170">{
                        if i &gt;= 1 </span><span class="cov8" title="104">{
                                refBool = strings.Contains(value.Content[i-1].Value, "$ref")
                                ansibleVars = strings.Contains(value.Content[i-1].Value, "include_vars")
                        }</span>
                        <span class="cov9" title="170">resolved, ok := r.yamlWalk(originalFileContent, fullObject,
                                value.Content[i], path,
                                resolveCount, maxResolverDepth, resolvedFilesCache,
                                refBool, resolveReferences, ansibleVars)

                        if i &gt;= 1 &amp;&amp; refBool &amp;&amp; (resolved.Kind == yaml.MappingNode || !ok) </span><span class="cov4" title="6">{
                                // Create RefMetadata and add it to yaml Node
                                if !ok </span><span class="cov0" title="0">{
                                        resolved = yaml.Node{
                                                Kind: yaml.MappingNode,
                                        }
                                }</span>
                                <span class="cov4" title="6">originalValueNode := &amp;yaml.Node{
                                        Kind:  yaml.ScalarNode,
                                        Value: "$ref",
                                }
                                refAloneKeyNode := &amp;yaml.Node{
                                        Kind:  yaml.ScalarNode,
                                        Value: "alone",
                                }
                                refAloneValueNode := &amp;yaml.Node{
                                        Kind:  yaml.ScalarNode,
                                        Value: strconv.FormatBool(len(value.Content) == 2),
                                }
                                refMetadataKeyNode := &amp;yaml.Node{
                                        Kind:  yaml.ScalarNode,
                                        Value: "RefMetadata",
                                }
                                refMetadataValueNode := &amp;yaml.Node{
                                        Kind: yaml.MappingNode,
                                }
                                refMetadataValueNode.Content = append(refMetadataValueNode.Content,
                                        originalValueNode, value.Content[i], refAloneKeyNode, refAloneValueNode)
                                resolved.Content = append(resolved.Content, refMetadataKeyNode, refMetadataValueNode)

                                return resolved, false</span>
                        }
                        <span class="cov9" title="164">value.Content[i] = &amp;resolved</span>
                }
                <span class="cov8" title="60">return *value, false</span>
        }
}

// isPath returns true if the value is a valid path
func (r *Resolver) resolveYamlPath(
        originalFileContent []byte,
        fullObject *yaml.Node,
        v *yaml.Node,
        filePath string,
        resolveCount, maxResolverDepth int,
        resolvedFilesCache map[string]ResolvedFile,
        refBool, resolveReferences, ansibleVars bool) (yaml.Node, bool) <span class="cov9" title="120">{
        value := v.Value
        if resolveCount &gt;= maxResolverDepth || (strings.HasPrefix(value, "#") &amp;&amp; !refBool) || (value == "#" &amp;&amp; refBool) </span><span class="cov0" title="0">{
                return *v, false
        }</span>
        <span class="cov9" title="120">var splitPath []string
        var obj *yaml.Node
        sameFileResolve := false
        if strings.HasPrefix(value, "#") </span><span class="cov0" title="0">{ // same file resolve
                sameFileResolve = true
                path := filePath + value
                splitPath = strings.Split(path, "#") // splitting by removing the section to look for in the file
                obj = fullObject
        }</span> else<span class="cov9" title="120"> { // external file resolve
                value = checkServerlessFileReference(value)

                exists, path, onlyFilePath, filename := findFilePath(filepath.Dir(filePath), value, ansibleVars, r.Extension)
                if !exists </span><span class="cov9" title="107">{
                        return *v, false
                }</span>

                // Check if file has already been resolved, if not resolve it and save it for future references
                <span class="cov5" title="13">if _, ok := resolvedFilesCache[filename]; !ok </span><span class="cov5" title="11">{
                        if ret, isError := r.resolveFile(
                                value, onlyFilePath, resolveCount, maxResolverDepth,
                                resolvedFilesCache, true, resolveReferences); isError </span><span class="cov0" title="0">{
                                if retYaml, yamlNode := ret.(yaml.Node); yamlNode </span><span class="cov0" title="0">{
                                        return retYaml, false
                                }</span> else<span class="cov0" title="0"> {
                                        return *v, false
                                }</span>
                        }
                }

                <span class="cov5" title="13">r.ResolvedFiles[getPathFromString(value)] = model.ResolvedFile{
                        Content:      resolvedFilesCache[filename].fileContent,
                        Path:         path,
                        LinesContent: utils.SplitLines(string(resolvedFilesCache[filename].fileContent)),
                }

                node, _ := resolvedFilesCache[filename].resolvedFileObject.(yaml.Node)
                obj = &amp;node

                if strings.Contains(strings.ToLower(value), "!ref") </span><span class="cov0" title="0">{ // Cloudformation !Ref check
                        return *obj, false
                }</span>
                <span class="cov5" title="13">if !strings.Contains(path, "#") </span><span class="cov5" title="13">{
                        return *obj, true
                }</span>
        }

        <span class="cov0" title="0">return r.returnResolveYamlPathValue(splitPath, sameFileResolve, filePath, originalFileContent, obj, v)</span>
}

func (r *Resolver) returnResolveYamlPathValue(
        splitPath []string,
        sameFileResolve bool,
        filePath string,
        originalFileContent []byte,
        obj, v *yaml.Node) (yaml.Node, bool) <span class="cov0" title="0">{
        if len(splitPath) &gt; 1 </span><span class="cov0" title="0">{
                if sameFileResolve </span><span class="cov0" title="0">{
                        r.ResolvedFiles[filePath] = model.ResolvedFile{
                                Content:      originalFileContent,
                                Path:         filePath,
                                LinesContent: utils.SplitLines(string(originalFileContent)),
                        }
                }</span>
                <span class="cov0" title="0">section, err := findSectionYaml(obj, splitPath[1])
                // Check if there was an error finding the section or if the reference is circular
                if err == nil &amp;&amp; !checkIfCircularYaml(v.Value, &amp;section) </span><span class="cov0" title="0">{
                        return section, true
                }</span>
        }
        <span class="cov0" title="0">return *v, false</span>
}

func (r *Resolver) resolveFile(
        value string,
        filePath string,
        resolveCount, maxResolverDepth int,
        resolvedFilesCache map[string]ResolvedFile,
        yamlResolve, resolveReferences bool) (any, bool) <span class="cov5" title="14">{
        // open the file with the content to replace
        file, err := os.Open(filepath.Clean(filePath))
        if err != nil </span><span class="cov0" title="0">{
                return value, true
        }</span>

        <span class="cov5" title="14">defer func(file *os.File) </span><span class="cov5" title="14">{
                err = file.Close()
                if err != nil </span><span class="cov0" title="0">{
                        log.Err(err).Msgf("failed to close resolved file: %s", filePath)
                }</span>
        }(file)
        // read the content
        <span class="cov5" title="14">fileContent, _ := io.ReadAll(file)

        resolvedFile := r.Resolve(fileContent, filePath, resolveCount+1, maxResolverDepth, resolvedFilesCache, resolveReferences)

        if yamlResolve </span><span class="cov5" title="11">{
                var obj yaml.Node

                err = r.unmarshler(resolvedFile, &amp;obj) // parse the content
                if err != nil </span><span class="cov0" title="0">{
                        return value, true
                }</span>

                <span class="cov5" title="11">if obj.Kind == 1 &amp;&amp; len(obj.Content) == 1 </span><span class="cov5" title="11">{
                        obj = *obj.Content[0]
                }</span>

                <span class="cov5" title="11">resolvedFilesCache[filePath] = ResolvedFile{fileContent, obj}</span>
        } else<span class="cov2" title="3"> {
                var obj any
                err = r.unmarshler(resolvedFile, &amp;obj) // parse the content
                if err != nil </span><span class="cov0" title="0">{
                        return value, true
                }</span>

                <span class="cov2" title="3">resolvedFilesCache[filePath] = ResolvedFile{fileContent, obj}</span>
        }

        <span class="cov5" title="14">return nil, false</span>
}

func getPathFromString(path string) string <span class="cov6" title="29">{
        lastIndex := strings.LastIndex(path, "#")
        if lastIndex == -1 </span><span class="cov6" title="28">{
                return path
        }</span>
        <span class="cov1" title="1">return path[:lastIndex]</span>
}

// isPath returns true if the value is a valid path
func (r *Resolver) resolvePath(
        originalFileContent []byte,
        fullObject interface{},
        value, filePath string,
        resolveCount, maxResolverDepth int,
        resolvedFilesCache map[string]ResolvedFile,
        refBool bool, resolveReferences bool) (any, bool) <span class="cov5" title="13">{
        if resolveCount &gt;= maxResolverDepth || (strings.HasPrefix(value, "#") &amp;&amp; !refBool) || (value == "#" &amp;&amp; refBool) </span><span class="cov0" title="0">{
                return value, false
        }</span>
        <span class="cov5" title="13">var splitPath []string
        var obj any
        sameFileResolve := false
        if strings.HasPrefix(value, "#") </span><span class="cov0" title="0">{ // same file resolve
                sameFileResolve = true
                path := filePath + value
                splitPath = strings.Split(path, "#") // splitting by removing the section to look for in the file
                obj = fullObject
        }</span> else<span class="cov5" title="13"> { // external file resolve
                path := filepath.Join(filepath.Dir(filePath), value)
                splitPath = strings.Split(path, "#") // splitting by removing the section to look for in the file

                // index 0 contains the path of the file while the other indexes contain the sections (e.g. path = "./definitions.json#User/schema")
                onlyFilePath := splitPath[0]
                _, err := os.Stat(onlyFilePath)

                if err != nil || !contains(filepath.Ext(onlyFilePath), r.Extension) </span><span class="cov4" title="10">{
                        return value, false
                }</span>

                // Check if file has already been resolved, if not resolve it and save it for future references
                <span class="cov2" title="3">if _, ok := resolvedFilesCache[onlyFilePath]; !ok </span><span class="cov2" title="3">{
                        if ret, isError := r.resolveFile(
                                value, onlyFilePath, resolveCount, maxResolverDepth,
                                resolvedFilesCache, false, resolveReferences); isError </span><span class="cov0" title="0">{
                                return ret, false
                        }</span>
                }

                <span class="cov2" title="3">r.ResolvedFiles[getPathFromString(value)] = model.ResolvedFile{
                        Content:      resolvedFilesCache[onlyFilePath].fileContent,
                        Path:         path,
                        LinesContent: utils.SplitLines(string(resolvedFilesCache[onlyFilePath].fileContent)),
                }

                obj = resolvedFilesCache[onlyFilePath].resolvedFileObject

                // Cloudformation !Ref check
                if strings.Contains(strings.ToLower(value), "!ref") || len(splitPath) == 1 </span><span class="cov2" title="2">{
                        return obj, false
                }</span>
        }
        <span class="cov1" title="1">return r.resolvePathReturnValue(value, filePath, splitPath, sameFileResolve, originalFileContent, obj, maxResolverDepth)</span>
}

func (r *Resolver) resolvePathReturnValue(
        value, filePath string,
        splitPath []string,
        sameFileResolve bool,
        originalFileContent []byte,
        obj any,
        maxResolverDepth int) (any, bool) <span class="cov1" title="1">{
        if len(splitPath) &gt; 1 </span><span class="cov1" title="1">{
                if sameFileResolve </span><span class="cov0" title="0">{
                        r.ResolvedFiles[filePath] = model.ResolvedFile{
                                Content:      originalFileContent,
                                Path:         filePath,
                                LinesContent: utils.SplitLines(string(originalFileContent)),
                        }
                }</span>
                <span class="cov1" title="1">section, err := findSection(obj, splitPath[1])
                // Check if there was an error finding the section or if the reference is circular
                if err != nil || checkIfCircular(value, section, maxResolverDepth) </span><span class="cov0" title="0">{
                        return value, false
                }</span>
                <span class="cov1" title="1">if sectionMap, ok := section.(map[string]interface{}); ok </span><span class="cov1" title="1">{
                        newSectionMap := make(map[string]interface{})
                        for k, v := range sectionMap </span><span class="cov1" title="1">{
                                newSectionMap[k] = v
                        }</span>
                        <span class="cov1" title="1">section = newSectionMap</span>
                }

                <span class="cov1" title="1">return section, true</span>
        }
        <span class="cov0" title="0">return value, false</span>
}

func findSectionYaml(object *yaml.Node, sectionsString string) (yaml.Node, error) <span class="cov0" title="0">{
        object = object.Content[0]
        sectionsString = strings.ReplaceAll(sectionsString, "\\", "/")
        sections := strings.Split(sectionsString[1:], "/")
        for _, section := range sections </span><span class="cov0" title="0">{
                found := false
                for index, node := range object.Content </span><span class="cov0" title="0">{
                        if node.Value == section </span><span class="cov0" title="0">{
                                object = object.Content[index+1]
                                found = true
                                break</span>
                        }
                }
                <span class="cov0" title="0">if !found </span><span class="cov0" title="0">{
                        return *object, errors.New("section not present in file")
                }</span>
        }
        <span class="cov0" title="0">return *object, nil</span>
}

func checkIfCircularYaml(circularValue string, yamlSection *yaml.Node) bool <span class="cov0" title="0">{
        if len(yamlSection.Content) == 0 </span><span class="cov0" title="0">{
                return false
        }</span>
        <span class="cov0" title="0">for index := 0; index &lt; len(yamlSection.Content)-1; index += 1 </span><span class="cov0" title="0">{
                // if there is a reference to the same value that was resolved it is a circular definition
                if yamlSection.Content[index].Value == "$ref" &amp;&amp; yamlSection.Content[index+1].Value == circularValue </span><span class="cov0" title="0">{
                        return true
                }</span> else<span class="cov0" title="0"> if checkIfCircularYaml(circularValue, yamlSection.Content[index]) </span><span class="cov0" title="0">{
                        return true
                }</span>
        }
        <span class="cov0" title="0">return checkIfCircularYaml(circularValue, yamlSection.Content[len(yamlSection.Content)-1])</span>
}

func findSection(object interface{}, sectionsString string) (interface{}, error) <span class="cov1" title="1">{
        sectionsString = strings.ReplaceAll(sectionsString, "\\", "/")
        sections := strings.Split(sectionsString[1:], "/")
        for _, section := range sections </span><span class="cov2" title="2">{
                if sectionObjectTemp, ok := object.(map[string]interface{}); ok </span><span class="cov2" title="2">{
                        if sectionObject, ok := sectionObjectTemp[section]; ok </span><span class="cov2" title="2">{
                                object = sectionObject
                        }</span> else<span class="cov0" title="0"> {
                                return object, errors.New("section not present in file")
                        }</span>
                } else<span class="cov0" title="0"> {
                        return object, errors.New("section not of map type")
                }</span>
        }
        <span class="cov1" title="1">return object, nil</span>
}

func checkIfCircular(circularValue string, section interface{}, maxResolverDepth int) bool <span class="cov2" title="2">{
        if maxResolverDepth &gt; 0 </span><span class="cov2" title="2">{
                sectionAsMap, okMap := section.(map[string]interface{})
                sectionAsList, okList := section.([]interface{})
                if !okList &amp;&amp; !okMap </span><span class="cov1" title="1">{
                        return false
                }</span>
                <span class="cov1" title="1">if okMap </span><span class="cov1" title="1">{
                        for key, val := range sectionAsMap </span><span class="cov1" title="1">{
                                // if there is a reference to the same value that was resolved it is a circular definition
                                if key == "$ref" &amp;&amp; val == circularValue </span><span class="cov0" title="0">{
                                        return true
                                }</span> else<span class="cov1" title="1"> if checkIfCircular(circularValue, val, maxResolverDepth-1) </span><span class="cov0" title="0">{
                                        return true
                                }</span>
                        }
                } else<span class="cov0" title="0"> {
                        for _, listSection := range sectionAsList </span><span class="cov0" title="0">{
                                if checkIfCircular(circularValue, listSection, maxResolverDepth-1) </span><span class="cov0" title="0">{
                                        return true
                                }</span>
                        }
                }
        }
        <span class="cov1" title="1">return false</span>
}

func contains(elem string, list []string) bool <span class="cov5" title="16">{
        for _, e := range list </span><span class="cov6" title="22">{
                if elem == e </span><span class="cov5" title="16">{
                        return true
                }</span>
        }
        <span class="cov0" title="0">return false</span>
}

func checkServerlessFileReference(value string) string <span class="cov9" title="120">{
        re := regexp.MustCompile(`^\${file\((.*\.(yaml|yml))\)}$`)
        matches := re.FindStringSubmatch(value)
        if len(matches) &gt; 1 </span><span class="cov1" title="1">{
                return matches[1]
        }</span>
        <span class="cov9" title="119">return value</span>
}

func findFilePath(
        folderPath, filename string,
        ansibleVars bool,
        extensions []string) (exists bool, path, onlyFilePath, cleanFilePath string) <span class="cov9" title="120">{
        path = filepath.Join(folderPath, filename)
        if ansibleVars </span><span class="cov2" title="2">{
                if exists, ansibleVarsPath := findAnsibleVarsPath(folderPath, filename); !exists </span><span class="cov0" title="0">{
                        return false, "", "", ""
                }</span> else<span class="cov2" title="2"> {
                        path = ansibleVarsPath
                }</span>
        } else<span class="cov9" title="118"> if _, err := os.Stat(path); err != nil </span><span class="cov9" title="107">{
                return false, "", "", ""
        }</span>

        <span class="cov5" title="13">if !contains(filepath.Ext(path), extensions) </span><span class="cov0" title="0">{
                return false, "", "", ""
        }</span>

        <span class="cov5" title="13">onlyFilePath = getPathFromString(path)
        return true, path, onlyFilePath, filepath.Clean(onlyFilePath)</span>
}

func findAnsibleVarsPath(folderPath, filename string) (exists bool, ansibleVarsPath string) <span class="cov2" title="2">{
        possiblePaths := []string{
                filepath.Join(folderPath, "vars", filename),
                filepath.Join(folderPath, filename),
        }

        for _, path := range possiblePaths </span><span class="cov2" title="3">{
                if _, err := os.Stat(path); err == nil </span><span class="cov2" title="2">{
                        return true, path
                }</span>
        }

        <span class="cov0" title="0">return false, ""</span>
}
</pre>
		
		<pre class="file" id="file125" style="display: none">package helm

import (
        "fmt"
        "io"
        "log"
        "os"
        "path/filepath"
        "strings"

        "github.com/pkg/errors"
        "helm.sh/helm/v3/pkg/action"
        "helm.sh/helm/v3/pkg/chart"
        "helm.sh/helm/v3/pkg/chart/loader"
        "helm.sh/helm/v3/pkg/chartutil"
        "helm.sh/helm/v3/pkg/cli"
        "helm.sh/helm/v3/pkg/cli/values"
        "helm.sh/helm/v3/pkg/getter"
        "helm.sh/helm/v3/pkg/release"
)

// credit: https://github.com/helm/helm

var (
        settings = cli.New()
)

func runInstall(args []string, client *action.Install,
        valueOpts *values.Options) (*release.Release, []string, error) <span class="cov2" title="3">{
        log.SetOutput(io.Discard)
        defer log.SetOutput(os.Stderr)
        if client.Version == "" &amp;&amp; client.Devel </span><span class="cov0" title="0">{
                client.Version = "&gt;0.0.0-0"
        }</span>

        <span class="cov2" title="3">name, charts, err := client.NameAndChart(args)
        if err != nil </span><span class="cov0" title="0">{
                return nil, []string{}, err
        }</span>
        <span class="cov2" title="3">client.ReleaseName = name

        cp, err := client.ChartPathOptions.LocateChart(charts, settings)
        if err != nil </span><span class="cov0" title="0">{
                return nil, []string{}, err
        }</span>

        <span class="cov2" title="3">p := getter.All(settings)
        vals, err := valueOpts.MergeValues(p)
        if err != nil </span><span class="cov0" title="0">{
                return nil, []string{}, err
        }</span>

        // Check chart dependencies to make sure all are present in /charts
        <span class="cov2" title="3">chartRequested, err := loader.Load(cp)
        if err != nil </span><span class="cov1" title="1">{
                return nil, []string{}, err
        }</span>

        <span class="cov2" title="2">excluded := getExcluded(chartRequested, cp)

        chartRequested = setID(chartRequested)

        if instErr := checkIfInstallable(chartRequested); instErr != nil </span><span class="cov0" title="0">{
                return nil, []string{}, instErr
        }</span>

        <span class="cov2" title="2">client.Namespace = "kics-namespace"
        helmRelease, err := client.Run(chartRequested, vals)
        if err != nil </span><span class="cov0" title="0">{
                return nil, []string{}, err
        }</span>
        <span class="cov2" title="2">return helmRelease, excluded, nil</span>
}

// checkIfInstallable validates if a chart can be installed
//
// Application chart type is only installable
func checkIfInstallable(ch *chart.Chart) error <span class="cov2" title="2">{
        switch ch.Metadata.Type </span>{
        case "", "application":<span class="cov2" title="2">
                return nil</span>
        }
        <span class="cov0" title="0">return errors.Errorf("%s charts are not installable", ch.Metadata.Type)</span>
}

// newClient will create a new instance on helm client used to render the chart
func newClient() *action.Install <span class="cov2" title="3">{
        cfg := new(action.Configuration)
        client := action.NewInstall(cfg)
        client.DryRun = true
        client.ReleaseName = "kics-helm"
        client.Replace = true // Skip the name check
        client.ClientOnly = true
        client.APIVersions = chartutil.VersionSet([]string{})
        client.IncludeCRDs = false
        return client
}</span>

// setID will add auxiliary lines for each template as well as its dependencies
func setID(chartReq *chart.Chart) *chart.Chart <span class="cov2" title="3">{
        for _, temp := range chartReq.Templates </span><span class="cov4" title="9">{
                temp = addID(temp)
                if temp != nil </span><span class="cov4" title="9">{
                        continue</span>
                }
        }
        <span class="cov2" title="3">for _, dep := range chartReq.Dependencies() </span><span class="cov1" title="1">{
                dep = setID(dep)
                if dep != nil </span><span class="cov1" title="1">{
                        continue</span>
                }
        }
        <span class="cov2" title="3">return chartReq</span>
}

// addID will add auxiliary lines used to detect line
// one for each "apiVersion:" where the id will be the line
func addID(file *chart.File) *chart.File <span class="cov4" title="9">{
        split := strings.Split(string(file.Data), "\n")
        for i := 0; i &lt; len(split); i++ </span><span class="cov10" title="303">{
                if strings.Contains(split[i], "apiVersion:") </span><span class="cov2" title="3">{
                        split = append(split, "")
                        copy(split[i+1:], split[i:])
                        split[i] = fmt.Sprintf("# KICS_HELM_ID_%d:", i)
                        i++
                }</span>
        }
        <span class="cov4" title="9">file.Data = []byte(strings.Join(split, "\n"))
        return file</span>
}

// getExcluded will return all files rendered to be excluded from scan
func getExcluded(charterino *chart.Chart, chartpath string) []string <span class="cov2" title="2">{
        excluded := make([]string, 0)
        for _, file := range charterino.Raw </span><span class="cov5" title="18">{
                excluded = append(excluded, filepath.Join(chartpath, file.Name))
        }</span>

        <span class="cov2" title="2">return excluded</span>
}
</pre>
		
		<pre class="file" id="file126" style="display: none">package helm

import (
        "path/filepath"
        "regexp"
        "strconv"
        "strings"

        "github.com/Checkmarx/kics/v2/pkg/model"
        masterUtils "github.com/Checkmarx/kics/v2/pkg/utils"
        "github.com/pkg/errors"
        "helm.sh/helm/v3/pkg/chart"
        "helm.sh/helm/v3/pkg/cli/values"
        "helm.sh/helm/v3/pkg/release"
)

// Resolver is an instance of the helm resolver
type Resolver struct {
}

// splitManifest keeps the information of the manifest splitted by source
type splitManifest struct {
        path       string
        content    []byte
        original   []byte
        splitID    string
        splitIDMap map[int]interface{}
}

const (
        kicsHelmID = "# KICS_HELM_ID_"
)

// Resolve will render the passed helm chart and return its content ready for parsing
func (r *Resolver) Resolve(filePath string) (model.ResolvedFiles, error) <span class="cov3" title="3">{
        // handle panic during resolve process
        defer func() </span><span class="cov3" title="3">{
                if r := recover(); r != nil </span><span class="cov0" title="0">{
                        errMessage := "Recovered from panic during resolve of file " + filePath
                        masterUtils.HandlePanic(r, errMessage)
                }</span>
        }()
        <span class="cov3" title="3">splits, excluded, err := renderHelm(filePath)
        if err != nil </span><span class="cov1" title="1">{ // return error to be logged
                return model.ResolvedFiles{}, errors.New("failed to render helm chart")
        }</span>
        <span class="cov2" title="2">var rfiles = model.ResolvedFiles{
                Excluded: excluded,
        }
        for _, split := range *splits </span><span class="cov3" title="3">{
                subFolder := filepath.Base(filePath)

                splitPath := strings.Split(split.path, getPathSeparator(split.path))

                splited := filepath.Join(splitPath[1:]...)

                origpath := filepath.Join(filepath.Dir(filePath), subFolder, splited)
                rfiles.File = append(rfiles.File, model.ResolvedHelm{
                        FileName:     origpath,
                        Content:      split.content,
                        OriginalData: split.original,
                        SplitID:      split.splitID,
                        IDInfo:       split.splitIDMap,
                })
        }</span>
        <span class="cov2" title="2">return rfiles, nil</span>
}

// SupportedTypes returns the supported fileKinds for this resolver
func (r *Resolver) SupportedTypes() []model.FileKind <span class="cov1" title="1">{
        return []model.FileKind{model.KindHELM}
}</span>

// renderHelm will use helm library to render helm charts
func renderHelm(path string) (*[]splitManifest, []string, error) <span class="cov3" title="3">{
        client := newClient()
        manifest, excluded, err := runInstall([]string{path}, client, &amp;values.Options{})
        if err != nil </span><span class="cov1" title="1">{
                return nil, []string{}, err
        }</span>
        <span class="cov2" title="2">splitted, err := splitManifestYAML(manifest)
        if err != nil </span><span class="cov0" title="0">{
                return nil, []string{}, err
        }</span>
        <span class="cov2" title="2">return splitted, excluded, nil</span>
}

// splitManifestYAML will split the rendered file and return its content by template as well as the template path
func splitManifestYAML(template *release.Release) (*[]splitManifest, error) <span class="cov2" title="2">{
        sources := make([]*chart.File, 0)
        sources = updateName(sources, template.Chart, template.Chart.Name())
        var splitedManifest []splitManifest
        splitedSource := strings.Split(template.Manifest, "---") // split manifest by '---'
        origData := toMap(sources)
        for _, splited := range splitedSource </span><span class="cov4" title="5">{
                var lineID string
                for _, line := range strings.Split(splited, "\n") </span><span class="cov6" title="11">{
                        if strings.Contains(line, kicsHelmID) </span><span class="cov3" title="3">{
                                lineID = line // get auxiliary line id
                                break</span>
                        }
                }
                <span class="cov4" title="5">path := strings.Split(strings.TrimPrefix(splited, "\n# Source: "), "\n") // get source of split yaml
                // ignore auxiliary files used to render chart
                if path[0] == "" </span><span class="cov2" title="2">{
                        continue</span>
                }
                <span class="cov3" title="3">if origData[filepath.FromSlash(path[0])] == nil </span><span class="cov0" title="0">{
                        continue</span>
                }
                <span class="cov3" title="3">idMap, err := getIDMap(origData[filepath.FromSlash(path[0])])
                if err != nil </span><span class="cov0" title="0">{
                        return nil, err
                }</span>
                <span class="cov3" title="3">splitedManifest = append(splitedManifest, splitManifest{
                        path:       path[0],
                        content:    []byte(strings.ReplaceAll(splited, "\r", "")),
                        original:   origData[filepath.FromSlash(path[0])], // get original data from template
                        splitID:    lineID,
                        splitIDMap: idMap,
                })</span>
        }
        <span class="cov2" title="2">return &amp;splitedManifest, nil</span>
}

// toMap will convert to map original data having the path as it's key
func toMap(files []*chart.File) map[string][]byte <span class="cov2" title="2">{
        mapFiles := make(map[string][]byte)
        for _, file := range files </span><span class="cov6" title="9">{
                mapFiles[file.Name] = []byte(strings.ReplaceAll(string(file.Data), "\r", ""))
        }</span>
        <span class="cov2" title="2">return mapFiles</span>
}

// updateName will update the templates name as well as its dependencies
func updateName(template []*chart.File, charts *chart.Chart, name string) []*chart.File <span class="cov3" title="3">{
        if name != charts.Name() </span><span class="cov1" title="1">{
                name = filepath.Join(name, charts.Name())
        }</span>
        <span class="cov3" title="3">for _, temp := range charts.Templates </span><span class="cov6" title="9">{
                temp.Name = filepath.Join(name, temp.Name)
        }</span>
        <span class="cov3" title="3">template = append(template, charts.Templates...)
        for _, dep := range charts.Dependencies() </span><span class="cov1" title="1">{
                template = updateName(template, dep, filepath.Join(name, "charts"))
        }</span>
        <span class="cov3" title="3">return template</span>
}

// getIdMap will construct a map with ids with the corresponding lines as keys
// for use in detector
func getIDMap(originalData []byte) (map[int]interface{}, error) <span class="cov3" title="3">{
        ids := make(map[int]interface{})
        mapLines := make(map[int]int)
        idHelm := -1
        for line, stringLine := range strings.Split(string(originalData), "\n") </span><span class="cov10" title="48">{
                if strings.Contains(stringLine, kicsHelmID) </span><span class="cov3" title="3">{
                        id, err := strconv.Atoi(strings.TrimSuffix(strings.TrimPrefix(stringLine, kicsHelmID), ":"))
                        if err != nil </span><span class="cov0" title="0">{
                                return nil, err
                        }</span>
                        <span class="cov3" title="3">if idHelm == -1 </span><span class="cov3" title="3">{
                                idHelm = id
                                mapLines[line] = line
                        }</span> else<span class="cov0" title="0"> {
                                ids[idHelm] = mapLines
                                mapLines = make(map[int]int)
                                idHelm = id
                                mapLines[line] = line
                        }</span>
                } else<span class="cov9" title="45"> if idHelm != -1 </span><span class="cov9" title="44">{
                        mapLines[line] = line
                }</span>
        }
        <span class="cov3" title="3">ids[idHelm] = mapLines

        return ids, nil</span>
}

func getPathSeparator(path string) string <span class="cov3" title="3">{
        if matched, err := regexp.MatchString(`[a-zA-Z0-9_\/-]+(\[a-zA-Z0-9_\/-]+)*`, path); matched &amp;&amp; err == nil </span><span class="cov3" title="3">{
                return "/"
        }</span> else<span class="cov0" title="0"> if matched, err := regexp.MatchString(`[a-z0-9_.$-]+(\\[a-z0-9_.$-]+)*`, path); matched &amp;&amp; err == nil </span><span class="cov0" title="0">{
                return "\\"
        }</span>
        <span class="cov0" title="0">return ""</span>
}
</pre>
		
		<pre class="file" id="file127" style="display: none">package resolver

import (
        "os"
        "path/filepath"

        "github.com/Checkmarx/kics/v2/pkg/model"
        "github.com/rs/zerolog/log"
)

// kindResolver is a type of resolver interface (ex: helm resolver)
// Resolve will render file/template
// SupportedTypes will return the file kinds that the resolver supports
type kindResolver interface {
        Resolve(filePath string) (model.ResolvedFiles, error)
        SupportedTypes() []model.FileKind
}

// Resolver is a struct containing the resolvers by file kind
type Resolver struct {
        resolvers map[model.FileKind]kindResolver
}

// Builder is a struct used to create a new resolver
type Builder struct {
        resolvers []kindResolver
}

// NewBuilder creates a new Builder's reference
func NewBuilder() *Builder <span class="cov10" title="2">{
        return &amp;Builder{}
}</span>

// Add will add kindResolvers for building the resolver
func (b *Builder) Add(p kindResolver) *Builder <span class="cov10" title="2">{
        log.Debug().Msgf("resolver.Add()")
        b.resolvers = append(b.resolvers, p)
        return b
}</span>

// Build will create a new instance of a resolver
func (b *Builder) Build() (*Resolver, error) <span class="cov10" title="2">{
        log.Debug().Msg("resolver.Build()")

        resolvers := make(map[model.FileKind]kindResolver, len(b.resolvers))
        for _, resolver := range b.resolvers </span><span class="cov10" title="2">{
                for _, typeRes := range resolver.SupportedTypes() </span><span class="cov10" title="2">{
                        resolvers[typeRes] = resolver
                }</span>
        }

        <span class="cov10" title="2">return &amp;Resolver{
                resolvers: resolvers,
        }, nil</span>
}

// Resolve will resolve the files according to its type
func (r *Resolver) Resolve(filePath string, kind model.FileKind) (model.ResolvedFiles, error) <span class="cov1" title="1">{
        if r, ok := r.resolvers[kind]; ok </span><span class="cov1" title="1">{
                obj, err := r.Resolve(filePath)
                if err != nil </span><span class="cov0" title="0">{
                        return model.ResolvedFiles{}, err
                }</span>
                <span class="cov1" title="1">log.Debug().Msgf("resolver.Resolve() rendered file: %s", filePath)
                return obj, nil</span>
        }
        // need to log here
        <span class="cov0" title="0">return model.ResolvedFiles{}, nil</span>
}

// GetType will analyze the filepath to determine which resolver to use
func (r *Resolver) GetType(filePath string) model.FileKind <span class="cov10" title="2">{
        _, err := os.Stat(filepath.Join(filePath, "Chart.yaml"))
        if err == nil </span><span class="cov1" title="1">{
                return model.KindHELM
        }</span>
        <span class="cov1" title="1">return model.KindCOMMON</span>
}
</pre>
		
		<pre class="file" id="file128" style="display: none">package scan

import (
        "context"
        "time"

        "github.com/Checkmarx/kics/v2/internal/storage"
        "github.com/Checkmarx/kics/v2/internal/tracker"
        "github.com/Checkmarx/kics/v2/pkg/descriptions"
        consolePrinter "github.com/Checkmarx/kics/v2/pkg/printer"
        "github.com/Checkmarx/kics/v2/pkg/progress"
        "github.com/rs/zerolog/log"
)

// Parameters represents all available scan parameters
type Parameters struct {
        CloudProvider               []string
        DisableFullDesc             bool
        ExcludeCategories           []string
        ExcludePaths                []string
        ExcludeQueries              []string
        ExcludeResults              []string
        ExcludeSeverities           []string
        ExperimentalQueries         bool
        IncludeQueries              []string
        InputData                   string
        OutputName                  string
        OutputPath                  string
        Path                        []string
        PayloadPath                 string
        PreviewLines                int
        QueriesPath                 []string
        LibrariesPath               string
        ReportFormats               []string
        Platform                    []string
        ExcludePlatform             []string
        TerraformVarsPath           string
        QueryExecTimeout            int
        LineInfoPayload             bool
        DisableSecrets              bool
        SecretsRegexesPath          string
        ChangedDefaultQueryPath     bool
        ChangedDefaultLibrariesPath bool
        ScanID                      string
        BillOfMaterials             bool
        ExcludeGitIgnore            bool
        OpenAPIResolveReferences    bool
        ParallelScanFlag            int
        MaxFileSizeFlag             int
        UseOldSeverities            bool
        MaxResolverDepth            int
        KicsComputeNewSimID         bool
}

// Client represents a scan client
type Client struct {
        ScanParams        *Parameters
        ScanStartTime     time.Time
        Tracker           *tracker.CITracker
        Storage           *storage.MemoryStorage
        ExcludeResultsMap map[string]bool
        Printer           *consolePrinter.Printer
        ProBarBuilder     *progress.PbBuilder
}

// NewClient initializes the client with all the required parameters
func NewClient(params *Parameters, proBarBuilder *progress.PbBuilder, customPrint *consolePrinter.Printer) (*Client, error) <span class="cov10" title="3">{
        t, err := tracker.NewTracker(params.PreviewLines)
        if err != nil </span><span class="cov1" title="1">{
                log.Err(err)
                return nil, err
        }</span>

        <span class="cov6" title="2">descriptions.CheckVersion(t)

        store := storage.NewMemoryStorage()

        excludeResultsMap := getExcludeResultsMap(params.ExcludeResults)

        return &amp;Client{
                ScanParams:        params,
                Tracker:           t,
                ProBarBuilder:     proBarBuilder,
                Storage:           store,
                ExcludeResultsMap: excludeResultsMap,
                Printer:           customPrint,
        }, nil</span>
}

// PerformScan executes executeScan and postScan
func (c *Client) PerformScan(ctx context.Context) error <span class="cov0" title="0">{
        c.ScanStartTime = time.Now()

        scanResults, err := c.executeScan(ctx)

        if err != nil </span><span class="cov0" title="0">{
                log.Err(err)
                return err
        }</span>

        <span class="cov0" title="0">postScanError := c.postScan(scanResults)

        if postScanError != nil </span><span class="cov0" title="0">{
                log.Err(postScanError)
                return postScanError
        }</span>

        <span class="cov0" title="0">return nil</span>
}
</pre>
		
		<pre class="file" id="file129" style="display: none">package scan

import (
        _ "embed" // Embed kics CLI img and scan-flags
        "os"
        "path/filepath"
        "sort"
        "strings"
        "time"

        consoleHelpers "github.com/Checkmarx/kics/v2/internal/console/helpers"
        "github.com/Checkmarx/kics/v2/pkg/descriptions"
        "github.com/Checkmarx/kics/v2/pkg/engine/provider"
        "github.com/Checkmarx/kics/v2/pkg/model"
        consolePrinter "github.com/Checkmarx/kics/v2/pkg/printer"
        "github.com/Checkmarx/kics/v2/pkg/progress"
        "github.com/Checkmarx/kics/v2/pkg/report"
        "github.com/rs/zerolog/log"
)

func (c *Client) getSummary(results []model.Vulnerability, end time.Time, pathParameters model.PathParameters) model.Summary <span class="cov7" title="4">{
        counters := model.Counters{
                ScannedFiles:           c.Tracker.FoundFiles,
                ScannedFilesLines:      c.Tracker.FoundCountLines,
                ParsedFilesLines:       c.Tracker.ParsedCountLines,
                ParsedFiles:            c.Tracker.ParsedFiles,
                IgnoredFilesLines:      c.Tracker.IgnoreCountLines,
                TotalQueries:           c.Tracker.LoadedQueries,
                FailedToExecuteQueries: c.Tracker.ExecutingQueries - c.Tracker.ExecutedQueries,
                FailedSimilarityID:     c.Tracker.FailedSimilarityID,
        }

        summary := model.CreateSummary(counters, results, c.ScanParams.ScanID, pathParameters.PathExtractionMap, c.Tracker.Version)
        summary.Times = model.Times{
                Start: c.ScanStartTime,
                End:   end,
        }

        if c.ScanParams.DisableFullDesc </span><span class="cov0" title="0">{
                log.Warn().Msg("Skipping descriptions because provided disable flag is set")
        }</span> else<span class="cov7" title="4"> {
                err := descriptions.RequestAndOverrideDescriptions(&amp;summary)
                if err != nil </span><span class="cov7" title="4">{
                        log.Warn().Msgf("Unable to get descriptions: %s", err)
                        log.Warn().Msgf("Using default descriptions")
                }</span>
        }

        <span class="cov7" title="4">return summary</span>
}

func (c *Client) resolveOutputs(
        summary *model.Summary,
        documents model.Documents,
        printer *consolePrinter.Printer,
        proBarBuilder progress.PbBuilder,
) error <span class="cov6" title="3">{
        log.Debug().Msg("console.resolveOutputs()")

        usingCustomQueries := usingCustomQueries(c.ScanParams.QueriesPath)
        if err := consolePrinter.PrintResult(summary, printer, usingCustomQueries); err != nil </span><span class="cov0" title="0">{
                return err
        }</span>
        <span class="cov6" title="3">if c.ScanParams.PayloadPath != "" </span><span class="cov0" title="0">{
                if err := report.ExportJSONReport(
                        filepath.Dir(c.ScanParams.PayloadPath),
                        filepath.Base(c.ScanParams.PayloadPath),
                        documents,
                ); err != nil </span><span class="cov0" title="0">{
                        return err
                }</span>
        }

        <span class="cov6" title="3">return printOutput(
                c.ScanParams.OutputPath,
                c.ScanParams.OutputName,
                summary, c.ScanParams.ReportFormats,
                proBarBuilder,
        )</span>
}

func printOutput(outputPath, filename string, body interface{}, formats []string, proBarBuilder progress.PbBuilder) error <span class="cov10" title="6">{
        log.Debug().Msg("console.printOutput()")
        if outputPath == "" </span><span class="cov7" title="4">{
                return nil
        }</span>
        <span class="cov4" title="2">if len(formats) == 0 </span><span class="cov1" title="1">{
                formats = []string{"json"}
        }</span>

        <span class="cov4" title="2">log.Debug().Msgf("Output formats provided [%v]", strings.Join(formats, ","))
        err := consoleHelpers.GenerateReport(outputPath, filename, body, formats, proBarBuilder)

        return err</span>
}

// postScan is responsible for the output results
func (c *Client) postScan(scanResults *Results) error <span class="cov6" title="3">{
        if scanResults == nil </span><span class="cov1" title="1">{
                log.Info().Msg("No files were scanned")
                scanResults = &amp;Results{
                        Results:        []model.Vulnerability{},
                        ExtractedPaths: provider.ExtractedPath{},
                        Files:          model.FileMetadatas{},
                        FailedQueries:  map[string]error{},
                }
        }</span>

        // mask results preview if Secrets Scan is disabled
        <span class="cov6" title="3">if c.ScanParams.DisableSecrets </span><span class="cov4" title="2">{
                err := maskPreviewLines(c.ScanParams.SecretsRegexesPath, scanResults)
                if err != nil </span><span class="cov0" title="0">{
                        log.Err(err)
                        return err
                }</span>
        }
        <span class="cov6" title="3">sort.Strings(c.ScanParams.Path)
        summary := c.getSummary(scanResults.Results, time.Now(), model.PathParameters{
                ScannedPaths:      c.ScanParams.Path,
                PathExtractionMap: scanResults.ExtractedPaths.ExtractionMap,
        })

        if err := c.resolveOutputs(
                &amp;summary,
                scanResults.Files.Combine(c.ScanParams.LineInfoPayload),
                c.Printer,
                *c.ProBarBuilder); err != nil </span><span class="cov0" title="0">{
                log.Err(err)
                return err
        }</span>

        <span class="cov6" title="3">deleteExtractionFolder(scanResults.ExtractedPaths.ExtractionMap)

        logger := consolePrinter.NewLogger(nil)
        consolePrinter.PrintScanDuration(&amp;logger, time.Since(c.ScanStartTime))

        printVersionCheck(c.Printer, &amp;summary)

        contributionAppeal(c.Printer, c.ScanParams.QueriesPath)

        exitCode := consoleHelpers.ResultsExitCode(&amp;summary)
        if consoleHelpers.ShowError("results") &amp;&amp; exitCode != 0 </span><span class="cov0" title="0">{
                os.Exit(exitCode)
        }</span>

        <span class="cov6" title="3">return nil</span>
}
</pre>
		
		<pre class="file" id="file130" style="display: none">// Package scan implements functions and helpers to ensure the proper scan of the specified files
package scan

import (
        "encoding/json"
        "regexp"
        "strings"

        "github.com/Checkmarx/kics/v2/pkg/engine/secrets"
        "github.com/Checkmarx/kics/v2/pkg/model"
)

func maskPreviewLines(secretsPath string, scanResults *Results) error <span class="cov2" title="2">{
        secretsRegexRulesContent, err := getSecretsRegexRules(secretsPath)
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>

        <span class="cov2" title="2">var allRegexQueries secrets.RegexRuleStruct

        err = json.Unmarshal([]byte(secretsRegexRulesContent), &amp;allRegexQueries)
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>

        <span class="cov2" title="2">allowRules, err := secrets.CompileRegex(allRegexQueries.AllowRules)
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>

        <span class="cov2" title="2">rules, err := compileRegexQueries(allRegexQueries.Rules)
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>

        <span class="cov2" title="2">for i := range scanResults.Results </span><span class="cov2" title="2">{
                item := scanResults.Results[i]
                hideSecret(item.VulnLines, &amp;allowRules, &amp;rules)
        }</span>
        <span class="cov2" title="2">return nil</span>
}

func compileRegexQueries(allRegexQueries []secrets.RegexQuery) ([]secrets.RegexQuery, error) <span class="cov2" title="2">{
        for i := range allRegexQueries </span><span class="cov8" title="72">{
                compiledRegexp, err := regexp.Compile(allRegexQueries[i].RegexStr)
                if err != nil </span><span class="cov0" title="0">{
                        return allRegexQueries, err
                }</span>
                <span class="cov8" title="72">allRegexQueries[i].Regex = compiledRegexp

                for j := range allRegexQueries[i].AllowRules </span><span class="cov8" title="52">{
                        allRegexQueries[i].AllowRules[j].Regex = regexp.MustCompile(allRegexQueries[i].AllowRules[j].RegexStr)
                }</span>
        }
        <span class="cov2" title="2">return allRegexQueries, nil</span>
}

func hideSecret(lines *[]model.CodeLine, allowRules *[]secrets.AllowRule, rules *[]secrets.RegexQuery) <span class="cov2" title="2">{
        for idx, line := range *lines </span><span class="cov3" title="4">{
                for i := range *rules </span><span class="cov10" title="144">{
                        rule := (*rules)[i]

                        isSecret, groups := isSecret(line.Line, &amp;rule, allowRules)
                        // if not a secret skip to next line
                        if !isSecret </span><span class="cov9" title="143">{
                                continue</span>
                        }

                        <span class="cov1" title="1">if len(rule.Entropies) == 0 </span><span class="cov1" title="1">{
                                maskSecret(&amp;rule, lines, idx)
                        }</span>

                        <span class="cov1" title="1">if len(groups[0]) &gt; 0 </span><span class="cov1" title="1">{
                                for _, entropy := range rule.Entropies </span><span class="cov0" title="0">{
                                        // if matched group does not exist continue
                                        if len(groups[0]) &lt;= entropy.Group </span><span class="cov0" title="0">{
                                                return
                                        }</span>
                                        <span class="cov0" title="0">isMatch, _ := secrets.CheckEntropyInterval(
                                                entropy,
                                                groups[0][entropy.Group],
                                        )
                                        if isMatch </span><span class="cov0" title="0">{
                                                maskSecret(&amp;rule, lines, idx)
                                        }</span>
                                }
                        }
                }
        }
}

func maskSecret(rule *secrets.RegexQuery, lines *[]model.CodeLine, idx int) <span class="cov1" title="1">{
        if rule.SpecialMask == "all" </span><span class="cov0" title="0">{
                (*lines)[idx].Line = "&lt;SECRET-MASKED-ON-PURPOSE&gt;"
                return
        }</span>

        <span class="cov1" title="1">regex := rule.RegexStr
        line := (*lines)[idx]

        if rule.SpecialMask != "" </span><span class="cov1" title="1">{
                regex = "(.+)" + rule.SpecialMask
        }</span>

        <span class="cov1" title="1">var re = regexp.MustCompile(regex)
        match := re.FindString(line.Line)

        if rule.SpecialMask != "" </span><span class="cov1" title="1">{
                match = line.Line[len(match):]
        }</span>

        <span class="cov1" title="1">if match != "" </span><span class="cov1" title="1">{
                (*lines)[idx].Line = strings.Replace(line.Line, match, "&lt;SECRET-MASKED-ON-PURPOSE&gt;", 1)
        }</span> else<span class="cov0" title="0"> {
                (*lines)[idx].Line = "&lt;SECRET-MASKED-ON-PURPOSE&gt;"
        }</span>
}

// repurposed isSecret from inspector
func isSecret(line string, rule *secrets.RegexQuery, allowRules *[]secrets.AllowRule) (isSecretRet bool, groups [][]string) <span class="cov10" title="144">{
        if secrets.IsAllowRule(line, rule, *allowRules) </span><span class="cov0" title="0">{
                return false, [][]string{}
        }</span>

        <span class="cov10" title="144">groups = rule.Regex.FindAllStringSubmatch(line, -1)

        for _, group := range groups </span><span class="cov1" title="1">{
                splitedText := strings.Split(line, "\n")
                max := -1
                for i, splited := range splitedText </span><span class="cov1" title="1">{
                        if len(groups) &lt; rule.Multiline.DetectLineGroup </span><span class="cov0" title="0">{
                                if strings.Contains(splited, group[rule.Multiline.DetectLineGroup]) &amp;&amp; i &gt; max </span><span class="cov0" title="0">{
                                        max = i
                                }</span>
                        }
                }
                <span class="cov1" title="1">if max == -1 </span><span class="cov1" title="1">{
                        continue</span>
                }
                <span class="cov0" title="0">secret, newGroups := isSecret(strings.Join(append(splitedText[:max], splitedText[max+1:]...), "\n"), rule, allowRules)
                if !secret </span><span class="cov0" title="0">{
                        continue</span>
                }
                <span class="cov0" title="0">groups = append(groups, newGroups...)</span>
        }

        <span class="cov10" title="144">if len(groups) &gt; 0 </span><span class="cov1" title="1">{
                return true, groups
        }</span>
        <span class="cov9" title="143">return false, [][]string{}</span>
}
</pre>
		
		<pre class="file" id="file131" style="display: none">// Package scan implements functions and helpers to ensure the proper scan of the specified files
package scan

import (
        "context"
        "os"

        "github.com/Checkmarx/kics/v2/assets"
        "github.com/Checkmarx/kics/v2/pkg/engine"
        "github.com/Checkmarx/kics/v2/pkg/engine/provider"
        "github.com/Checkmarx/kics/v2/pkg/engine/secrets"
        "github.com/Checkmarx/kics/v2/pkg/engine/source"
        "github.com/Checkmarx/kics/v2/pkg/kics"
        "github.com/Checkmarx/kics/v2/pkg/model"
        "github.com/Checkmarx/kics/v2/pkg/parser"
        ansibleConfigParser "github.com/Checkmarx/kics/v2/pkg/parser/ansible/ini/config"
        ansibleHostsParser "github.com/Checkmarx/kics/v2/pkg/parser/ansible/ini/hosts"
        bicepParser "github.com/Checkmarx/kics/v2/pkg/parser/bicep"
        buildahParser "github.com/Checkmarx/kics/v2/pkg/parser/buildah"
        dockerParser "github.com/Checkmarx/kics/v2/pkg/parser/docker"
        protoParser "github.com/Checkmarx/kics/v2/pkg/parser/grpc"
        jsonParser "github.com/Checkmarx/kics/v2/pkg/parser/json"
        terraformParser "github.com/Checkmarx/kics/v2/pkg/parser/terraform"
        yamlParser "github.com/Checkmarx/kics/v2/pkg/parser/yaml"
        "github.com/Checkmarx/kics/v2/pkg/resolver"
        "github.com/Checkmarx/kics/v2/pkg/resolver/helm"
        "github.com/Checkmarx/kics/v2/pkg/scanner"
        "github.com/rs/zerolog/log"
)

// Results represents a result generated by a single scan
type Results struct {
        Results        []model.Vulnerability
        ExtractedPaths provider.ExtractedPath
        Files          model.FileMetadatas
        FailedQueries  map[string]error
}

type executeScanParameters struct {
        services       []*kics.Service
        inspector      *engine.Inspector
        extractedPaths provider.ExtractedPath
}

func (c *Client) initScan(ctx context.Context) (*executeScanParameters, error) <span class="cov1" title="1">{
        progressBar := c.ProBarBuilder.BuildCircle("Preparing Scan Assets: ")
        go progressBar.Start()

        extractedPaths, err := c.prepareAndAnalyzePaths(ctx)
        if err != nil </span><span class="cov0" title="0">{
                log.Err(err)
                return nil, err
        }</span>

        <span class="cov1" title="1">if len(extractedPaths.Path) == 0 </span><span class="cov0" title="0">{
                return nil, nil
        }</span>

        <span class="cov1" title="1">paramsPlatforms := c.ScanParams.Platform
        useDifferentPlatformQueries(&amp;paramsPlatforms)

        querySource := source.NewFilesystemSource(
                c.ScanParams.QueriesPath,
                paramsPlatforms,
                c.ScanParams.CloudProvider,
                c.ScanParams.LibrariesPath,
                c.ScanParams.ExperimentalQueries)

        queryFilter := c.createQueryFilter()

        inspector, err := engine.NewInspector(ctx,
                querySource,
                engine.DefaultVulnerabilityBuilder,
                c.Tracker,
                queryFilter,
                c.ExcludeResultsMap,
                c.ScanParams.QueryExecTimeout,
                c.ScanParams.UseOldSeverities,
                true,
                c.ScanParams.ParallelScanFlag,
                c.ScanParams.KicsComputeNewSimID,
        )
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>

        <span class="cov1" title="1">secretsRegexRulesContent, err := getSecretsRegexRules(c.ScanParams.SecretsRegexesPath)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>

        <span class="cov1" title="1">isCustomSecretsRegexes := c.ScanParams.SecretsRegexesPath != ""

        secretsInspector, err := secrets.NewInspector(
                ctx,
                c.ExcludeResultsMap,
                c.Tracker,
                queryFilter,
                c.ScanParams.DisableSecrets,
                c.ScanParams.QueryExecTimeout,
                secretsRegexRulesContent,
                isCustomSecretsRegexes,
        )
        if err != nil </span><span class="cov0" title="0">{
                log.Err(err)
                return nil, err
        }</span>

        <span class="cov1" title="1">services, err := c.createService(
                inspector,
                secretsInspector,
                extractedPaths.Path,
                c.Tracker,
                c.Storage,
                querySource,
        )
        if err != nil </span><span class="cov0" title="0">{
                log.Err(err)
                return nil, err
        }</span>

        <span class="cov1" title="1">if err := progressBar.Close(); err != nil </span><span class="cov0" title="0">{
                log.Debug().Msgf("Failed to close progress bar: %s", err.Error())
        }</span>

        <span class="cov1" title="1">return &amp;executeScanParameters{
                services:       services,
                inspector:      inspector,
                extractedPaths: extractedPaths,
        }, nil</span>
}

func (c *Client) executeScan(ctx context.Context) (*Results, error) <span class="cov1" title="1">{
        executeScanParameters, err := c.initScan(ctx)

        if err != nil </span><span class="cov0" title="0">{
                log.Err(err)
                return nil, err
        }</span>

        <span class="cov1" title="1">if executeScanParameters == nil </span><span class="cov0" title="0">{
                return nil, nil
        }</span>

        <span class="cov1" title="1">if err = scanner.PrepareAndScan(
                ctx,
                c.ScanParams.ScanID, c.ScanParams.OpenAPIResolveReferences, c.ScanParams.MaxResolverDepth, *c.ProBarBuilder,
                executeScanParameters.services); err != nil </span><span class="cov0" title="0">{
                log.Err(err)
                return nil, err
        }</span>

        <span class="cov1" title="1">failedQueries := executeScanParameters.inspector.GetFailedQueries()

        results, err := c.Storage.GetVulnerabilities(ctx, c.ScanParams.ScanID)
        if err != nil </span><span class="cov0" title="0">{
                log.Err(err)
                return nil, err
        }</span>

        <span class="cov1" title="1">files, err := c.Storage.GetFiles(ctx, c.ScanParams.ScanID)
        if err != nil </span><span class="cov0" title="0">{
                log.Err(err)
                return nil, err
        }</span>

        <span class="cov1" title="1">return &amp;Results{
                Results:        results,
                ExtractedPaths: executeScanParameters.extractedPaths,
                Files:          files,
                FailedQueries:  failedQueries,
        }, nil</span>
}

func useDifferentPlatformQueries(platforms *[]string) <span class="cov1" title="1">{
        hasBicep := false
        hasARM := false
        for _, platform := range *platforms </span><span class="cov1" title="1">{
                if platform == "bicep" </span><span class="cov0" title="0">{
                        hasBicep = true
                }</span>
                <span class="cov1" title="1">if platform == "azureresourcemanager" </span><span class="cov0" title="0">{
                        hasARM = true
                }</span>
                <span class="cov1" title="1">if hasARM &amp;&amp; hasBicep </span><span class="cov0" title="0">{
                        break</span>
                }
        }

        <span class="cov1" title="1">if hasBicep &amp;&amp; !hasARM </span><span class="cov0" title="0">{
                *platforms = append(*platforms, "azureresourcemanager")
        }</span>
}

func getExcludeResultsMap(excludeResults []string) map[string]bool <span class="cov4" title="2">{
        excludeResultsMap := make(map[string]bool)
        for _, er := range excludeResults </span><span class="cov0" title="0">{
                excludeResultsMap[er] = true
        }</span>
        <span class="cov4" title="2">return excludeResultsMap</span>
}

func getSecretsRegexRules(regexRulesPath string) (regexRulesContent string, err error) <span class="cov10" title="6">{
        if regexRulesPath != "" </span><span class="cov4" title="2">{
                b, err := os.ReadFile(regexRulesPath)
                if err != nil </span><span class="cov1" title="1">{
                        return regexRulesContent, err
                }</span>
                <span class="cov1" title="1">regexRulesContent = string(b)</span>
        } else<span class="cov7" title="4"> {
                regexRulesContent = assets.SecretsQueryRegexRulesJSON
        }</span>

        <span class="cov9" title="5">return regexRulesContent, nil</span>
}

func (c *Client) createQueryFilter() *source.QueryInspectorParameters <span class="cov6" title="3">{
        excludeQueries := source.ExcludeQueries{
                ByIDs:        c.ScanParams.ExcludeQueries,
                ByCategories: c.ScanParams.ExcludeCategories,
                BySeverities: c.ScanParams.ExcludeSeverities,
        }

        includeQueries := source.IncludeQueries{
                ByIDs: c.ScanParams.IncludeQueries,
        }

        queryFilter := source.QueryInspectorParameters{
                IncludeQueries:      includeQueries,
                ExcludeQueries:      excludeQueries,
                ExperimentalQueries: c.ScanParams.ExperimentalQueries,
                InputDataPath:       c.ScanParams.InputData,
                BomQueries:          c.ScanParams.BillOfMaterials,
        }

        return &amp;queryFilter
}</span>

func (c *Client) createService(
        inspector *engine.Inspector,
        secretsInspector *secrets.Inspector,
        paths []string,
        t kics.Tracker,
        store kics.Storage,
        querySource *source.FilesystemSource) ([]*kics.Service, error) <span class="cov1" title="1">{
        filesSource, err := c.getFileSystemSourceProvider(paths)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>

        <span class="cov1" title="1">combinedParser, err := parser.NewBuilder().
                Add(&amp;jsonParser.Parser{}).
                Add(&amp;yamlParser.Parser{}).
                Add(terraformParser.NewDefaultWithVarsPath(c.ScanParams.TerraformVarsPath)).
                Add(&amp;bicepParser.Parser{}).
                Add(&amp;dockerParser.Parser{}).
                Add(&amp;protoParser.Parser{}).
                Add(&amp;buildahParser.Parser{}).
                Add(&amp;ansibleConfigParser.Parser{}).
                Add(&amp;ansibleHostsParser.Parser{}).
                Build(querySource.Types, querySource.CloudProviders)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>

        // combinedResolver to be used to resolve files and templates
        <span class="cov1" title="1">combinedResolver, err := resolver.NewBuilder().
                Add(&amp;helm.Resolver{}).
                Build()
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>

        <span class="cov1" title="1">services := make([]*kics.Service, 0, len(combinedParser))

        for _, parser := range combinedParser </span><span class="cov4" title="2">{
                services = append(
                        services,
                        &amp;kics.Service{
                                SourceProvider:   filesSource,
                                Storage:          store,
                                Parser:           parser,
                                Inspector:        inspector,
                                SecretsInspector: secretsInspector,
                                Tracker:          t,
                                Resolver:         combinedResolver,
                                MaxFileSize:      c.ScanParams.MaxFileSizeFlag,
                        },
                )
        }</span>
        <span class="cov1" title="1">return services, nil</span>
}

func (c *Client) getFileSystemSourceProvider(paths []string) (*provider.FileSystemSourceProvider, error) <span class="cov1" title="1">{
        var excludePaths []string
        if c.ScanParams.PayloadPath != "" </span><span class="cov0" title="0">{
                excludePaths = append(excludePaths, c.ScanParams.PayloadPath)
        }</span>

        <span class="cov1" title="1">if len(c.ScanParams.ExcludePaths) &gt; 0 </span><span class="cov1" title="1">{
                excludePaths = append(excludePaths, c.ScanParams.ExcludePaths...)
        }</span>

        <span class="cov1" title="1">filesSource, err := provider.NewFileSystemSourceProvider(paths, excludePaths)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov1" title="1">return filesSource, nil</span>
}
</pre>
		
		<pre class="file" id="file132" style="display: none">package scan

import (
        "context"
        "fmt"
        "os"
        "path/filepath"
        "regexp"
        "strings"

        consoleHelpers "github.com/Checkmarx/kics/v2/internal/console/helpers"
        "github.com/Checkmarx/kics/v2/pkg/analyzer"
        "github.com/Checkmarx/kics/v2/pkg/engine/provider"
        "github.com/Checkmarx/kics/v2/pkg/model"
        consolePrinter "github.com/Checkmarx/kics/v2/pkg/printer"
        "github.com/Checkmarx/kics/v2/pkg/utils"
        "github.com/pkg/errors"
        "github.com/rs/zerolog/log"
)

var (
        kuberneterRegex = regexp.MustCompile(`^kuberneter::`)
)

func (c *Client) prepareAndAnalyzePaths(ctx context.Context) (provider.ExtractedPath, error) <span class="cov1" title="1">{
        queryExPaths, libExPaths, err := c.preparePaths()
        if err != nil </span><span class="cov0" title="0">{
                return provider.ExtractedPath{}, err
        }</span>

        <span class="cov1" title="1">regularPaths, kuberneterPaths := extractPathType(c.ScanParams.Path)

        kuberneterExPaths, err := provider.GetKuberneterSources(ctx, kuberneterPaths, c.ScanParams.OutputPath)
        if err != nil </span><span class="cov0" title="0">{
                return provider.ExtractedPath{}, err
        }</span>

        <span class="cov1" title="1">regularExPaths, err := provider.GetSources(regularPaths)
        if err != nil </span><span class="cov0" title="0">{
                return provider.ExtractedPath{}, err
        }</span>

        <span class="cov1" title="1">allPaths := combinePaths(kuberneterExPaths, regularExPaths, queryExPaths, libExPaths)
        if len(allPaths.Path) == 0 </span><span class="cov0" title="0">{
                return provider.ExtractedPath{}, nil
        }</span>
        <span class="cov1" title="1">log.Info().Msgf("Total files in the project: %d", getTotalFiles(allPaths.Path))

        a := &amp;analyzer.Analyzer{
                Paths:             allPaths.Path,
                Types:             c.ScanParams.Platform,
                ExcludeTypes:      c.ScanParams.ExcludePlatform,
                Exc:               c.ScanParams.ExcludePaths,
                GitIgnoreFileName: ".gitignore",
                ExcludeGitIgnore:  c.ScanParams.ExcludeGitIgnore,
                MaxFileSize:       c.ScanParams.MaxFileSizeFlag,
        }

        pathTypes, errAnalyze := analyzePaths(a)

        if errAnalyze != nil </span><span class="cov0" title="0">{
                return provider.ExtractedPath{}, errAnalyze
        }</span>

        <span class="cov1" title="1">if len(pathTypes.Types) == 0 </span><span class="cov0" title="0">{
                return provider.ExtractedPath{}, nil
        }</span>

        <span class="cov1" title="1">c.ScanParams.Platform = pathTypes.Types
        c.ScanParams.ExcludePaths = pathTypes.Exc

        return allPaths, nil</span>
}

func combinePaths(kuberneter, regular, query, library provider.ExtractedPath) provider.ExtractedPath <span class="cov4" title="4">{
        var combinedPaths provider.ExtractedPath
        paths := make([]string, 0)
        combinedPathsEx := make(map[string]model.ExtractedPathObject)
        paths = append(paths, kuberneter.Path...)
        paths = append(paths, regular.Path...)
        combinedPaths.Path = paths
        for k, v := range regular.ExtractionMap </span><span class="cov4" title="4">{
                combinedPathsEx[k] = v
        }</span>
        <span class="cov4" title="4">for k, v := range kuberneter.ExtractionMap </span><span class="cov1" title="1">{
                combinedPathsEx[k] = v
        }</span>
        <span class="cov4" title="4">for k, v := range query.ExtractionMap </span><span class="cov1" title="1">{
                combinedPathsEx[k] = v
        }</span>
        <span class="cov4" title="4">for k, v := range library.ExtractionMap </span><span class="cov0" title="0">{
                combinedPathsEx[k] = v
        }</span>

        <span class="cov4" title="4">combinedPaths.ExtractionMap = combinedPathsEx
        return combinedPaths</span>
}

func (c *Client) preparePaths() (queryExtPath, libExtPath provider.ExtractedPath, err error) <span class="cov4" title="4">{
        queryExtPath, err = c.GetQueryPath()
        if err != nil </span><span class="cov0" title="0">{
                return provider.ExtractedPath{}, provider.ExtractedPath{}, err
        }</span>

        <span class="cov4" title="4">libExtPath, err = c.getLibraryPath()
        if err != nil </span><span class="cov1" title="1">{
                return queryExtPath, provider.ExtractedPath{}, err
        }</span>

        <span class="cov3" title="3">return queryExtPath, libExtPath, nil</span>
}

// GetQueryPath gets all the queries paths
func (c *Client) GetQueryPath() (provider.ExtractedPath, error) <span class="cov5" title="7">{
        queriesPath := make([]string, 0)
        extPath := provider.ExtractedPath{
                Path:          []string{},
                ExtractionMap: make(map[string]model.ExtractedPathObject),
        }
        if c.ScanParams.ChangedDefaultQueryPath </span><span class="cov5" title="6">{
                for _, queryPath := range c.ScanParams.QueriesPath </span><span class="cov5" title="9">{
                        extractedPath, errExtractQueries := resolvePath(queryPath, "queries-path")
                        if errExtractQueries != nil </span><span class="cov0" title="0">{
                                return extPath, errExtractQueries
                        }</span>
                        <span class="cov5" title="9">extPath = extractedPath
                        queriesPath = append(queriesPath, extractedPath.Path[0])</span>
                }
        } else<span class="cov1" title="1"> {
                log.Debug().Msgf("Looking for queries in executable path and in current work directory")
                defaultQueryPath, errDefaultQueryPath := consoleHelpers.GetDefaultQueryPath(c.ScanParams.QueriesPath[0])
                if errDefaultQueryPath != nil </span><span class="cov1" title="1">{
                        return extPath, errors.Wrap(errDefaultQueryPath, "unable to find queries")
                }</span>
                <span class="cov0" title="0">queriesPath = append(queriesPath, defaultQueryPath)</span>
        }
        <span class="cov5" title="6">c.ScanParams.QueriesPath = queriesPath
        return extPath, nil</span>
}

func (c *Client) getLibraryPath() (provider.ExtractedPath, error) <span class="cov5" title="7">{
        extPath := provider.ExtractedPath{
                Path:          []string{},
                ExtractionMap: make(map[string]model.ExtractedPathObject),
        }
        if c.ScanParams.ChangedDefaultLibrariesPath </span><span class="cov4" title="4">{
                extractedLibrariesPath, errExtractLibraries := resolvePath(c.ScanParams.LibrariesPath, "libraries-path")
                if errExtractLibraries != nil </span><span class="cov2" title="2">{
                        return extPath, errExtractLibraries
                }</span>

                <span class="cov2" title="2">extPath = extractedLibrariesPath
                c.ScanParams.LibrariesPath = extractedLibrariesPath.Path[0]</span>
        }
        <span class="cov4" title="5">return extPath, nil</span>
}

func resolvePath(flagContent, flagName string) (provider.ExtractedPath, error) <span class="cov6" title="13">{
        extractedPath, errExtractPath := provider.GetSources([]string{flagContent})
        if errExtractPath != nil </span><span class="cov2" title="2">{
                return extractedPath, errExtractPath
        }</span>
        <span class="cov6" title="11">if len(extractedPath.Path) != 1 </span><span class="cov0" title="0">{
                return extractedPath, fmt.Errorf("could not find a valid path (--%s) on %s", flagName, flagContent)
        }</span>
        <span class="cov6" title="11">log.Debug().Msgf("Trying to load path (--%s) from %s", flagName, flagContent)
        return extractedPath, nil</span>
}

// analyzePaths will analyze the paths to scan to determine which type of queries to load
// and which files should be ignored, it then updates the types and exclude flags variables
// with the results found
func analyzePaths(a *analyzer.Analyzer) (model.AnalyzedPaths, error) <span class="cov2" title="2">{
        var err error
        var pathsFlag model.AnalyzedPaths
        excluded := make([]string, 0)

        pathsFlag, err = analyzer.Analyze(a)
        if err != nil </span><span class="cov0" title="0">{
                log.Err(err)
                return model.AnalyzedPaths{}, err
        }</span>

        <span class="cov2" title="2">logLoadingQueriesType(pathsFlag.Types)

        excluded = append(excluded, a.Exc...)
        excluded = append(excluded, pathsFlag.Exc...)
        pathsFlag.Exc = excluded
        return pathsFlag, nil</span>
}

func logLoadingQueriesType(types []string) <span class="cov4" title="5">{
        if len(types) == 0 </span><span class="cov1" title="1">{
                log.Info().Msg("No queries were loaded")
                return
        }</span>

        <span class="cov4" title="4">log.Info().Msgf("Loading queries of type: %s", strings.Join(types, ", "))</span>
}

func extractPathType(paths []string) (regular, kuberneter []string) <span class="cov4" title="4">{
        for _, path := range paths </span><span class="cov4" title="4">{
                if kuberneterRegex.MatchString(path) </span><span class="cov1" title="1">{
                        kuberneter = append(kuberneter, kuberneterRegex.ReplaceAllString(path, ""))
                }</span> else<span class="cov3" title="3"> {
                        regular = append(regular, path)
                }</span>
        }
        <span class="cov4" title="4">return</span>
}

func deleteExtractionFolder(extractionMap map[string]model.ExtractedPathObject) <span class="cov3" title="3">{
        for extractionFile := range extractionMap </span><span class="cov0" title="0">{
                if strings.Contains(extractionFile, "kics-extract-kuberneter") </span><span class="cov0" title="0">{
                        continue</span>
                }
                <span class="cov0" title="0">err := os.RemoveAll(extractionFile)
                if err != nil </span><span class="cov0" title="0">{
                        log.Err(err).Msg("Failed to delete KICS extraction folder")
                }</span>
        }
}

func contributionAppeal(customPrint *consolePrinter.Printer, queriesPath []string) <span class="cov4" title="5">{
        if usingCustomQueries(queriesPath) </span><span class="cov4" title="4">{
                msg := "\nAre you using a custom query? If so, feel free to contribute to KICS!\n"
                contributionPage := "Check out how to do it: https://github.com/Checkmarx/kics/blob/master/docs/CONTRIBUTING.md\n"

                output := customPrint.ContributionMessage.Sprintf(msg + contributionPage)
                fmt.Println(output)
        }</span>
}

func usingCustomQueries(queriesPath []string) bool <span class="cov5" title="8">{
        return !utils.ContainsInString(filepath.Join("assets", "queries"), queriesPath)
}</span>

// printVersionCheck - Prints and logs warning if not using KICS latest version
func printVersionCheck(customPrint *consolePrinter.Printer, s *model.Summary) <span class="cov4" title="5">{
        if !s.LatestVersion.Latest </span><span class="cov1" title="1">{
                message := fmt.Sprintf("A new version 'v%s' of KICS is available, please consider updating", s.LatestVersion.LatestVersionTag)

                fmt.Println(customPrint.VersionMessage.Sprintf(message))
                log.Warn().Msgf(message)
        }</span>
}

func getTotalFiles(paths []string) int <span class="cov4" title="5">{
        files := 0
        for _, path := range paths </span><span class="cov5" title="6">{
                if err := filepath.Walk(path, func(path string, info os.FileInfo, err error) error </span><span class="cov10" title="56">{
                        if err != nil </span><span class="cov1" title="1">{
                                return err
                        }</span>

                        <span class="cov9" title="55">if !info.IsDir() </span><span class="cov9" title="47">{
                                files++
                        }</span>

                        <span class="cov9" title="55">return nil</span>
                }); err != nil <span class="cov1" title="1">{
                        log.Error().Msgf("failed to walk path %s: %s", path, err)
                }</span>
        }
        <span class="cov4" title="5">return files</span>
}
</pre>
		
		<pre class="file" id="file133" style="display: none">package scanner

import (
        "context"
        "fmt"
        "sync"

        "github.com/Checkmarx/kics/v2/internal/metrics"
        "github.com/Checkmarx/kics/v2/pkg/kics"
        "github.com/Checkmarx/kics/v2/pkg/progress"
)

type serviceSlice []*kics.Service

func PrepareAndScan(
        ctx context.Context,
        scanID string,
        openAPIResolveReferences bool,
        maxResolverDepth int,
        proBarBuilder progress.PbBuilder,
        services serviceSlice,
) error <span class="cov0" title="0">{
        metrics.Metric.Start("prepare_sources")
        var wg sync.WaitGroup
        wgDone := make(chan bool)
        errCh := make(chan error)
        var wgProg sync.WaitGroup

        for _, service := range services </span><span class="cov0" title="0">{
                wg.Add(1)
                go service.PrepareSources(ctx, scanID, openAPIResolveReferences, maxResolverDepth, &amp;wg, errCh)
        }</span>

        <span class="cov0" title="0">go func() </span><span class="cov0" title="0">{
                defer func() </span><span class="cov0" title="0">{
                        close(wgDone)
                }</span>()
                <span class="cov0" title="0">wg.Wait()
                wgProg.Wait()</span>
        }()

        <span class="cov0" title="0">select </span>{
        case &lt;-wgDone:<span class="cov0" title="0">
                metrics.Metric.Stop()
                err := StartScan(ctx, scanID, proBarBuilder, services)
                if err != nil </span><span class="cov0" title="0">{
                        return err
                }</span>
                <span class="cov0" title="0">break</span>
        case err := &lt;-errCh:<span class="cov0" title="0">
                close(errCh)
                return err</span>
        }
        <span class="cov0" title="0">return nil</span>
}

// StartScan will run concurrent scans by parser
func StartScan(ctx context.Context, scanID string,
        proBarBuilder progress.PbBuilder, services serviceSlice) error <span class="cov4" title="2">{
        defer metrics.Metric.Stop()
        metrics.Metric.Start("start_scan")
        var wg sync.WaitGroup
        wgDone := make(chan bool)
        errCh := make(chan error)
        currentQuery := make(chan int64, 1)
        var wgProg sync.WaitGroup

        total := services.GetQueriesLength()
        if total != 0 </span><span class="cov4" title="2">{
                startProgressBar(total, &amp;wgProg, currentQuery, proBarBuilder)
        }</span>

        <span class="cov4" title="2">for _, service := range services </span><span class="cov10" title="8">{
                wg.Add(1)
                go service.StartScan(ctx, scanID, errCh, &amp;wg, currentQuery)
        }</span>

        <span class="cov4" title="2">go func() </span><span class="cov4" title="2">{
                defer func() </span><span class="cov4" title="2">{
                        close(currentQuery)
                        close(wgDone)
                        fmt.Println("\r")
                }</span>()
                <span class="cov4" title="2">wg.Wait()
                wgProg.Wait()</span>
        }()

        <span class="cov4" title="2">select </span>{
        case &lt;-wgDone:<span class="cov4" title="2">
                break</span>
        case err := &lt;-errCh:<span class="cov0" title="0">
                close(errCh)
                return err</span>
        }
        <span class="cov4" title="2">return nil</span>
}

// GetQueriesLength returns the Total of queries for all Services
func (s serviceSlice) GetQueriesLength() int <span class="cov4" title="2">{
        count := 0
        for _, service := range s </span><span class="cov10" title="8">{
                count += service.Inspector.LenQueriesByPlat(service.Parser.Platform)
                count += service.SecretsInspector.GetQueriesLength()
        }</span>
        <span class="cov4" title="2">return count</span>
}

func startProgressBar(total int, wg *sync.WaitGroup, progressChannel chan int64, proBarBuilder progress.PbBuilder) <span class="cov4" title="2">{
        wg.Add(1)
        progressBar := proBarBuilder.BuildCounter("Executing queries: ", total, wg, progressChannel)
        go progressBar.Start()
}</span>
</pre>
		
		<pre class="file" id="file134" style="display: none">package utils

import (
        "regexp"

        "github.com/rs/zerolog/log"
        vault "github.com/sosedoff/ansible-vault-go"
)

// DecryptAnsibleVault verifies if the fileContent is encrypted by ansible-vault. If yes, the function decrypts it
func DecryptAnsibleVault(fileContent []byte, secret string) []byte <span class="cov8" title="1">{
        match, err := regexp.MatchString(`^\s*\$ANSIBLE_VAULT.*`, string(fileContent))
        if err != nil </span><span class="cov0" title="0">{
                return fileContent
        }</span>
        <span class="cov8" title="1">if secret != "" &amp;&amp; match </span><span class="cov8" title="1">{
                content, err := vault.Decrypt(string(fileContent), secret)

                if err == nil </span><span class="cov8" title="1">{
                        log.Info().Msg("Decrypting Ansible Vault file")
                        fileContent = []byte(content)
                }</span>
        }
        <span class="cov8" title="1">return fileContent</span>
}
</pre>
		
		<pre class="file" id="file135" style="display: none">package utils

import (
        "reflect"
        "strings"
)

// Contains if a function to check if list contains target
func Contains(target, list interface{}) bool <span class="cov7" title="7">{
        listVal := reflect.ValueOf(list)

        if listVal.Kind() == reflect.Slice || listVal.Kind() == reflect.Array </span><span class="cov6" title="6">{
                for i := 0; i &lt; listVal.Len(); i++ </span><span class="cov10" title="18">{
                        if listVal.Index(i).Interface() == target </span><span class="cov4" title="3">{
                                return true
                        }</span>
                }
        }

        <span class="cov5" title="4">return false</span>
}

// ContainsInString verifies if some string in list contains the specified target
func ContainsInString(target string, list []string) bool <span class="cov0" title="0">{
        for i := 0; i &lt; len(list); i++ </span><span class="cov0" title="0">{
                if strings.Contains(list[i], target) </span><span class="cov0" title="0">{
                        return true
                }</span>
        }
        <span class="cov0" title="0">return false</span>
}
</pre>
		
		<pre class="file" id="file136" style="display: none">package utils

import (
        "bufio"
        "bytes"
        "fmt"
        "os"
        "path/filepath"
        "strings"

        "github.com/rs/zerolog/log"
        "golang.org/x/tools/godoc/util"
)

// GetExtension gets the extension of a file path
func GetExtension(path string) (string, error) <span class="cov10" title="5">{
        targets := []string{"Dockerfile", "tfvars"}

        // Get file information
        fileInfo, err := os.Stat(path)
        if err != nil </span><span class="cov0" title="0">{
                return "", fmt.Errorf("file %s not found", path)
        }</span>

        <span class="cov10" title="5">if fileInfo.IsDir() </span><span class="cov1" title="1">{
                return "", fmt.Errorf("the path %s is a directory", path)
        }</span>

        <span class="cov8" title="4">ext := filepath.Ext(path)
        if ext == "" </span><span class="cov7" title="3">{
                base := filepath.Base(path)

                if Contains(base, targets) </span><span class="cov1" title="1">{
                        ext = base
                }</span> else<span class="cov4" title="2"> {
                        isText, err := isTextFile(path)

                        if err != nil </span><span class="cov0" title="0">{
                                return "", err
                        }</span>

                        <span class="cov4" title="2">if isText </span><span class="cov4" title="2">{
                                if readPossibleDockerFile(path) </span><span class="cov1" title="1">{
                                        ext = "possibleDockerfile"
                                }</span>
                        }
                }
        }

        <span class="cov8" title="4">return ext, nil</span>
}

func readPossibleDockerFile(path string) bool <span class="cov4" title="2">{
        path = filepath.Clean(path)
        if strings.HasSuffix(path, "gitignore") </span><span class="cov0" title="0">{
                return true
        }</span>
        <span class="cov4" title="2">file, err := os.Open(path)
        if err != nil </span><span class="cov0" title="0">{
                return false
        }</span>
        <span class="cov4" title="2">defer file.Close()
        // Create a scanner to read the file line by line
        scanner := bufio.NewScanner(file)
        // Read lines from the file
        for scanner.Scan() </span><span class="cov7" title="3">{
                if strings.HasPrefix(scanner.Text(), "FROM") </span><span class="cov1" title="1">{
                        return true
                }</span> else<span class="cov4" title="2"> if strings.HasPrefix(scanner.Text(), "#") </span><span class="cov1" title="1">{
                        continue</span>
                } else<span class="cov1" title="1"> {
                        return false
                }</span>
        }
        <span class="cov0" title="0">return false</span>
}

func isTextFile(path string) (bool, error) <span class="cov4" title="2">{
        info, err := os.Stat(path)
        if err != nil </span><span class="cov0" title="0">{
                log.Error().Msgf("failed to get file info: %s", err)
                return false, err
        }</span>

        <span class="cov4" title="2">if info.IsDir() </span><span class="cov0" title="0">{
                return false, nil
        }</span>

        <span class="cov4" title="2">content, err := os.ReadFile(filepath.Clean(path))
        if err != nil </span><span class="cov0" title="0">{
                log.Error().Msgf("failed to analyze file: %s", err)
                return false, err
        }</span>

        <span class="cov4" title="2">content = bytes.Replace(content, []byte("\r"), []byte(""), -1)

        isText := util.IsText(content)

        return isText, nil</span>
}
</pre>
		
		<pre class="file" id="file137" style="display: none">// Package utils contains various utility functions to use in other packages
package utils

import (
        "bufio"
        "os"
        "path/filepath"

        "github.com/rs/zerolog/log"
)

// LineCounter get the number of lines of a given file
func LineCounter(path string) (int, error) <span class="cov3" title="3">{
        file, err := os.Open(filepath.Clean(path))
        if err != nil </span><span class="cov1" title="1">{
                return 0, err
        }</span>
        <span class="cov2" title="2">defer func() </span><span class="cov2" title="2">{
                if err := file.Close(); err != nil </span><span class="cov0" title="0">{
                        log.Err(err).Msgf("failed to close '%s'", filepath.Clean(path))
                }</span>
        }()

        <span class="cov2" title="2">scanner := bufio.NewScanner(file)
        lineCount := 0
        for scanner.Scan() </span><span class="cov10" title="32">{
                lineCount++
        }</span>

        <span class="cov2" title="2">if err := scanner.Err(); err != nil </span><span class="cov0" title="0">{
                return 0, err
        }</span>

        <span class="cov2" title="2">return lineCount, nil</span>
}
</pre>
		
		<pre class="file" id="file138" style="display: none">package utils

import "sort"

// SortedKeys returns a sorted slice with all map keys
func SortedKeys(mapToSort map[string]string) []string <span class="cov1" title="1">{
        keys := make([]string, 0, len(mapToSort))
        for k := range mapToSort </span><span class="cov10" title="3">{
                keys = append(keys, k)
        }</span>
        <span class="cov1" title="1">sort.Strings(keys)
        return keys</span>
}

// MergeMaps merges two maps
func MergeMaps(map1, map2 map[string]interface{}) <span class="cov1" title="1">{
        for key, value := range map2 </span><span class="cov1" title="1">{
                map1[key] = value
        }</span>
}
</pre>
		
		<pre class="file" id="file139" style="display: none">package utils

import (
        "fmt"

        "github.com/rs/zerolog/log"
)

func HandlePanic(r any, errMessage string) <span class="cov0" title="0">{
        err := fmt.Errorf("panic: %v", r)
        log.Err(err).Msg(errMessage)
}</span>
</pre>
		
		<pre class="file" id="file140" style="display: none">package utils

import (
        "os"
        "strconv"
        "sync"
        "time"
)

// ======== Golang way to create random number for tmp dir naming =============
var rand uint32
var randmu sync.Mutex

const tempDirFormat = 1e9

func reseed() uint32 <span class="cov1" title="1">{
        return uint32(time.Now().UnixNano() + int64(os.Getpid()))
}</span>

// NextRandom returns a random number
func NextRandom() string <span class="cov10" title="2">{
        randmu.Lock()
        r := rand
        if r == 0 </span><span class="cov1" title="1">{
                r = reseed()
        }</span>
        <span class="cov10" title="2">r = r*1664525 + 1013904223 // constants from Numerical Recipes
        rand = r
        randmu.Unlock()
        return strconv.Itoa(int(tempDirFormat + r%tempDirFormat))[1:]</span>
}

// ==============================================================================
</pre>
		
		<pre class="file" id="file141" style="display: none">package utils

import "strings"

// SplitLines splits the document by line
func SplitLines(content string) *[]string <span class="cov8" title="1">{
        text := strings.ReplaceAll(content, "\r", "")
        split := strings.Split(text, "\n")

        return &amp;split
}</span>
</pre>
		
		<pre class="file" id="file142" style="display: none">// Package utils contains various utility functions to use in other packages
package utils

import "regexp"

// ValidateUUID checks if the given id is valid by the format UUID using regex expression
func ValidateUUID(id string) bool <span class="cov10" title="4">{
        uuidRegex := "^[0-9a-fA-F]{8}\\b-[0-9a-fA-F]{4}\\b-[0-9a-fA-F]{4}\\b-[0-9a-fA-F]{4}\\b-[0-9a-fA-F]{12}$"
        if matched, _ := regexp.MatchString(uuidRegex, id); matched </span><span class="cov1" title="1">{
                return true
        }</span>
        <span class="cov8" title="3">return false</span>
}
</pre>
		
		<pre class="file" id="file143" style="display: none">package test

import (
        "bytes"
        "encoding/json"
        "errors"
        "fmt"
        "io"
        "os"
        "path/filepath"
        "strings"

        "github.com/Checkmarx/kics/v2/pkg/model"
        "github.com/spf13/cobra"
)

const (
        // ValidUUIDRegex is a constant representing a regular expression rule to validate UUID string
        ValidUUIDRegex    = `(?i)^[0-9a-f]{8}-[0-9a-f]{4}-[0-5][0-9a-f]{3}-[089ab][0-9a-f]{3}-[0-9a-f]{12}$`
        positive          = "positive.tf"
        positiveYamlSonar = "../../../test/fixtures/test_critical_custom_queries/amazon_mq_broker_encryption_disabled/test/positive1.yaml"
        positiveYaml      = "test/fixtures/test_critical_custom_queries/amazon_mq_broker_encryption_disabled/test/positive1.yaml"
)

type execute func() error

// CaptureOutput changes default stdout to intercept into a buffer, converts it to string and returns it
func CaptureOutput(funcToExec execute) (string, error) <span class="cov0" title="0">{
        old := os.Stdout
        r, w, _ := os.Pipe()
        os.Stdout = w

        err := funcToExec()

        outC := make(chan string)

        go func() </span><span class="cov0" title="0">{
                var buf bytes.Buffer
                if _, errs := io.Copy(&amp;buf, r); errs != nil </span><span class="cov0" title="0">{
                        return
                }</span>
                <span class="cov0" title="0">outC &lt;- buf.String()</span>
        }()

        <span class="cov0" title="0">if errs := w.Close(); errs != nil </span><span class="cov0" title="0">{
                return "", errs
        }</span>
        <span class="cov0" title="0">os.Stdout = old
        out := &lt;-outC

        return out, err</span>
}

// CaptureCommandOutput set cobra command args, if necessary, then capture the output
func CaptureCommandOutput(cmd *cobra.Command, args []string) (string, error) <span class="cov0" title="0">{
        if len(args) &gt; 0 </span><span class="cov0" title="0">{
                cmd.SetArgs(args)
        }</span>

        <span class="cov0" title="0">return CaptureOutput(cmd.Execute)</span>
}

// ChangeCurrentDir gets current working directory and changes to its parent until finds the desired directory
// or fail
func ChangeCurrentDir(desiredDir string) error <span class="cov1" title="2">{
        for currentDir, err := os.Getwd(); GetCurrentDirName(currentDir) != desiredDir; currentDir, err = os.Getwd() </span><span class="cov1" title="3">{
                if err == nil </span><span class="cov1" title="3">{
                        if err = os.Chdir(".."); err != nil </span><span class="cov0" title="0">{
                                fmt.Print(formatCurrentDirError(err))
                                return errors.New(formatCurrentDirError(err))
                        }</span>
                } else<span class="cov0" title="0"> {
                        return errors.New(formatCurrentDirError(err))
                }</span>
        }
        <span class="cov1" title="2">return nil</span>
}

func formatCurrentDirError(err error) string <span class="cov1" title="1">{
        return fmt.Sprintf("change path error = %v", err)
}</span>

// GetCurrentDirName returns current working directory
func GetCurrentDirName(path string) string <span class="cov2" title="7">{
        dirs := strings.Split(path, string(os.PathSeparator))
        if dirs[len(dirs)-1] == "" &amp;&amp; len(dirs) &gt; 1 </span><span class="cov1" title="1">{
                return dirs[len(dirs)-2]
        }</span>
        <span class="cov2" title="6">return dirs[len(dirs)-1]</span>
}

// StringifyStruct stringify struct for pretty print
func StringifyStruct(v interface{}) (string, error) <span class="cov0" title="0">{
        jsonValue, err := json.MarshalIndent(v, "", "  ")
        if err != nil </span><span class="cov0" title="0">{
                return "", err
        }</span>
        <span class="cov0" title="0">return string(jsonValue), nil</span>
}

// MapToStringSlice extract slice of keys from a map[string]string
func MapToStringSlice(stringKeyMap map[string]string) []string <span class="cov7" title="5108">{
        keys := make([]string, len(stringKeyMap))

        i := 0
        for k := range stringKeyMap </span><span class="cov10" title="86835">{
                keys[i] = k
                i++
        }</span>
        <span class="cov7" title="5108">return keys</span>
}

var queryHigh = model.QueryResult{ //nolint
        QueryName:                   "ALB protocol is HTTP",
        QueryID:                     "de7f5e83-da88-4046-871f-ea18504b1d43",
        Description:                 "ALB protocol is HTTP Description",
        DescriptionID:               "504b1d43",
        CISDescriptionIDFormatted:   "testCISID",
        CISDescriptionTitle:         "testCISTitle",
        CISDescriptionTextFormatted: "testCISDescription",
        Severity:                    model.SeverityHigh,
        Files: []model.VulnerableFile{
                {
                        FileName:         positive,
                        Line:             25,
                        IssueType:        "MissingAttribute",
                        SearchKey:        "aws_alb_listener[front_end].default_action.redirect",
                        KeyExpectedValue: "'default_action.redirect.protocol' is equal 'HTTPS'",
                        KeyActualValue:   "'default_action.redirect.protocol' is missing",
                        Value:            nil,
                        VulnLines:        &amp;[]model.CodeLine{},
                },
                {
                        FileName:         positive,
                        Line:             19,
                        IssueType:        "IncorrectValue",
                        SearchKey:        "aws_alb_listener[front_end].default_action.redirect",
                        KeyExpectedValue: "'default_action.redirect.protocol' is equal 'HTTPS'",
                        KeyActualValue:   "'default_action.redirect.protocol' is equal 'HTTP'",
                        Value:            nil,
                        VulnLines:        &amp;[]model.CodeLine{},
                },
        },
        CWE: "",
}

var queryMedium = model.QueryResult{
        QueryName:     "AmazonMQ Broker Encryption Disabled",
        Description:   "AmazonMQ Broker should have Encryption Options defined",
        QueryID:       "3db3f534-e3a3-487f-88c7-0a9fbf64b702",
        CloudProvider: "AWS",
        Severity:      model.SeverityMedium,
        Files: []model.VulnerableFile{
                {
                        FileName:         positive,
                        Line:             1,
                        IssueType:        "MissingAttribute",
                        SimilarityID:     "6b76f7a507e200bb2c73468ec9649b099da96a4efa0f49a3bdc88e12476d8ee7",
                        SearchKey:        "resource.aws_mq_broker[positive1]",
                        KeyExpectedValue: "resource.aws_mq_broker[positive1].encryption_options is defined",
                        KeyActualValue:   "resource.aws_mq_broker[positive1].encryption_options is not defined",
                        Value:            nil,
                        VulnLines:        &amp;[]model.CodeLine{},
                },
        },
        CWE: "",
}

var queryMedium2 = model.QueryResult{
        QueryName: "GuardDuty Detector Disabled",
        QueryID:   "704dadd3-54fc-48ac-b6a0-02f170011473",
        Severity:  model.SeverityMedium,
        Files: []model.VulnerableFile{
                {
                        FileName:         filepath.Join("assets", "queries", "terraform", "aws", "guardduty_detector_disabled", "test", "positive.tf"),
                        Line:             2,
                        IssueType:        "IncorrectValue",
                        SearchKey:        "aws_guardduty_detector[positive1].enable",
                        KeyExpectedValue: "GuardDuty Detector should be Enabled",
                        KeyActualValue:   "GuardDuty Detector is not Enabled",
                        Value:            nil,
                        VulnLines:        &amp;[]model.CodeLine{},
                },
        },
        Platform:    "Terraform",
        Description: "Make sure that Amazon GuardDuty is Enabled",
        CWE:         "",
}

var queryInfo = model.QueryResult{
        QueryName: "Resource Not Using Tags",
        QueryID:   "e38a8e0a-b88b-4902-b3fe-b0fcb17d5c10",
        Severity:  model.SeverityInfo,
        Files: []model.VulnerableFile{
                {
                        FileName:         filepath.Join("assets", "queries", "terraform", "aws", "guardduty_detector_disabled", "test", "negative.tf"),
                        Line:             1,
                        IssueType:        "MissingAttribute",
                        SearchKey:        "aws_guardduty_detector[{{negative1}}]",
                        KeyExpectedValue: "aws_guardduty_detector[{{negative1}}].tags is defined and not null",
                        KeyActualValue:   "aws_guardduty_detector[{{negative1}}].tags is undefined or null",
                        Value:            nil,
                        VulnLines:        &amp;[]model.CodeLine{},
                },
                {
                        FileName:         filepath.Join("assets", "queries", "terraform", "aws", "guardduty_detector_disabled", "test", "positive.tf"),
                        Line:             1,
                        IssueType:        "MissingAttribute",
                        SearchKey:        "aws_guardduty_detector[{{positive1}}]",
                        KeyExpectedValue: "aws_guardduty_detector[{{positive1}}].tags is defined and not null",
                        KeyActualValue:   "aws_guardduty_detector[{{positive1}}].tags is undefined or null",
                        Value:            nil,
                        VulnLines:        &amp;[]model.CodeLine{},
                },
        },
        Platform:    "Terraform",
        Description: "AWS services resource tags are an essential part of managing components",
}

var queryHighExperimental = model.QueryResult{
        QueryName:                   "ALB protocol is HTTP",
        QueryID:                     "de7f5e83-da88-4046-871f-ea18504b1d43",
        Description:                 "ALB protocol is HTTP Description",
        DescriptionID:               "504b1d43",
        CISDescriptionIDFormatted:   "testCISID",
        CISDescriptionTitle:         "testCISTitle",
        CISDescriptionTextFormatted: "testCISDescription",
        Severity:                    model.SeverityHigh,
        Experimental:                true,
        Files: []model.VulnerableFile{
                {
                        FileName:         positive,
                        Line:             25,
                        IssueType:        "MissingAttribute",
                        SearchKey:        "aws_alb_listener[front_end].default_action.redirect",
                        KeyExpectedValue: "'default_action.redirect.protocol' is equal 'HTTPS'",
                        KeyActualValue:   "'default_action.redirect.protocol' is missing",
                        Value:            nil,
                        VulnLines:        &amp;[]model.CodeLine{},
                },
                {
                        FileName:         positive,
                        Line:             19,
                        IssueType:        "IncorrectValue",
                        SearchKey:        "aws_alb_listener[front_end].default_action.redirect",
                        KeyExpectedValue: "'default_action.redirect.protocol' is equal 'HTTPS'",
                        KeyActualValue:   "'default_action.redirect.protocol' is equal 'HTTP'",
                        Value:            nil,
                        VulnLines:        &amp;[]model.CodeLine{},
                },
        },
}

var queryMediumCycloneCWE = model.QueryResult{
        QueryName: "GuardDuty Detector Disabled",
        QueryID:   "704dadd3-54fc-48ac-b6a0-02f170011473",
        Severity:  model.SeverityMedium,
        Files: []model.VulnerableFile{
                {
                        FileName:         filepath.Join("assets", "queries", "terraform", "aws", "guardduty_detector_disabled", "test", "negative.tf"),
                        Line:             2,
                        IssueType:        "IncorrectValue",
                        SearchKey:        "aws_guardduty_detector[negative1].enable",
                        KeyExpectedValue: "GuardDuty Detector should be Enabled",
                        KeyActualValue:   "GuardDuty Detector is not Enabled",
                        Value:            nil,
                        VulnLines:        &amp;[]model.CodeLine{},
                },
        },
        Platform:    "Terraform",
        Description: "Make sure that Amazon GuardDuty is Enabled",
        CWE:         "22",
}

var queryMediumCWE = model.QueryResult{
        QueryName:     "AmazonMQ Broker Encryption Disabled",
        Description:   "AmazonMQ Broker should have Encryption Options defined",
        QueryID:       "3db3f534-e3a3-487f-88c7-0a9fbf64b702",
        CloudProvider: "AWS",
        Severity:      model.SeverityMedium,
        Files: []model.VulnerableFile{
                {
                        FileName:         positive,
                        Line:             1,
                        IssueType:        "MissingAttribute",
                        SimilarityID:     "6b76f7a507e200bb2c73468ec9649b099da96a4efa0f49a3bdc88e12476d8ee7",
                        SearchKey:        "resource.aws_mq_broker[positive1]",
                        KeyExpectedValue: "resource.aws_mq_broker[positive1].encryption_options is defined",
                        KeyActualValue:   "resource.aws_mq_broker[positive1].encryption_options is not defined",
                        Value:            nil,
                        VulnLines:        &amp;[]model.CodeLine{},
                },
        },
        CWE: "22",
}

var queryHighCWE = model.QueryResult{ //nolint
        QueryName:                   "AMI Not Encrypted",
        QueryID:                     "97707503-a22c-4cd7-b7c0-f088fa7cf830",
        Description:                 "AWS AMI Encryption is not enabled",
        DescriptionID:               "a4342f0",
        CISDescriptionIDFormatted:   "testCISID",
        CISDescriptionTitle:         "testCISTitle",
        CISDescriptionTextFormatted: "testCISDescription",
        Severity:                    model.SeverityHigh,
        Files: []model.VulnerableFile{
                {
                        FileName:         positive,
                        Line:             30,
                        IssueType:        "MissingAttribute",
                        SearchKey:        "aws_alb_listener[front_end].default_action.redirect",
                        KeyExpectedValue: "'default_action.redirect.protocol' is equal 'HTTPS'",
                        KeyActualValue:   "'default_action.redirect.protocol' is missing",
                        Value:            nil,
                        VulnLines:        &amp;[]model.CodeLine{},
                },
                {
                        FileName:         positive,
                        Line:             35,
                        IssueType:        "IncorrectValue",
                        SearchKey:        "aws_alb_listener[front_end].default_action.redirect",
                        KeyExpectedValue: "'default_action.redirect.protocol' is equal 'HTTPS'",
                        KeyActualValue:   "'default_action.redirect.protocol' is equal 'HTTP'",
                        Value:            nil,
                        VulnLines:        &amp;[]model.CodeLine{},
                },
        },
        CWE: "22",
}

var queryCritical = model.QueryResult{
        QueryName:                   "AmazonMQ Broker Encryption Disabled",
        QueryID:                     "316278b3-87ac-444c-8f8f-a733a28da609",
        Description:                 "AmazonMQ Broker should have Encryption Options defined",
        DescriptionID:               "c5d562d9",
        CISDescriptionIDFormatted:   "testCISID",
        CISDescriptionTitle:         "testCISTitle",
        CISDescriptionTextFormatted: "testCISDescription",
        CloudProvider:               "AWS",
        Severity:                    model.SeverityCritical,
        Files: []model.VulnerableFile{
                {
                        FileName:         positiveYaml,
                        Line:             6,
                        IssueType:        "MissingAttribute",
                        SearchKey:        "aws_alb_listener[front_end].default_action.redirect",
                        KeyExpectedValue: "'default_action.redirect.protocol' is equal 'HTTPS'",
                        KeyActualValue:   "'default_action.redirect.protocol' is missing",
                        Value:            nil,
                        VulnLines:        &amp;[]model.CodeLine{},
                },
        },
}

var queryLowCICDCloudProvider = model.QueryResult{
        QueryName:     "Unpinned Actions Full Length Commit SHA",
        QueryID:       "555ab8f9-2001-455e-a077-f2d0f41e2fb9",
        Description:   "Pinning an action to a full length commit SHA is currently the only way to use an action as an immutable release.",
        DescriptionID: "9cb8402d",
        Platform:      "CICD",
        CloudProvider: "COMMON",
        Severity:      model.SeverityLow,
        Files: []model.VulnerableFile{
                {
                        FileName:         positive,
                        Line:             12,
                        IssueType:        "IncorrectValue",
                        SearchKey:        "uses={{thollander/actions-comment-pull-request@v2}}",
                        KeyExpectedValue: "Action is not pinned to a full length commit SHA.",
                        KeyActualValue:   "Action pinned to a full length commit SHA.",
                        Value:            nil,
                        VulnLines:        &amp;[]model.CodeLine{},
                },
        },
}

var queryHighPasswordsAndSecrets = model.QueryResult{
        QueryName:     "Passwords And Secrets - AWS Secret Key",
        QueryID:       "83ab47ff-381d-48cd-bac5-fb32222f54af",
        Description:   "Query to find passwords and secrets in infrastructure code.",
        DescriptionID: "d69d8a89",
        Platform:      "Common",
        CloudProvider: "common",
        Severity:      model.SeverityHigh,
        Files: []model.VulnerableFile{
                {
                        FileName:         positive,
                        Line:             15,
                        IssueType:        "RedundantAttribute",
                        SearchKey:        "",
                        KeyExpectedValue: "Hardcoded secret key should not appear in source",
                        KeyActualValue:   "Hardcoded secret key appears in source",
                        Value:            nil,
                        VulnLines:        &amp;[]model.CodeLine{},
                },
        },
}

var queryCriticalSonar = model.QueryResult{
        QueryName:                   "AmazonMQ Broker Encryption Disabled",
        QueryID:                     "316278b3-87ac-444c-8f8f-a733a28da609",
        Description:                 "AmazonMQ Broker should have Encryption Options defined",
        DescriptionID:               "c5d562d9",
        CISDescriptionIDFormatted:   "testCISID",
        CISDescriptionTitle:         "testCISTitle",
        CISDescriptionTextFormatted: "testCISDescription",
        CloudProvider:               "AWS",
        Severity:                    model.SeverityCritical,
        Files: []model.VulnerableFile{
                {
                        FileName:         positiveYamlSonar,
                        Line:             6,
                        IssueType:        "MissingAttribute",
                        SearchKey:        "aws_alb_listener[front_end].default_action.redirect",
                        KeyExpectedValue: "'default_action.redirect.protocol' is equal 'HTTPS'",
                        KeyActualValue:   "'default_action.redirect.protocol' is missing",
                        Value:            nil,
                        VulnLines:        &amp;[]model.CodeLine{},
                },
        },
}

var SummaryMockCriticalSonar = model.Summary{
        Counters: model.Counters{
                ScannedFiles:           2,
                ParsedFiles:            2,
                FailedToScanFiles:      0,
                TotalQueries:           1,
                FailedToExecuteQueries: 0,
        },
        Queries: []model.QueryResult{
                queryCriticalSonar,
        },
        SeveritySummary: model.SeveritySummary{
                ScanID: "console",
                SeverityCounters: map[model.Severity]int{
                        model.SeverityInfo:     0,
                        model.SeverityLow:      0,
                        model.SeverityMedium:   0,
                        model.SeverityHigh:     0,
                        model.SeverityCritical: 1,
                },
                TotalCounter: 1,
        },
        ScannedPaths: []string{
                "./",
        },
}

var SummaryMockCritical = model.Summary{
        Counters: model.Counters{
                ScannedFiles:           2,
                ParsedFiles:            2,
                FailedToScanFiles:      0,
                TotalQueries:           1,
                FailedToExecuteQueries: 0,
        },
        Queries: []model.QueryResult{
                queryCritical,
        },
        SeveritySummary: model.SeveritySummary{
                ScanID: "console",
                SeverityCounters: map[model.Severity]int{
                        model.SeverityInfo:     0,
                        model.SeverityLow:      0,
                        model.SeverityMedium:   0,
                        model.SeverityHigh:     0,
                        model.SeverityCritical: 1,
                },
                TotalCounter: 1,
        },
        ScannedPaths: []string{
                "./",
        },
}

var queryCriticalASFF = model.QueryResult{
        QueryName:     "AmazonMQ Broker Encryption Disabled",
        QueryID:       "316278b3-87ac-444c-8f8f-a733a28da609",
        Description:   "AmazonMQ Broker should have Encryption Options defined",
        DescriptionID: "c5d562d9",
        CloudProvider: "AWS",
        Severity:      model.SeverityCritical,
        Files: []model.VulnerableFile{
                {
                        FileName:         positiveYaml,
                        Line:             6,
                        IssueType:        "MissingAttribute",
                        SearchKey:        "aws_alb_listener[front_end].default_action.redirect",
                        KeyExpectedValue: "'default_action.redirect.protocol' is equal 'HTTPS'",
                        KeyActualValue:   "'default_action.redirect.protocol' is missing",
                        Value:            nil,
                        VulnLines:        &amp;[]model.CodeLine{},
                },
        },
        CWE: "22",
}

var SummaryMockCriticalFullPathASFF = model.Summary{
        Counters: model.Counters{
                ScannedFiles:           2,
                ParsedFiles:            2,
                FailedToScanFiles:      0,
                TotalQueries:           1,
                FailedToExecuteQueries: 0,
        },
        Queries: []model.QueryResult{
                queryCriticalASFF,
        },
        SeveritySummary: model.SeveritySummary{
                ScanID: "console",
                SeverityCounters: map[model.Severity]int{
                        model.SeverityInfo:     0,
                        model.SeverityLow:      0,
                        model.SeverityMedium:   0,
                        model.SeverityHigh:     0,
                        model.SeverityCritical: 1,
                },
                TotalCounter: 1,
        },
        ScannedPaths: []string{
                "./",
        },
}

// SummaryMock a summary to be used without running kics scan
var SummaryMock = model.Summary{
        Counters: model.Counters{
                ScannedFiles:           1,
                ParsedFiles:            1,
                FailedToScanFiles:      0,
                TotalQueries:           1,
                FailedToExecuteQueries: 0,
        },
        Queries: []model.QueryResult{
                queryHigh,
        },
        SeveritySummary: model.SeveritySummary{
                ScanID: "console",
                SeverityCounters: map[model.Severity]int{
                        model.SeverityInfo:     0,
                        model.SeverityLow:      0,
                        model.SeverityMedium:   0,
                        model.SeverityHigh:     2,
                        model.SeverityCritical: 0,
                },
                TotalCounter: 2,
        },
        ScannedPaths: []string{
                "./",
        },
}

var queryCriticalCLI = model.QueryResult{
        QueryName:                   "Run Block Injection",
        QueryID:                     "20f14e1a-a899-4e79-9f09-b6a84cd4649b",
        Description:                 "GitHub Actions workflows can be triggered by a variety of events. Every workflow trigger is provided with a GitHub context that contains information about the triggering event, such as which user triggered it, the branch name, and other event context details. Some of this event data, like the base repository name, hash value of a changeset, or pull request number, is unlikely to be controlled or used for injection by the user that triggered the event.", //nolint
        DescriptionID:               "02044a75",
        CISDescriptionIDFormatted:   "testCISID",
        CISDescriptionTitle:         "testCISTitle",
        CISDescriptionTextFormatted: "testCISDescription",
        Severity:                    model.SeverityCritical,
        Files: []model.VulnerableFile{
                {
                        FileName:         positive,
                        Line:             10,
                        IssueType:        "MissingAttribute",
                        SearchKey:        "aws_alb_listener[front_end].default_action.redirect",
                        KeyExpectedValue: "'default_action.redirect.protocol' is equal 'HTTPS'",
                        KeyActualValue:   "'default_action.redirect.protocol' is missing",
                        Value:            nil,
                        VulnLines:        &amp;[]model.CodeLine{},
                },
        },
        CWE: "",
}

// SummaryMockCWE a summary to be used with cwe field complete
var SummaryMockCWE = model.Summary{
        Counters: model.Counters{
                ScannedFiles:           1,
                ParsedFiles:            1,
                FailedToScanFiles:      0,
                TotalQueries:           1,
                FailedToExecuteQueries: 0,
        },
        Queries: []model.QueryResult{
                queryHighCWE,
        },
        SeveritySummary: model.SeveritySummary{
                ScanID: "console",
                SeverityCounters: map[model.Severity]int{
                        model.SeverityInfo:     0,
                        model.SeverityLow:      0,
                        model.SeverityMedium:   0,
                        model.SeverityHigh:     2,
                        model.SeverityCritical: 0,
                },
                TotalCounter: 2,
        },
        ScannedPaths: []string{
                "./",
        },
}

// SimpleSummaryMockAsff a simple summary to be used with cwe field complete
var SimpleSummaryMockAsff = model.Summary{
        Counters: model.Counters{
                ScannedFiles:           1,
                ParsedFiles:            1,
                FailedToScanFiles:      0,
                TotalQueries:           1,
                FailedToExecuteQueries: 0,
        },
        Queries: []model.QueryResult{
                queryMediumCWE,
        },
        SeveritySummary: model.SeveritySummary{
                ScanID: "console",
                SeverityCounters: map[model.Severity]int{
                        model.SeverityInfo:     0,
                        model.SeverityLow:      0,
                        model.SeverityMedium:   1,
                        model.SeverityHigh:     2,
                        model.SeverityCritical: 0,
                },
                TotalCounter: 1,
        },
        LatestVersion: model.Version{
                Latest: true,
        },
}

// ComplexSummaryMock a summary with more results to be used without running kics scan
var ComplexSummaryMock = model.Summary{
        Counters: model.Counters{
                ScannedFiles:           2,
                ParsedFiles:            2,
                FailedToScanFiles:      0,
                TotalQueries:           3,
                FailedToExecuteQueries: 0,
        },
        Queries: []model.QueryResult{
                queryHigh,
                queryMedium,
                queryHighCWE,
                queryCriticalCLI,
        },
        SeveritySummary: model.SeveritySummary{
                ScanID: "console",
                SeverityCounters: map[model.Severity]int{
                        model.SeverityInfo:     0,
                        model.SeverityLow:      0,
                        model.SeverityMedium:   1,
                        model.SeverityHigh:     2,
                        model.SeverityCritical: 2,
                },
                TotalCounter: 5,
        },
        LatestVersion: model.Version{
                Latest: true,
        },
}

var ComplexSummaryMockWithExperimental = model.Summary{
        Counters: model.Counters{
                ScannedFiles:           2,
                ParsedFiles:            2,
                FailedToScanFiles:      0,
                TotalQueries:           2,
                FailedToExecuteQueries: 0,
        },
        Queries: []model.QueryResult{
                queryHighExperimental,
                queryMedium,
        },
        SeveritySummary: model.SeveritySummary{
                ScanID: "console",
                SeverityCounters: map[model.Severity]int{
                        model.SeverityInfo:     0,
                        model.SeverityLow:      0,
                        model.SeverityMedium:   1,
                        model.SeverityHigh:     2,
                        model.SeverityCritical: 0,
                },
                TotalCounter: 3,
        },
        LatestVersion: model.Version{
                Latest: true,
        },
}

// ExampleSummaryMock a summary with specific results to CycloneDX report tests
var ExampleSummaryMock = model.Summary{
        Counters: model.Counters{
                ScannedFiles:           2,
                ParsedFiles:            2,
                FailedToScanFiles:      0,
                TotalQueries:           2,
                FailedToExecuteQueries: 0,
        },
        Queries: []model.QueryResult{
                queryInfo,
                queryMedium2,
        },
        SeveritySummary: model.SeveritySummary{
                ScanID: "console",
                SeverityCounters: map[model.Severity]int{
                        model.SeverityInfo:     2,
                        model.SeverityLow:      0,
                        model.SeverityMedium:   1,
                        model.SeverityHigh:     0,
                        model.SeverityCritical: 0,
                },
                TotalCounter: 3,
        },
        ScannedPaths: []string{
                "./",
        },
}

// ExampleSummaryMockCWE a summary with specific results to CycloneDX report tests with cwe field complete
var ExampleSummaryMockCWE = model.Summary{
        Counters: model.Counters{
                ScannedFiles:           1,
                ParsedFiles:            1,
                FailedToScanFiles:      0,
                TotalQueries:           1,
                FailedToExecuteQueries: 0,
        },
        Queries: []model.QueryResult{
                queryMediumCycloneCWE,
        },
        SeveritySummary: model.SeveritySummary{
                ScanID: "console",
                SeverityCounters: map[model.Severity]int{
                        model.SeverityInfo:   0,
                        model.SeverityLow:    0,
                        model.SeverityMedium: 1,
                        model.SeverityHigh:   0,
                },
                TotalCounter: 1,
        },
        ScannedPaths: []string{
                "./",
        },
}

// SimpleSummaryMock a summary with specific results to ASFF report tests
var SimpleSummaryMock = model.Summary{
        Counters: model.Counters{
                ScannedFiles:           1,
                ParsedFiles:            1,
                FailedToScanFiles:      0,
                TotalQueries:           1,
                FailedToExecuteQueries: 0,
        },
        Queries: []model.QueryResult{
                queryMedium,
        },
        SeveritySummary: model.SeveritySummary{
                ScanID: "console",
                SeverityCounters: map[model.Severity]int{
                        model.SeverityInfo:     0,
                        model.SeverityLow:      0,
                        model.SeverityMedium:   1,
                        model.SeverityHigh:     0,
                        model.SeverityCritical: 0,
                },
                TotalCounter: 1,
        },
        ScannedPaths: []string{
                "./",
        },
}

// ExampleSummaryMockWithCloudProviderCommon a summary with "common" as cloud provider to console tests
var ExampleSummaryMockWithCloudProviderCommon = model.Summary{
        Counters: model.Counters{
                ScannedFiles:           1,
                ParsedFiles:            1,
                FailedToScanFiles:      0,
                TotalQueries:           1,
                FailedToExecuteQueries: 0,
        },
        Queries: []model.QueryResult{
                queryLowCICDCloudProvider,
        },
        SeveritySummary: model.SeveritySummary{
                ScanID: "console",
                SeverityCounters: map[model.Severity]int{
                        model.SeverityInfo:     0,
                        model.SeverityLow:      1,
                        model.SeverityMedium:   0,
                        model.SeverityHigh:     0,
                        model.SeverityCritical: 0,
                },
                TotalCounter: 1,
        },
        ScannedPaths: []string{
                "./",
        },
}

// ExampleSummaryMockWithPasswordsAndSecretsCommonQuery a summary using the "Passwords And Secrets" common query that contains multiple Ids
var ExampleSummaryMockWithPasswordsAndSecretsCommonQuery = model.Summary{
        Counters: model.Counters{
                ScannedFiles:           1,
                ParsedFiles:            1,
                FailedToScanFiles:      0,
                TotalQueries:           1,
                FailedToExecuteQueries: 0,
        },
        Queries: []model.QueryResult{
                queryHighPasswordsAndSecrets,
        },
        SeveritySummary: model.SeveritySummary{
                ScanID: "console",
                SeverityCounters: map[model.Severity]int{
                        model.SeverityInfo:     0,
                        model.SeverityLow:      0,
                        model.SeverityMedium:   0,
                        model.SeverityHigh:     1,
                        model.SeverityCritical: 0,
                },
                TotalCounter: 1,
        },
        ScannedPaths: []string{
                "./",
        },
}
</pre>
		
		</div>
	</body>
	<script>
	(function() {
		var files = document.getElementById('files');
		var visible;
		files.addEventListener('change', onChange, false);
		function select(part) {
			if (visible)
				visible.style.display = 'none';
			visible = document.getElementById(part);
			if (!visible)
				return;
			files.value = part;
			visible.style.display = 'block';
			location.hash = part;
		}
		function onChange() {
			select(files.value);
			window.scrollTo(0, 0);
		}
		if (location.hash != "") {
			select(location.hash.substr(1));
		}
		if (!visible) {
			select("file0");
		}
	})();
	</script>
</html>
