
<!DOCTYPE html>
<html>
	<head>
		<meta http-equiv="Content-Type" content="text/html; charset=utf-8">
		<title>flags: Go Coverage Report</title>
		<style>
			body {
				background: black;
				color: rgb(80, 80, 80);
			}
			body, pre, #legend span {
				font-family: Menlo, monospace;
				font-weight: bold;
			}
			#topbar {
				background: black;
				position: fixed;
				top: 0; left: 0; right: 0;
				height: 42px;
				border-bottom: 1px solid rgb(80, 80, 80);
			}
			#content {
				margin-top: 50px;
			}
			#nav, #legend {
				float: left;
				margin-left: 10px;
			}
			#legend {
				margin-top: 12px;
			}
			#nav {
				margin-top: 10px;
			}
			#legend span {
				margin: 0 5px;
			}
			.cov0 { color: rgb(192, 0, 0) }
.cov1 { color: rgb(128, 128, 128) }
.cov2 { color: rgb(116, 140, 131) }
.cov3 { color: rgb(104, 152, 134) }
.cov4 { color: rgb(92, 164, 137) }
.cov5 { color: rgb(80, 176, 140) }
.cov6 { color: rgb(68, 188, 143) }
.cov7 { color: rgb(56, 200, 146) }
.cov8 { color: rgb(44, 212, 149) }
.cov9 { color: rgb(32, 224, 152) }
.cov10 { color: rgb(20, 236, 155) }

		</style>
	</head>
	<body>
		<div id="topbar">
			<div id="nav">
				<select id="files">
				
				<option value="file0">github.com/Checkmarx/kics/internal/console/flags/flags.go (94.4%)</option>
				
				<option value="file1">github.com/Checkmarx/kics/internal/console/flags/flags_utils.go (87.1%)</option>
				
				<option value="file2">github.com/Checkmarx/kics/internal/console/flags/validate.go (50.0%)</option>
				
				<option value="file3">github.com/Checkmarx/kics/internal/console/flags/validate_multi_str.go (100.0%)</option>
				
				<option value="file4">github.com/Checkmarx/kics/internal/console/flags/validate_str.go (100.0%)</option>
				
				<option value="file5">github.com/Checkmarx/kics/internal/console/generate_id.go (80.0%)</option>
				
				<option value="file6">github.com/Checkmarx/kics/internal/console/helpers/exit_handler.go (100.0%)</option>
				
				<option value="file7">github.com/Checkmarx/kics/internal/console/helpers/helpers.go (56.6%)</option>
				
				<option value="file8">github.com/Checkmarx/kics/internal/console/kics.go (78.9%)</option>
				
				<option value="file9">github.com/Checkmarx/kics/internal/console/list_platforms.go (100.0%)</option>
				
				<option value="file10">github.com/Checkmarx/kics/internal/console/pre_scan.go (83.1%)</option>
				
				<option value="file11">github.com/Checkmarx/kics/internal/console/remediate.go (81.8%)</option>
				
				<option value="file12">github.com/Checkmarx/kics/internal/console/scan.go (73.2%)</option>
				
				<option value="file13">github.com/Checkmarx/kics/internal/console/version.go (100.0%)</option>
				
				<option value="file14">github.com/Checkmarx/kics/internal/constants/constants.go (83.3%)</option>
				
				<option value="file15">github.com/Checkmarx/kics/internal/metrics/cpu_metric.go (91.7%)</option>
				
				<option value="file16">github.com/Checkmarx/kics/internal/metrics/mem_metric.go (92.9%)</option>
				
				<option value="file17">github.com/Checkmarx/kics/internal/metrics/metrics.go (90.3%)</option>
				
				<option value="file18">github.com/Checkmarx/kics/internal/storage/memory.go (95.2%)</option>
				
				<option value="file19">github.com/Checkmarx/kics/internal/tracker/ci.go (100.0%)</option>
				
				<option value="file20">github.com/Checkmarx/kics/pkg/analyzer/analyzer.go (85.5%)</option>
				
				<option value="file21">github.com/Checkmarx/kics/pkg/builder/engine/engine.go (71.8%)</option>
				
				<option value="file22">github.com/Checkmarx/kics/pkg/builder/model/model.go (100.0%)</option>
				
				<option value="file23">github.com/Checkmarx/kics/pkg/builder/parser/tag/tag_parser.go (92.0%)</option>
				
				<option value="file24">github.com/Checkmarx/kics/pkg/builder/writer/rego.go (89.8%)</option>
				
				<option value="file25">github.com/Checkmarx/kics/pkg/descriptions/client.go (76.2%)</option>
				
				<option value="file26">github.com/Checkmarx/kics/pkg/descriptions/descriptions.go (85.7%)</option>
				
				<option value="file27">github.com/Checkmarx/kics/pkg/descriptions/version.go (100.0%)</option>
				
				<option value="file28">github.com/Checkmarx/kics/pkg/detector/default_detect.go (100.0%)</option>
				
				<option value="file29">github.com/Checkmarx/kics/pkg/detector/detector.go (100.0%)</option>
				
				<option value="file30">github.com/Checkmarx/kics/pkg/detector/docker/docker_detect.go (82.9%)</option>
				
				<option value="file31">github.com/Checkmarx/kics/pkg/detector/helm/helm_detect.go (87.9%)</option>
				
				<option value="file32">github.com/Checkmarx/kics/pkg/detector/helper.go (92.9%)</option>
				
				<option value="file33">github.com/Checkmarx/kics/pkg/detector/search_line_detector.go (95.0%)</option>
				
				<option value="file34">github.com/Checkmarx/kics/pkg/engine/inspector.go (81.2%)</option>
				
				<option value="file35">github.com/Checkmarx/kics/pkg/engine/provider/extract.go (72.9%)</option>
				
				<option value="file36">github.com/Checkmarx/kics/pkg/engine/provider/filesystem.go (71.8%)</option>
				
				<option value="file37">github.com/Checkmarx/kics/pkg/engine/secrets/inspector.go (85.0%)</option>
				
				<option value="file38">github.com/Checkmarx/kics/pkg/engine/similarity/similarity_id.go (94.7%)</option>
				
				<option value="file39">github.com/Checkmarx/kics/pkg/engine/source/filesystem.go (73.6%)</option>
				
				<option value="file40">github.com/Checkmarx/kics/pkg/engine/source/source.go (67.9%)</option>
				
				<option value="file41">github.com/Checkmarx/kics/pkg/engine/vulnerability_builder.go (86.5%)</option>
				
				<option value="file42">github.com/Checkmarx/kics/pkg/engine/vulnerability_utils.go (84.4%)</option>
				
				<option value="file43">github.com/Checkmarx/kics/pkg/kics/resolver_sink.go (0.0%)</option>
				
				<option value="file44">github.com/Checkmarx/kics/pkg/kics/service.go (40.3%)</option>
				
				<option value="file45">github.com/Checkmarx/kics/pkg/kics/sink.go (40.0%)</option>
				
				<option value="file46">github.com/Checkmarx/kics/pkg/kuberneter/auth.go (100.0%)</option>
				
				<option value="file47">github.com/Checkmarx/kics/pkg/kuberneter/kuberneter.go (25.0%)</option>
				
				<option value="file48">github.com/Checkmarx/kics/pkg/kuberneter/utils.go (70.0%)</option>
				
				<option value="file49">github.com/Checkmarx/kics/pkg/model/comment_yaml.go (75.0%)</option>
				
				<option value="file50">github.com/Checkmarx/kics/pkg/model/comments.go (100.0%)</option>
				
				<option value="file51">github.com/Checkmarx/kics/pkg/model/model.go (89.7%)</option>
				
				<option value="file52">github.com/Checkmarx/kics/pkg/model/model_easyjson.go (34.7%)</option>
				
				<option value="file53">github.com/Checkmarx/kics/pkg/model/model_yaml.go (86.1%)</option>
				
				<option value="file54">github.com/Checkmarx/kics/pkg/model/summary.go (87.0%)</option>
				
				<option value="file55">github.com/Checkmarx/kics/pkg/parser/buildah/comments.go (100.0%)</option>
				
				<option value="file56">github.com/Checkmarx/kics/pkg/parser/buildah/parser.go (89.5%)</option>
				
				<option value="file57">github.com/Checkmarx/kics/pkg/parser/docker/comments.go (100.0%)</option>
				
				<option value="file58">github.com/Checkmarx/kics/pkg/parser/docker/parser.go (95.0%)</option>
				
				<option value="file59">github.com/Checkmarx/kics/pkg/parser/grpc/converter/converter.go (87.4%)</option>
				
				<option value="file60">github.com/Checkmarx/kics/pkg/parser/grpc/parser.go (85.7%)</option>
				
				<option value="file61">github.com/Checkmarx/kics/pkg/parser/json/json_line.go (89.5%)</option>
				
				<option value="file62">github.com/Checkmarx/kics/pkg/parser/json/parser.go (77.4%)</option>
				
				<option value="file63">github.com/Checkmarx/kics/pkg/parser/json/tfplan.go (84.6%)</option>
				
				<option value="file64">github.com/Checkmarx/kics/pkg/parser/jsonfilter/parser/error_listener.go (100.0%)</option>
				
				<option value="file65">github.com/Checkmarx/kics/pkg/parser/jsonfilter/parser/jsonfilter_base_visitor.go (0.0%)</option>
				
				<option value="file66">github.com/Checkmarx/kics/pkg/parser/jsonfilter/parser/jsonfilter_lexer.go (0.0%)</option>
				
				<option value="file67">github.com/Checkmarx/kics/pkg/parser/jsonfilter/parser/jsonfilter_parser.go (0.0%)</option>
				
				<option value="file68">github.com/Checkmarx/kics/pkg/parser/jsonfilter/parser/jsonfilter_tree_visitor.go (0.0%)</option>
				
				<option value="file69">github.com/Checkmarx/kics/pkg/parser/parser.go (89.8%)</option>
				
				<option value="file70">github.com/Checkmarx/kics/pkg/parser/terraform/comment/comment.go (96.8%)</option>
				
				<option value="file71">github.com/Checkmarx/kics/pkg/parser/terraform/converter/default.go (77.1%)</option>
				
				<option value="file72">github.com/Checkmarx/kics/pkg/parser/terraform/data_source.go (76.8%)</option>
				
				<option value="file73">github.com/Checkmarx/kics/pkg/parser/terraform/terraform.go (81.4%)</option>
				
				<option value="file74">github.com/Checkmarx/kics/pkg/parser/terraform/variables.go (91.5%)</option>
				
				<option value="file75">github.com/Checkmarx/kics/pkg/parser/utils/certificate_utils.go (81.6%)</option>
				
				<option value="file76">github.com/Checkmarx/kics/pkg/parser/yaml/parser.go (82.4%)</option>
				
				<option value="file77">github.com/Checkmarx/kics/pkg/printer/options.go (90.0%)</option>
				
				<option value="file78">github.com/Checkmarx/kics/pkg/printer/printer.go (82.4%)</option>
				
				<option value="file79">github.com/Checkmarx/kics/pkg/printer/utils.go (82.4%)</option>
				
				<option value="file80">github.com/Checkmarx/kics/pkg/progress/circle/circle_progress.go (80.0%)</option>
				
				<option value="file81">github.com/Checkmarx/kics/pkg/progress/counter/counter_progress.go (63.6%)</option>
				
				<option value="file82">github.com/Checkmarx/kics/pkg/progress/progress.go (100.0%)</option>
				
				<option value="file83">github.com/Checkmarx/kics/pkg/remediation/remediation.go (84.2%)</option>
				
				<option value="file84">github.com/Checkmarx/kics/pkg/remediation/scan.go (63.5%)</option>
				
				<option value="file85">github.com/Checkmarx/kics/pkg/remediation/utils.go (80.0%)</option>
				
				<option value="file86">github.com/Checkmarx/kics/pkg/report/asff.go (87.5%)</option>
				
				<option value="file87">github.com/Checkmarx/kics/pkg/report/code_climate.go (87.5%)</option>
				
				<option value="file88">github.com/Checkmarx/kics/pkg/report/commons.go (82.1%)</option>
				
				<option value="file89">github.com/Checkmarx/kics/pkg/report/csv.go (88.9%)</option>
				
				<option value="file90">github.com/Checkmarx/kics/pkg/report/cyclonedx.go (81.8%)</option>
				
				<option value="file91">github.com/Checkmarx/kics/pkg/report/gitlab_sast.go (93.3%)</option>
				
				<option value="file92">github.com/Checkmarx/kics/pkg/report/html.go (90.0%)</option>
				
				<option value="file93">github.com/Checkmarx/kics/pkg/report/json.go (92.3%)</option>
				
				<option value="file94">github.com/Checkmarx/kics/pkg/report/junit.go (92.3%)</option>
				
				<option value="file95">github.com/Checkmarx/kics/pkg/report/model/asff.go (85.3%)</option>
				
				<option value="file96">github.com/Checkmarx/kics/pkg/report/model/code_climate.go (100.0%)</option>
				
				<option value="file97">github.com/Checkmarx/kics/pkg/report/model/csv.go (100.0%)</option>
				
				<option value="file98">github.com/Checkmarx/kics/pkg/report/model/cyclonedx.go (91.4%)</option>
				
				<option value="file99">github.com/Checkmarx/kics/pkg/report/model/gitlab_sast.go (75.0%)</option>
				
				<option value="file100">github.com/Checkmarx/kics/pkg/report/model/junit.go (94.4%)</option>
				
				<option value="file101">github.com/Checkmarx/kics/pkg/report/model/sarif.go (94.0%)</option>
				
				<option value="file102">github.com/Checkmarx/kics/pkg/report/model/sarif_categories.go (100.0%)</option>
				
				<option value="file103">github.com/Checkmarx/kics/pkg/report/model/sonarqube.go (92.9%)</option>
				
				<option value="file104">github.com/Checkmarx/kics/pkg/report/pdf.go (89.2%)</option>
				
				<option value="file105">github.com/Checkmarx/kics/pkg/report/sarif.go (90.9%)</option>
				
				<option value="file106">github.com/Checkmarx/kics/pkg/report/sonarqube.go (90.9%)</option>
				
				<option value="file107">github.com/Checkmarx/kics/pkg/resolver/file/file.go (80.0%)</option>
				
				<option value="file108">github.com/Checkmarx/kics/pkg/resolver/helm/helm.go (88.5%)</option>
				
				<option value="file109">github.com/Checkmarx/kics/pkg/resolver/helm/resolver.go (85.7%)</option>
				
				<option value="file110">github.com/Checkmarx/kics/pkg/resolver/resolver.go (90.5%)</option>
				
				<option value="file111">github.com/Checkmarx/kics/pkg/scan/client.go (44.4%)</option>
				
				<option value="file112">github.com/Checkmarx/kics/pkg/scan/post_scan.go (82.5%)</option>
				
				<option value="file113">github.com/Checkmarx/kics/pkg/scan/scan.go (16.3%)</option>
				
				<option value="file114">github.com/Checkmarx/kics/pkg/scan/utils.go (71.3%)</option>
				
				<option value="file115">github.com/Checkmarx/kics/pkg/scanner/scanner.go (56.4%)</option>
				
				<option value="file116">github.com/Checkmarx/kics/pkg/terraformer/terraformer.go (73.9%)</option>
				
				<option value="file117">github.com/Checkmarx/kics/pkg/terraformer/utils.go (16.7%)</option>
				
				<option value="file118">github.com/Checkmarx/kics/pkg/utils/ansible_vault.go (88.9%)</option>
				
				<option value="file119">github.com/Checkmarx/kics/pkg/utils/contains.go (60.0%)</option>
				
				<option value="file120">github.com/Checkmarx/kics/pkg/utils/get_extension.go (77.3%)</option>
				
				<option value="file121">github.com/Checkmarx/kics/pkg/utils/map.go (100.0%)</option>
				
				<option value="file122">github.com/Checkmarx/kics/pkg/utils/random.go (100.0%)</option>
				
				<option value="file123">github.com/Checkmarx/kics/pkg/utils/split_lines.go (100.0%)</option>
				
				<option value="file124">github.com/Checkmarx/kics/test/helpers.go (37.5%)</option>
				
				</select>
			</div>
			<div id="legend">
				<span>not tracked</span>
			
				<span class="cov0">no coverage</span>
				<span class="cov1">low coverage</span>
				<span class="cov2">*</span>
				<span class="cov3">*</span>
				<span class="cov4">*</span>
				<span class="cov5">*</span>
				<span class="cov6">*</span>
				<span class="cov7">*</span>
				<span class="cov8">*</span>
				<span class="cov9">*</span>
				<span class="cov10">high coverage</span>
			
			</div>
		</div>
		<div id="content">
		
		<pre class="file" id="file0" style="display: none">package flags

import (
        "encoding/json"
        "regexp"
        "strconv"
        "strings"

        "github.com/Checkmarx/kics/internal/console/helpers"
        "github.com/Checkmarx/kics/internal/constants"
        "github.com/rs/zerolog/log"
        "github.com/spf13/cobra"
        "github.com/spf13/pflag"
)

var (
        flagsMultiStrReferences = make(map[string]*[]string)
        flagsStrReferences      = make(map[string]*string)
        flagsBoolReferences     = make(map[string]*bool)
        flagsIntReferences      = make(map[string]*int)

        validations = make(map[string][]string)
)

type flagJSON struct {
        FlagType       string
        ShorthandFlag  string
        DefaultValue   *string
        Usage          string
        Hidden         bool
        Deprecated     bool
        DeprecatedInfo string
        Validation     string
}

func evalUsage(usage string, supportedPlatforms, supportedCloudProviders []string) string <span class="cov10" title="19">{
        variables := map[string]string{
                "sliceInstructions":  "can be provided multiple times or as a comma separated string",
                "supportedLogLevels": strings.Join(constants.AvailableLogLevels, ","),
                "supportedPlatforms": strings.Join(supportedPlatforms, ", "),
                "supportedProviders": strings.Join(supportedCloudProviders, ", "),
                "supportedReports":   strings.Join(append([]string{"all"}, helpers.ListReportFormats()...), ", "),
                "defaultLogFile":     constants.DefaultLogFile,
                "logFormatPretty":    constants.LogFormatPretty,
                "logFormatJSON":      constants.LogFormatJSON,
        }
        variableRegex := regexp.MustCompile(`\$\{(\w+)\}`)
        match := variableRegex.FindAllStringSubmatch(usage, -1)
        for i := range match </span><span class="cov7" title="8">{
                usage = strings.ReplaceAll(usage, "${"+match[i][1]+"}", variables[match[i][1]])
        }</span>
        <span class="cov10" title="19">return usage</span>
}

func checkHiddenAndDeprecated(flagSet *pflag.FlagSet, flagName string, flagProps flagJSON) error <span class="cov9" title="14">{ //nolint:gocritic
        if flagProps.Hidden </span><span class="cov1" title="1">{
                err := flagSet.MarkHidden(flagName)
                if err != nil </span><span class="cov0" title="0">{
                        log.Err(err).Msg("Loading flags: could not mark flag as hidden")
                        return err
                }</span>
        }
        <span class="cov9" title="14">if flagProps.Deprecated </span><span class="cov1" title="1">{
                err := flagSet.MarkDeprecated(flagName, flagProps.DeprecatedInfo)
                if err != nil </span><span class="cov0" title="0">{
                        log.Err(err).Msg("Loading flags: could not mark flag as deprecated")
                        return err
                }</span>
        }
        <span class="cov9" title="14">return nil</span>
}

// InitJSONFlags initialize cobra flags
func InitJSONFlags(
        cmd *cobra.Command,
        flagsListContent string,
        persistentFlag bool,
        supportedPlatforms,
        supportedCloudProviders []string) error <span class="cov6" title="7">{
        var flagsList map[string]flagJSON
        err := json.Unmarshal([]byte(flagsListContent), &amp;flagsList)
        if err != nil </span><span class="cov1" title="1">{
                log.Err(err).Msg("Loading flags: could not unmarshal flags")
                return err
        }</span>

        <span class="cov6" title="6">flagSet := cmd.Flags()
        if persistentFlag </span><span class="cov5" title="5">{
                flagSet = cmd.PersistentFlags()
        }</span>

        <span class="cov6" title="6">for flagName, flagProps := range flagsList </span><span class="cov9" title="16">{
                flagProps.Usage = evalUsage(flagProps.Usage, supportedPlatforms, supportedCloudProviders)

                switch flagProps.FlagType </span>{
                case "multiStr":<span class="cov1" title="1">
                        var flag []string
                        flagsMultiStrReferences[flagName] = &amp;flag
                        defaultValues := make([]string, 0)
                        if flagProps.DefaultValue != nil </span><span class="cov1" title="1">{
                                defaultValues = strings.Split(*flagProps.DefaultValue, ",")
                        }</span>
                        <span class="cov1" title="1">flagSet.StringSliceVarP(flagsMultiStrReferences[flagName], flagName, flagProps.ShorthandFlag, defaultValues, flagProps.Usage)</span>
                case "str":<span class="cov5" title="5">
                        var flag string
                        flagsStrReferences[flagName] = &amp;flag
                        flagSet.StringVarP(flagsStrReferences[flagName], flagName, flagProps.ShorthandFlag, *flagProps.DefaultValue, flagProps.Usage)</span>
                case "bool":<span class="cov6" title="7">
                        var flag bool
                        flagsBoolReferences[flagName] = &amp;flag
                        defaultValue, err := strconv.ParseBool(*flagProps.DefaultValue)
                        if err != nil </span><span class="cov1" title="1">{
                                log.Err(err).Msg("Loading flags: could not convert default values")
                                return err
                        }</span>
                        <span class="cov6" title="6">flagSet.BoolVarP(flagsBoolReferences[flagName], flagName, flagProps.ShorthandFlag, defaultValue, flagProps.Usage)</span>
                case "int":<span class="cov3" title="2">
                        var flag int
                        flagsIntReferences[flagName] = &amp;flag
                        defaultValue, err := strconv.Atoi(*flagProps.DefaultValue)
                        if err != nil </span><span class="cov1" title="1">{
                                log.Err(err).Msg("Loading flags: could not convert default values")
                                return err
                        }</span>
                        <span class="cov1" title="1">flagSet.IntVarP(flagsIntReferences[flagName], flagName, flagProps.ShorthandFlag, defaultValue, flagProps.Usage)</span>
                default:<span class="cov1" title="1">
                        log.Error().Msgf("Flag %s has unknown type %s", flagName, flagProps.FlagType)</span>
                }

                <span class="cov9" title="14">err := checkHiddenAndDeprecated(flagSet, flagName, flagProps)
                if err != nil </span><span class="cov0" title="0">{
                        return err
                }</span>

                <span class="cov9" title="14">if flagProps.Validation != "" </span><span class="cov3" title="2">{
                        validations[flagName] = strings.Split(flagProps.Validation, ",")
                }</span>
        }
        <span class="cov5" title="4">return nil</span>
}

// GetStrFlag get a string flag by its name
func GetStrFlag(flagName string) string <span class="cov6" title="6">{
        if value, ok := flagsStrReferences[flagName]; ok </span><span class="cov5" title="4">{
                return *value
        }</span>
        <span class="cov3" title="2">log.Debug().Msgf("Could not find string flag %s", flagName)
        return ""</span>
}

// GetMultiStrFlag get a slice of strings flag by its name
func GetMultiStrFlag(flagName string) []string <span class="cov10" title="19">{
        if value, ok := flagsMultiStrReferences[flagName]; ok </span><span class="cov9" title="14">{
                return *value
        }</span>
        <span class="cov5" title="5">log.Debug().Msgf("Could not find string slice flag %s", flagName)
        return []string{}</span>
}

// GetBoolFlag get a boolean flag by its name
func GetBoolFlag(flagName string) bool <span class="cov3" title="2">{
        if value, ok := flagsBoolReferences[flagName]; ok </span><span class="cov1" title="1">{
                return *value
        }</span>
        <span class="cov1" title="1">log.Debug().Msgf("Could not find boolean flag %s", flagName)
        return false</span>
}

// GetIntFlag get a integer flag by its name
func GetIntFlag(flagName string) int <span class="cov3" title="2">{
        if value, ok := flagsIntReferences[flagName]; ok </span><span class="cov1" title="1">{
                return *value
        }</span>
        <span class="cov1" title="1">log.Debug().Msgf("Could not find integer flag %s", flagName)
        return -1</span>
}

// SetStrFlag set a string flag using its name
func SetStrFlag(flagName, value string) <span class="cov3" title="2">{
        if _, ok := flagsStrReferences[flagName]; ok </span><span class="cov1" title="1">{
                *flagsStrReferences[flagName] = value
        }</span> else<span class="cov1" title="1"> {
                log.Debug().Msgf("Could not set string flag %s", flagName)
        }</span>
}

// SetMultiStrFlag set a slice of strings flag using its name
func SetMultiStrFlag(flagName string, value []string) <span class="cov3" title="2">{
        if _, ok := flagsMultiStrReferences[flagName]; ok </span><span class="cov1" title="1">{
                *flagsMultiStrReferences[flagName] = value
        }</span> else<span class="cov1" title="1"> {
                log.Debug().Msgf("Could not set string slice flag %s", flagName)
        }</span>
}

// GetAllFlags returns all flags values
func GetAllFlags() map[string]interface{} <span class="cov1" title="1">{
        flags := make(map[string]interface{})
        for flag, value := range flagsBoolReferences </span><span class="cov1" title="1">{
                flags[flag] = value
        }</span>
        <span class="cov1" title="1">for flag, value := range flagsIntReferences </span><span class="cov1" title="1">{
                flags[flag] = value
        }</span>
        <span class="cov1" title="1">for flag, value := range flagsMultiStrReferences </span><span class="cov1" title="1">{
                flags[flag] = value
        }</span>
        <span class="cov1" title="1">for flag, value := range flagsStrReferences </span><span class="cov1" title="1">{
                flags[flag] = value
        }</span>

        <span class="cov1" title="1">return flags</span>
}
</pre>
		
		<pre class="file" id="file1" style="display: none">package flags

import (
        "fmt"
        "strings"

        "github.com/pkg/errors"
        "github.com/rs/zerolog/log"
        "github.com/spf13/cobra"
        "github.com/spf13/pflag"
        "github.com/spf13/viper"
)

// FormatNewError reports the impossibility of flag1 and flag2 usage simultaneously
func FormatNewError(flag1, flag2 string) error <span class="cov10" title="4">{
        return errors.Errorf("can't provide '%s' and '%s' flags simultaneously",
                flag1,
                flag2)
}</span>

// ValidateQuerySelectionFlags reports the impossibility of include and exclude flags usage simultaneously
func ValidateQuerySelectionFlags() error <span class="cov8" title="3">{
        if len(GetMultiStrFlag(IncludeQueriesFlag)) &gt; 0 &amp;&amp; len(GetMultiStrFlag(ExcludeQueriesFlag)) &gt; 0 </span><span class="cov1" title="1">{
                return FormatNewError(IncludeQueriesFlag, ExcludeQueriesFlag)
        }</span>
        <span class="cov5" title="2">if len(GetMultiStrFlag(IncludeQueriesFlag)) &gt; 0 &amp;&amp; len(GetMultiStrFlag(ExcludeCategoriesFlag)) &gt; 0 </span><span class="cov1" title="1">{
                return FormatNewError(IncludeQueriesFlag, ExcludeCategoriesFlag)
        }</span>
        <span class="cov1" title="1">return nil</span>
}

// BindFlags fill flags values with config file or environment variables data
func BindFlags(cmd *cobra.Command, v *viper.Viper) error <span class="cov1" title="1">{
        log.Debug().Msg("console.bindFlags()")
        settingsMap := v.AllSettings()
        cmd.Flags().VisitAll(func(f *pflag.Flag) </span><span class="cov8" title="3">{
                settingsMap[f.Name] = true
                if strings.Contains(f.Name, "-") </span><span class="cov8" title="3">{
                        envVarSuffix := strings.ToUpper(strings.ReplaceAll(f.Name, "-", "_"))
                        variableName := fmt.Sprintf("%s_%s", "KICS", envVarSuffix)
                        if err := v.BindEnv(f.Name, variableName); err != nil </span><span class="cov0" title="0">{
                                log.Err(err).Msg("Failed to bind Viper flags")
                        }</span>
                }
                <span class="cov8" title="3">if !f.Changed &amp;&amp; v.IsSet(f.Name) </span><span class="cov5" title="2">{
                        val := v.Get(f.Name)
                        setBoundFlags(f.Name, val, cmd)
                }</span>
        })
        <span class="cov1" title="1">for key, val := range settingsMap </span><span class="cov8" title="3">{
                if val != true </span><span class="cov0" title="0">{
                        return fmt.Errorf("unknown configuration key: '%s'\nShowing help for '%s' command", key, cmd.Name())
                }</span>
        }
        <span class="cov1" title="1">return nil</span>
}

func setBoundFlags(flagName string, val interface{}, cmd *cobra.Command) <span class="cov5" title="2">{
        switch t := val.(type) </span>{
        case []interface{}:<span class="cov1" title="1">
                var paramSlice []string
                for _, param := range t </span><span class="cov5" title="2">{
                        paramSlice = append(paramSlice, param.(string))
                }</span>
                <span class="cov1" title="1">valStr := strings.Join(paramSlice, ",")
                if err := cmd.Flags().Set(flagName, valStr); err != nil </span><span class="cov0" title="0">{
                        log.Err(err).Msg("Failed to set Viper flags")
                }</span>
        default:<span class="cov1" title="1">
                if err := cmd.Flags().Set(flagName, fmt.Sprintf("%v", val)); err != nil </span><span class="cov0" title="0">{
                        log.Err(err).Msg("Failed to set Viper flags")
                }</span>
        }
}
</pre>
		
		<pre class="file" id="file2" style="display: none">package flags

import "regexp"

type flagValidationFuncsMap map[string]func(flagName string) error

var flagValidationFuncs = flagValidationFuncsMap{
        "sliceFlagsShouldNotStartWithFlags": sliceFlagsShouldNotStartWithFlags,
        "validateMultiStrEnum":              validateMultiStrEnum,
        "validateStrEnum":                   validateStrEnum,
        "allQueriesID":                      allQueriesID,
}

func isQueryID(id string) bool <span class="cov5" title="5">{
        re := regexp.MustCompile(`^[0-9a-fA-F]{8}\b-[0-9a-fA-F]{4}\b-[0-9a-fA-F]{4}\b-[0-9a-fA-F]{4}\b-[0-9a-fA-F]{12}$`)
        return re.MatchString(id)
}</span>

func convertSliceToDummyMap(slice []string) map[string]string <span class="cov5" title="5">{
        returnMap := make(map[string]string, len(slice))
        for _, element := range slice </span><span class="cov10" title="30">{
                returnMap[element] = ""
        }</span>
        <span class="cov5" title="5">return returnMap</span>
}

// Validate validate if flag values are ok, if not, returns an error
func Validate() error <span class="cov0" title="0">{
        for validation, validationFuncs := range validations </span><span class="cov0" title="0">{
                for _, validationFunc := range validationFuncs </span><span class="cov0" title="0">{
                        if function, ok := flagValidationFuncs[validationFunc]; ok </span><span class="cov0" title="0">{
                                if err := function(validation); err != nil </span><span class="cov0" title="0">{
                                        return err
                                }</span>
                        }
                }
        }
        <span class="cov0" title="0">return nil</span>
}
</pre>
		
		<pre class="file" id="file3" style="display: none">package flags

import (
        "fmt"
        "regexp"
        "strings"

        "github.com/Checkmarx/kics/internal/console/helpers"
        "github.com/Checkmarx/kics/internal/constants"
        "github.com/Checkmarx/kics/pkg/utils"
)

var validMultiStrEnums = map[string]map[string]string{
        CloudProviderFlag:     constants.AvailableCloudProviders,
        ExcludeCategoriesFlag: constants.AvailableCategories,
        ExcludeSeveritiesFlag: convertSliceToDummyMap(constants.AvailableSeverities),
        FailOnFlag:            convertSliceToDummyMap(constants.AvailableSeverities),
        ReportFormatsFlag:     convertSliceToDummyMap(append([]string{"all"}, helpers.ListReportFormats()...)),
        TypeFlag:              constants.AvailablePlatforms,
}

func sliceFlagsShouldNotStartWithFlags(flagName string) error <span class="cov3" title="3">{
        values := GetMultiStrFlag(flagName)
        re := regexp.MustCompile(`^--[a-z-]+$`)
        if len(values) &gt; 0 </span><span class="cov3" title="3">{
                firstArg := values[0]
                if strings.HasPrefix(firstArg, "-") &amp;&amp; len(firstArg) == 2 || re.MatchString(firstArg) </span><span class="cov2" title="2">{
                        return fmt.Errorf("flag needs an argument: %s", flagName)
                }</span>
        }
        <span class="cov1" title="1">return nil</span>
}

func allQueriesID(flagName string) error <span class="cov2" title="2">{
        queriesID := GetMultiStrFlag(flagName)
        for _, queryID := range queriesID </span><span class="cov3" title="3">{
                if !isQueryID(queryID) </span><span class="cov1" title="1">{
                        return fmt.Errorf("invalid argument --%s: %s is not a valid query ID", flagName, queryID)
                }</span>
        }
        <span class="cov1" title="1">return nil</span>
}

func validateMultiStrEnum(flagName string) error <span class="cov2" title="2">{
        enums := GetMultiStrFlag(flagName)
        invalidEnum := make([]string, 0)
        caseInsensitiveMap := make(map[string]string)
        for key, value := range validMultiStrEnums[flagName] </span><span class="cov10" title="30">{
                caseInsensitiveMap[strings.ToLower(key)] = value
        }</span>
        <span class="cov2" title="2">for _, enum := range enums </span><span class="cov3" title="3">{
                if _, ok := caseInsensitiveMap[strings.ToLower(enum)]; enum != "" &amp;&amp; !ok </span><span class="cov1" title="1">{
                        invalidEnum = append(invalidEnum, enum)
                }</span>
        }
        <span class="cov2" title="2">validEnumsValues := utils.SortedKeys(validMultiStrEnums[flagName])
        if len(invalidEnum) &gt; 0 </span><span class="cov1" title="1">{
                return fmt.Errorf(
                        "unknown argument(s) for --%s: %s\nvalid arguments:\n  %s",
                        flagName,
                        strings.Join(invalidEnum, ", "),
                        strings.Join(validEnumsValues, "\n  "),
                )
        }</span>
        <span class="cov1" title="1">return nil</span>
}
</pre>
		
		<pre class="file" id="file4" style="display: none">package flags

import (
        "fmt"
        "strings"

        "github.com/Checkmarx/kics/internal/constants"
        "github.com/Checkmarx/kics/pkg/utils"
)

var validStrEnums = map[string]map[string]string{
        LogLevelFlag: convertSliceToDummyMap(constants.AvailableLogLevels),
}

func validateStrEnum(flagName string) error <span class="cov3" title="2">{
        value := GetStrFlag(flagName)
        caseInsensitiveMap := make(map[string]string)
        for key, value := range validStrEnums[flagName] </span><span class="cov10" title="12">{
                caseInsensitiveMap[strings.ToLower(key)] = value
        }</span>
        <span class="cov3" title="2">validEnumsValues := utils.SortedKeys(validStrEnums[flagName])
        if _, ok := caseInsensitiveMap[strings.ToLower(value)]; value != "" &amp;&amp; !ok </span><span class="cov1" title="1">{
                return fmt.Errorf(
                        "unknown argument for --%s: %s\nvalid arguments:\n  %s",
                        flagName,
                        value,
                        strings.Join(validEnumsValues, "\n  "),
                )
        }</span>
        <span class="cov1" title="1">return nil</span>
}
</pre>
		
		<pre class="file" id="file5" style="display: none">package console

import (
        "fmt"

        "github.com/google/uuid"
        "github.com/rs/zerolog/log"
        "github.com/spf13/cobra"
)

// NewGenerateIDCmd creates a new instance of the generate-id Command
func NewGenerateIDCmd() *cobra.Command <span class="cov10" title="18">{
        return &amp;cobra.Command{
                Use:   "generate-id",
                Short: "Generates uuid for query",
                RunE: func(cmd *cobra.Command, args []string) error </span><span class="cov1" title="1">{
                        _, err := fmt.Fprintln(cmd.OutOrStdout(), uuid.New().String())
                        if err != nil </span><span class="cov0" title="0">{
                                log.Err(err).Msg("failed to get uuid")
                        }</span>
                        <span class="cov1" title="1">return err</span>
                },
        }
}
</pre>
		
		<pre class="file" id="file6" style="display: none">package helpers

import (
        "fmt"
        "strings"

        "github.com/Checkmarx/kics/pkg/model"
)

var shouldIgnore string
var shouldFail map[string]struct{}

// ResultsExitCode calculate exit code base on severity of results, returns 0 if no results was reported
func ResultsExitCode(summary *model.Summary) int <span class="cov5" title="4">{
        // severityArr is needed to make sure 'for' cycle is made in an ordered fashion
        severityArr := []model.Severity{"HIGH", "MEDIUM", "LOW", "INFO", "TRACE"}
        codeMap := map[model.Severity]int{"HIGH": 50, "MEDIUM": 40, "LOW": 30, "INFO": 20, "TRACE": 0}
        exitMap := summary.SeveritySummary.SeverityCounters
        for _, severity := range severityArr </span><span class="cov8" title="9">{
                if _, reportSeverity := shouldFail[strings.ToLower(string(severity))]; !reportSeverity </span><span class="cov6" title="5">{
                        continue</span>
                }
                <span class="cov5" title="4">if exitMap[severity] &gt; 0 </span><span class="cov4" title="3">{
                        return codeMap[severity]
                }</span>
        }
        <span class="cov1" title="1">return 0</span>
}

// InitShouldIgnoreArg initializes what kind of errors should be used on exit codes
func InitShouldIgnoreArg(arg string) error <span class="cov7" title="7">{
        validArgs := []string{"none", "all", "results", "errors"}
        for _, validArg := range validArgs </span><span class="cov10" title="16">{
                if strings.EqualFold(validArg, arg) </span><span class="cov6" title="6">{
                        shouldIgnore = strings.ToLower(arg)
                        return nil
                }</span>
        }
        <span class="cov1" title="1">return fmt.Errorf("unknown argument for --ignore-on-exit: %s\nvalid arguments:\n  %s", arg, strings.Join(validArgs, "\n  "))</span>
}

// InitShouldFailArg initializes which kind of vulnerability severity should changes exit code
func InitShouldFailArg(args []string) error <span class="cov5" title="4">{
        possibleArgs := map[string]struct{}{
                "high":   {},
                "medium": {},
                "low":    {},
                "info":   {},
        }
        if len(args) == 0 </span><span class="cov1" title="1">{
                shouldFail = possibleArgs
                return nil
        }</span>

        <span class="cov4" title="3">argsConverted := make(map[string]struct{})
        for _, arg := range args </span><span class="cov6" title="6">{
                if _, ok := possibleArgs[strings.ToLower(arg)]; !ok </span><span class="cov1" title="1">{
                        validArgs := []string{"high", "medium", "low", "info"}
                        return fmt.Errorf("unknown argument for --fail-on: %s\nvalid arguments:\n  %s", arg, strings.Join(validArgs, "\n  "))
                }</span>
                <span class="cov6" title="5">argsConverted[strings.ToLower(arg)] = struct{}{}</span>
        }

        <span class="cov3" title="2">shouldFail = argsConverted
        return nil</span>
}

// ShowError returns true if should show error, otherwise returns false
func ShowError(kind string) bool <span class="cov5" title="4">{
        return strings.EqualFold(shouldIgnore, "none") || (!strings.EqualFold(shouldIgnore, "all") &amp;&amp; !strings.EqualFold(shouldIgnore, kind))
}</span>

// RemediateExitCode calculate exit code base on the difference between remediation selected and done
func RemediateExitCode(selectedRemediationNumber, actualRemediationDoneNumber int) int <span class="cov3" title="2">{
        statusCode := 70
        if selectedRemediationNumber != actualRemediationDoneNumber </span><span class="cov1" title="1">{
                // KICS AR was not able to remediate all the selected remediation
                return statusCode
        }</span>

        <span class="cov1" title="1">return 0</span>
}
</pre>
		
		<pre class="file" id="file7" style="display: none">package helpers

import (
        "bufio"
        "encoding/json"
        "errors"
        "fmt"
        "io"
        "os"
        "path/filepath"
        "runtime"
        "sort"
        "strconv"
        "strings"

        "github.com/BurntSushi/toml"
        "github.com/Checkmarx/kics/internal/metrics"
        "github.com/Checkmarx/kics/pkg/progress"
        "github.com/Checkmarx/kics/pkg/report"
        "github.com/hashicorp/hcl"
        "github.com/rs/zerolog"
        "github.com/rs/zerolog/log"
        "gopkg.in/yaml.v3"
)

const divisor = float32(100000)

var reportGenerators = map[string]func(path, filename string, body interface{}) error{
        "json":        report.PrintJSONReport,
        "sarif":       report.PrintSarifReport,
        "html":        report.PrintHTMLReport,
        "glsast":      report.PrintGitlabSASTReport,
        "pdf":         report.PrintPdfReport,
        "sonarqube":   report.PrintSonarQubeReport,
        "cyclonedx":   report.PrintCycloneDxReport,
        "junit":       report.PrintJUnitReport,
        "asff":        report.PrintASFFReport,
        "csv":         report.PrintCSVReport,
        "codeclimate": report.PrintCodeClimateReport,
}

// CustomConsoleWriter creates an output to print log in a files
func CustomConsoleWriter(fileLogger *zerolog.ConsoleWriter) zerolog.ConsoleWriter <span class="cov1" title="1">{
        fileLogger.FormatLevel = func(i interface{}) string </span><span class="cov0" title="0">{
                return strings.ToUpper(fmt.Sprintf("| %-6s|", i))
        }</span>

        <span class="cov1" title="1">fileLogger.FormatFieldName = func(i interface{}) string </span><span class="cov0" title="0">{
                return fmt.Sprintf("%s:", i)
        }</span>

        <span class="cov1" title="1">fileLogger.FormatErrFieldName = func(i interface{}) string </span><span class="cov0" title="0">{
                return "ERROR:"
        }</span>

        <span class="cov1" title="1">fileLogger.FormatFieldValue = func(i interface{}) string </span><span class="cov0" title="0">{
                return fmt.Sprintf("%s", i)
        }</span>

        <span class="cov1" title="1">return *fileLogger</span>
}

// FileAnalyzer determines the type of extension in the passed config file by its content
func FileAnalyzer(path string) (string, error) <span class="cov10" title="12">{
        ostat, err := os.Open(filepath.Clean(path))
        if err != nil </span><span class="cov1" title="1">{
                return "", err
        }</span>
        <span class="cov9" title="11">rc, err := io.ReadAll(ostat)
        if err != nil </span><span class="cov0" title="0">{
                return "", err
        }</span>
        <span class="cov9" title="11">var temp map[string]interface{}

        // CxSAST query under review
        if err := json.Unmarshal(rc, &amp;temp); err == nil </span><span class="cov3" title="2">{
                return "json", nil
        }</span>

        // CxSAST query under review
        <span class="cov8" title="9">if err := yaml.Unmarshal(rc, &amp;temp); err == nil </span><span class="cov4" title="3">{
                return "yaml", nil
        }</span>

        // CxSAST query under review
        <span class="cov7" title="6">if _, err := toml.Decode(string(rc), &amp;temp); err == nil </span><span class="cov3" title="2">{
                return "toml", nil
        }</span>

        // CxSAST query under review
        <span class="cov6" title="4">if c, err := hcl.Parse(string(rc)); err == nil </span><span class="cov3" title="2">{
                if err = hcl.DecodeObject(&amp;temp, c); err == nil </span><span class="cov3" title="2">{
                        return "hcl", nil
                }</span>
        }

        <span class="cov3" title="2">return "", errors.New("invalid configuration file format")</span>
}

// GenerateReport execute each report function to generate report
func GenerateReport(path, filename string, body interface{}, formats []string, proBarBuilder progress.PbBuilder) error <span class="cov6" title="4">{
        log.Debug().Msgf("helpers.GenerateReport()")
        metrics.Metric.Start("generate_report")

        progressBar := proBarBuilder.BuildCircle("Generating Reports: ")

        var err error = nil
        go progressBar.Start()
        defer progressBar.Close()

        for _, format := range formats </span><span class="cov6" title="4">{
                format = strings.ToLower(format)
                if err = reportGenerators[format](path, filename, body); err != nil </span><span class="cov1" title="1">{
                        log.Error().Msgf("Failed to generate %s report", format)
                        break</span>
                }
        }
        <span class="cov6" title="4">metrics.Metric.Stop()
        return err</span>
}

// GetExecutableDirectory - returns the path to the directory containing KICS executable
func GetExecutableDirectory() string <span class="cov3" title="2">{
        log.Debug().Msg("helpers.GetExecutableDirectory()")
        path, err := os.Executable()
        if err != nil </span><span class="cov0" title="0">{
                log.Err(err)
        }</span>
        <span class="cov3" title="2">return filepath.Dir(path)</span>
}

// GetDefaultQueryPath - returns the default query path
func GetDefaultQueryPath(queriesPath string) (string, error) <span class="cov3" title="2">{
        log.Debug().Msg("helpers.GetDefaultQueryPath()")
        executableDirPath := GetExecutableDirectory()
        queriesDirectory := filepath.Join(executableDirPath, queriesPath)
        if _, err := os.Stat(queriesDirectory); os.IsNotExist(err) </span><span class="cov3" title="2">{
                currentWorkDir, err := os.Getwd()
                if err != nil </span><span class="cov0" title="0">{
                        return "", err
                }</span>
                <span class="cov3" title="2">idx := strings.Index(currentWorkDir, "kics")
                if idx != -1 </span><span class="cov3" title="2">{
                        currentWorkDir = currentWorkDir[:strings.LastIndex(currentWorkDir, "kics")] + "kics"
                }</span>
                <span class="cov3" title="2">queriesDirectory = filepath.Join(currentWorkDir, queriesPath)
                if _, err := os.Stat(queriesDirectory); os.IsNotExist(err) </span><span class="cov1" title="1">{
                        return "", err
                }</span>
        }

        <span class="cov1" title="1">log.Debug().Msgf("Queries found in %s", queriesDirectory)
        return queriesDirectory, nil</span>
}

// ListReportFormats return a slice with all supported report formats
func ListReportFormats() []string <span class="cov1" title="1">{
        supportedFormats := make([]string, 0, len(reportGenerators))
        for reportFormats := range reportGenerators </span><span class="cov9" title="11">{
                supportedFormats = append(supportedFormats, reportFormats)
        }</span>
        <span class="cov1" title="1">sort.Strings(supportedFormats)
        return supportedFormats</span>
}

// GetNumCPU return the number of cpus available
func GetNumCPU() float32 <span class="cov1" title="1">{
        // Check if application is running inside docker
        _, err := os.Stat("/.dockerenv")
        if err == nil </span><span class="cov0" title="0">{
                numCPU, err := getCPUFromQuotaUS()
                if err == nil </span><span class="cov0" title="0">{
                        return numCPU
                }</span>
                <span class="cov0" title="0">numCPU, err = getCPUFromCPUMax()
                if err == nil </span><span class="cov0" title="0">{
                        return numCPU
                }</span>
        }

        <span class="cov1" title="1">return float32(runtime.NumCPU())</span>
}

func getCPUFromQuotaUS() (float32, error) <span class="cov0" title="0">{
        f, err := os.Open("/sys/fs/cgroup/cpu/cpu.cfs_quota_us")
        if err != nil </span><span class="cov0" title="0">{
                return -1, err
        }</span>

        <span class="cov0" title="0">defer func() </span><span class="cov0" title="0">{
                if err := f.Close(); err != nil </span><span class="cov0" title="0">{
                        log.Err(err).Msg("failed to close '/sys/fs/cgroup/cpu/cpu.cfs_quota_us'")
                }</span>
        }()

        <span class="cov0" title="0">scanner := bufio.NewScanner(f)
        if scanner.Scan() </span><span class="cov0" title="0">{
                text := scanner.Text()
                cpus, err := strconv.Atoi(text)
                if err != nil </span><span class="cov0" title="0">{
                        return float32(cpus) / divisor, err
                }</span>

                <span class="cov0" title="0">if cpus != -1 </span><span class="cov0" title="0">{
                        return float32(cpus) / divisor, nil
                }</span>

                <span class="cov0" title="0">return float32(runtime.NumCPU()), nil</span>
        }

        <span class="cov0" title="0">return float32(runtime.NumCPU()), nil</span>
}

func getCPUFromCPUMax() (float32, error) <span class="cov0" title="0">{
        f, err := os.Open("/sys/fs/cgroup/cpu.max")
        if err != nil </span><span class="cov0" title="0">{
                return -1, err
        }</span>

        <span class="cov0" title="0">defer func() </span><span class="cov0" title="0">{
                if err := f.Close(); err != nil </span><span class="cov0" title="0">{
                        log.Err(err).Msg("failed to close '/sys/fs/cgroup/cpu.max'")
                }</span>
        }()

        <span class="cov0" title="0">scanner := bufio.NewScanner(f)
        if scanner.Scan() </span><span class="cov0" title="0">{
                text := scanner.Text()
                stringCpus := strings.Split(text, " ")[0]
                cpus, err := strconv.Atoi(stringCpus)
                if err != nil </span><span class="cov0" title="0">{
                        return float32(cpus) / divisor, err
                }</span>

                <span class="cov0" title="0">if cpus != -1 </span><span class="cov0" title="0">{
                        return float32(cpus) / divisor, nil
                }</span>

                <span class="cov0" title="0">return float32(runtime.NumCPU()), nil</span>
        }

        <span class="cov0" title="0">return float32(runtime.NumCPU()), nil</span>
}
</pre>
		
		<pre class="file" id="file8" style="display: none">package console

import (
        "context"
        _ "embed" // Embed kics flags
        "os"
        "time"

        "github.com/Checkmarx/kics/internal/console/flags"
        "github.com/Checkmarx/kics/internal/constants"
        sentryReport "github.com/Checkmarx/kics/internal/sentry"
        "github.com/Checkmarx/kics/pkg/engine/source"
        "github.com/Checkmarx/kics/pkg/printer"
        "github.com/getsentry/sentry-go"
        "github.com/rs/zerolog"
        "github.com/rs/zerolog/log"
        "github.com/spf13/cobra"
        "github.com/spf13/viper"
)

const (
        scanID = "console"
)

var (
        //go:embed assets/kics-flags.json
        kicsFlagsListContent string

        // warnings - a buffer to accumulate warnings before the printer gets initialized
        warnings = make([]string, 0)

        ctx = context.Background()
)

// NewKICSCmd creates a new instance of the kics Command
func NewKICSCmd() *cobra.Command <span class="cov10" title="18">{
        return &amp;cobra.Command{
                Use:   "kics",
                Short: constants.Fullname,
        }
}</span>

func initialize(rootCmd *cobra.Command) error <span class="cov10" title="18">{
        scanCmd := NewScanCmd()
        remediateCmd := NewRemediateCmd()
        rootCmd.AddCommand(NewVersionCmd())
        rootCmd.AddCommand(NewGenerateIDCmd())
        rootCmd.AddCommand(scanCmd)
        rootCmd.AddCommand(NewListPlatformsCmd())
        rootCmd.AddCommand(remediateCmd)
        rootCmd.CompletionOptions.DisableDefaultCmd = true

        if err := flags.InitJSONFlags(
                rootCmd,
                kicsFlagsListContent,
                true,
                source.ListSupportedPlatforms(),
                source.ListSupportedCloudProviders()); err != nil </span><span class="cov0" title="0">{
                return err
        }</span>

        <span class="cov10" title="18">if err := viper.BindPFlags(rootCmd.PersistentFlags()); err != nil </span><span class="cov0" title="0">{
                return err
        }</span>

        <span class="cov10" title="18">if err := initRemediateCmd(remediateCmd); err != nil </span><span class="cov0" title="0">{
                return err
        }</span>

        <span class="cov10" title="18">return initScanCmd(scanCmd)</span>
}

// Execute starts kics execution
func Execute() error <span class="cov10" title="18">{
        zerolog.SetGlobalLevel(zerolog.InfoLevel)

        enableCrashReport()

        rootCmd := NewKICSCmd()

        if err := initialize(rootCmd); err != nil </span><span class="cov0" title="0">{
                sentryReport.ReportSentry(&amp;sentryReport.Report{
                        Message:  "Failed to initialize CLI",
                        Err:      err,
                        Location: "func Execute()",
                }, true)
                return err
        }</span>

        <span class="cov10" title="18">if err := rootCmd.ExecuteContext(ctx); err != nil </span><span class="cov6" title="5">{
                sentryReport.ReportSentry(&amp;sentryReport.Report{
                        Message:  "Failed to run application",
                        Err:      err,
                        Location: "func Execute()",
                }, printer.IsInitialized())
                return err
        }</span>

        <span class="cov8" title="13">return nil</span>
}

func enableCrashReport() <span class="cov10" title="18">{
        enableCrashReport, found := os.LookupEnv("DISABLE_CRASH_REPORT")
        if found &amp;&amp; (enableCrashReport == "0" || enableCrashReport == "false") </span><span class="cov0" title="0">{
                initSentry("")
        }</span> else<span class="cov10" title="18"> {
                initSentry(constants.SentryDSN)
        }</span>
}

func initSentry(dsn string) <span class="cov10" title="18">{
        var err error
        if dsn == "" </span><span class="cov10" title="18">{
                warnings = append(warnings, "KICS crash report disabled")
                err = sentry.Init(sentry.ClientOptions{
                        Release: constants.GetRelease(),
                })
        }</span> else<span class="cov0" title="0"> {
                err = sentry.Init(sentry.ClientOptions{
                        Dsn:     dsn,
                        Release: constants.GetRelease(),
                })
        }</span>
        <span class="cov10" title="18">if err != nil </span><span class="cov0" title="0">{
                log.Err(err).Msg("Failed to initialize sentry")
        }</span>
        <span class="cov10" title="18">sentry.Flush(constants.SentryRefreshRate * time.Second)</span>
}
</pre>
		
		<pre class="file" id="file9" style="display: none">package console

import (
        "fmt"

        "github.com/Checkmarx/kics/pkg/engine/source"
        "github.com/spf13/cobra"
)

// NewListPlatformsCmd creates a new instance of the list-platforms Command
func NewListPlatformsCmd() *cobra.Command <span class="cov10" title="18">{
        return &amp;cobra.Command{
                Use:   "list-platforms",
                Short: "List supported platforms",
                RunE: func(cmd *cobra.Command, args []string) error </span><span class="cov1" title="1">{
                        for _, v := range source.ListSupportedPlatforms() </span><span class="cov9" title="15">{
                                fmt.Fprintf(cmd.OutOrStdout(), "%s\n", v)
                        }</span>
                        <span class="cov1" title="1">return nil</span>
                },
        }
}
</pre>
		
		<pre class="file" id="file10" style="display: none">package console

import (
        _ "embed" // Embed kics CLI img and scan-flags
        "fmt"
        "os"
        "path/filepath"
        "runtime"
        "strings"

        "code.cloudfoundry.org/bytefmt"
        "github.com/Checkmarx/kics/internal/console/flags"
        consoleHelpers "github.com/Checkmarx/kics/internal/console/helpers"
        "github.com/Checkmarx/kics/internal/constants"
        "github.com/Checkmarx/kics/internal/metrics"
        internalPrinter "github.com/Checkmarx/kics/pkg/printer"
        "github.com/Checkmarx/kics/pkg/progress"
        "github.com/mackerelio/go-osstat/memory"
        "github.com/pkg/errors"
        "github.com/rs/zerolog/log"
        "github.com/spf13/cobra"
        "github.com/spf13/viper"
)

func preRun(cmd *cobra.Command) error <span class="cov6" title="8">{
        err := initializeConfig(cmd)
        if err != nil </span><span class="cov1" title="1">{
                return errors.New(initError + err.Error())
        }</span>

        <span class="cov6" title="7">err = flags.Validate()
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>

        <span class="cov6" title="7">err = flags.ValidateQuerySelectionFlags()
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>
        <span class="cov6" title="7">err = internalPrinter.SetupPrinter(cmd.InheritedFlags())
        if err != nil </span><span class="cov0" title="0">{
                return errors.New(initError + err.Error())
        }</span>
        <span class="cov6" title="7">err = metrics.InitializeMetrics(flags.GetStrFlag(flags.ProfilingFlag), flags.GetBoolFlag(flags.CIFlag))
        if err != nil </span><span class="cov0" title="0">{
                return errors.New(initError + err.Error())
        }</span>
        <span class="cov6" title="7">return nil</span>
}

func setupConfigFile() (bool, error) <span class="cov6" title="8">{
        if flags.GetStrFlag(flags.ConfigFlag) == "" </span><span class="cov5" title="6">{
                path := flags.GetMultiStrFlag(flags.PathFlag)
                if len(path) == 0 </span><span class="cov0" title="0">{
                        return true, nil
                }</span>
                <span class="cov5" title="6">if len(path) &gt; 1 </span><span class="cov1" title="1">{
                        warnings = append(warnings, "Any kics.config file will be ignored, please use --config if kics.config is wanted")
                        return true, nil
                }</span>
                <span class="cov5" title="5">configPath := path[0]
                info, err := os.Stat(configPath)
                if err != nil </span><span class="cov0" title="0">{
                        return true, nil
                }</span>
                <span class="cov5" title="5">if !info.IsDir() </span><span class="cov4" title="4">{
                        configPath = filepath.Dir(configPath)
                }</span>
                <span class="cov5" title="5">_, err = os.Stat(filepath.ToSlash(filepath.Join(configPath, constants.DefaultConfigFilename)))
                if err != nil </span><span class="cov5" title="5">{
                        if os.IsNotExist(err) </span><span class="cov5" title="5">{
                                return true, nil
                        }</span>
                        <span class="cov0" title="0">return true, err</span>
                }
                <span class="cov0" title="0">flags.SetStrFlag(flags.ConfigFlag, filepath.ToSlash(filepath.Join(configPath, constants.DefaultConfigFilename)))</span>
        }
        <span class="cov2" title="2">return false, nil</span>
}

func initializeConfig(cmd *cobra.Command) error <span class="cov6" title="8">{
        log.Debug().Msg("console.initializeConfig()")

        v := viper.New()
        v.SetEnvPrefix("KICS")
        v.AutomaticEnv()
        errBind := flags.BindFlags(cmd, v)
        if errBind != nil </span><span class="cov0" title="0">{
                return errBind
        }</span>

        <span class="cov6" title="8">exit, err := setupConfigFile()
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>
        <span class="cov6" title="8">if exit </span><span class="cov5" title="6">{
                return nil
        }</span>

        <span class="cov2" title="2">base := filepath.Base(flags.GetStrFlag(flags.ConfigFlag))
        v.SetConfigName(base)
        v.AddConfigPath(filepath.Dir(flags.GetStrFlag(flags.ConfigFlag)))
        ext, err := consoleHelpers.FileAnalyzer(flags.GetStrFlag(flags.ConfigFlag))
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>
        <span class="cov2" title="2">v.SetConfigType(ext)
        if err := v.ReadInConfig(); err != nil </span><span class="cov0" title="0">{
                return err
        }</span>

        <span class="cov2" title="2">errBind = flags.BindFlags(cmd, v)
        if errBind != nil </span><span class="cov1" title="1">{
                return errBind
        }</span>
        <span class="cov1" title="1">return nil</span>
}

type console struct {
        Printer       *internalPrinter.Printer
        ProBarBuilder *progress.PbBuilder
}

func newConsole() *console <span class="cov6" title="7">{
        return &amp;console{}
}</span>

// preScan is responsible for scan preparation
func (console *console) preScan() <span class="cov6" title="7">{
        log.Debug().Msg("console.scan()")
        for _, warn := range warnings </span><span class="cov10" title="30">{
                log.Warn().Msgf(warn)
        }</span>

        <span class="cov6" title="7">printer := internalPrinter.NewPrinter(flags.GetBoolFlag(flags.MinimalUIFlag))
        printer.Success.Printf("\n%s\n", banner)

        versionMsg := fmt.Sprintf("\nScanning with %s\n\n", constants.GetVersion())
        fmt.Println(versionMsg)
        log.Info().Msgf(strings.ReplaceAll(versionMsg, "\n", ""))

        log.Info().Msgf("Operating system: %s", runtime.GOOS)

        mem, err := memory.Get()
        if err != nil </span><span class="cov0" title="0">{
                log.Err(err)
        }</span> else<span class="cov6" title="7"> {
                log.Info().Msgf("Total memory: %s", bytefmt.ByteSize(mem.Total))
        }</span>

        <span class="cov6" title="7">cpu := consoleHelpers.GetNumCPU()
        log.Info().Msgf("CPU: %.1f", cpu)

        noProgress := flags.GetBoolFlag(flags.NoProgressFlag)
        if strings.EqualFold(flags.GetStrFlag(flags.LogLevelFlag), "debug") </span><span class="cov0" title="0">{
                noProgress = true
        }</span>

        <span class="cov6" title="7">proBarBuilder := progress.InitializePbBuilder(
                noProgress,
                flags.GetBoolFlag(flags.CIFlag),
                flags.GetBoolFlag(flags.SilentFlag))

        console.Printer = printer
        console.ProBarBuilder = proBarBuilder</span>
}
</pre>
		
		<pre class="file" id="file11" style="display: none">package console

import (
        _ "embed" // Embed remediate flags
        "encoding/json"
        "fmt"
        "os"
        "path/filepath"

        "github.com/Checkmarx/kics/internal/console/flags"
        consoleHelpers "github.com/Checkmarx/kics/internal/console/helpers"
        sentryReport "github.com/Checkmarx/kics/internal/sentry"
        "github.com/Checkmarx/kics/pkg/engine/source"
        internalPrinter "github.com/Checkmarx/kics/pkg/printer"
        "github.com/Checkmarx/kics/pkg/remediation"
        "github.com/pkg/errors"
        "github.com/rs/zerolog/log"
        "github.com/spf13/cobra"
)

var (
        //go:embed assets/remediate-flags.json
        remediateFlagsListContent string
)

// NewRemediateCmd creates a new instance of the remediate Command
func NewRemediateCmd() *cobra.Command <span class="cov10" title="18">{
        return &amp;cobra.Command{
                Use:   "remediate",
                Short: "Auto remediates the project",
                PersistentPreRunE: func(cmd *cobra.Command, args []string) error </span><span class="cov6" title="5">{
                        return preRemediate(cmd)
                }</span>,
                RunE: func(cmd *cobra.Command, args []string) error <span class="cov5" title="4">{
                        return remediate(cmd)
                }</span>,
        }
}

func initRemediateCmd(remediateCmd *cobra.Command) error <span class="cov10" title="18">{
        if err := flags.InitJSONFlags(
                remediateCmd,
                remediateFlagsListContent,
                false,
                source.ListSupportedPlatforms(),
                source.ListSupportedCloudProviders()); err != nil </span><span class="cov0" title="0">{
                return err
        }</span>

        <span class="cov10" title="18">if err := remediateCmd.MarkFlagRequired(flags.Results); err != nil </span><span class="cov0" title="0">{
                sentryReport.ReportSentry(&amp;sentryReport.Report{
                        Message:  "Failed to add command required flags",
                        Err:      err,
                        Location: "func initScanCmd()",
                }, true)
                log.Err(err).Msg("Failed to add command required flags")
        }</span>
        <span class="cov10" title="18">return nil</span>
}

func preRemediate(cmd *cobra.Command) error <span class="cov6" title="5">{
        err := flags.Validate()
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>

        <span class="cov6" title="5">err = flags.ValidateQuerySelectionFlags()
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>
        <span class="cov6" title="5">err = internalPrinter.SetupPrinter(cmd.InheritedFlags())
        if err != nil </span><span class="cov0" title="0">{
                return errors.New(initError + err.Error())
        }</span>
        <span class="cov6" title="5">return err</span>
}

func remediate(cmd *cobra.Command) error <span class="cov5" title="4">{
        resultsPath := flags.GetStrFlag(flags.Results)
        include := flags.GetMultiStrFlag(flags.IncludeIds)

        filepath.Clean(resultsPath)

        content, err := os.ReadFile(resultsPath)
        if err != nil </span><span class="cov1" title="1">{
                log.Error().Msgf("failed to read file: %s", err)
                return err
        }</span>

        <span class="cov4" title="3">results := remediation.Report{}

        err = json.Unmarshal(content, &amp;results)
        if err != nil </span><span class="cov1" title="1">{
                log.Error().Msgf("failed to unmarshal file: %s", err)
                return err
        }</span>

        <span class="cov3" title="2">summary := &amp;remediation.Summary{
                SelectedRemediationNumber:   0,
                ActualRemediationDoneNumber: 0,
        }

        // get all the remediationSets related to each filePath
        remediationSets := summary.GetRemediationSets(results, include)

        for filePath := range remediationSets </span><span class="cov3" title="2">{
                fix := remediationSets[filePath].(remediation.Set)
                err = summary.RemediateFile(filePath, fix)
                if err != nil </span><span class="cov0" title="0">{
                        return err
                }</span>
        }

        <span class="cov3" title="2">fmt.Printf("\nSelected remediation: %d\n", summary.SelectedRemediationNumber)
        fmt.Printf("Remediation done: %d\n", summary.ActualRemediationDoneNumber)

        exitCode := consoleHelpers.RemediateExitCode(summary.SelectedRemediationNumber, summary.ActualRemediationDoneNumber)
        if exitCode != 0 </span><span class="cov0" title="0">{
                os.Exit(exitCode)
        }</span>

        <span class="cov3" title="2">return nil</span>
}
</pre>
		
		<pre class="file" id="file12" style="display: none">package console

import (
        _ "embed" // Embed kics CLI img and scan-flags
        "os"
        "os/signal"
        "path/filepath"
        "strings"
        "syscall"

        "github.com/Checkmarx/kics/internal/console/flags"
        consoleHelpers "github.com/Checkmarx/kics/internal/console/helpers"
        "github.com/Checkmarx/kics/internal/constants"
        sentryReport "github.com/Checkmarx/kics/internal/sentry"
        "github.com/Checkmarx/kics/pkg/engine/source"
        "github.com/Checkmarx/kics/pkg/scan"
        "github.com/rs/zerolog/log"
        "github.com/spf13/cobra"
)

var (
        //go:embed assets/kics-console
        banner string

        //go:embed assets/scan-flags.json
        scanFlagsListContent string
)

const (
        scanCommandStr = "scan"
        initError      = "initialization error - "
)

// NewScanCmd creates a new instance of the scan Command
func NewScanCmd() *cobra.Command <span class="cov8" title="18">{
        return &amp;cobra.Command{
                Use:   scanCommandStr,
                Short: "Executes a scan analysis",
                PersistentPreRunE: func(cmd *cobra.Command, args []string) error </span><span class="cov6" title="8">{
                        return preRun(cmd)
                }</span>,
                RunE: func(cmd *cobra.Command, args []string) error <span class="cov6" title="7">{
                        return run(cmd)
                }</span>,
        }
}

func initScanCmd(scanCmd *cobra.Command) error <span class="cov8" title="18">{
        if err := flags.InitJSONFlags(
                scanCmd,
                scanFlagsListContent,
                false,
                source.ListSupportedPlatforms(),
                source.ListSupportedCloudProviders()); err != nil </span><span class="cov0" title="0">{
                return err
        }</span>

        <span class="cov8" title="18">if err := scanCmd.MarkFlagRequired(flags.PathFlag); err != nil </span><span class="cov0" title="0">{
                sentryReport.ReportSentry(&amp;sentryReport.Report{
                        Message:  "Failed to add command required flags",
                        Err:      err,
                        Location: "func initScanCmd()",
                }, true)
                log.Err(err).Msg("Failed to add command required flags")
        }</span>
        <span class="cov8" title="18">return nil</span>
}

func run(cmd *cobra.Command) error <span class="cov6" title="7">{
        changedDefaultQueryPath := cmd.Flags().Lookup(flags.QueriesPath).Changed
        changedDefaultLibrariesPath := cmd.Flags().Lookup(flags.LibrariesPath).Changed
        if err := consoleHelpers.InitShouldIgnoreArg(flags.GetStrFlag(flags.IgnoreOnExitFlag)); err != nil </span><span class="cov0" title="0">{
                return err
        }</span>
        <span class="cov6" title="7">if err := consoleHelpers.InitShouldFailArg(flags.GetMultiStrFlag(flags.FailOnFlag)); err != nil </span><span class="cov0" title="0">{
                return err
        }</span>
        <span class="cov6" title="7">if flags.GetStrFlag(flags.OutputPathFlag) != "" </span><span class="cov1" title="1">{
                updateReportFormats()
                flags.SetStrFlag(flags.OutputNameFlag, filepath.Base(flags.GetStrFlag(flags.OutputNameFlag)))
                if filepath.Ext(flags.GetStrFlag(flags.OutputPathFlag)) != "" </span><span class="cov1" title="1">{
                        flags.SetStrFlag(flags.OutputPathFlag, filepath.Join(flags.GetStrFlag(flags.OutputPathFlag), string(os.PathSeparator)))
                }</span>
                <span class="cov1" title="1">if err := os.MkdirAll(flags.GetStrFlag(flags.OutputPathFlag), os.ModePerm); err != nil </span><span class="cov0" title="0">{
                        return err
                }</span>
        }
        <span class="cov6" title="7">if flags.GetStrFlag(flags.PayloadPathFlag) != "" &amp;&amp; filepath.Dir(flags.GetStrFlag(flags.PayloadPathFlag)) != "." </span><span class="cov0" title="0">{
                if err := os.MkdirAll(filepath.Dir(flags.GetStrFlag(flags.PayloadPathFlag)), os.ModePerm); err != nil </span><span class="cov0" title="0">{
                        return err
                }</span>
        }
        <span class="cov6" title="7">gracefulShutdown()

        // save the scan parameters into the ScanParameters struct
        scanParams := getScanParameters(changedDefaultQueryPath, changedDefaultLibrariesPath)

        return executeScan(scanParams)</span>
}

func updateReportFormats() <span class="cov1" title="1">{
        for _, format := range flags.GetMultiStrFlag(flags.ReportFormatsFlag) </span><span class="cov1" title="1">{
                if strings.EqualFold(format, "all") </span><span class="cov0" title="0">{
                        flags.SetMultiStrFlag(flags.ReportFormatsFlag, consoleHelpers.ListReportFormats())
                        break</span>
                }
        }
}

func getScanParameters(changedDefaultQueryPath, changedDefaultLibrariesPath bool) *scan.Parameters <span class="cov6" title="7">{
        scanParams := scan.Parameters{
                CloudProvider:               flags.GetMultiStrFlag(flags.CloudProviderFlag),
                DisableCISDesc:              flags.GetBoolFlag(flags.DisableCISDescFlag),
                DisableFullDesc:             flags.GetBoolFlag(flags.DisableFullDescFlag),
                ExcludeCategories:           flags.GetMultiStrFlag(flags.ExcludeCategoriesFlag),
                ExcludePaths:                flags.GetMultiStrFlag(flags.ExcludePathsFlag),
                ExcludeQueries:              flags.GetMultiStrFlag(flags.ExcludeQueriesFlag),
                ExcludeResults:              flags.GetMultiStrFlag(flags.ExcludeResultsFlag),
                ExcludeSeverities:           flags.GetMultiStrFlag(flags.ExcludeSeveritiesFlag),
                IncludeQueries:              flags.GetMultiStrFlag(flags.IncludeQueriesFlag),
                InputData:                   flags.GetStrFlag(flags.InputDataFlag),
                OutputName:                  flags.GetStrFlag(flags.OutputNameFlag),
                OutputPath:                  flags.GetStrFlag(flags.OutputPathFlag),
                Path:                        flags.GetMultiStrFlag(flags.PathFlag),
                PayloadPath:                 flags.GetStrFlag(flags.PayloadPathFlag),
                PreviewLines:                flags.GetIntFlag(flags.PreviewLinesFlag),
                QueriesPath:                 flags.GetMultiStrFlag(flags.QueriesPath),
                LibrariesPath:               flags.GetStrFlag(flags.LibrariesPath),
                ReportFormats:               flags.GetMultiStrFlag(flags.ReportFormatsFlag),
                Platform:                    flags.GetMultiStrFlag(flags.TypeFlag),
                QueryExecTimeout:            flags.GetIntFlag(flags.QueryExecTimeoutFlag),
                LineInfoPayload:             flags.GetBoolFlag(flags.LineInfoPayloadFlag),
                DisableSecrets:              flags.GetBoolFlag(flags.DisableSecretsFlag),
                SecretsRegexesPath:          flags.GetStrFlag(flags.SecretsRegexesPathFlag),
                ScanID:                      scanID,
                ChangedDefaultLibrariesPath: changedDefaultLibrariesPath,
                ChangedDefaultQueryPath:     changedDefaultQueryPath,
                BillOfMaterials:             flags.GetBoolFlag(flags.BomFlag),
                ExcludeGitIgnore:            flags.GetBoolFlag(flags.ExcludeGitIgnore),
        }

        return &amp;scanParams
}</span>

func executeScan(scanParams *scan.Parameters) error <span class="cov6" title="7">{
        log.Debug().Msg("console.scan()")

        for _, warn := range warnings </span><span class="cov10" title="30">{
                log.Warn().Msgf(warn)
        }</span>

        <span class="cov6" title="7">console := newConsole()

        console.preScan()

        client, err := scan.NewClient(scanParams, console.ProBarBuilder, console.Printer)

        if err != nil </span><span class="cov0" title="0">{
                log.Err(err)
                return err
        }</span>

        <span class="cov6" title="7">err = client.PerformScan(ctx)

        if err != nil </span><span class="cov0" title="0">{
                log.Err(err)
                return err
        }</span>

        <span class="cov6" title="7">return nil</span>
}

// gracefulShutdown catches signal interrupt and returns the appropriate exit code
func gracefulShutdown() <span class="cov6" title="7">{
        c := make(chan os.Signal)
        // This line should not be lint, since golangci-lint has an issue about it (https://github.com/golang/go/issues/45043)
        signal.Notify(c, os.Interrupt, syscall.SIGTERM) // nolint
        showErrors := consoleHelpers.ShowError("errors")
        interruptCode := constants.SignalInterruptCode
        go func(showErrors bool, interruptCode int) </span><span class="cov6" title="7">{
                &lt;-c
                if showErrors </span><span class="cov0" title="0">{
                        os.Exit(interruptCode)
                }</span>
        }(showErrors, interruptCode)
}
</pre>
		
		<pre class="file" id="file13" style="display: none">package console

import (
        "fmt"

        "github.com/Checkmarx/kics/internal/constants"
        "github.com/spf13/cobra"
)

// NewVersionCmd creates a new instance of the version Command
func NewVersionCmd() *cobra.Command <span class="cov10" title="18">{
        return &amp;cobra.Command{
                Use:   "version",
                Short: "Displays the current version",
                RunE: func(cmd *cobra.Command, args []string) error </span><span class="cov1" title="1">{
                        fmt.Fprintf(cmd.OutOrStdout(), "%s\n", constants.GetVersion())
                        return nil
                }</span>,
        }
}
</pre>
		
		<pre class="file" id="file14" style="display: none">package constants

import (
        "fmt"
        "math"
        "os"
        "path/filepath"
)

var (
        // Version - current KICS version
        Version = "development"
        // SCMCommit - Source control management commit identifier
        SCMCommit = "NOCOMMIT"
        // SentryDSN - sentry DSN, unset for disabling
        SentryDSN = ""
        // BaseURL - CIS descriptions endpoint URL
        BaseURL = ""
        // APIScanner - API scanner feature switch
        APIScanner = ""

        // AvailableCategories - All categories and its identifies
        AvailableCategories = map[string]string{
                "Access Control":          "CAT001",
                "Availability":            "CAT002",
                "Backup":                  "CAT003",
                "Best Practices":          "CAT004",
                "Build Process":           "CAT005",
                "Encryption":              "CAT006",
                "Insecure Configurations": "CAT007",
                "Insecure Defaults":       "CAT008",
                "Networking and Firewall": "CAT009",
                "Observability":           "CAT010",
                "Resource Management":     "CAT011",
                "Secret Management":       "CAT012",
                "Supply-Chain":            "CAT013",
                "Structure and Semantics": "CAT014",
                "Bill Of Materials":       "CAT015",
        }

        // AvailablePlatforms - All platforms available
        AvailablePlatforms = map[string]string{
                "Ansible":                 "ansible",
                "CloudFormation":          "cloudFormation",
                "Crossplane":              "crossplane",
                "Dockerfile":              "dockerfile",
                "DockerCompose":           "dockerCompose",
                "Knative":                 "knative",
                "Kubernetes":              "k8s",
                "OpenAPI":                 "openAPI",
                "Terraform":               "terraform",
                "AzureResourceManager":    "azureResourceManager",
                "GoogleDeploymentManager": "googleDeploymentManager",
                "GRPC":                    "grpc",
                "Buildah":                 "buildah",
                "Pulumi":                  "pulumi",
                "ServerlessFW":            "serverlessFW",
        }

        // AvailableSeverities - All severities available
        AvailableSeverities = []string{
                "high",
                "medium",
                "low",
                "info",
                "trace",
        }

        // AvailableLogLevels - All log levels available
        AvailableLogLevels = []string{
                "TRACE",
                "DEBUG",
                "INFO",
                "WARN",
                "ERROR",
                "FATAL",
        }

        // AvailableCloudProviders - All cloud providers available
        AvailableCloudProviders = map[string]string{
                "alicloud": "",
                "aws":      "",
                "azure":    "",
                "gcp":      "",
        }
)

const (
        // Fullname - KICS fullname
        Fullname = "Keeping Infrastructure as Code Secure"

        // URL - KICS url
        URL = "https://www.kics.io/"

        // DefaultLogFile - logfile name
        DefaultLogFile = "info.log"

        // DefaultConfigFilename - default configuration filename
        DefaultConfigFilename = "kics.config"

        // MinimumPreviewLines - default minimum preview lines number
        MinimumPreviewLines = 1

        // MaximumPreviewLines - default maximum preview lines number
        MaximumPreviewLines = 30

        // EngineErrorCode - Exit Status code for error in engine
        EngineErrorCode = 126

        // SignalInterruptCode - Exit Status code for a signal interrupt
        SignalInterruptCode = 130

        // MaxInteger - max possible integer in golang
        MaxInteger = math.MaxInt64

        // SentryRefreshRate - sentry crash report refresh rate
        SentryRefreshRate = 2

        // LogFormatJSON - print log as json
        LogFormatJSON = "json"

        // LogFormatPretty - print log more readable
        LogFormatPretty = "pretty"

        // MaxResolvedFiles - max files kics will resolve to prevent circular cycles
        MaxResolvedFiles = 50
)

// GetRelease - returns the current release in the format 'kics@version' to be used by sentry
func GetRelease() string <span class="cov8" title="1">{
        return fmt.Sprintf("kics@%s", Version)
}</span>

// GetVersion - returns the current version in the format 'Keeping Infrastructure as Code Secure &lt;version&gt;'
func GetVersion() string <span class="cov8" title="1">{
        return fmt.Sprintf("%s %s", Fullname, Version)
}</span>

// GetDefaultLogPath - returns the path where the default log file is located
func GetDefaultLogPath() (string, error) <span class="cov8" title="1">{
        currentWorkDir, err := os.Getwd()
        if err != nil </span><span class="cov0" title="0">{
                return "", err
        }</span>
        <span class="cov8" title="1">return filepath.Join(currentWorkDir, DefaultLogFile), nil</span>
}
</pre>
		
		<pre class="file" id="file15" style="display: none">package metrics

import (
        "bytes"
        "runtime/pprof"
        "time"

        "github.com/rs/zerolog/log"
)

type cpuMetric struct {
        close   func()
        writer  *bytes.Buffer
        idx     int
        typeMap map[string]float64
}

var cpuMap = map[string]float64{
        "ns":  float64(time.Nanosecond),
        "us":  float64(time.Microsecond),
        "ms":  float64(time.Millisecond),
        "s":   float64(time.Second),
        "hrs": float64(time.Hour),
}

func (c *cpuMetric) getDefault() string <span class="cov8" title="1">{
        return "ms"
}</span>

// Start - start gathering metrics for CPU usage
func (c *cpuMetric) start() <span class="cov8" title="1">{
        c.idx = 1
        c.typeMap = cpuMap

        c.writer = bytes.NewBuffer([]byte{})

        if err := pprof.StartCPUProfile(c.writer); err != nil </span><span class="cov0" title="0">{
                log.Error().Msgf("failed to write cpu profile")
        }</span>
        <span class="cov8" title="1">c.close = func() </span><span class="cov8" title="1">{
                pprof.StopCPUProfile()
        }</span>
}

// Stop - stop gathering metrics for CPU usage
func (c *cpuMetric) stop() <span class="cov8" title="1">{
        c.close()
}</span>

// getWriter returns the profile buffer
func (c *cpuMetric) getWriter() *bytes.Buffer <span class="cov8" title="1">{
        return c.writer
}</span>

// getIndex returns the cpu sample index
func (c *cpuMetric) getIndex() int <span class="cov8" title="1">{
        return c.idx
}</span>

// getMap returns the map used to format total value
func (c *cpuMetric) getMap() map[string]float64 <span class="cov8" title="1">{
        return c.typeMap
}</span>
</pre>
		
		<pre class="file" id="file16" style="display: none">package metrics

import (
        "bytes"
        "runtime"
        "runtime/pprof"

        "github.com/rs/zerolog/log"
)

type memMetric struct {
        close   func()
        writer  *bytes.Buffer
        idx     int
        typeMap map[string]float64
}

var (
        b  = 1
        kb = 10
        mb = 20
        gb = 30
        tb = 40
        pb = 50
)

var memoryMap = map[string]float64{
        "B":  float64(b),
        "kB": float64(b &lt;&lt; kb),
        "MB": float64(b &lt;&lt; mb),
        "GB": float64(b &lt;&lt; gb),
        "TB": float64(b &lt;&lt; tb),
        "PB": float64(b &lt;&lt; pb),
}

// Start - start gathering metrics for Memory usage
func (c *memMetric) start() <span class="cov8" title="1">{
        c.idx = 3
        c.typeMap = memoryMap

        old := runtime.MemProfileRate
        runtime.MemProfileRate = 4096 // set default memory rate

        c.writer = bytes.NewBuffer([]byte{})
        c.close = func() </span><span class="cov8" title="1">{
                if err := pprof.Lookup("heap").WriteTo(c.writer, 0); err != nil </span><span class="cov0" title="0">{
                        log.Error().Msgf("failed to write mem profile")
                }</span>

                <span class="cov8" title="1">runtime.MemProfileRate = old</span>
        }
}

func (c *memMetric) getDefault() string <span class="cov8" title="1">{
        return "B"
}</span>

// Stop - stop gathering metrics for Memory usage
func (c *memMetric) stop() <span class="cov8" title="1">{
        c.close()
}</span>

// getWriter returns the profile buffer
func (c *memMetric) getWriter() *bytes.Buffer <span class="cov8" title="1">{
        return c.writer
}</span>

// getIndex returns the memory sample index
func (c *memMetric) getIndex() int <span class="cov8" title="1">{
        return c.idx
}</span>

// getMap returns the map used to format total value
func (c *memMetric) getMap() map[string]float64 <span class="cov8" title="1">{
        return c.typeMap
}</span>
</pre>
		
		<pre class="file" id="file17" style="display: none">package metrics

import (
        "bytes"
        "fmt"
        "math"
        "strings"

        "github.com/google/pprof/profile"
        "github.com/rs/zerolog/log"
)

var (
        // Metric is the global metrics object
        Metric = &amp;Metrics{
                Disable: true,
        }
)

// Start - starts gathering metrics based on the type of metrics and writes metrics to string
// Stop - stops gathering metrics for the type of metrics specified
type metricType interface {
        start()
        stop()
        getWriter() *bytes.Buffer
        getIndex() int
        getMap() map[string]float64
        getDefault() string
}

// Metrics - structure to keep information relevant to the metrics calculation
// Disable - disables metric calculations
type Metrics struct {
        metric    metricType
        metricsID string
        location  string
        Disable   bool
        total     int64
        ci        bool
}

// InitializeMetrics - creates a new instance of a Metrics based on the type of metrics specified
func InitializeMetrics(metric string, ci bool) error <span class="cov5" title="7">{
        var err error
        switch strings.ToLower(metric) </span>{
        case "cpu":<span class="cov2" title="2">
                Metric.Disable = false
                Metric.metric = &amp;cpuMetric{}
                Metric.total = 0</span>
        case "mem":<span class="cov2" title="2">
                Metric.total = 0
                Metric.metric = &amp;memMetric{}
                Metric.Disable = false</span>
        case "":<span class="cov2" title="2">
                Metric.total = 0
                Metric.Disable = true</span>
        default:<span class="cov1" title="1">
                Metric.total = 0
                Metric.Disable = true
                err = fmt.Errorf("unknonwn metric: %s (available metrics: CPU, MEM)", metric)</span>
        }

        // Create temporary dir to keep pprof file
        <span class="cov5" title="7">if !Metric.Disable </span><span class="cov4" title="4">{
                Metric.metricsID = metric
                Metric.ci = ci
        }</span>

        <span class="cov5" title="7">return err</span>
}

// Start - starts gathering metrics for the location specified
func (m *Metrics) Start(location string) <span class="cov3" title="3">{
        if m.Disable </span><span class="cov1" title="1">{
                return
        }</span>

        <span class="cov2" title="2">log.Debug().Msgf("Started %s profiling for %s", m.metricsID, location)

        m.location = location
        m.metric.start()</span>
}

// Stop - stops gathering metrics and logs the result
func (m *Metrics) Stop() <span class="cov3" title="3">{
        if m.Disable </span><span class="cov1" title="1">{
                return
        }</span>
        <span class="cov2" title="2">log.Debug().Msgf("Stopped %s profiling for %s", m.metricsID, m.location)

        m.metric.stop()

        p, err := profile.Parse(m.metric.getWriter())
        if err != nil </span><span class="cov0" title="0">{
                log.Error().Msgf("failed to parse profile on %s: %s", m.location, err)
        }</span>

        <span class="cov2" title="2">if err := p.CheckValid(); err != nil </span><span class="cov0" title="0">{
                log.Error().Msgf("invalid profile on %s: %s", m.location, err)
        }</span>

        <span class="cov2" title="2">total := getTotal(p, m.metric.getIndex())
        log.Info().
                Msgf("Total %s usage for %s: %s", strings.ToUpper(m.metricsID),
                        m.location, m.formatTotal(total, m.metric.getMap(), m.metric.getDefault()))
        m.total = total</span>
}

// getTotal goes through the profile samples summing their values according to
// the type of profile
func getTotal(prof *profile.Profile, idx int) int64 <span class="cov2" title="2">{
        var total, diffTotal int64
        for _, sample := range prof.Sample </span><span class="cov9" title="36">{
                var v int64
                v = sample.Value[idx]
                if v &lt; 0 </span><span class="cov0" title="0">{
                        v = -v
                }</span>
                <span class="cov9" title="36">total += v
                if sample.DiffBaseSample() </span><span class="cov0" title="0">{
                        diffTotal += v
                }</span>
        }
        <span class="cov2" title="2">if diffTotal &gt; 0 </span><span class="cov0" title="0">{
                total = diffTotal
        }</span>

        <span class="cov2" title="2">return total</span>
}

// formatTotal parses total value into a human readble way
func (m *Metrics) formatTotal(b int64, typeMap map[string]float64, defaultMetric string) string <span class="cov6" title="11">{
        value := float64(b)
        var formatter float64
        var mesure string
        if m.ci </span><span class="cov1" title="1">{
                metric := value / typeMap[defaultMetric]
                if math.IsNaN(metric) </span><span class="cov0" title="0">{
                        metric = 0
                }</span>
                <span class="cov1" title="1">return fmt.Sprintf("%.f%s", metric, defaultMetric)</span>
        }
        <span class="cov6" title="10">for k, u := range typeMap </span><span class="cov10" title="55">{
                if u &gt;= formatter &amp;&amp; (value/u) &gt;= 1.0 </span><span class="cov7" title="17">{
                        formatter = u
                        mesure = k
                }</span>
        }

        <span class="cov6" title="10">metric := value / formatter
        if math.IsNaN(metric) </span><span class="cov2" title="2">{
                metric = 0
        }</span>

        <span class="cov6" title="10">return fmt.Sprintf("%.2f%s", metric, mesure)</span>
}
</pre>
		
		<pre class="file" id="file18" style="display: none">package storage

import (
        "context"
        "fmt"
        "sync"

        "github.com/Checkmarx/kics/pkg/model"
        "github.com/rs/zerolog/log"
)

var (
        memoryMu sync.Mutex
)

// MemoryStorage is scans' results representation
type MemoryStorage struct {
        vulnerabilities []model.Vulnerability
        allFiles        model.FileMetadatas
}

// SaveFile adds a new file metadata to files collection
func (m *MemoryStorage) SaveFile(_ context.Context, metadata *model.FileMetadata) error <span class="cov8" title="1">{
        m.allFiles = append(m.allFiles, *metadata)
        return nil
}</span>

// GetFiles returns a collection of files saved on MemoryStorage
func (m *MemoryStorage) GetFiles(_ context.Context, _ string) (model.FileMetadatas, error) <span class="cov8" title="1">{
        return m.allFiles, nil
}</span>

// SaveVulnerabilities adds a list of vulnerabilities to vulnerabilities collection
func (m *MemoryStorage) SaveVulnerabilities(_ context.Context, vulnerabilities []model.Vulnerability) error <span class="cov8" title="1">{
        defer memoryMu.Unlock()
        memoryMu.Lock()
        m.vulnerabilities = append(m.vulnerabilities, vulnerabilities...)
        return nil
}</span>

// GetVulnerabilities returns a collection of vulnerabilities saved on MemoryStorage
func (m *MemoryStorage) GetVulnerabilities(_ context.Context, _ string) ([]model.Vulnerability, error) <span class="cov8" title="1">{
        return m.getUniqueVulnerabilities(), nil
}</span>

func (m *MemoryStorage) getUniqueVulnerabilities() []model.Vulnerability <span class="cov8" title="1">{
        vulnDictionary := make(map[string]model.Vulnerability)
        for i := range m.vulnerabilities </span><span class="cov8" title="1">{
                key := fmt.Sprintf("%s:%s:%d:%s:%s:%s",
                        m.vulnerabilities[i].QueryID,
                        m.vulnerabilities[i].FileName,
                        m.vulnerabilities[i].Line,
                        m.vulnerabilities[i].SimilarityID,
                        m.vulnerabilities[i].SearchKey,
                        m.vulnerabilities[i].KeyActualValue,
                )
                vulnDictionary[key] = m.vulnerabilities[i]
        }</span>

        <span class="cov8" title="1">var uniqueVulnerabilities []model.Vulnerability
        for key := range vulnDictionary </span><span class="cov8" title="1">{
                uniqueVulnerabilities = append(uniqueVulnerabilities, vulnDictionary[key])
        }</span>
        <span class="cov8" title="1">if len(uniqueVulnerabilities) == 0 </span><span class="cov0" title="0">{
                return m.vulnerabilities
        }</span>
        <span class="cov8" title="1">return uniqueVulnerabilities</span>
}

// GetScanSummary is not supported by MemoryStorage
func (m *MemoryStorage) GetScanSummary(_ context.Context, _ []string) ([]model.SeveritySummary, error) <span class="cov8" title="1">{
        return nil, nil
}</span>

// NewMemoryStorage creates a new MemoryStorage empty and returns it
func NewMemoryStorage() *MemoryStorage <span class="cov8" title="1">{
        log.Debug().Msg("storage.NewMemoryStorage()")
        return &amp;MemoryStorage{
                allFiles:        make(model.FileMetadatas, 0),
                vulnerabilities: make([]model.Vulnerability, 0),
        }
}</span>
</pre>
		
		<pre class="file" id="file19" style="display: none">package tracker

import (
        "fmt"
        "sync"

        "github.com/Checkmarx/kics/internal/constants"
        "github.com/Checkmarx/kics/pkg/model"
)

// CITracker contains information of how many queries were loaded and executed
// and how many files were found and executed

var (
        trackerMu sync.Mutex
)

type CITracker struct {
        ExecutingQueries   int
        ExecutedQueries    int
        FoundFiles         int
        FailedSimilarityID int
        LoadedQueries      int
        ParsedFiles        int
        ScanSecrets        int
        ScanPaths          int
        lines              int
        FoundCountLines    int
        ParsedCountLines   int
        Version            model.Version
}

// NewTracker will create a new instance of a tracker with the number of lines to display in results output
// number of lines can not be smaller than 1
func NewTracker(previewLines int) (*CITracker, error) <span class="cov10" title="2">{
        if previewLines &lt; constants.MinimumPreviewLines || previewLines &gt; constants.MaximumPreviewLines </span><span class="cov1" title="1">{
                return &amp;CITracker{},
                        fmt.Errorf("output lines minimum is %v and maximum is %v", constants.MinimumPreviewLines, constants.MaximumPreviewLines)
        }</span>
        <span class="cov1" title="1">return &amp;CITracker{
                lines: previewLines,
        }, nil</span>
}

// GetOutputLines returns the number of lines to display in results output
func (c *CITracker) GetOutputLines() int <span class="cov1" title="1">{
        return c.lines
}</span>

// TrackQueryLoad adds a loaded query
func (c *CITracker) TrackQueryLoad(queryAggregation int) <span class="cov1" title="1">{
        c.LoadedQueries += queryAggregation
}</span>

// TrackQueryExecuting adds a executing queries
func (c *CITracker) TrackQueryExecuting(queryAggregation int) <span class="cov1" title="1">{
        c.ExecutingQueries += queryAggregation
}</span>

// TrackQueryExecution adds a query executed
func (c *CITracker) TrackQueryExecution(queryAggregation int) <span class="cov1" title="1">{
        trackerMu.Lock()
        defer trackerMu.Unlock()
        c.ExecutedQueries += queryAggregation
}</span>

// TrackFileFound adds a found file to be scanned
func (c *CITracker) TrackFileFound() <span class="cov1" title="1">{
        c.FoundFiles++
}</span>

// TrackFileParse adds a successful parsed file to be scanned
func (c *CITracker) TrackFileParse() <span class="cov1" title="1">{
        c.ParsedFiles++
}</span>

// FailedDetectLine - queries that fail to detect line are counted as failed to execute queries
func (c *CITracker) FailedDetectLine() <span class="cov1" title="1">{
        c.ExecutedQueries--
}</span>

// FailedComputeSimilarityID - queries that failed to compute similarity ID
func (c *CITracker) FailedComputeSimilarityID() <span class="cov1" title="1">{
        c.FailedSimilarityID++
}</span>

// TrackScanSecret - add to secrets scanned
func (c *CITracker) TrackScanSecret() <span class="cov1" title="1">{
        c.ScanSecrets++
}</span>

// TrackScanPath - paths to preform scan
func (c *CITracker) TrackScanPath() <span class="cov1" title="1">{
        c.ScanPaths++
}</span>

// TrackVersion - information if current version is latest
func (c *CITracker) TrackVersion(retrievedVersion model.Version) <span class="cov1" title="1">{
        c.Version = retrievedVersion
}</span>

// TrackFileFoundCountLines - information about the lines of the scanned files
func (c *CITracker) TrackFileFoundCountLines(countLines int) <span class="cov1" title="1">{
        c.FoundCountLines += countLines
}</span>

// TrackFileParseCountLines - information about the lines of the parsed files
func (c *CITracker) TrackFileParseCountLines(countLines int) <span class="cov1" title="1">{
        c.ParsedCountLines += countLines
}</span>
</pre>
		
		<pre class="file" id="file20" style="display: none">package analyzer

import (
        "os"
        "path/filepath"
        "regexp"
        "sort"
        "strings"
        "sync"

        "github.com/Checkmarx/kics/internal/metrics"
        "github.com/Checkmarx/kics/pkg/engine/provider"
        "github.com/Checkmarx/kics/pkg/model"
        "github.com/Checkmarx/kics/pkg/utils"
        "github.com/pkg/errors"
        "github.com/rs/zerolog/log"
        ignore "github.com/sabhiram/go-gitignore"

        yamlParser "gopkg.in/yaml.v3"
)

// openAPIRegex - Regex that finds OpenAPI defining property "openapi" or "swagger"
// openAPIRegexInfo - Regex that finds OpenAPI defining property "info"
// openAPIRegexPath - Regex that finds OpenAPI defining property "paths", "components", or "webhooks" (from 3.1.0)
// cloudRegex - Regex that finds CloudFormation defining property "Resources"
// k8sRegex - Regex that finds Kubernetes defining property "apiVersion"
// k8sRegexKind - Regex that finds Kubernetes defining property "kind"
// k8sRegexMetadata - Regex that finds Kubernetes defining property "metadata"
// k8sRegexSpec - Regex that finds Kubernetes defining property "spec"
var (
        openAPIRegex                                    = regexp.MustCompile("\\s*\"?(openapi|swagger)\"?\\s*:")
        openAPIRegexInfo                                = regexp.MustCompile("\\s*\"?info\"?\\s*:")
        openAPIRegexPath                                = regexp.MustCompile("\\s*\"?(paths|components|webhooks)\"?\\s*:")
        armRegexContentVersion                          = regexp.MustCompile("\\s*\"contentVersion\"\\s*:")
        armRegexResources                               = regexp.MustCompile("\\s*\"resources\"\\s*:")
        cloudRegex                                      = regexp.MustCompile("\\s*\"?Resources\"?\\s*:")
        k8sRegex                                        = regexp.MustCompile("\\s*\"?apiVersion\"?\\s*:")
        k8sRegexKind                                    = regexp.MustCompile("\\s*\"?kind\"?\\s*:")
        ansibleVaultRegex                               = regexp.MustCompile(`^\s*\$ANSIBLE_VAULT.*`)
        tfPlanRegexPV                                   = regexp.MustCompile("\\s*\"planned_values\"\\s*:")
        tfPlanRegexRC                                   = regexp.MustCompile("\\s*\"resource_changes\"\\s*:")
        tfPlanRegexConf                                 = regexp.MustCompile("\\s*\"configuration\"\\s*:")
        tfPlanRegexTV                                   = regexp.MustCompile("\\s*\"terraform_version\"\\s*:")
        cdkTfRegexMetadata                              = regexp.MustCompile("\\s*\"metadata\"\\s*:")
        cdkTfRegexStackName                             = regexp.MustCompile("\\s*\"stackName\"\\s*:")
        cdkTfRegexTerraform                             = regexp.MustCompile("\\s*\"terraform\"\\s*:")
        artifactsRegexKind                              = regexp.MustCompile("\\s*\"?kind\"?\\s*:")
        artifactsRegexProperties                        = regexp.MustCompile("\\s*\"?properties\"?\\s*:")
        artifactsRegexParametes                         = regexp.MustCompile("\\s*\"?parameters\"?\\s*:")
        policyAssignmentArtifactRegexPolicyDefinitionID = regexp.MustCompile("\\s*\"?policyDefinitionId\"?\\s*:")
        roleAssignmentArtifactRegexPrincipalIds         = regexp.MustCompile("\\s*\"?principalIds\"?\\s*:")
        roleAssignmentArtifactRegexRoleDefinitionID     = regexp.MustCompile("\\s*\"?roleDefinitionId\"?\\s*:")
        templateArtifactRegexParametes                  = regexp.MustCompile("\\s*\"?template\"?\\s*:")
        blueprintpRegexTargetScope                      = regexp.MustCompile("\\s*\"?targetScope\"?\\s*:")
        blueprintpRegexProperties                       = regexp.MustCompile("\\s*\"?properties\"?\\s*:")
        buildahRegex                                    = regexp.MustCompile(`\s*buildah\s*from\s*\w+`)
        dockerComposeVersionRegex                       = regexp.MustCompile(`\s*version\s*:`)
        dockerComposeServicesRegex                      = regexp.MustCompile(`\s*services\s*:`)
        crossPlaneRegex                                 = regexp.MustCompile(`\s*\"?apiVersion\"?\s*:\s*(\w+\.)+crossplane\.io/v\w+\s*`)
        knativeRegex                                    = regexp.MustCompile(`\s*\"?apiVersion\"?\s*:\s*(\w+\.)+knative\.dev/v\w+\s*`)
        pulumiNameRegex                                 = regexp.MustCompile(`\s*name\s*:`)
        pulumiRuntimeRegex                              = regexp.MustCompile(`\s*runtime\s*:`)
        pulumiResourcesRegex                            = regexp.MustCompile(`\s*resources\s*:`)
        serverlessServiceRegex                          = regexp.MustCompile(`\s*service\s*:`)
        serverlessProviderRegex                         = regexp.MustCompile(`\s*provider\s*:`)
)

var (
        listKeywordsGoogleDeployment = []string{"resources"}
        armRegexTypes                = []string{"blueprint", "templateArtifact", "roleAssignmentArtifact", "policyAssignmentArtifact"}
        possibleFileTypes            = map[string]bool{
                ".yml":               true,
                ".yaml":              true,
                ".json":              true,
                ".dockerfile":        true,
                "Dockerfile":         true,
                "possibleDockerfile": true,
                ".debian":            true,
                ".ubi8":              true,
                ".tf":                true,
                "tfvars":             true,
                ".proto":             true,
                ".sh":                true,
        }
        supportedRegexes = map[string][]string{
                "azureresourcemanager": append(armRegexTypes, arm),
                "buildah":              {"buildah"},
                "cloudformation":       {"cloudformation"},
                "crossplane":           {"crossplane"},
                "dockercompose":        {"dockercompose"},
                "knative":              {"knative"},
                "kubernetes":           {"kubernetes"},
                "openapi":              {"openapi"},
                "terraform":            {"terraform", "cdkTf"},
                "pulumi":               {"pulumi"},
                "serverlessfw":         {"serverlessfw"},
        }
)

const (
        yml        = ".yml"
        yaml       = ".yaml"
        json       = ".json"
        sh         = ".sh"
        arm        = "azureresourcemanager"
        kubernetes = "kubernetes"
        terraform  = "terraform"
        gdm        = "googledeploymentmanager"
        ansible    = "ansible"
        grpc       = "grpc"
        dockerfile = "dockerfile"
        crossplane = "crossplane"
        knative    = "knative"
)

// regexSlice is a struct to contain a slice of regex
type regexSlice struct {
        regex []*regexp.Regexp
}

type analyzerInfo struct {
        typesFlag []string
        filePath  string
}

// Analyzer keeps all the relevant info for the function Analyze
type Analyzer struct {
        Paths             []string
        Types             []string
        Exc               []string
        GitIgnoreFileName string
        ExcludeGitIgnore  bool
}

// types is a map that contains the regex by type
var types = map[string]regexSlice{
        "openapi": {
                regex: []*regexp.Regexp{
                        openAPIRegex,
                        openAPIRegexInfo,
                        openAPIRegexPath,
                },
        },
        "kubernetes": {
                regex: []*regexp.Regexp{
                        k8sRegex,
                        k8sRegexKind,
                },
        },
        "crossplane": {
                regex: []*regexp.Regexp{
                        crossPlaneRegex,
                        k8sRegexKind,
                },
        },
        "knative": {
                regex: []*regexp.Regexp{
                        knativeRegex,
                        k8sRegexKind,
                },
        },
        "cloudformation": {
                regex: []*regexp.Regexp{
                        cloudRegex,
                },
        },
        "azureresourcemanager": {
                []*regexp.Regexp{
                        armRegexContentVersion,
                        armRegexResources,
                },
        },
        "terraform": {
                []*regexp.Regexp{
                        tfPlanRegexConf,
                        tfPlanRegexPV,
                        tfPlanRegexRC,
                        tfPlanRegexTV,
                },
        },
        "cdkTf": {
                []*regexp.Regexp{
                        cdkTfRegexMetadata,
                        cdkTfRegexStackName,
                        cdkTfRegexTerraform,
                },
        },
        "policyAssignmentArtifact": {
                []*regexp.Regexp{
                        artifactsRegexKind,
                        artifactsRegexProperties,
                        artifactsRegexParametes,
                        policyAssignmentArtifactRegexPolicyDefinitionID,
                },
        },
        "roleAssignmentArtifact": {
                []*regexp.Regexp{
                        artifactsRegexKind,
                        artifactsRegexProperties,
                        roleAssignmentArtifactRegexPrincipalIds,
                        roleAssignmentArtifactRegexRoleDefinitionID,
                },
        },
        "templateArtifact": {
                []*regexp.Regexp{
                        artifactsRegexKind,
                        artifactsRegexProperties,
                        artifactsRegexParametes,
                        templateArtifactRegexParametes,
                },
        },
        "blueprint": {
                []*regexp.Regexp{
                        blueprintpRegexTargetScope,
                        blueprintpRegexProperties,
                },
        },
        "buildah": {
                []*regexp.Regexp{
                        buildahRegex,
                },
        },
        "dockercompose": {
                []*regexp.Regexp{
                        dockerComposeVersionRegex,
                        dockerComposeServicesRegex,
                },
        },
        "pulumi": {
                []*regexp.Regexp{
                        pulumiNameRegex,
                        pulumiRuntimeRegex,
                        pulumiResourcesRegex,
                },
        },
        "serverlessfw": {
                []*regexp.Regexp{
                        serverlessServiceRegex,
                        serverlessProviderRegex,
                },
        },
}

// Analyze will go through the slice paths given and determine what type of queries should be loaded
// should be loaded based on the extension of the file and the content
func Analyze(a *Analyzer) (model.AnalyzedPaths, error) <span class="cov4" title="11">{
        // start metrics for file analyzer
        metrics.Metric.Start("file_type_analyzer")
        returnAnalyzedPaths := model.AnalyzedPaths{
                Types: make([]string, 0),
                Exc:   make([]string, 0),
        }

        var files []string
        var wg sync.WaitGroup
        // results is the channel shared by the workers that contains the types found
        results := make(chan string)
        ignoreFiles := make([]string, 0)
        hasGitIgnoreFile, gitIgnore := shouldConsiderGitIgnoreFile(a.Paths[0], a.GitIgnoreFileName, a.ExcludeGitIgnore)

        // get all the files inside the given paths
        for _, path := range a.Paths </span><span class="cov4" title="12">{
                if _, err := os.Stat(path); err != nil </span><span class="cov1" title="1">{
                        return returnAnalyzedPaths, errors.Wrap(err, "failed to analyze path")
                }</span>
                <span class="cov4" title="11">if err := filepath.Walk(path, func(path string, info os.FileInfo, err error) error </span><span class="cov6" title="53">{
                        if err != nil </span><span class="cov0" title="0">{
                                return err
                        }</span>

                        <span class="cov6" title="53">ext := utils.GetExtension(path)

                        if hasGitIgnoreFile &amp;&amp; gitIgnore.MatchesPath(path) </span><span class="cov1" title="2">{
                                ignoreFiles = append(ignoreFiles, path)
                                a.Exc = append(a.Exc, path)
                        }</span>

                        <span class="cov6" title="53">if _, ok := possibleFileTypes[ext]; ok &amp;&amp; !isExcludedFile(path, a.Exc) </span><span class="cov6" title="35">{
                                files = append(files, path)
                        }</span>

                        <span class="cov6" title="53">return nil</span>
                }); err != nil <span class="cov0" title="0">{
                        log.Error().Msgf("failed to analize path %s: %s", path, err)
                }</span>
        }

        // unwanted is the channel shared by the workers that contains the unwanted files that the parser will ignore
        <span class="cov4" title="10">unwanted := make(chan string, len(files))

        for i := range a.Types </span><span class="cov4" title="10">{
                a.Types[i] = strings.ToLower(a.Types[i])
        }</span>

        <span class="cov4" title="10">for _, file := range files </span><span class="cov6" title="35">{
                wg.Add(1)
                // analyze the files concurrently
                a := &amp;analyzerInfo{
                        typesFlag: a.Types,
                        filePath:  file,
                }
                go a.worker(results, unwanted, &amp;wg)
        }</span>

        <span class="cov4" title="10">go func() </span><span class="cov4" title="10">{
                // close channel results when the worker has finished writing into it
                defer func() </span><span class="cov4" title="10">{
                        close(unwanted)
                        close(results)
                }</span>()
                <span class="cov4" title="10">wg.Wait()</span>
        }()

        <span class="cov4" title="10">availableTypes := createSlice(results)
        multiPlatformTypeCheck(&amp;availableTypes)
        unwantedPaths := createSlice(unwanted)
        unwantedPaths = append(unwantedPaths, ignoreFiles...)
        returnAnalyzedPaths.Types = availableTypes
        returnAnalyzedPaths.Exc = unwantedPaths
        // stop metrics for file analyzer
        metrics.Metric.Stop()
        return returnAnalyzedPaths, nil</span>
}

// worker determines the type of the file by ext (dockerfile and terraform)/content and
// writes the answer to the results channel
// if no types were found, the worker will write the path of the file in the unwanted channel
func (a *analyzerInfo) worker(results, unwanted chan&lt;- string, wg *sync.WaitGroup) <span class="cov6" title="35">{
        defer wg.Done()

        ext := utils.GetExtension(a.filePath)

        typesFlag := a.typesFlag

        switch ext </span>{
        // Dockerfile (direct identification)
        case ".dockerfile", "Dockerfile":<span class="cov2" title="3">
                if typesFlag[0] == "" || utils.Contains(dockerfile, typesFlag) </span><span class="cov2" title="3">{
                        results &lt;- dockerfile
                }</span>
        // Dockerfile (indirect identification)
        case "possibleDockerfile", ".ubi8", ".debian":<span class="cov1" title="2">
                if (typesFlag[0] == "" || utils.Contains(dockerfile, typesFlag)) &amp;&amp; isDockerfile(a.filePath) </span><span class="cov0" title="0">{
                        results &lt;- dockerfile
                }</span> else<span class="cov1" title="2"> {
                        unwanted &lt;- a.filePath
                }</span>
        // Terraform
        case ".tf", "tfvars":<span class="cov2" title="3">
                if typesFlag[0] == "" || utils.Contains(terraform, typesFlag) </span><span class="cov2" title="3">{
                        results &lt;- terraform
                }</span>
        // GRPC
        case ".proto":<span class="cov0" title="0">
                if typesFlag[0] == "" || utils.Contains(grpc, typesFlag) </span><span class="cov0" title="0">{
                        results &lt;- grpc
                }</span>
        // Cloud Formation, Ansible, OpenAPI, Buildah
        case yaml, yml, json, sh:<span class="cov5" title="27">
                a.checkContent(results, unwanted, ext)</span>
        }
}

func isDockerfile(path string) bool <span class="cov1" title="2">{
        content, err := os.ReadFile(filepath.Clean(path))
        if err != nil </span><span class="cov0" title="0">{
                log.Error().Msgf("failed to analyze file: %s", err)
                return false
        }</span>

        <span class="cov1" title="2">regexes := []*regexp.Regexp{
                regexp.MustCompile(`\s*FROM\s*`),
                regexp.MustCompile(`\s*RUN\s*`),
        }

        check := true

        for _, regex := range regexes </span><span class="cov1" title="2">{
                if !regex.Match(content) </span><span class="cov1" title="2">{
                        check = false
                        break</span>
                }
        }

        <span class="cov1" title="2">return check</span>
}

// overrides k8s match when all regexs passes for azureresourcemanager key and extension is set to json
func needsOverride(check bool, returnType, key, ext string) bool <span class="cov9" title="412">{
        if check &amp;&amp; returnType == kubernetes &amp;&amp; key == arm &amp;&amp; ext == json </span><span class="cov0" title="0">{
                return true
        }</span> else<span class="cov9" title="412"> if check &amp;&amp; returnType == kubernetes &amp;&amp; (key == knative || key == crossplane) &amp;&amp; ext == yaml </span><span class="cov2" title="3">{
                return true
        }</span>
        <span class="cov9" title="409">return false</span>
}

// checkContent will determine the file type by content when worker was unable to
// determine by ext, if no type was determined checkContent adds it to unwanted channel
func (a *analyzerInfo) checkContent(results, unwanted chan&lt;- string, ext string) <span class="cov5" title="27">{
        typesFlag := a.typesFlag
        // get file content
        content, err := os.ReadFile(a.filePath)
        if err != nil </span><span class="cov0" title="0">{
                log.Error().Msgf("failed to analyze file: %s", err)
                return
        }</span>

        <span class="cov5" title="27">returnType := ""

        // Sort map so that CloudFormation (type that as less requireds) goes last
        keys := make([]string, 0, len(types))
        for k := range types </span><span class="cov9" title="432">{
                keys = append(keys, k)
        }</span>

        <span class="cov5" title="27">if typesFlag[0] != "" </span><span class="cov0" title="0">{
                keys = getKeysFromTypesFlag(typesFlag)
        }</span>

        <span class="cov5" title="27">sort.Sort(sort.Reverse(sort.StringSlice(keys)))

        for _, key := range keys </span><span class="cov9" title="432">{
                check := true
                for _, typeRegex := range types[key].regex </span><span class="cov10" title="513">{
                        if !typeRegex.Match(content) </span><span class="cov9" title="405">{
                                check = false
                                break</span>
                        }
                }
                // If all regexs passed and there wasn't a type already assigned
                <span class="cov9" title="432">if check &amp;&amp; returnType == "" </span><span class="cov5" title="20">{
                        returnType = key
                }</span> else<span class="cov9" title="412"> if needsOverride(check, returnType, key, ext) </span><span class="cov2" title="3">{
                        returnType = key
                }</span>
        }
        <span class="cov5" title="27">returnType = checkReturnType(a.filePath, returnType, ext, content)
        if returnType != "" </span><span class="cov5" title="26">{
                if typesFlag[0] == "" || utils.Contains(returnType, typesFlag) </span><span class="cov5" title="26">{
                        results &lt;- returnType
                        return
                }</span>
        }
        // No type was determined (ignore on parser)
        <span class="cov1" title="1">unwanted &lt;- a.filePath</span>
}

func checkReturnType(path, returnType, ext string, content []byte) string <span class="cov5" title="27">{
        if returnType != "" </span><span class="cov5" title="20">{
                if returnType == "cdkTf" </span><span class="cov0" title="0">{
                        return terraform
                }</span>
                <span class="cov5" title="20">if utils.Contains(returnType, armRegexTypes) </span><span class="cov0" title="0">{
                        return arm
                }</span>
        } else<span class="cov3" title="7"> if ext == yaml || ext == yml </span><span class="cov3" title="6">{
                if checkHelm(path) </span><span class="cov2" title="4">{
                        return kubernetes
                }</span>
                <span class="cov1" title="2">platform := checkYamlPlatform(content, path)
                if platform != "" </span><span class="cov1" title="2">{
                        return platform
                }</span>
        }
        <span class="cov5" title="21">return returnType</span>
}

func checkHelm(path string) bool <span class="cov3" title="6">{
        _, err := os.Stat(filepath.Join(filepath.Dir(path), "Chart.yaml"))
        if errors.Is(err, os.ErrNotExist) </span><span class="cov1" title="2">{
                return false
        }</span> else<span class="cov2" title="4"> if err != nil </span><span class="cov0" title="0">{
                log.Error().Msgf("failed to check helm: %s", err)
        }</span>

        <span class="cov2" title="4">return true</span>
}

func checkYamlPlatform(content []byte, path string) string <span class="cov1" title="2">{
        content = utils.DecryptAnsibleVault(content, os.Getenv("ANSIBLE_VAULT_PASSWORD_FILE"))

        var yamlContent model.Document
        if err := yamlParser.Unmarshal(content, &amp;yamlContent); err != nil </span><span class="cov0" title="0">{
                log.Warn().Msgf("failed to parse yaml file (%s): %s", path, err)
        }</span>
        // check if it is google deployment manager platform
        <span class="cov1" title="2">for _, keyword := range listKeywordsGoogleDeployment </span><span class="cov1" title="2">{
                if _, ok := yamlContent[keyword]; ok </span><span class="cov1" title="1">{
                        return gdm
                }</span>
        }
        // check if it is an ansible vault
        <span class="cov1" title="1">if !ansibleVaultRegex.Match(content) </span><span class="cov1" title="1">{
                // Since Ansible has no defining property
                // and no other type matched for YAML file extension, assume the file type is Ansible
                return ansible
        }</span>
        <span class="cov0" title="0">return ""</span>
}

// createSlice creates a slice from the channel given removing any duplicates
func createSlice(chanel chan string) []string <span class="cov5" title="20">{
        slice := make([]string, 0)
        for i := range chanel </span><span class="cov6" title="35">{
                if !utils.Contains(i, slice) </span><span class="cov5" title="27">{
                        slice = append(slice, i)
                }</span>
        }
        <span class="cov5" title="20">return slice</span>
}

// getKeysFromTypesFlag gets all the regexes keys related to the types flag
func getKeysFromTypesFlag(typesFlag []string) []string <span class="cov0" title="0">{
        ks := make([]string, 0, len(types))
        for i := range typesFlag </span><span class="cov0" title="0">{
                t := typesFlag[i]

                if regexes, ok := supportedRegexes[t]; ok </span><span class="cov0" title="0">{
                        ks = append(ks, regexes...)
                }</span>
        }
        <span class="cov0" title="0">return ks</span>
}

// isExcludedFile verifies if the path is pointed in the --exclude-paths flag
func isExcludedFile(path string, exc []string) bool <span class="cov6" title="37">{
        for i := range exc </span><span class="cov6" title="41">{
                exclude, err := provider.GetExcludePaths(exc[i])
                if err != nil </span><span class="cov0" title="0">{
                        log.Err(err).Msg("failed to get exclude paths")
                }</span>
                <span class="cov6" title="41">for j := range exclude </span><span class="cov6" title="41">{
                        if exclude[j] == path </span><span class="cov1" title="2">{
                                log.Info().Msgf("Excluded file %s from analyzer", path)
                                return true
                        }</span>
                }
        }
        <span class="cov6" title="35">return false</span>
}

// shouldConsiderGitIgnoreFile verifies if the scan should exclude the files according to the .gitignore file
func shouldConsiderGitIgnoreFile(path, gitIgnore string, excludeGitIgnoreFile bool) (bool, *ignore.GitIgnore) <span class="cov4" title="11">{
        gitIgnorePath := filepath.ToSlash(filepath.Join(path, gitIgnore))
        _, err := os.Stat(gitIgnorePath)

        if !excludeGitIgnoreFile &amp;&amp; err == nil </span><span class="cov4" title="9">{
                gitIgnore, _ := ignore.CompileIgnoreFile(gitIgnorePath)
                if gitIgnore != nil </span><span class="cov3" title="5">{
                        log.Info().Msgf(".gitignore file was found in '%s' and it will be used to automatically exclude paths", path)
                        return true, gitIgnore
                }</span>
        }
        <span class="cov3" title="6">return false, nil</span>
}

func multiPlatformTypeCheck(typesSelected *[]string) <span class="cov4" title="10">{
        if utils.Contains("serverlessfw", *typesSelected) &amp;&amp; !utils.Contains("cloudformation", *typesSelected) </span><span class="cov1" title="1">{
                *typesSelected = append(*typesSelected, "cloudformation")
        }</span>
        <span class="cov4" title="10">if utils.Contains("knative", *typesSelected) &amp;&amp; !utils.Contains("kubernetes", *typesSelected) </span><span class="cov1" title="1">{
                *typesSelected = append(*typesSelected, "kubernetes")
        }</span>
}
</pre>
		
		<pre class="file" id="file21" style="display: none">package engine

import (
        "fmt"
        "strings"

        build "github.com/Checkmarx/kics/pkg/builder/model"
        commentParser "github.com/Checkmarx/kics/pkg/builder/parser/comment"
        tagParser "github.com/Checkmarx/kics/pkg/builder/parser/tag"
        "github.com/Checkmarx/kics/pkg/model"
        "github.com/hashicorp/hcl/v2"
        "github.com/hashicorp/hcl/v2/hclsyntax"
        "github.com/rs/zerolog/log"
        "github.com/zclconf/go-cty/cty"
        ctyConvert "github.com/zclconf/go-cty/cty/convert"
)

const resourceLabelsCount = 2

// Engine contains the conditions of rules and comments positions
type Engine struct {
        commentParser *commentParser.Parser
        conditions    []build.Condition
}

// Run parses files and execute engine.Run
func Run(src []byte, filename string) ([]build.Rule, error) <span class="cov1" title="1">{
        cp, err := commentParser.NewParser(src, filename)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>

        <span class="cov1" title="1">file, diags := hclsyntax.ParseConfig(src, filename, hcl.Pos{Byte: 0, Line: 1, Column: 1})
        if diags != nil &amp;&amp; diags.HasErrors() </span><span class="cov0" title="0">{
                return nil, diags.Errs()[0]
        }</span>
        <span class="cov1" title="1">if file == nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("invalid parse result")
        }</span>

        <span class="cov1" title="1">e := &amp;Engine{
                commentParser: cp,
        }

        return e.Run(file.Body.(*hclsyntax.Body))</span>
}

// Run initializes rules for Engine and returns it
func (e *Engine) Run(body *hclsyntax.Body) ([]build.Rule, error) <span class="cov1" title="1">{
        e.conditions = make([]build.Condition, 0)
        if err := e.walkBody(body, []build.PathItem{}); err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>

        <span class="cov1" title="1">rules := make([]build.Rule, 0)
        conditionGroups := make(map[string][]build.Condition)
        for _, condition := range e.conditions </span><span class="cov1" title="1">{
                group, ok := condition.AttrAsString("group")
                if !ok </span><span class="cov1" title="1">{
                        rules = append(rules, build.Rule{
                                Conditions: []build.Condition{condition},
                        })
                        continue</span>
                }

                <span class="cov0" title="0">conditionGroups[group] = append(conditionGroups[group], condition)</span>
        }

        <span class="cov1" title="1">for _, conditionGroup := range conditionGroups </span><span class="cov0" title="0">{
                rules = append(rules, build.Rule{
                        Conditions: conditionGroup,
                })
        }</span>
        <span class="cov1" title="1">return rules, nil</span>
}

func (e *Engine) walkBody(body *hclsyntax.Body, walkHistory []build.PathItem) error <span class="cov5" title="3">{
        for _, attribute := range body.Attributes </span><span class="cov6" title="4">{
                if err := e.walkAttribute(attribute, walkHistory); err != nil </span><span class="cov0" title="0">{
                        return err
                }</span>
        }

        <span class="cov5" title="3">for _, block := range body.Blocks </span><span class="cov3" title="2">{
                if err := e.walkBlock(block, walkHistory); err != nil </span><span class="cov0" title="0">{
                        return err
                }</span>
        }

        <span class="cov5" title="3">return nil</span>
}

func (e *Engine) walkBlock(block *hclsyntax.Block, walkHistory []build.PathItem) error <span class="cov3" title="2">{
        if len(block.Labels) == resourceLabelsCount </span><span class="cov1" title="1">{
                walkHistory = append(walkHistory,
                        build.PathItem{Type: build.PathTypeResource, Name: block.Type},
                        build.PathItem{Type: build.PathTypeResourceType, Name: block.Labels[0]},
                        build.PathItem{Type: build.PathTypeResourceName, Name: block.Type},
                )
        }</span> else<span class="cov1" title="1"> {
                walkHistory = append(walkHistory, build.PathItem{Type: build.PathTypeDefault, Name: block.Type})
        }</span>

        <span class="cov3" title="2">e.checkComment(block.Range(), walkHistory, nil)

        return e.walkBody(block.Body, walkHistory)</span>
}

func (e *Engine) walkAttribute(attr *hclsyntax.Attribute, walkHistory []build.PathItem) error <span class="cov6" title="4">{
        walkHistory = append(walkHistory, build.PathItem{Type: build.PathTypeDefault, Name: attr.Name})

        switch exp := attr.Expr.(type) </span>{
        case *hclsyntax.TemplateExpr,
                *hclsyntax.TemplateWrapExpr,
                *hclsyntax.LiteralValueExpr,
                *hclsyntax.ScopeTraversalExpr:<span class="cov5" title="3">

                v, err := e.ExpToString(attr.Expr)
                if err != nil </span><span class="cov0" title="0">{
                        return err
                }</span>

                <span class="cov5" title="3">e.checkComment(attr.Range(), walkHistory, &amp;v)</span>
        case *hclsyntax.ObjectConsExpr:<span class="cov1" title="1">
                e.checkComment(attr.Range(), walkHistory, nil)

                for _, item := range exp.Items </span><span class="cov3" title="2">{
                        if err := e.walkConstantItem(item, walkHistory); err != nil </span><span class="cov0" title="0">{
                                return err
                        }</span>
                }
        default:<span class="cov0" title="0">
                e.checkComment(attr.Range(), walkHistory, nil)</span>
        }

        <span class="cov6" title="4">return nil</span>
}

// ExpToString converts an expression into a string
func (e *Engine) ExpToString(expr hclsyntax.Expression) (string, error) <span class="cov10" title="9">{
        switch t := expr.(type) </span>{
        case *hclsyntax.LiteralValueExpr:<span class="cov1" title="1">
                s, err := ctyConvert.Convert(t.Val, cty.String)
                if err != nil </span><span class="cov0" title="0">{
                        return "", err
                }</span>
                <span class="cov1" title="1">return s.AsString(), nil</span>
        case *hclsyntax.TemplateExpr:<span class="cov6" title="4">
                if t.IsStringLiteral() </span><span class="cov6" title="4">{
                        v, err := t.Value(nil)
                        if err != nil </span><span class="cov0" title="0">{
                                return "", err
                        }</span>
                        <span class="cov6" title="4">return v.AsString(), nil</span>
                }
                <span class="cov0" title="0">builderString, err := e.buildString(t.Parts)
                if err != nil </span><span class="cov0" title="0">{
                        return "", err
                }</span>

                <span class="cov0" title="0">return builderString, nil</span>
        case *hclsyntax.TemplateWrapExpr:<span class="cov0" title="0">
                return e.ExpToString(t.Wrapped)</span>
        case *hclsyntax.ObjectConsKeyExpr:<span class="cov3" title="2">
                return e.ExpToString(t.Wrapped)</span>
        case *hclsyntax.ScopeTraversalExpr:<span class="cov3" title="2">
                items := evaluateScopeTraversalExpr(t.Traversal)
                return strings.Join(items, "."), nil</span>
        }

        <span class="cov0" title="0">return "", fmt.Errorf("can't convert expression %T to string", expr)</span>
}

func (e *Engine) buildString(parts []hclsyntax.Expression) (string, error) <span class="cov1" title="1">{
        builder := &amp;strings.Builder{}

        for _, part := range parts </span><span class="cov0" title="0">{
                s, err := e.ExpToString(part)
                if err != nil </span><span class="cov0" title="0">{
                        return "", err
                }</span>
                <span class="cov0" title="0">builder.WriteString(s)</span>
        }

        <span class="cov1" title="1">s := builder.String()

        builder.Reset()
        builder = nil

        return s, nil</span>
}

func (e *Engine) walkConstantItem(item hclsyntax.ObjectConsItem, walkHistory []build.PathItem) error <span class="cov3" title="2">{
        k, err := e.ExpToString(item.KeyExpr)
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>

        <span class="cov3" title="2">walkHistory = append(walkHistory, build.PathItem{Type: build.PathTypeDefault, Name: k})

        v, err := e.ExpToString(item.ValueExpr)
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>

        <span class="cov3" title="2">e.checkComment(item.ValueExpr.Range(), walkHistory, &amp;v)

        return nil</span>
}

func (e *Engine) checkComment(rg hcl.Range, walkHistory []build.PathItem, actualValue *string) <span class="cov9" title="8">{
        leadComment, endLineComment := e.commentParser.ParseCommentsForNode(rg)
        if !leadComment.IsEmpty() </span><span class="cov1" title="1">{
                e.addRule(walkHistory, leadComment, actualValue)
        }</span>
        <span class="cov9" title="8">if !endLineComment.IsEmpty() </span><span class="cov1" title="1">{
                e.addRule(walkHistory, endLineComment, actualValue)
        }</span>
}

func (e *Engine) addRule(walkHistory []build.PathItem, comment commentParser.Comment, actualValue *string) <span class="cov3" title="2">{
        tags, err := tagParser.Parse(comment.Value(), model.AllIssueTypesAsString)
        if err != nil </span><span class="cov0" title="0">{
                log.Err(err).Msgf("Line %d: failed to parse comment '%s'", comment.Line(), comment.Value())
                return
        }</span>

        <span class="cov3" title="2">if len(tags) == 0 </span><span class="cov1" title="1">{
                return
        }</span>

        <span class="cov1" title="1">cp := make([]build.PathItem, len(walkHistory))
        copy(cp, walkHistory)

        for _, t := range tags </span><span class="cov1" title="1">{
                e.conditions = append(e.conditions, build.Condition{
                        Line:       comment.Line(),
                        IssueType:  model.IssueType(t.Name),
                        Path:       cp,
                        Value:      actualValue,
                        Attributes: t.Attributes,
                })
        }</span>
}

func evaluateScopeTraversalExpr(t hcl.Traversal) []string <span class="cov3" title="2">{
        items := make([]string, 0)
        for _, part := range t </span><span class="cov3" title="2">{
                switch tt := part.(type) </span>{
                case hcl.TraverseAttr:<span class="cov0" title="0">
                        items = append(items, tt.Name)</span>
                case hcl.TraverseRoot:<span class="cov3" title="2">
                        items = append(items, tt.Name)</span>
                case hcl.TraverseIndex:<span class="cov0" title="0">
                        switch tt.Key.Type() </span>{
                        case cty.Number:<span class="cov0" title="0">
                                items = append(items, tt.Key.AsBigFloat().String())</span>
                        case cty.String:<span class="cov0" title="0">
                                items = append(items, tt.Key.AsString())</span>
                        }
                }
        }
        <span class="cov3" title="2">return items</span>
}
</pre>
		
		<pre class="file" id="file22" style="display: none">package model

import "github.com/Checkmarx/kics/pkg/model"

// PathItemType represents which type of path that item belongs on json representation
type PathItemType string

// Constants for kinds of PathItemTypes
const (
        PathTypeDefault      PathItemType = "DEFAULT"
        PathTypeResource     PathItemType = "RESOURCE"
        PathTypeResourceType PathItemType = "RESOURCE_TYPE"
        PathTypeResourceName PathItemType = "RESOURCE_NAME"
)

// PathItem represents json's element name and type
type PathItem struct {
        Name string
        Type PathItemType
}

// Condition represents a condition from a rule that should be checked
type Condition struct {
        Line int

        IssueType  model.IssueType
        Path       []PathItem
        Value      interface{}
        Attributes map[string]interface{}
}

// Rule represents a list of conditions to validate a rule
type Rule struct {
        Conditions []Condition
}

// Attr add some configurations to the condition to return the condition to be matched
func (c Condition) Attr(name string) (interface{}, bool) <span class="cov6" title="2">{
        v, ok := c.Attributes[name]
        if !ok </span><span class="cov1" title="1">{
                return nil, false
        }</span>

        <span class="cov1" title="1">return v, true</span>
}

// AttrAsString gets Attr and converts to string
func (c Condition) AttrAsString(name string) (string, bool) <span class="cov10" title="3">{
        v, ok := c.Attributes[name]
        if !ok </span><span class="cov1" title="1">{
                return "", false
        }</span>

        <span class="cov6" title="2">if vv, ok := v.(string); ok </span><span class="cov1" title="1">{
                return vv, true
        }</span>

        <span class="cov1" title="1">return "", false</span>
}
</pre>
		
		<pre class="file" id="file23" style="display: none">package tag

import (
        "bytes"
        "errors"
        "fmt"
        "strconv"
        "strings"
        "text/scanner"
)

const (
        base      = 10
        bitSize64 = 64
)

// Tag contains the tag name reference and its atributtes
type Tag struct {
        Name       string
        Attributes map[string]interface{}
}

// Parse tag from following structure
// name1:"expected=private,test=false" name2:"attr=1"
func Parse(s string, supportedNames []string) ([]Tag, error) <span class="cov7" title="15">{
        s = strings.TrimLeft(strings.TrimLeft(strings.TrimSpace(s), "/"), " ")
        var tags []Tag
        for _, si := range strings.Split(s, " ") </span><span class="cov7" title="18">{
                cleanSi := strings.TrimSpace(si)
                if cleanSi == "" </span><span class="cov1" title="1">{
                        continue</span>
                }

                <span class="cov7" title="17">for _, supportedName := range supportedNames </span><span class="cov8" title="22">{
                        if !strings.HasPrefix(cleanSi, supportedName) </span><span class="cov5" title="6">{
                                continue</span>
                        }

                        <span class="cov7" title="16">tag, err := parseTag(cleanSi, supportedName)
                        if err != nil </span><span class="cov5" title="6">{
                                return nil, err
                        }</span>

                        <span class="cov6" title="10">tags = append(tags, tag)</span>
                }
        }

        <span class="cov6" title="9">return tags, nil</span>
}

func parseTag(s, name string) (Tag, error) <span class="cov7" title="16">{
        t := Tag{
                Name:       name,
                Attributes: make(map[string]interface{}),
        }

        attributePart := strings.TrimPrefix(s, name)
        attributePart = strings.TrimPrefix(attributePart, ":")
        attributePart = strings.TrimPrefix(attributePart, "\"")
        attributePart = strings.TrimSuffix(attributePart, "\"")

        if attributePart == "" </span><span class="cov4" title="4">{
                return t, nil
        }</span>

        <span class="cov6" title="12">sc := &amp;scanner.Scanner{}
        sc.Mode = scanner.ScanIdents | scanner.ScanInts | scanner.ScanFloats | scanner.ScanStrings
        sc.Init(strings.NewReader(attributePart))

        for </span><span class="cov10" title="43">{
                tok := sc.Scan()
                switch tok </span>{
                case scanner.EOF:<span class="cov5" title="6">
                        return t, nil</span>
                case scanner.Ident:<span class="cov8" title="26">
                        ident := sc.TokenText()
                        switch sc.Peek() </span>{
                        case '=':<span class="cov8" title="19">
                                sc.Next()
                                value, err := parseValue(sc)
                                if err != nil </span><span class="cov4" title="4">{
                                        return Tag{}, err
                                }</span>
                                <span class="cov7" title="15">t.Attributes[ident] = value</span>
                        case '[':<span class="cov2" title="2">
                                sc.Next()
                                arg, err := parseArgs(sc)
                                if err != nil </span><span class="cov1" title="1">{
                                        return Tag{}, err
                                }</span>
                                <span class="cov1" title="1">t.Attributes[ident] = arg</span>
                        case ',':<span class="cov4" title="5">
                                sc.Next()
                                t.Attributes[ident] = nil</span>
                        case scanner.EOF:<span class="cov0" title="0">
                                t.Attributes[ident] = nil</span>
                        }
                case ',':<span class="cov6" title="10"></span>
                        // NOP
                default:<span class="cov1" title="1">
                        return Tag{}, fmt.Errorf("invalid token: %s", sc.TokenText())</span>
                }
        }
}

func parseArray(sc *scanner.Scanner) ([]interface{}, error) <span class="cov4" title="4">{
        var result []interface{}
        for </span><span class="cov7" title="13">{
                value, err := parseValue(sc)
                if err != nil </span><span class="cov0" title="0">{
                        return result, err
                }</span>
                <span class="cov7" title="13">result = append(result, value)
                next := sc.Next()
                if next == ']' </span><span class="cov3" title="3">{
                        return result, nil
                }</span>
                <span class="cov6" title="10">if next == ',' </span><span class="cov6" title="9">{
                        continue</span>
                }
                <span class="cov1" title="1">return result, fmt.Errorf(", expected but got %s", string(next))</span>
        }
}

func parseValue(sc *scanner.Scanner) (interface{}, error) <span class="cov9" title="34">{
        switch sc.Peek() </span>{
        case '\'':<span class="cov7" title="18">
                sc.Next()
                return parseString(sc)</span>
        case '*':<span class="cov1" title="1">
                r := sc.Next()
                return string(r), nil</span>
        case '&lt;', '&gt;':<span class="cov2" title="2">
                r := sc.Next()
                if sc.Peek() == '=' </span><span class="cov1" title="1">{
                        sc.Next()
                        return string(r) + "=", nil
                }</span>
                <span class="cov1" title="1">return string(r), nil</span>
        case '!':<span class="cov2" title="2">
                sc.Next()
                if sc.Peek() == '=' </span><span class="cov1" title="1">{
                        sc.Next()
                        return "!=", nil
                }</span>
                <span class="cov1" title="1">return nil, fmt.Errorf("invalid value: %s", sc.TokenText())</span>
        case '[':<span class="cov4" title="4">
                sc.Next()
                return parseArray(sc)</span>
        default:<span class="cov5" title="7">
                tok := sc.Scan()
                switch tok </span>{
                case scanner.Ident:<span class="cov4" title="5">
                        return checkType(sc.TokenText()), nil</span>
                case scanner.String, scanner.Int, scanner.Float:<span class="cov2" title="2">
                        if tok == scanner.String </span><span class="cov0" title="0">{
                                str := sc.TokenText()
                                return str[1 : len(str)-1], nil
                        }</span> else<span class="cov2" title="2"> if tok == scanner.Int </span><span class="cov1" title="1">{
                                return strconv.ParseInt(sc.TokenText(), base, bitSize64)
                        }</span> else<span class="cov1" title="1"> if tok == scanner.Float </span><span class="cov1" title="1">{
                                return strconv.ParseFloat(sc.TokenText(), bitSize64)
                        }</span>
                default:<span class="cov0" title="0">
                        return nil, fmt.Errorf("invalid value: %s", sc.TokenText())</span>
                }
        }
        <span class="cov0" title="0">return nil, errors.New("invalid value")</span>
}

func parseArgs(sc *scanner.Scanner) (map[string]interface{}, error) <span class="cov2" title="2">{
        result := map[string]interface{}{}
        for </span><span class="cov3" title="3">{
                tok := sc.Scan()
                if tok != scanner.Ident </span><span class="cov0" title="0">{
                        return result, fmt.Errorf("invalid attribute name: %s", sc.TokenText())
                }</span>
                <span class="cov3" title="3">name := sc.TokenText()
                eq := sc.Next()
                if eq != '=' </span><span class="cov1" title="1">{
                        return result, fmt.Errorf("= expected but got %s", string(eq))
                }</span>
                <span class="cov2" title="2">value, err := parseValue(sc)
                if err != nil </span><span class="cov0" title="0">{
                        return result, err
                }</span>
                <span class="cov2" title="2">result[name] = value
                next := sc.Next()
                if next == ']' </span><span class="cov1" title="1">{
                        return result, nil
                }</span>
                <span class="cov1" title="1">if next == ',' </span><span class="cov1" title="1">{
                        continue</span>
                }
                <span class="cov0" title="0">return result, fmt.Errorf(") or , expected but got %s", string(next))</span>
        }
}

func parseString(sc *scanner.Scanner) (string, error) <span class="cov7" title="18">{
        var buf bytes.Buffer
        ch := sc.Next()
        for ch != '\'' </span><span class="cov8" title="26">{
                if ch == '\n' || ch == '\r' || ch &lt; 0 </span><span class="cov1" title="1">{
                        return "", errors.New("unterminated string")
                }</span>
                <span class="cov8" title="25">if ch == '\\' </span><span class="cov6" title="12">{
                        s, err := parseEscape(sc)
                        if err != nil </span><span class="cov1" title="1">{
                                return "", err
                        }</span>
                        <span class="cov6" title="11">buf.WriteString(s)</span>
                } else<span class="cov7" title="13"> {
                        buf.WriteRune(ch)
                }</span>
                <span class="cov8" title="24">ch = sc.Next()</span>
        }
        <span class="cov7" title="16">return buf.String(), nil</span>
}

func parseEscape(sc *scanner.Scanner) (string, error) <span class="cov6" title="12">{
        ch := sc.Next()
        switch ch </span>{
        case 'a':<span class="cov1" title="1">
                return "\a", nil</span>
        case 'b':<span class="cov1" title="1">
                return "\b", nil</span>
        case 'f':<span class="cov1" title="1">
                return "\f", nil</span>
        case 'n':<span class="cov1" title="1">
                return "\n", nil</span>
        case 'r':<span class="cov1" title="1">
                return "\r", nil</span>
        case 't':<span class="cov1" title="1">
                return "\t", nil</span>
        case 'v':<span class="cov1" title="1">
                return "\v", nil</span>
        case '\\':<span class="cov1" title="1">
                return "\\", nil</span>
        case '"':<span class="cov2" title="2">
                return "\"", nil</span>
        case '\'':<span class="cov1" title="1">
                return "'", nil</span>
        }
        <span class="cov1" title="1">return "", fmt.Errorf("invalid escape sequence: %s", string(ch))</span>
}

func checkType(s string) interface{} <span class="cov4" title="5">{
        switch s </span>{
        case "true", "TRUE":<span class="cov1" title="1">
                return true</span>
        case "false", "FALSE":<span class="cov1" title="1">
                return false</span>
        default:<span class="cov3" title="3">
                if i, err := strconv.ParseInt(s, base, bitSize64); err == nil </span><span class="cov0" title="0">{
                        return i
                }</span>
                <span class="cov3" title="3">if f, err := strconv.ParseFloat(s, bitSize64); err == nil </span><span class="cov0" title="0">{
                        return f
                }</span>

                <span class="cov3" title="3">return s</span>
        }
}
</pre>
		
		<pre class="file" id="file24" style="display: none">package writer

import (
        "bytes"
        "fmt"
        "html/template"
        "strconv"
        "strings"

        build "github.com/Checkmarx/kics/pkg/builder/model"
        "github.com/Checkmarx/kics/pkg/model"
        "github.com/pkg/errors"
        "github.com/rs/zerolog/log"
)

// RegoWriter represents the template for a Rego rule
type RegoWriter struct {
        tmpl *template.Template
}

// Block represents a json block of a file for scan
type Block struct {
        Name string
        All  bool
        List []string
}

// RegoRule contains a block to be scanned and a rule to be applied
type RegoRule struct {
        Block Block
        build.Rule
}

const (
        stringValue = "\"%s\""
        prec        = 6
        bitSize32   = 32
        bitSize64   = 64
)

// NewRegoWriter initializes a default RegoWriter using builder template
func NewRegoWriter() (*RegoWriter, error) <span class="cov1" title="1">{
        tmpl, err := template.New("template.gorego").
                Funcs(template.FuncMap{
                        "condition": condition,
                        "regoValue": regoValueToString,
                        "lastCondition": func(r RegoRule) build.Condition </span><span class="cov1" title="1">{
                                return r.Conditions[len(r.Conditions)-1]
                        }</span>,
                        "unescape": func(v string) template.HTML <span class="cov1" title="1">{
                                return template.HTML(v) // nolint:gosec
                        }</span>,
                        "innerKey": func(r RegoRule) template.HTML <span class="cov2" title="2">{
                                condition := r.Conditions[len(r.Conditions)-1]
                                return template.HTML(conditionKey(r.Block, condition, false, true)) // nolint:gosec
                        }</span>,
                        "searchKey": func(r RegoRule) template.HTML <span class="cov1" title="1">{
                                format := "%%s[%%s].%s"
                                condition := r.Conditions[len(r.Conditions)-1]
                                var vars []string

                                if v, ok := condition.Attr("resource"); ok &amp;&amp; v == "*" </span><span class="cov1" title="1">{
                                        vars = append(vars, "blockType")
                                }</span> else<span class="cov0" title="0"> {
                                        vars = append(vars, "blockTypes[blockIndex]")
                                }</span>
                                <span class="cov1" title="1">vars = append(vars, "name")
                                if _, ok := condition.Attr("any_key"); ok </span><span class="cov1" title="1">{
                                        format += ".%%s"
                                        vars = append(vars, "key")
                                }</span>
                                <span class="cov1" title="1">format = fmt.Sprintf(format, conditionKey(r.Block, condition, false, true))

                                return template.HTML(fmt.Sprintf("sprintf(\"%s\", [%s])", format, strings.Join(vars, ", ")))</span> // nolint
                        },
                }).
                ParseFiles("./pkg/builder/writer/template.gorego")
        <span class="cov1" title="1">if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>

        <span class="cov1" title="1">return &amp;RegoWriter{tmpl: tmpl}, nil</span>
}

// Render starts RegoWriter rules list passed as parameter
func (w *RegoWriter) Render(rules []build.Rule) ([]byte, error) <span class="cov1" title="1">{
        wr := bytes.NewBuffer(nil)

        if err := w.tmpl.Execute(wr, format(rules)); err != nil </span><span class="cov0" title="0">{
                return nil, errors.Wrap(err, "failed to render")
        }</span>

        <span class="cov1" title="1">return wr.Bytes(), nil</span>
}

func condition(r Block, c build.Condition) string <span class="cov5" title="6">{
        key := conditionKey(r, c, true, false)

        if c.IssueType == model.IssueTypeRedundantAttribute </span><span class="cov1" title="1">{
                return key
        }</span>
        <span class="cov4" title="5">if c.IssueType == model.IssueTypeMissingAttribute </span><span class="cov1" title="1">{
                return fmt.Sprintf("not %s", key)
        }</span>

        <span class="cov4" title="4">if _, ok := c.Attr("upper"); ok </span><span class="cov1" title="1">{
                key = fmt.Sprintf("upper(%s)", key)
        }</span>
        <span class="cov4" title="4">if _, ok := c.Attr("lower"); ok </span><span class="cov1" title="1">{
                key = fmt.Sprintf("lower(%s)", key)
        }</span>

        <span class="cov4" title="4">if reg, ok := c.Attr("regex"); ok </span><span class="cov1" title="1">{
                return fmt.Sprintf("re_match(%q, %s)", reg, key)
        }</span>

        <span class="cov3" title="3">condition := "=="
        if v, ok := c.AttrAsString("condition"); ok </span><span class="cov1" title="1">{
                condition = v
        }</span>

        <span class="cov3" title="3">if value, ok := c.AttrAsString("val"); ok </span><span class="cov1" title="1">{
                return fmt.Sprintf("%s %s %s", key, condition, regoValueToString(value))
        }</span>

        <span class="cov2" title="2">return fmt.Sprintf("%s %s %s", key, condition, regoValueToString(c.Value))</span>
}

func regoValueToString(i interface{}) string <span class="cov7" title="15">{
        switch v := i.(type) </span>{
        case bool:<span class="cov2" title="2">
                if v </span><span class="cov1" title="1">{
                        return "true"
                }</span>
                <span class="cov1" title="1">return "false"</span>
        case int64:<span class="cov1" title="1">
                return strconv.Itoa(int(v))</span>
        case int32:<span class="cov1" title="1">
                return strconv.Itoa(int(v))</span>
        case int:<span class="cov1" title="1">
                return strconv.Itoa(v)</span>
        case float64:<span class="cov1" title="1">
                return strconv.FormatFloat(v, 'f', prec, bitSize64)</span>
        case float32:<span class="cov1" title="1">
                return strconv.FormatFloat(float64(v), 'f', prec, bitSize32)</span>
        case string:<span class="cov4" title="4">
                return fmt.Sprintf(stringValue, v)</span>
        case *string:<span class="cov2" title="2">
                if v == nil </span><span class="cov1" title="1">{
                        return "\"\""
                }</span>
                <span class="cov1" title="1">return fmt.Sprintf(stringValue, *v)</span>
        case []string:<span class="cov1" title="1">
                sts := make([]string, 0, len(v))
                for _, vi := range v </span><span class="cov3" title="3">{
                        sts = append(sts, fmt.Sprintf(stringValue, vi))
                }</span>

                <span class="cov1" title="1">return fmt.Sprintf("{%s}", strings.Join(sts, ", "))</span>
        default:<span class="cov1" title="1">
                log.Warn().Msgf("Can't convert value, %T to string", i)
                return ""</span>
        }
}

func conditionKey(block Block, c build.Condition, withBlockPrefix, pathOnly bool) string <span class="cov6" title="10">{
        key := ""
        if withBlockPrefix </span><span class="cov5" title="7">{
                key = "block"
        }</span>
        <span class="cov6" title="10">for i, pathItem := range c.Path </span><span class="cov10" title="50">{
                switch pathItem.Type </span>{
                case build.PathTypeResourceType:<span class="cov6" title="10">
                        if pathOnly </span><span class="cov3" title="3">{
                                continue</span>
                        } else<span class="cov5" title="7"> if block.All </span><span class="cov5" title="7">{
                                key += "[blockType]"
                        }</span> else<span class="cov0" title="0"> {
                                key += "[blockTypes[blockIndex]]"
                        }</span>
                case build.PathTypeResourceName:<span class="cov6" title="10">
                        if !pathOnly </span><span class="cov5" title="7">{
                                key += "[name]"
                        }</span>
                case build.PathTypeDefault:<span class="cov7" title="20">
                        key = buildDefaultType(c, i, pathOnly, pathItem, key)</span>
                }
        }

        <span class="cov6" title="10">return key</span>
}

func buildDefaultType(c build.Condition, i int, pathOnly bool, pathItem build.PathItem, key string) string <span class="cov7" title="20">{
        if _, ok := c.Attr("any_key"); ok &amp;&amp; i == len(c.Path)-1 </span><span class="cov6" title="10">{
                if !pathOnly </span><span class="cov5" title="7">{
                        key += "[key]"
                }</span>
                <span class="cov6" title="10">return key</span>
        }

        <span class="cov6" title="10">if key != "" </span><span class="cov5" title="7">{
                key += "."
        }</span>

        <span class="cov6" title="10">key += pathItem.Name
        return key</span>
}

func format(rules []build.Rule) []RegoRule <span class="cov2" title="2">{
        res := make([]RegoRule, len(rules))
        for i, r := range rules </span><span class="cov2" title="2">{
                res[i] = RegoRule{
                        Rule:  r,
                        Block: createBlock(r),
                }
        }</span>

        <span class="cov2" title="2">return res</span>
}

func createBlock(rule build.Rule) Block <span class="cov3" title="3">{
        result := Block{}
        result = resultName(rule, result)

        resources := make(map[string]struct{}, len(rule.Conditions))
        for _, condition := range rule.Conditions </span><span class="cov3" title="3">{
                if len(condition.Path) == 0 </span><span class="cov0" title="0">{
                        continue</span>
                }

                <span class="cov3" title="3">v, ok := condition.Attr("resource")
                if !ok </span><span class="cov0" title="0">{
                        for _, pathItem := range condition.Path </span><span class="cov0" title="0">{
                                if pathItem.Type == build.PathTypeResourceType </span><span class="cov0" title="0">{
                                        resources[pathItem.Name] = struct{}{}
                                }</span>
                        }

                        <span class="cov0" title="0">continue</span>
                }
                <span class="cov3" title="3">resources, result = switchFunction(v, result, resources)</span>
        }

        <span class="cov3" title="3">result.List = make([]string, 0, len(resources))
        for resource := range resources </span><span class="cov3" title="3">{
                result.List = append(result.List, resource)
        }</span>

        <span class="cov3" title="3">return result</span>
}

func switchFunction(v interface{}, result Block, resources map[string]struct{}) (map[string]struct{}, Block) <span class="cov4" title="5">{
        switch vv := v.(type) </span>{
        case string:<span class="cov4" title="4">
                if vv == "*" </span><span class="cov4" title="4">{
                        result.All = true
                }</span>
                <span class="cov4" title="4">resources[vv] = struct{}{}</span>
        case []string:<span class="cov1" title="1">
                for _, vi := range vv </span><span class="cov2" title="2">{
                        resources[vi] = struct{}{}
                }</span>
        case []interface{}:<span class="cov0" title="0">
                for _, vi := range vv </span><span class="cov0" title="0">{
                        if vvi, ok := vi.(string); ok </span><span class="cov0" title="0">{
                                resources[vvi] = struct{}{}
                        }</span>
                }
        }
        <span class="cov4" title="5">return resources, result</span>
}

func resultName(rule build.Rule, result Block) Block <span class="cov4" title="4">{
        for _, pathItem := range rule.Conditions[len(rule.Conditions)-1].Path </span><span class="cov4" title="4">{
                if pathItem.Type == build.PathTypeResource </span><span class="cov4" title="4">{
                        result.Name = pathItem.Name
                        break</span>
                }
        }
        <span class="cov4" title="4">return result</span>
}
</pre>
		
		<pre class="file" id="file25" style="display: none">package descriptions

import (
        "bytes"
        "encoding/base64"
        "encoding/json"
        "fmt"
        "io"
        "net/http"
        "os"
        "time"

        "github.com/Checkmarx/kics/internal/constants"
        descModel "github.com/Checkmarx/kics/pkg/descriptions/model"
        "github.com/Checkmarx/kics/pkg/model"
        "github.com/rs/zerolog/log"
)

var (
        //
        // The requested description content is CIS Proprietary Content owned
        // by CIS Center for Internet Security Inc. (cissecurity.org)
        //
        //  Apache License 2.0 shall not apply to any content generated by KICS
        //  which is marked as being Proprietary to CIS (the CIS Proprietary Content).
        //
        //  The CIS Proprietary Content is exclusively owned by the Center for Internet Security, Inc.
        //  and you are granted a limited, non-exclusively, non-transferable, non-sublicensable license
        //  to view the CIS Proprietary Content in connection with your use of KICS
        //
        // ***************************************************
        // *  HARDCODED authKey is NOT FOR SECURITY PURPOSES *
        // ***************************************************
        authKey = []rune{67, 101, 110, 116, 101, 114, 95, 102, 111, 114, 95, 73, 110, 116, 101, 114, 110, 101,
                116, 95, 83, 101, 99, 117, 114, 105, 116, 121, 95, 80, 114, 111, 112, 114, 105, 101, 116, 97, 114, 121,
                95, 67, 111, 110, 116, 101, 110, 116, 95, 99, 105, 115, 101, 99, 117, 114, 105, 116, 121, 46, 111, 114, 103}

        tr = &amp;http.Transport{
                Proxy:              http.ProxyFromEnvironment,
                MaxIdleConns:       10,
                IdleConnTimeout:    30 * time.Second,
                DisableCompression: true,
        }
        // HTTPRequestClient - http client to use for requests
        HTTPRequestClient HTTPClient = &amp;http.Client{
                Transport: tr,
                Timeout:   20 * time.Second,
        }
)

// HTTPClient - http client to use for requests
type HTTPClient interface {
        Do(req *http.Request) (*http.Response, error)
}

// HTTPDescription - HTTP client interface to use for requesting descriptions
type HTTPDescription interface {
        CheckConnection() error
        RequestDescriptions(descriptionIDs []string) (map[string]descModel.CISDescriptions, error)
        CheckLatestVersion(version string) (model.Version, error)
}

// Client - client for making CIS descriptions requests
type Client struct {
}

// CheckConnection - checks if the endpoint is reachable
func (c *Client) CheckConnection() error <span class="cov7" title="3">{
        baseURL, err := getBaseURL()
        if err != nil </span><span class="cov1" title="1">{
                return err
        }</span>

        <span class="cov4" title="2">endpointURL := fmt.Sprintf("%s/api/", baseURL)
        req, err := http.NewRequest(http.MethodGet, endpointURL, http.NoBody)
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>

        <span class="cov4" title="2">resp, err := doRequest(req)
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>
        <span class="cov4" title="2">defer resp.Body.Close()
        return err</span>
}

// CheckLatestVersion - Check if using KICS latest version from endpoint
func (c *Client) CheckLatestVersion(version string) (model.Version, error) <span class="cov1" title="1">{
        baseURL, err := getBaseURL()
        if err != nil </span><span class="cov0" title="0">{
                return model.Version{}, err
        }</span>
        <span class="cov1" title="1">endpointURL := fmt.Sprintf("%s/api/%s", baseURL, "version")

        versionRequest := descModel.VersionRequest{
                Version: version,
        }

        requestBody, err := json.Marshal(versionRequest)
        if err != nil </span><span class="cov0" title="0">{
                return model.Version{}, err
        }</span>

        <span class="cov1" title="1">req, err := http.NewRequest(http.MethodPost, endpointURL, bytes.NewReader(requestBody))
        if err != nil </span><span class="cov0" title="0">{
                return model.Version{}, err
        }</span>
        <span class="cov1" title="1">req.Header.Add("Content-Type", "application/json")
        req.Header.Add("Authorization", fmt.Sprintf("Basic %s", base64.StdEncoding.EncodeToString([]byte(getBasicAuth()))))

        resp, err := doRequest(req)
        if err != nil </span><span class="cov0" title="0">{
                return model.Version{}, err
        }</span>
        <span class="cov1" title="1">defer resp.Body.Close()

        b, err := io.ReadAll(resp.Body)
        if err != nil </span><span class="cov0" title="0">{
                return model.Version{}, err
        }</span>

        <span class="cov1" title="1">var VersionResponse model.Version
        err = json.Unmarshal(b, &amp;VersionResponse)
        if err != nil </span><span class="cov0" title="0">{
                return model.Version{}, err
        }</span>

        <span class="cov1" title="1">return VersionResponse, nil</span>
}

// RequestDescriptions - gets CIS descriptions from endpoint
func (c *Client) RequestDescriptions(descriptionIDs []string) (map[string]descModel.CISDescriptions, error) <span class="cov1" title="1">{
        baseURL, err := getBaseURL()
        if err != nil </span><span class="cov0" title="0">{
                log.Debug().Msg("Unable to get baseURL")
                return nil, err
        }</span>

        <span class="cov1" title="1">endpointURL := fmt.Sprintf("%s/api/%s", baseURL, "descriptions")

        descriptionRequest := descModel.DescriptionRequest{
                Version:        constants.Version,
                DescriptionIDs: descriptionIDs,
        }

        requestBody, err := json.Marshal(descriptionRequest)
        if err != nil </span><span class="cov0" title="0">{
                log.Err(err).Msg("Unable to marshal request body")
                return nil, err
        }</span>

        <span class="cov1" title="1">req, err := http.NewRequest(http.MethodPost, endpointURL, bytes.NewReader(requestBody))
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov1" title="1">req.Header.Add("Content-Type", "application/json")
        req.Header.Add("Authorization", fmt.Sprintf("Basic %s", base64.StdEncoding.EncodeToString([]byte(getBasicAuth()))))

        log.Debug().Msgf("HTTP POST to descriptions endpoint")
        startTime := time.Now()
        resp, err := doRequest(req)
        if err != nil </span><span class="cov0" title="0">{
                log.Err(err).Msgf("Unable to POST to descriptions endpoint")
                return nil, err
        }</span>
        <span class="cov1" title="1">defer resp.Body.Close()
        endTime := time.Since(startTime)
        log.Debug().Msgf("HTTP Status: %d %s %v", resp.StatusCode, http.StatusText(resp.StatusCode), endTime)

        b, err := io.ReadAll(resp.Body)
        if err != nil </span><span class="cov0" title="0">{
                log.Err(err).Msg("Unable to read response body")
                return nil, err
        }</span>

        <span class="cov1" title="1">var getDescriptionsResponse descModel.DescriptionResponse
        err = json.Unmarshal(b, &amp;getDescriptionsResponse)
        if err != nil </span><span class="cov0" title="0">{
                log.Err(err).Msg("Unable to unmarshal response body")
                return nil, err
        }</span>

        <span class="cov1" title="1">return getDescriptionsResponse.Descriptions, nil</span>
}

// doRequest - make HTTP request
func doRequest(request *http.Request) (*http.Response, error) <span class="cov10" title="5">{
        return HTTPRequestClient.Do(request)
}</span>

func getBaseURL() (string, error) <span class="cov10" title="5">{
        var rtnBaseURL string
        urlFromEnv := os.Getenv("KICS_DESCRIPTIONS_ENDPOINT")
        if constants.BaseURL == "" &amp;&amp; urlFromEnv == "" </span><span class="cov1" title="1">{
                return "", fmt.Errorf("the BaseURL or KICS_DESCRIPTIONS_ENDPOINT environment variable not set")
        }</span>

        <span class="cov8" title="4">if urlFromEnv != "" </span><span class="cov8" title="4">{
                rtnBaseURL = urlFromEnv
        }</span> else<span class="cov0" title="0"> {
                rtnBaseURL = constants.BaseURL
        }</span>
        <span class="cov8" title="4">return rtnBaseURL, nil</span>
}

func getBasicAuth() string <span class="cov4" title="2">{
        auth := os.Getenv("KICS_BASIC_AUTH_PASS")
        if auth == "" </span><span class="cov4" title="2">{
                auth = string(authKey)
        }</span>
        <span class="cov4" title="2">return auth</span>
}
</pre>
		
		<pre class="file" id="file26" style="display: none">package descriptions

import (
        "fmt"

        "github.com/Checkmarx/kics/pkg/model"
)

var (
        descClient HTTPDescription = &amp;Client{}
)

// RequestAndOverrideDescriptions - Requests CIS descriptions and override default descriptions
func RequestAndOverrideDescriptions(summary *model.Summary) error <span class="cov8" title="1">{
        descriptionIDs := make([]string, 0)
        for idx := range summary.Queries </span><span class="cov8" title="1">{
                descriptionIDs = append(descriptionIDs, summary.Queries[idx].DescriptionID)
        }</span>

        <span class="cov8" title="1">if err := descClient.CheckConnection(); err != nil </span><span class="cov0" title="0">{
                return err
        }</span>

        <span class="cov8" title="1">descriptionMap, err := descClient.RequestDescriptions(descriptionIDs)
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>

        <span class="cov8" title="1">for idx := range summary.Queries </span><span class="cov8" title="1">{
                if descriptionMap[summary.Queries[idx].DescriptionID].DescriptionID == "" &amp;&amp;
                        descriptionMap[summary.Queries[idx].DescriptionID].RationaleText == "" </span><span class="cov0" title="0">{
                        continue</span>
                }
                <span class="cov8" title="1">descriptionID := summary.Queries[idx].DescriptionID

                summary.Queries[idx].CISDescriptionID = descriptionMap[descriptionID].DescriptionID
                summary.Queries[idx].CISDescriptionTitle = descriptionMap[descriptionID].DescriptionTitle
                summary.Queries[idx].CISDescriptionText = descriptionMap[descriptionID].DescriptionText
                summary.Queries[idx].CISRationaleText = descriptionMap[descriptionID].RationaleText
                summary.Queries[idx].CISBenchmarkName = descriptionMap[descriptionID].BenchmarkName
                summary.Queries[idx].CISBenchmarkVersion = descriptionMap[descriptionID].BenchmarkVersion

                summary.Queries[idx].CISDescriptionIDFormatted = fmt.Sprintf(
                        "CIS Security - %s v%s - Rule %s",
                        descriptionMap[descriptionID].BenchmarkName,
                        descriptionMap[descriptionID].BenchmarkVersion,
                        descriptionMap[descriptionID].DescriptionID,
                )
                summary.Queries[idx].CISDescriptionTextFormatted = fmt.Sprintf(
                        "%s\n%s",
                        descriptionMap[descriptionID].DescriptionText,
                        descriptionMap[descriptionID].RationaleText,
                )</span>
        }
        <span class="cov8" title="1">return nil</span>
}
</pre>
		
		<pre class="file" id="file27" style="display: none">package descriptions

import (
        "github.com/Checkmarx/kics/internal/constants"
        "github.com/Checkmarx/kics/internal/tracker"
        "github.com/Checkmarx/kics/pkg/model"
)

// CheckVersion - checks if using the latest version and saves that information in the tracker
func CheckVersion(t *tracker.CITracker) <span class="cov10" title="3">{
        baseVersionInfo := model.Version{
                Latest: true,
        }

        if err := descClient.CheckConnection(); err != nil </span><span class="cov1" title="1">{
                t.TrackVersion(baseVersionInfo)
                return
        }</span>

        <span class="cov6" title="2">versionInfo, err := descClient.CheckLatestVersion(constants.Version)
        if err != nil </span><span class="cov1" title="1">{
                t.TrackVersion(baseVersionInfo)
                return
        }</span>

        <span class="cov1" title="1">t.TrackVersion(versionInfo)</span>
}
</pre>
		
		<pre class="file" id="file28" style="display: none">package detector

import (
        "strconv"
        "strings"

        "github.com/Checkmarx/kics/pkg/model"
        "github.com/rs/zerolog"
)

const (
        undetectedVulnerabilityLine = -1
)

type defaultDetectLine struct {
}

// DetectLine searches vulnerability line if kindDetectLine is not in detectors
func (d defaultDetectLine) DetectLine(file *model.FileMetadata, searchKey string,
        outputLines int, logwithfields *zerolog.Logger) model.VulnerabilityLines <span class="cov7" title="3">{
        detector := &amp;DefaultDetectLineResponse{
                CurrentLine:     0,
                IsBreak:         false,
                FoundAtLeastOne: false,
                ResolvedFile:    file.FilePath,
                ResolvedFiles:   d.prepareResolvedFiles(file.ResolvedFiles),
        }

        var extractedString [][]string
        extractedString = GetBracketValues(searchKey, extractedString, "")
        sanitizedSubstring := searchKey
        for idx, str := range extractedString </span><span class="cov7" title="3">{
                sanitizedSubstring = strings.Replace(sanitizedSubstring, str[0], `{{`+strconv.Itoa(idx)+`}}`, -1)
        }</span>

        <span class="cov7" title="3">lines := *file.LinesOriginalData
        for _, key := range strings.Split(sanitizedSubstring, ".") </span><span class="cov10" title="5">{
                substr1, substr2 := GenerateSubstrings(key, extractedString)

                detector, lines = detector.DetectCurrentLine(substr1, substr2, 0, lines)

                if detector.IsBreak </span><span class="cov1" title="1">{
                        break</span>
                }
        }

        <span class="cov7" title="3">if detector.FoundAtLeastOne </span><span class="cov4" title="2">{
                return model.VulnerabilityLines{
                        Line:         detector.CurrentLine + 1,
                        VulnLines:    GetAdjacentVulnLines(detector.CurrentLine, outputLines, lines),
                        ResolvedFile: detector.ResolvedFile,
                }
        }</span>

        <span class="cov1" title="1">logwithfields.Warn().Msgf("Failed to detect line, query response %s", searchKey)

        return model.VulnerabilityLines{
                Line:         undetectedVulnerabilityLine,
                VulnLines:    &amp;[]model.CodeLine{},
                ResolvedFile: detector.ResolvedFile,
        }</span>
}

func (d defaultDetectLine) prepareResolvedFiles(resFiles map[string]model.ResolvedFile) map[string]model.ResolvedFileSplit <span class="cov8" title="4">{
        resolvedFiles := make(map[string]model.ResolvedFileSplit)
        for f, res := range resFiles </span><span class="cov1" title="1">{
                resolvedFiles[f] = model.ResolvedFileSplit{
                        Path:  res.Path,
                        Lines: *res.LinesContent,
                }
        }</span>
        <span class="cov8" title="4">return resolvedFiles</span>
}
</pre>
		
		<pre class="file" id="file29" style="display: none">package detector

import (
        "github.com/Checkmarx/kics/pkg/model"
        "github.com/rs/zerolog"
)

type kindDetectLine interface {
        DetectLine(file *model.FileMetadata, searchKey string, outputLines int, logWithFields *zerolog.Logger) model.VulnerabilityLines
}

// DetectLine is a struct that associates a kindDetectLine to its FileKind
type DetectLine struct {
        detectors       map[model.FileKind]kindDetectLine
        outputLines     int
        logWithFields   *zerolog.Logger
        defaultDetector kindDetectLine
}

// NewDetectLine creates a new DetectLine's reference
func NewDetectLine(outputLines int) *DetectLine <span class="cov10" title="7">{
        return &amp;DetectLine{
                detectors:       make(map[model.FileKind]kindDetectLine),
                logWithFields:   &amp;zerolog.Logger{},
                outputLines:     outputLines,
                defaultDetector: defaultDetectLine{},
        }
}</span>

// SetupLogs will change the logger feild to be used in kindDetectLine DetectLine method
func (d *DetectLine) SetupLogs(logger *zerolog.Logger) <span class="cov1" title="1">{
        d.logWithFields = logger
}</span>

// Add adds a new kindDetectLine to the caller and returns it
func (d *DetectLine) Add(detector kindDetectLine, kind model.FileKind) *DetectLine <span class="cov6" title="3">{
        d.detectors[kind] = detector
        return d
}</span>

// DetectLine will use the correct kindDetectLine according to the files kind
// if file kind is not in detectors default detect line is called
func (d *DetectLine) DetectLine(file *model.FileMetadata, searchKey string, logWithFields *zerolog.Logger) model.VulnerabilityLines <span class="cov4" title="2">{
        if det, ok := d.detectors[file.Kind]; ok </span><span class="cov1" title="1">{
                return det.DetectLine(file, searchKey, d.outputLines, logWithFields)
        }</span>
        <span class="cov1" title="1">return d.defaultDetector.DetectLine(file, searchKey, d.outputLines, logWithFields)</span>
}

// GetAdjecent finds and returns the lines adjecent to the line containing the vulnerability
func (d *DetectLine) GetAdjecent(file *model.FileMetadata, line int) model.VulnerabilityLines <span class="cov4" title="2">{
        return model.VulnerabilityLines{
                Line:         line,
                VulnLines:    GetAdjacentVulnLines(line-1, d.outputLines, *file.LinesOriginalData),
                ResolvedFile: file.FilePath,
        }
}</span>
</pre>
		
		<pre class="file" id="file30" style="display: none">package docker

import (
        "regexp"
        "strconv"
        "strings"

        "github.com/Checkmarx/kics/pkg/detector"
        "github.com/Checkmarx/kics/pkg/model"
        "github.com/rs/zerolog"
)

// DetectKindLine defines a kindDetectLine type
type DetectKindLine struct {
}

const (
        undetectedVulnerabilityLine = -1
)

var (
        nameRegexDockerFileML = regexp.MustCompile(`.+\s+\\$`)
        commentRegex          = regexp.MustCompile(`^\s*#.*`)
        splitRegex            = regexp.MustCompile(`\s\\`)
)

// DetectLine searches vulnerability line in docker files
func (d DetectKindLine) DetectLine(file *model.FileMetadata, searchKey string,
        outputLines int, logwithfields *zerolog.Logger) model.VulnerabilityLines <span class="cov3" title="3">{
        det := &amp;detector.DefaultDetectLineResponse{
                CurrentLine:     0,
                IsBreak:         false,
                FoundAtLeastOne: false,
                ResolvedFile:    file.FilePath,
                ResolvedFiles:   make(map[string]model.ResolvedFileSplit),
        }

        var extractedString [][]string
        extractedString = detector.GetBracketValues(searchKey, extractedString, "")
        sKey := searchKey
        for idx, str := range extractedString </span><span class="cov4" title="5">{
                sKey = strings.Replace(sKey, str[0], `{{`+strconv.Itoa(idx)+`}}`, -1)
        }</span>

        <span class="cov3" title="3">unchangedText := make([]string, len(*file.LinesOriginalData))
        copy(unchangedText, *file.LinesOriginalData)

        for _, key := range strings.Split(sKey, ".") </span><span class="cov4" title="6">{
                substr1, substr2 := detector.GenerateSubstrings(key, extractedString)

                det, _ = det.DetectCurrentLine(substr1, substr2, 0, prepareDockerFileLines(*file.LinesOriginalData))

                if det.IsBreak </span><span class="cov0" title="0">{
                        break</span>
                }
        }

        <span class="cov3" title="3">if det.FoundAtLeastOne </span><span class="cov3" title="3">{
                return model.VulnerabilityLines{
                        Line:         det.CurrentLine + 1,
                        VulnLines:    detector.GetAdjacentVulnLines(det.CurrentLine, outputLines, unchangedText),
                        ResolvedFile: file.FilePath,
                }
        }</span>

        <span class="cov0" title="0">logwithfields.Warn().Msgf("Failed to detect Docker line, query response %s", sKey)

        return model.VulnerabilityLines{
                Line:         undetectedVulnerabilityLine,
                VulnLines:    &amp;[]model.CodeLine{},
                ResolvedFile: file.FilePath,
        }</span>
}

func prepareDockerFileLines(text []string) []string <span class="cov4" title="6">{
        for idx, key := range text </span><span class="cov9" title="74">{
                if !commentRegex.MatchString(key) </span><span class="cov9" title="74">{
                        text[idx] = multiLineSpliter(text, key, idx)
                }</span>
        }
        <span class="cov4" title="6">return text</span>
}

func multiLineSpliter(textSplit []string, key string, idx int) string <span class="cov10" title="85">{
        if nameRegexDockerFileML.MatchString(key) </span><span class="cov5" title="11">{
                i := idx + 1
                if i &gt;= len(textSplit) </span><span class="cov0" title="0">{
                        return textSplit[idx]
                }</span>
                <span class="cov5" title="11">for textSplit[i] == "" </span><span class="cov5" title="8">{
                        i++
                        if i &gt;= len(textSplit) </span><span class="cov0" title="0">{
                                return textSplit[idx]
                        }</span>
                }
                <span class="cov5" title="11">if commentRegex.MatchString(textSplit[i]) </span><span class="cov0" title="0">{
                        textSplit[i] += " \\"
                }</span>
                <span class="cov5" title="11">textSplit[idx] = splitRegex.ReplaceAllLiteralString(textSplit[idx], " "+textSplit[i])
                textSplit[i] = ""
                textSplit[idx] = multiLineSpliter(textSplit, textSplit[idx], idx)</span>
        }
        <span class="cov10" title="85">return textSplit[idx]</span>
}
</pre>
		
		<pre class="file" id="file31" style="display: none">package helm

import (
        "fmt"
        "sort"
        "strconv"
        "strings"

        "github.com/Checkmarx/kics/pkg/detector"
        "github.com/Checkmarx/kics/pkg/model"
        "github.com/agnivade/levenshtein"
        "github.com/rs/zerolog"
)

// DetectKindLine defines a kindDetectLine type
type DetectKindLine struct {
}

type detectCurlLine struct {
        foundRes   bool
        lineRes    int
        breakRes   bool
        lastUnique dupHistory
}

// dupHistory keeps the history of uniques
type dupHistory struct {
        unique         bool
        lastUniqueLine int
}

const (
        undetectedVulnerabilityLine = -1
)

// DetectLine is used to detect line on the helm template,
// it looks only at the keys of the template and will make use of the auxiliary added
// lines (ex: "# KICS_HELM_ID_")
func (d DetectKindLine) DetectLine(file *model.FileMetadata, searchKey string,
        outputLines int, logWithFields *zerolog.Logger) model.VulnerabilityLines <span class="cov2" title="3">{
        searchKey = fmt.Sprintf("%s.%s", strings.TrimRight(strings.TrimLeft(file.HelmID, "# "), ":"), searchKey)
        lines := *file.LinesOriginalData
        curLineRes := detectCurlLine{
                foundRes: false,
                lineRes:  0,
                breakRes: false,
        }
        var extractedString [][]string
        extractedString = detector.GetBracketValues(searchKey, extractedString, "")
        sanitizedSubstring := searchKey
        for idx, str := range extractedString </span><span class="cov3" title="6">{
                sanitizedSubstring = strings.Replace(sanitizedSubstring, str[0], `{{`+strconv.Itoa(idx)+`}}`, -1)
        }</span>

        <span class="cov2" title="3">helmID, err := strconv.Atoi(strings.TrimSuffix(strings.TrimPrefix(file.HelmID, "# KICS_HELM_ID_"), ":"))
        if err != nil </span><span class="cov0" title="0">{
                helmID = -1
        }</span>

        // Since we are only looking at keys we can ignore the second value passed through '=' and '[]'
        <span class="cov2" title="3">for _, key := range strings.Split(sanitizedSubstring, ".") </span><span class="cov5" title="18">{
                substr1, _ := detector.GenerateSubstrings(key, extractedString)
                curLineRes = curLineRes.detectCurrentLine(lines, fmt.Sprintf("%s:", substr1), "", true, file.IDInfo, helmID)

                if curLineRes.breakRes </span><span class="cov0" title="0">{
                        break</span>
                }
        }

        // Look at dupHistory to see if the last element was duplicate, if so
        // change the line to the last unique key
        <span class="cov2" title="3">if !curLineRes.lastUnique.unique </span><span class="cov1" title="1">{
                curLineRes.lineRes = curLineRes.lastUnique.lastUniqueLine
        }</span>

        <span class="cov2" title="3">if curLineRes.foundRes </span><span class="cov2" title="3">{
                lineRemove := make(map[int]int)
                count := 0
                for i, line := range lines </span><span class="cov7" title="74">{ // Remove auxiliary lines
                        if strings.Contains(line, "# KICS_HELM_ID_") </span><span class="cov3" title="4">{
                                count++
                                lineRemove[i] = count
                                lines = append(lines[:i], lines[i+1:]...)
                        }</span>
                }
                // Update found line
                <span class="cov2" title="3">curLineRes.lineRes = removeLines(curLineRes.lineRes, lineRemove)
                return model.VulnerabilityLines{
                        Line:                 curLineRes.lineRes + 1,
                        VulnLines:            detector.GetAdjacentVulnLines(curLineRes.lineRes, outputLines, lines),
                        LineWithVulnerabilty: strings.Split(lines[curLineRes.lineRes], ": ")[0],
                        ResolvedFile:         file.FilePath,
                }</span>
        }

        <span class="cov0" title="0">logWithFields.Warn().Msgf("Failed to detect line, query response %s", searchKey)

        return model.VulnerabilityLines{
                Line:         undetectedVulnerabilityLine,
                VulnLines:    &amp;[]model.CodeLine{},
                ResolvedFile: file.FilePath,
        }</span>
}

// removeLines is used to update the vulnerability line after removing the "# KICS_HELM_ID_"
func removeLines(current int, lineRemove map[int]int) int <span class="cov2" title="3">{
        orderByKey := make([]int, len(lineRemove))
        i := 0
        for k := range lineRemove </span><span class="cov3" title="4">{
                orderByKey[i] = k
                i++
        }</span>
        <span class="cov2" title="3">remove := 0
        sort.Ints(orderByKey)
        for _, k := range orderByKey </span><span class="cov3" title="4">{
                if current &gt; k </span><span class="cov3" title="4">{
                        remove = lineRemove[k]
                }</span> else<span class="cov0" title="0"> {
                        break</span>
                }
        }
        <span class="cov2" title="3">current -= remove
        return current</span>
}

func (d detectCurlLine) detectCurrentLine(lines []string, str1,
        str2 string, byKey bool, idInfo map[int]interface{}, id int) detectCurlLine <span class="cov5" title="18">{
        distances := make(map[int]int)
        for i := d.lineRes; i &lt; len(lines); i++ </span><span class="cov10" title="311">{
                if str1 != "" &amp;&amp; str2 != "" </span><span class="cov0" title="0">{
                        if strings.Contains(lines[i], str1) &amp;&amp; strings.Contains(lines[i], str2) </span><span class="cov0" title="0">{
                                distances[i] = levenshtein.ComputeDistance(detector.ExtractLineFragment(lines[i], str2, byKey), str2)
                        }</span>
                } else<span class="cov10" title="311"> if str1 != "" </span><span class="cov10" title="311">{
                        if strings.Contains(lines[i], str1) </span><span class="cov5" title="23">{
                                distances[i] = levenshtein.ComputeDistance(
                                        detector.ExtractLineFragment(strings.TrimSpace(lines[i]), str1, byKey), str1)
                        }</span>
                }
        }

        <span class="cov5" title="18">lastSingle := d.lastUnique.lastUniqueLine

        if len(distances) == 0 </span><span class="cov0" title="0">{
                return detectCurlLine{
                        foundRes: d.foundRes,
                        lineRes:  d.lineRes,
                        breakRes: true,
                        lastUnique: dupHistory{
                                lastUniqueLine: lastSingle,
                                unique:         d.lastUnique.unique,
                        },
                }
        }</span>

        <span class="cov5" title="18">lineResponse := detector.SelectLineWithMinimumDistance(distances, d.lineRes)
        // if lineResponse is unique
        unique := detectLastSingle(lineResponse, distances, idInfo, id)
        if unique </span><span class="cov5" title="17">{
                lastSingle = lineResponse
        }</span>

        <span class="cov5" title="18">return detectCurlLine{
                foundRes: true,
                lineRes:  lineResponse,
                breakRes: false,
                lastUnique: dupHistory{
                        unique:         unique,
                        lastUniqueLine: lastSingle,
                },
        }</span>
}

// detectLastSingle checks if the line is unique or a duplicate
func detectLastSingle(line int, dis map[int]int, idInfo map[int]interface{}, id int) bool <span class="cov5" title="18">{
        if idInfo == nil </span><span class="cov4" title="12">{
                return true
        }</span>
        <span class="cov3" title="6">for key, value := range dis </span><span class="cov4" title="9">{
                if value == dis[line] &amp;&amp; key != line </span><span class="cov1" title="1">{
                        // check if we are only looking at original data equivalent to the vulnerability
                        if ok := idInfo[id].(map[int]int)[key]; ok != 0 </span><span class="cov1" title="1">{
                                return false
                        }</span>
                }
        }
        <span class="cov3" title="5">return true</span>
}
</pre>
		
		<pre class="file" id="file32" style="display: none">package detector

import (
        "fmt"
        "regexp"
        "strconv"
        "strings"

        "github.com/agnivade/levenshtein"

        "github.com/Checkmarx/kics/internal/constants"
        "github.com/Checkmarx/kics/pkg/model"
        "github.com/rs/zerolog/log"
)

var (
        nameRegex       = regexp.MustCompile(`^([A-Za-z\d-_]+)\[([A-Za-z\d-_{}]+)]$`)
        nameRegexDocker = regexp.MustCompile(`{{(.*?)}}`)
)

const (
        namePartsLength  = 3
        valuePartsLength = 2
)

// DefaultDetectLineResponse is the default response for struct DetectLine
type DefaultDetectLineResponse struct {
        CurrentLine     int
        IsBreak         bool
        FoundAtLeastOne bool
        ResolvedFile    string
        ResolvedFiles   map[string]model.ResolvedFileSplit
}

// GetBracketValues gets values inside "{{ }}" ignoring any "{{" or "}}" inside
func GetBracketValues(expr string, list [][]string, restOfString string) [][]string <span class="cov7" title="21">{
        var tempList []string
        firstOpen := strings.Index(expr, "{{")
        firstClose := strings.Index(expr, "}}")
        for firstOpen &gt; firstClose &amp;&amp; firstClose != -1 </span><span class="cov1" title="1">{
                firstClose = strings.Index(expr[firstOpen:], "}}") + firstOpen
        }</span>
        // in case we have '}}}' we need to advance one position to get the close
        <span class="cov7" title="21">for firstClose+2 &lt; len(expr) &amp;&amp; string(expr[firstClose+2]) == `}` &amp;&amp; firstClose != -1 </span><span class="cov1" title="1">{
                firstClose++
        }</span>

        <span class="cov7" title="21">switch t := firstClose - firstOpen; t &gt;= 0 </span>{
        case true:<span class="cov7" title="18">
                if t == 0 &amp;&amp; expr != "" </span><span class="cov5" title="8">{
                        tempList = append(tempList, fmt.Sprintf("{{%s}}", expr), expr)
                        list = append(list, tempList)
                }</span>
                <span class="cov7" title="18">if t == 0 &amp;&amp; restOfString == "" </span><span class="cov5" title="9">{
                        return list // if there is no more string to read from return value of list
                }</span>
                <span class="cov5" title="9">if t &gt; 0 &amp;&amp; firstOpen+2 &lt;= firstClose </span><span class="cov5" title="8">{
                        list = GetBracketValues(expr[firstOpen+2:firstClose], list, expr[firstClose+2:])
                }</span> else<span class="cov1" title="1"> {
                        list = GetBracketValues(restOfString, list, "") // recursive call to the rest of the string
                }</span>
        case false:<span class="cov3" title="3">
                nextClose := strings.Index(restOfString, "}}")
                tempNextClose := nextClose + 2
                if tempNextClose == len(restOfString) </span><span class="cov2" title="2">{
                        tempNextClose = nextClose
                }</span>
                <span class="cov3" title="3">tempList = append(tempList, fmt.Sprintf("{{%s}}%s}}", expr, restOfString[:tempNextClose]),
                        fmt.Sprintf("%s}}%s", expr, restOfString[:tempNextClose]))
                list = append(list, tempList)
                list = GetBracketValues(restOfString[nextClose+2:], list, "")</span> // recursive call to the rest of the string
        }

        <span class="cov6" title="12">return list</span>
}

// GenerateSubstrings returns the substrings used for line searching depending on search key
// '.' is new line
// '=' is value in the same line
// '[]' is in the same line
func GenerateSubstrings(key string, extractedString [][]string) (substr1Res, substr2Res string) <span class="cov4" title="5">{
        var substr1, substr2 string
        if parts := nameRegex.FindStringSubmatch(key); len(parts) == namePartsLength </span><span class="cov2" title="2">{
                substr1, substr2 = getKeyWithCurlyBrackets(key, extractedString, parts)
        }</span> else<span class="cov3" title="3"> if parts := strings.Split(key, "="); len(parts) == valuePartsLength </span><span class="cov1" title="1">{
                substr1, substr2 = getKeyWithCurlyBrackets(key, extractedString, parts)
        }</span> else<span class="cov2" title="2"> {
                parts := []string{key, ""}
                substr1, substr2 = getKeyWithCurlyBrackets(key, extractedString, parts)
        }</span>
        <span class="cov4" title="5">return substr1, substr2</span>
}

func getKeyWithCurlyBrackets(key string, extractedString [][]string, parts []string) (substr1Res, substr2Res string) <span class="cov4" title="5">{
        var substr1, substr2 string
        extractedPart := nameRegexDocker.FindStringSubmatch(key)
        if len(extractedPart) == valuePartsLength </span><span class="cov1" title="1">{
                for idx, key := range parts </span><span class="cov2" title="2">{
                        if extractedPart[0] == key </span><span class="cov1" title="1">{
                                switch idx </span>{
                                case len(parts) - 2:<span class="cov0" title="0">
                                        i, err := strconv.Atoi(extractedPart[1])
                                        if err != nil </span><span class="cov0" title="0">{
                                                log.Error().Msgf("failed to extract curly brackets substring")
                                        }</span>
                                        <span class="cov0" title="0">if len(extractedString) &gt; i </span><span class="cov0" title="0">{
                                                if len(extractedString[i][1]) &gt; 0 </span><span class="cov0" title="0">{
                                                        substr1 = extractedString[i][1]
                                                }</span>
                                        }
                                case len(parts) - 1:<span class="cov1" title="1">
                                        i, err := strconv.Atoi(extractedPart[1])
                                        if err != nil </span><span class="cov0" title="0">{
                                                log.Error().Msgf("failed to extract curly brackets substring")
                                        }</span>
                                        <span class="cov1" title="1">if len(extractedString) &gt; i </span><span class="cov1" title="1">{
                                                if len(extractedString[i][1]) &gt; 0 </span><span class="cov1" title="1">{
                                                        substr2 = extractedString[i][1]
                                                }</span>
                                        }
                                }
                        } else<span class="cov1" title="1"> {
                                substr1 = generateSubstr(substr1, parts, valuePartsLength)
                                substr2 = generateSubstr(substr2, parts, 1)
                        }</span>
                }
        } else<span class="cov4" title="4"> {
                substr1 = parts[len(parts)-2]
                substr2 = parts[len(parts)-1]
        }</span>

        <span class="cov4" title="5">return substr1, substr2</span>
}

func generateSubstr(substr string, parts []string, length int) string <span class="cov2" title="2">{
        if substr == "" </span><span class="cov2" title="2">{
                substr = parts[len(parts)-length]
        }</span>
        <span class="cov2" title="2">return substr</span>
}

// GetAdjacentVulnLines is used to get the lines adjacent to the line that contains the vulnerability
// adj is the amount of lines wanted
func GetAdjacentVulnLines(idx, adj int, lines []string) *[]model.CodeLine <span class="cov6" title="11">{
        var endPos int
        var startPos int
        if adj &lt;= len(lines) </span><span class="cov6" title="10">{
                endPos = idx + adj/2 + 1 // if adj lines passes the number of lines in file
                if len(lines) &lt; endPos </span><span class="cov1" title="1">{
                        endPos = len(lines)
                }</span>
                <span class="cov6" title="10">startAdj := adj
                if adj%2 == 0 </span><span class="cov2" title="2">{
                        startAdj--
                }</span>

                <span class="cov6" title="10">startPos = idx - startAdj/2 // if adj lines passes the first line in the file
                if startPos &lt; 0 </span><span class="cov3" title="3">{
                        startPos = 0
                }</span>
        } else<span class="cov1" title="1"> { // in case adj is bigger than number of lines in file
                adj = len(lines)
                endPos = len(lines)
                startPos = 0
        }</span>

        <span class="cov6" title="11">switch idx </span>{
        case 0:<span class="cov4" title="4">
                // case vulnerability is the first line of the file
                return createVulnLines(1, lines[:adj])</span>
        case len(lines) - 1:<span class="cov3" title="3">
                // case vulnerability is the last line of the file
                return createVulnLines(startPos+1, lines[len(lines)-adj:])</span>
        default:<span class="cov4" title="4">
                // case vulnerability is in the middle of the file
                return createVulnLines(startPos+1, lines[startPos:endPos])</span>
        }
}

// createVulnLines is the function that will  generate the array that contains the lines numbers
// used to alter the color of the line that contains the vulnerability
func createVulnLines(startPos int, lines []string) *[]model.CodeLine <span class="cov6" title="11">{
        vulns := make([]model.CodeLine, len(lines))
        for idx, line := range lines </span><span class="cov8" title="30">{
                vulns[idx] = model.CodeLine{
                        Line:     line,
                        Position: startPos,
                }
                startPos++
        }</span>
        <span class="cov6" title="11">return &amp;vulns</span>
}

// SelectLineWithMinimumDistance will search a map of levenshtein distances to find the minimum distance
func SelectLineWithMinimumDistance(distances map[int]int, startingFrom int) int <span class="cov5" title="8">{
        minDistance, lineOfMinDistance := constants.MaxInteger, startingFrom
        for line, distance := range distances </span><span class="cov6" title="11">{
                if distance &lt; minDistance || distance == minDistance &amp;&amp; line &lt; lineOfMinDistance </span><span class="cov6" title="10">{
                        minDistance = distance
                        lineOfMinDistance = line
                }</span>
        }

        <span class="cov5" title="8">return lineOfMinDistance</span>
}

// ExtractLineFragment will prepare substr for line detection
func ExtractLineFragment(line, substr string, key bool) string <span class="cov5" title="9">{
        // If detecting line by keys only
        idx := strings.Index(line, ":")
        if key &amp;&amp; idx &gt;= 0 </span><span class="cov0" title="0">{
                return line[:idx]
        }</span>
        <span class="cov5" title="9">start := strings.Index(line, substr)
        end := start + len(substr)

        for start &gt;= 0 </span><span class="cov7" title="22">{
                if line[start] == ' ' </span><span class="cov5" title="7">{
                        break</span>
                }

                <span class="cov7" title="15">start--</span>
        }

        <span class="cov5" title="9">for end &lt; len(line) </span><span class="cov6" title="13">{
                if line[end] == ' ' </span><span class="cov5" title="7">{
                        break</span>
                }

                <span class="cov4" title="6">end++</span>
        }

        <span class="cov5" title="9">return removeExtras(line, start, end)</span>
}

func removeExtras(result string, start, end int) string <span class="cov5" title="9">{
        // workaround for selecting yaml keys
        if result[end-1] == ':' </span><span class="cov1" title="1">{
                end--
        }</span>

        <span class="cov5" title="9">if result[end-1] == '"' </span><span class="cov4" title="5">{
                end--
        }</span>

        <span class="cov5" title="9">if result[start+1] == '"' </span><span class="cov4" title="5">{
                start++
        }</span>

        <span class="cov5" title="9">return result[start+1 : end]</span>
}

// DetectCurrentLine uses levenshtein distance to find the most accurate line for the vulnerability
func (d *DefaultDetectLineResponse) DetectCurrentLine(str1, str2 string, recurseCount int,
        lines []string) (det *DefaultDetectLineResponse, l []string) <span class="cov4" title="6">{
        distances := make(map[int]int)

        for i := d.CurrentLine; i &lt; len(lines); i++ </span><span class="cov10" title="58">{
                if len(d.ResolvedFiles) &gt; 0 </span><span class="cov3" title="3">{
                        if res, newLines := d.checkResolvedFile(lines[i], str1, str2, recurseCount); res.FoundAtLeastOne </span><span class="cov0" title="0">{
                                return res, newLines
                        }</span>
                }
                <span class="cov10" title="58">distances = checkLine(str1, str2, distances, lines[i], i)</span>
        }

        <span class="cov4" title="6">if len(distances) == 0 </span><span class="cov1" title="1">{
                d.IsBreak = true
                return d, lines
        }</span>

        <span class="cov4" title="5">d.CurrentLine = SelectLineWithMinimumDistance(distances, d.CurrentLine)
        d.IsBreak = false
        d.FoundAtLeastOne = true

        return d, lines</span>
}

func checkLine(str1, str2 string, distances map[int]int, line string, i int) map[int]int <span class="cov10" title="58">{
        if str1 != "" &amp;&amp; str2 != "" &amp;&amp; strings.Contains(line, str1) </span><span class="cov4" title="5">{
                restLine := line[strings.Index(line, str1)+len(str1):]
                if strings.Contains(restLine, str2) </span><span class="cov4" title="4">{
                        distances[i] = levenshtein.ComputeDistance(ExtractLineFragment(line, str1, false), str1)
                        distances[i] += levenshtein.ComputeDistance(ExtractLineFragment(restLine, str2, false), str2)
                }</span>
        } else<span class="cov9" title="53"> if str1 != "" &amp;&amp; strings.Contains(line, str1) </span><span class="cov1" title="1">{
                distances[i] = levenshtein.ComputeDistance(ExtractLineFragment(line, str1, false), str1)
        }</span>

        <span class="cov10" title="58">return distances</span>
}

func (d *DefaultDetectLineResponse) checkResolvedFile(line, str1, st2 string,
        recurseCount int) (det *DefaultDetectLineResponse, l []string) <span class="cov4" title="4">{
        for key, r := range d.ResolvedFiles </span><span class="cov4" title="4">{
                if strings.Contains(line, key) </span><span class="cov1" title="1">{
                        if recurseCount &gt; constants.MaxResolvedFiles </span><span class="cov0" title="0">{
                                break</span>
                        }
                        <span class="cov1" title="1">return d.restore(r.Path).DetectCurrentLine(str1, st2, recurseCount+1, r.Lines)</span>
                }
        }

        <span class="cov3" title="3">d.CurrentLine = 0
        d.IsBreak = false
        d.FoundAtLeastOne = false

        return d, []string{}</span>
}

func (d *DefaultDetectLineResponse) restore(file string) *DefaultDetectLineResponse <span class="cov2" title="2">{
        restore := &amp;DefaultDetectLineResponse{
                CurrentLine:     0,
                IsBreak:         d.IsBreak,
                FoundAtLeastOne: false,
                ResolvedFile:    file,
                ResolvedFiles:   d.ResolvedFiles,
        }

        return restore
}</span>
</pre>
		
		<pre class="file" id="file33" style="display: none">package detector

import (
        "encoding/json"
        "strconv"
        "strings"

        "github.com/Checkmarx/kics/pkg/model"
        "github.com/tidwall/gjson"
)

// searchLineDetector is the struct used to get the line from the payload with lines information
// content - payload with line information
// resolvedPath - string created from pathComponents, used to create gjson paths
// resolvedArrayPath - string created from pathComponents containing an array used to create gjson paths
// targetObj - key of the interface{}, we want the line from
type searchLineDetector struct {
        content           []byte
        resolvedPath      string
        resolvedArrayPath string
        targetObj         string
}

// GetLineBySearchLine makes use of the gjson pkg to find the line of a key in the original file
// with it's path given by a slice of strings
func GetLineBySearchLine(pathComponents []string, file *model.FileMetadata) (int, error) <span class="cov6" title="5">{
        content, err := json.Marshal(file.LineInfoDocument)
        if err != nil </span><span class="cov0" title="0">{
                return -1, err
        }</span>

        <span class="cov6" title="5">detector := &amp;searchLineDetector{
                content: content,
        }

        return detector.preparePath(pathComponents), nil</span>
}

// preparePath resolves the path components and retrives important information
// for the creation of the paths to search
func (d *searchLineDetector) preparePath(pathItems []string) int <span class="cov6" title="5">{
        if len(pathItems) == 0 </span><span class="cov0" title="0">{
                return 1
        }</span>
        // Escaping '.' in path components so it doesn't conflict with gjson pkg
        <span class="cov6" title="5">objPath := strings.ReplaceAll(pathItems[0], ".", "\\.")
        ArrPath := strings.ReplaceAll(pathItems[0], ".", "\\.")

        obj := pathItems[len(pathItems)-1]

        arrayObject := ""

        // Iterate reversely through the path componets and get the key of the last array in the path
        // needed for cases where the fields in the array are &lt;"key": "value"&gt; type and not &lt;object&gt;
        foundArrayIdx := false
        for i := len(pathItems) - 1; i &gt;= 0; i-- </span><span class="cov10" title="14">{
                if _, err := strconv.Atoi(pathItems[i]); err == nil </span><span class="cov4" title="3">{
                        foundArrayIdx = true
                        continue</span>
                }
                <span class="cov9" title="11">if foundArrayIdx </span><span class="cov4" title="3">{
                        arrayObject = pathItems[i]
                        break</span>
                }
        }

        <span class="cov6" title="5">if arrayObject == objPath </span><span class="cov3" title="2">{
                ArrPath = "_kics_lines._kics_" + arrayObject + "._kics_arr"
        }</span>

        <span class="cov6" title="5">var treatedPathItems []string
        if len(pathItems) &gt; 1 </span><span class="cov6" title="5">{
                treatedPathItems = pathItems[1 : len(pathItems)-1]
        }</span>

        // Create a string based on the path components so it can be later transformed in a gjson path
        <span class="cov6" title="5">for _, pathItem := range treatedPathItems </span><span class="cov6" title="5">{
                // In case of an array present
                if pathItem == arrayObject </span><span class="cov1" title="1">{
                        ArrPath += "._kics_lines._kics_" + strings.ReplaceAll(pathItem, ".", "\\.") + "._kics_arr"
                }</span> else<span class="cov5" title="4"> {
                        ArrPath += "." + strings.ReplaceAll(pathItem, ".", "\\.")
                }</span>
                <span class="cov6" title="5">objPath += "." + strings.ReplaceAll(pathItem, ".", "\\.")</span>
        }

        <span class="cov6" title="5">d.resolvedPath = objPath
        d.resolvedArrayPath = ArrPath
        d.targetObj = obj

        return d.getResult()</span>
}

// getResult creates the paths to be used by gjson pkg to find the line in the content
func (d *searchLineDetector) getResult() int <span class="cov6" title="5">{
        pathObjects := []string{
                d.resolvedPath + "._kics_lines._kics_" + d.targetObj + "._kics_line",
                d.resolvedPath + "." + d.targetObj + "._kics_lines._kics__default._kics_line",
                d.resolvedArrayPath + "." + d.targetObj + "._kics__default._kics_line",
                d.resolvedArrayPath + "._kics_" + d.targetObj + "._kics_line",
        }

        result := -1
        // run gjson pkg
        for _, pathItem := range pathObjects </span><span class="cov8" title="10">{
                if tmpResult := gjson.GetBytes(d.content, pathItem); int(tmpResult.Int()) &gt; 0 </span><span class="cov6" title="5">{
                        result = int(tmpResult.Int())
                        break</span>
                }
        }
        <span class="cov6" title="5">return result</span>
}
</pre>
		
		<pre class="file" id="file34" style="display: none">package engine

import (
        "bytes"
        "context"
        "encoding/json"
        "fmt"
        "strings"
        "time"

        "github.com/Checkmarx/kics/internal/metrics"
        sentryReport "github.com/Checkmarx/kics/internal/sentry"
        "github.com/Checkmarx/kics/pkg/detector"
        "github.com/Checkmarx/kics/pkg/detector/docker"
        "github.com/Checkmarx/kics/pkg/detector/helm"
        "github.com/Checkmarx/kics/pkg/engine/source"
        "github.com/Checkmarx/kics/pkg/model"
        "github.com/open-policy-agent/opa/ast"
        "github.com/open-policy-agent/opa/cover"
        "github.com/open-policy-agent/opa/rego"
        "github.com/open-policy-agent/opa/storage/inmem"
        "github.com/open-policy-agent/opa/topdown"
        "github.com/open-policy-agent/opa/util"
        "github.com/pkg/errors"
        "github.com/rs/zerolog/log"
)

// Default values for inspector
const (
        UndetectedVulnerabilityLine = -1
        DefaultQueryID              = "Undefined"
        DefaultQueryName            = "Anonymous"
        DefaultQueryDescription     = "Undefined"
        DefaultQueryDescriptionID   = "Undefined"
        DefaultQueryURI             = "https://github.com/Checkmarx/kics/"
        DefaultIssueType            = model.IssueTypeIncorrectValue

        regoQuery = `result = data.Cx.CxPolicy`
)

// ErrNoResult - error representing when a query didn't return a result
var ErrNoResult = errors.New("query: not result")

// ErrInvalidResult - error representing invalid result
var ErrInvalidResult = errors.New("query: invalid result format")

// QueryLoader is responsible for loading the queries for the inspector
type QueryLoader struct {
        commonLibrary     source.RegoLibraries
        platformLibraries map[string]source.RegoLibraries
        querySum          int
        QueriesMetadata   []model.QueryMetadata
}

// VulnerabilityBuilder represents a function that will build a vulnerability
type VulnerabilityBuilder func(ctx *QueryContext, tracker Tracker, v interface{},
        detector *detector.DetectLine) (*model.Vulnerability, error)

// PreparedQuery includes the opaQuery and its metadata
type PreparedQuery struct {
        OpaQuery rego.PreparedEvalQuery
        Metadata model.QueryMetadata
}

// Inspector represents a list of compiled queries, a builder for vulnerabilities, an information tracker
// a flag to enable coverage and the coverage report if it is enabled
type Inspector struct {
        QueryLoader    *QueryLoader
        vb             VulnerabilityBuilder
        tracker        Tracker
        failedQueries  map[string]error
        excludeResults map[string]bool
        detector       *detector.DetectLine

        enableCoverageReport bool
        coverageReport       cover.Report
        queryExecTimeout     time.Duration
}

// QueryContext contains the context where the query is executed, which scan it belongs, basic information of query,
// the query compiled and its payload
type QueryContext struct {
        Ctx           context.Context
        scanID        string
        Files         map[string]model.FileMetadata
        Query         *PreparedQuery
        payload       *ast.Value
        BaseScanPaths []string
}

var (
        unsafeRegoFunctions = map[string]struct{}{
                "http.send":   {},
                "opa.runtime": {},
        }
)

// NewInspector initializes a inspector, compiling and loading queries for scan and its tracker
func NewInspector(
        ctx context.Context,
        queriesSource source.QueriesSource,
        vb VulnerabilityBuilder,
        tracker Tracker,
        queryParameters *source.QueryInspectorParameters,
        excludeResults map[string]bool,
        queryTimeout int,
        needsLog bool) (*Inspector, error) <span class="cov5" title="4">{
        log.Debug().Msg("engine.NewInspector()")

        metrics.Metric.Start("get_queries")
        queries, err := queriesSource.GetQueries(queryParameters)
        if err != nil </span><span class="cov0" title="0">{
                return nil, errors.Wrap(err, "failed to get queries")
        }</span>

        <span class="cov5" title="4">commonLibrary, err := queriesSource.GetQueryLibrary("common")
        if err != nil </span><span class="cov0" title="0">{
                sentryReport.ReportSentry(&amp;sentryReport.Report{
                        Message:  fmt.Sprintf("Inspector failed to get library for %s platform", "common"),
                        Err:      err,
                        Location: "func NewInspector()",
                        Platform: "common",
                }, true)
                return nil, errors.Wrap(err, "failed to get library")
        }</span>
        <span class="cov5" title="4">platformLibraries := getPlatformLibraries(queriesSource, queries)

        queryLoader := prepareQueries(queries, commonLibrary, platformLibraries, tracker)

        failedQueries := make(map[string]error)

        metrics.Metric.Stop()

        if needsLog </span><span class="cov5" title="4">{
                log.Info().
                        Msgf("Inspector initialized, number of queries=%d", queryLoader.querySum)
        }</span>

        <span class="cov5" title="4">lineDetector := detector.NewDetectLine(tracker.GetOutputLines()).
                Add(helm.DetectKindLine{}, model.KindHELM).
                Add(docker.DetectKindLine{}, model.KindDOCKER).
                Add(docker.DetectKindLine{}, model.KindBUILDAH)

        queryExecTimeout := time.Duration(queryTimeout) * time.Second

        if needsLog </span><span class="cov5" title="4">{
                log.Info().Msgf("Query execution timeout=%v", queryExecTimeout)
        }</span>

        <span class="cov5" title="4">return &amp;Inspector{
                QueryLoader:      &amp;queryLoader,
                vb:               vb,
                tracker:          tracker,
                failedQueries:    failedQueries,
                excludeResults:   excludeResults,
                detector:         lineDetector,
                queryExecTimeout: queryExecTimeout,
        }, nil</span>
}

func getPlatformLibraries(queriesSource source.QueriesSource, queries []model.QueryMetadata) map[string]source.RegoLibraries <span class="cov5" title="4">{
        supportedPlatforms := make(map[string]string)
        for _, query := range queries </span><span class="cov9" title="18">{
                supportedPlatforms[query.Platform] = ""
        }</span>
        <span class="cov5" title="4">platformLibraries := make(map[string]source.RegoLibraries)
        for platform := range supportedPlatforms </span><span class="cov8" title="11">{
                platformLibrary, errLoadingPlatformLib := queriesSource.GetQueryLibrary(platform)
                if errLoadingPlatformLib != nil </span><span class="cov3" title="2">{
                        sentryReport.ReportSentry(&amp;sentryReport.Report{
                                Message:  fmt.Sprintf("Inspector failed to get library for %s platform", platform),
                                Err:      errLoadingPlatformLib,
                                Location: "func getPlatformLibraries()",
                                Platform: platform,
                        }, true)
                        continue</span>
                }
                <span class="cov7" title="9">platformLibraries[platform] = platformLibrary</span>
        }
        <span class="cov5" title="4">return platformLibraries</span>
}

// Inspect scan files and return the a list of vulnerabilities found on the process
func (c *Inspector) Inspect(
        ctx context.Context,
        scanID string,
        files model.FileMetadatas,
        baseScanPaths []string,
        platforms []string,
        currentQuery chan&lt;- int64) ([]model.Vulnerability, error) <span class="cov3" title="2">{
        log.Debug().Msg("engine.Inspect()")
        combinedFiles := files.Combine(false)

        var vulnerabilities []model.Vulnerability
        vulnerabilities = make([]model.Vulnerability, 0)
        var p interface{}

        payload, err := json.Marshal(combinedFiles)
        if err != nil </span><span class="cov0" title="0">{
                return vulnerabilities, err
        }</span>

        <span class="cov3" title="2">err = util.UnmarshalJSON(payload, &amp;p)
        if err != nil </span><span class="cov0" title="0">{
                return vulnerabilities, err
        }</span>

        <span class="cov3" title="2">astPayload, err := ast.InterfaceToValue(p)
        if err != nil </span><span class="cov0" title="0">{
                return vulnerabilities, err
        }</span>

        <span class="cov3" title="2">queries := c.getQueriesByPlat(platforms)
        for i, queryMeta := range queries </span><span class="cov3" title="2">{
                currentQuery &lt;- 1

                queryOpa, err := c.QueryLoader.LoadQuery(ctx, &amp;queries[i])
                if err != nil </span><span class="cov0" title="0">{
                        continue</span>
                }

                <span class="cov3" title="2">log.Debug().Msgf("Starting to run query %s", queryMeta.Query)
                queryStartTime := time.Now()

                query := &amp;PreparedQuery{
                        OpaQuery: *queryOpa,
                        Metadata: queryMeta,
                }

                queryContext := &amp;QueryContext{
                        Ctx:           ctx,
                        scanID:        scanID,
                        Files:         files.ToMap(),
                        Query:         query,
                        payload:       &amp;astPayload,
                        BaseScanPaths: baseScanPaths,
                }

                vuls, err := c.doRun(queryContext)

                if err != nil </span><span class="cov0" title="0">{
                        sentryReport.ReportSentry(&amp;sentryReport.Report{
                                Message:  fmt.Sprintf("Inspector. query executed with error, query=%s", query.Metadata.Query),
                                Err:      err,
                                Location: "func Inspect()",
                                Platform: query.Metadata.Platform,
                                Metadata: query.Metadata.Metadata,
                                Query:    query.Metadata.Query,
                        }, true)

                        c.failedQueries[query.Metadata.Query] = err

                        continue</span>
                }

                <span class="cov3" title="2">log.Debug().Msgf("Finished to run query %s after %v", queryMeta.Query, time.Since(queryStartTime))

                vulnerabilities = append(vulnerabilities, vuls...)

                c.tracker.TrackQueryExecution(query.Metadata.Aggregation)</span>
        }

        <span class="cov3" title="2">return vulnerabilities, nil</span>
}

// LenQueriesByPlat returns the number of queries by platforms
func (c *Inspector) LenQueriesByPlat(platforms []string) int <span class="cov3" title="2">{
        count := 0
        for _, query := range c.QueryLoader.QueriesMetadata </span><span class="cov7" title="9">{
                if contains(platforms, query.Platform) </span><span class="cov5" title="4">{
                        c.tracker.TrackQueryExecuting(query.Aggregation)
                        count++
                }</span>
        }
        <span class="cov3" title="2">return count</span>
}

func (c *Inspector) getQueriesByPlat(platforms []string) []model.QueryMetadata <span class="cov3" title="2">{
        queries := make([]model.QueryMetadata, 0)
        for _, query := range c.QueryLoader.QueriesMetadata </span><span class="cov3" title="2">{
                if contains(platforms, query.Platform) </span><span class="cov3" title="2">{
                        queries = append(queries, query)
                }</span>
        }
        <span class="cov3" title="2">return queries</span>
}

// EnableCoverageReport enables the flag to create a coverage report
func (c *Inspector) EnableCoverageReport() <span class="cov1" title="1">{
        c.enableCoverageReport = true
}</span>

// GetCoverageReport returns the scan coverage report
func (c *Inspector) GetCoverageReport() cover.Report <span class="cov1" title="1">{
        return c.coverageReport
}</span>

// GetFailedQueries returns a map of failed queries and the associated error
func (c *Inspector) GetFailedQueries() map[string]error <span class="cov1" title="1">{
        return c.failedQueries
}</span>

func (c *Inspector) doRun(ctx *QueryContext) ([]model.Vulnerability, error) <span class="cov3" title="2">{
        timeoutCtx, cancel := context.WithTimeout(ctx.Ctx, c.queryExecTimeout)
        defer cancel()
        options := []rego.EvalOption{rego.EvalParsedInput(*ctx.payload)}

        var cov *cover.Cover
        if c.enableCoverageReport </span><span class="cov3" title="2">{
                cov = cover.New()
                options = append(options, rego.EvalQueryTracer(cov))
        }</span>

        <span class="cov3" title="2">results, err := ctx.Query.OpaQuery.Eval(timeoutCtx, options...)
        ctx.payload = nil
        if err != nil </span><span class="cov0" title="0">{
                if topdown.IsCancel(err) </span><span class="cov0" title="0">{
                        return nil, errors.Wrap(err, "query executing timeout exited")
                }</span>

                <span class="cov0" title="0">return nil, errors.Wrap(err, "failed to evaluate query")</span>
        }
        <span class="cov3" title="2">if c.enableCoverageReport &amp;&amp; cov != nil </span><span class="cov3" title="2">{
                module, parseErr := ast.ParseModule(ctx.Query.Metadata.Query, ctx.Query.Metadata.Content)
                if parseErr != nil </span><span class="cov0" title="0">{
                        return nil, errors.Wrap(parseErr, "failed to parse coverage module")
                }</span>

                <span class="cov3" title="2">c.coverageReport = cov.Report(map[string]*ast.Module{
                        ctx.Query.Metadata.Query: module,
                })</span>
        }

        <span class="cov3" title="2">log.Trace().
                Str("scanID", ctx.scanID).
                Msgf("Inspector executed with result %+v, query=%s", results, ctx.Query.Metadata.Query)

        return c.DecodeQueryResults(ctx, results)</span>
}

// DecodeQueryResults decodes the results into []model.Vulnerability
func (c *Inspector) DecodeQueryResults(ctx *QueryContext, results rego.ResultSet) ([]model.Vulnerability, error) <span class="cov3" title="2">{
        if len(results) == 0 </span><span class="cov0" title="0">{
                return nil, ErrNoResult
        }</span>

        <span class="cov3" title="2">result := results[0].Bindings

        queryResult, ok := result["result"]
        if !ok </span><span class="cov0" title="0">{
                return nil, ErrNoResult
        }</span>

        <span class="cov3" title="2">queryResultItems, ok := queryResult.([]interface{})
        if !ok </span><span class="cov0" title="0">{
                return nil, ErrInvalidResult
        }</span>

        <span class="cov3" title="2">vulnerabilities := make([]model.Vulnerability, 0, len(queryResultItems))
        failedDetectLine := false
        for _, queryResultItem := range queryResultItems </span><span class="cov3" title="2">{
                vulnerability, err := c.vb(ctx, c.tracker, queryResultItem, c.detector)
                if err != nil </span><span class="cov0" title="0">{
                        sentryReport.ReportSentry(&amp;sentryReport.Report{
                                Message:  fmt.Sprintf("Inspector can't save vulnerability, query=%s", ctx.Query.Metadata.Query),
                                Err:      err,
                                Location: "func decodeQueryResults()",
                                Platform: ctx.Query.Metadata.Platform,
                                Metadata: ctx.Query.Metadata.Metadata,
                                Query:    ctx.Query.Metadata.Query,
                        }, true)

                        if _, ok := c.failedQueries[ctx.Query.Metadata.Query]; !ok </span><span class="cov0" title="0">{
                                c.failedQueries[ctx.Query.Metadata.Query] = err
                        }</span>

                        <span class="cov0" title="0">continue</span>
                }
                <span class="cov3" title="2">file := ctx.Files[vulnerability.FileID]
                if ShouldSkipVulnerability(file.Commands, vulnerability.QueryID) </span><span class="cov0" title="0">{
                        log.Debug().Msgf("Skipping vulnerability in file %s for query '%s':%s", file.FilePath, vulnerability.QueryName, vulnerability.QueryID)
                        continue</span>
                }

                <span class="cov3" title="2">if vulnerability.Line == UndetectedVulnerabilityLine </span><span class="cov0" title="0">{
                        failedDetectLine = true
                }</span>

                <span class="cov3" title="2">if _, ok := c.excludeResults[vulnerability.SimilarityID]; ok </span><span class="cov1" title="1">{
                        log.Debug().
                                Msgf("Excluding result SimilarityID: %s", vulnerability.SimilarityID)
                        continue</span>
                } else<span class="cov1" title="1"> if checkComment(vulnerability.Line, file.LinesIgnore) </span><span class="cov0" title="0">{
                        log.Debug().
                                Msgf("Excluding result Comment: %s", vulnerability.SimilarityID)
                        continue</span>
                }

                <span class="cov1" title="1">vulnerabilities = append(vulnerabilities, *vulnerability)</span>
        }

        <span class="cov3" title="2">if failedDetectLine </span><span class="cov0" title="0">{
                c.tracker.FailedDetectLine()
        }</span>

        <span class="cov3" title="2">return vulnerabilities, nil</span>
}

// checkComment checks if the vulnerability should be skipped from comment
func checkComment(line int, ignoreLines []int) bool <span class="cov4" title="3">{
        for _, ignoreLine := range ignoreLines </span><span class="cov7" title="9">{
                if line == ignoreLine </span><span class="cov1" title="1">{
                        return true
                }</span>
        }
        <span class="cov3" title="2">return false</span>
}

// contains is a simple method to check if a slice
// contains an entry
func contains(s []string, e string) bool <span class="cov9" title="15">{
        if e == "common" </span><span class="cov3" title="2">{
                return true
        }</span>
        <span class="cov8" title="13">if e == "k8s" </span><span class="cov1" title="1">{
                e = "kubernetes"
        }</span>
        <span class="cov8" title="13">for _, a := range s </span><span class="cov9" title="14">{
                if strings.EqualFold(a, e) </span><span class="cov6" title="7">{
                        return true
                }</span>
        }
        <span class="cov6" title="6">return false</span>
}

func isDisabled(queries, queryID string, output bool) bool <span class="cov5" title="4">{
        for _, query := range strings.Split(queries, ",") </span><span class="cov5" title="4">{
                if strings.EqualFold(query, queryID) </span><span class="cov3" title="2">{
                        return output
                }</span>
        }

        <span class="cov3" title="2">return !output</span>
}

// ShouldSkipVulnerability verifies if the vulnerability in question should be ignored through comment commands
func ShouldSkipVulnerability(command model.CommentsCommands, queryID string) bool <span class="cov6" title="7">{
        if queries, ok := command["enable"]; ok </span><span class="cov3" title="2">{
                return isDisabled(queries, queryID, false)
        }</span>
        <span class="cov5" title="5">if queries, ok := command["disable"]; ok </span><span class="cov3" title="2">{
                return isDisabled(queries, queryID, true)
        }</span>
        <span class="cov4" title="3">return false</span>
}

func prepareQueries(queries []model.QueryMetadata, commonLibrary source.RegoLibraries,
        platformLibraries map[string]source.RegoLibraries, tracker Tracker) QueryLoader <span class="cov5" title="5">{
        // track queries loaded
        sum := 0
        for _, metadata := range queries </span><span class="cov10" title="19">{
                tracker.TrackQueryLoad(metadata.Aggregation)
                sum += metadata.Aggregation
        }</span>
        <span class="cov5" title="5">return QueryLoader{
                commonLibrary:     commonLibrary,
                platformLibraries: platformLibraries,
                querySum:          sum,
                QueriesMetadata:   queries,
        }</span>
}

// LoadQuery loads the query into memory so it can be freed when not used anymore
func (q QueryLoader) LoadQuery(ctx context.Context, query *model.QueryMetadata) (*rego.PreparedEvalQuery, error) <span class="cov3" title="2">{
        opaQuery := rego.PreparedEvalQuery{}

        platformGeneralQuery, ok := q.platformLibraries[query.Platform]
        if !ok </span><span class="cov0" title="0">{
                return nil, errors.New("failed to get platform library")
        }</span>

        <span class="cov3" title="2">select </span>{
        case &lt;-ctx.Done():<span class="cov0" title="0">
                return nil, nil</span>
        default:<span class="cov3" title="2">
                mergedInputData, err := source.MergeInputData(platformGeneralQuery.LibraryInputData, query.InputData)
                if err != nil </span><span class="cov0" title="0">{
                        log.Debug().Msgf("Could not merge %s library input data", query.Platform)
                }</span>
                <span class="cov3" title="2">mergedInputData, err = source.MergeInputData(q.commonLibrary.LibraryInputData, mergedInputData)
                if err != nil </span><span class="cov0" title="0">{
                        log.Debug().Msg("Could not merge common library input data")
                }</span>
                <span class="cov3" title="2">store := inmem.NewFromReader(bytes.NewBufferString(mergedInputData))
                opaQuery, err = rego.New(
                        rego.Query(regoQuery),
                        rego.Module("Common", q.commonLibrary.LibraryCode),
                        rego.Module("Generic", platformGeneralQuery.LibraryCode),
                        rego.Module(query.Query, query.Content),
                        rego.Store(store),
                        rego.UnsafeBuiltins(unsafeRegoFunctions),
                ).PrepareForEval(ctx)

                if err != nil </span><span class="cov0" title="0">{
                        sentryReport.ReportSentry(&amp;sentryReport.Report{
                                Message:  fmt.Sprintf("Inspector failed to prepare query for evaluation, query=%s", query.Query),
                                Err:      err,
                                Location: "func NewInspector()",
                                Query:    query.Query,
                                Metadata: query.Metadata,
                                Platform: query.Platform,
                        }, true)

                        return nil, err
                }</span>

                <span class="cov3" title="2">return &amp;opaQuery, nil</span>
        }
}
</pre>
		
		<pre class="file" id="file35" style="display: none">package provider

import (
        "context"
        "errors"
        "io/fs"
        "os"
        "os/signal"
        "path/filepath"
        "sync"

        "github.com/alexmullins/zip"

        "github.com/Checkmarx/kics/pkg/kuberneter"
        "github.com/Checkmarx/kics/pkg/model"
        "github.com/Checkmarx/kics/pkg/terraformer"
        "github.com/Checkmarx/kics/pkg/utils"
        "github.com/rs/zerolog/log"

        "github.com/hashicorp/go-getter"
)

const (
        channelLength = 2
)

// ExtractedPath is a struct that contains the paths, temporary paths to remove
// and extraction map path of the sources
// Path is the slice of paths to scan
// ExtractionMap is a map that correlates the temporary path to the given path
// RemoveTmp is the slice containing temporary paths to be removed
type ExtractedPath struct {
        Path          []string
        ExtractionMap map[string]model.ExtractedPathObject
}

type getterStruct struct {
        ctx         context.Context
        cancel      context.CancelFunc
        mode        getter.ClientMode
        pwd         string
        opts        []getter.ClientOption
        destination string
        source      string
}

// GetTerraformerSources uses Terraformer to download runtime resources from AWS provider
// to terraform.
// After Downloaded files kics scan the files as normal local files
func GetTerraformerSources(source []string, destinationPath string) (ExtractedPath, error) <span class="cov0" title="0">{
        extrStruct := ExtractedPath{
                Path:          []string{},
                ExtractionMap: make(map[string]model.ExtractedPathObject),
        }

        for _, path := range source </span><span class="cov0" title="0">{
                exportedPath, err := terraformer.Import(path, destinationPath)
                if err != nil </span><span class="cov0" title="0">{
                        log.Error().Msgf("failed to import %s: %s", path, err)
                }</span>

                <span class="cov0" title="0">extrStruct.ExtractionMap[exportedPath] = model.ExtractedPathObject{
                        Path:      exportedPath,
                        LocalPath: true,
                }

                extrStruct.Path = append(extrStruct.Path, exportedPath)</span>
        }

        <span class="cov0" title="0">return extrStruct, nil</span>
}

// GetKuberneterSources uses Kubernetes API to download runtime resources
// After Downloaded files kics scan the files as normal local files
func GetKuberneterSources(ctx context.Context, source []string, destinationPath string) (ExtractedPath, error) <span class="cov0" title="0">{
        extrStruct := ExtractedPath{
                Path:          []string{},
                ExtractionMap: make(map[string]model.ExtractedPathObject),
        }

        for _, path := range source </span><span class="cov0" title="0">{
                exportedPath, err := kuberneter.Import(ctx, path, destinationPath)
                if err != nil </span><span class="cov0" title="0">{
                        log.Error().Msgf("failed to import %s: %s", path, err)
                }</span>

                <span class="cov0" title="0">extrStruct.ExtractionMap[exportedPath] = model.ExtractedPathObject{
                        Path:      exportedPath,
                        LocalPath: true,
                }

                extrStruct.Path = append(extrStruct.Path, exportedPath)</span>
        }

        <span class="cov0" title="0">return extrStruct, nil</span>
}

// GetSources goes through the source slice, and determines the of source type (ex: zip, git, local).
// It than extracts the files to be scanned. If the source given is not local, a temp dir
// will be created where the files will be stored.
func GetSources(source []string) (ExtractedPath, error) <span class="cov10" title="5">{
        extrStruct := ExtractedPath{
                Path:          []string{},
                ExtractionMap: make(map[string]model.ExtractedPathObject),
        }
        for _, path := range source </span><span class="cov10" title="5">{
                destination := filepath.Join(os.TempDir(), "kics-extract-"+utils.NextRandom())

                mode := getter.ClientModeAny

                pwd, err := os.Getwd()
                if err != nil </span><span class="cov0" title="0">{
                        log.Fatal().Msgf("Error getting wd: %s", err)
                }</span>

                <span class="cov10" title="5">opts := []getter.ClientOption{}

                opts = append(opts, getter.WithInsecure())

                ctx, cancel := context.WithCancel(context.Background())

                goGetter := getterStruct{
                        ctx:         ctx,
                        cancel:      cancel,
                        mode:        mode,
                        pwd:         pwd,
                        opts:        opts,
                        destination: destination,
                        source:      path,
                }

                getterDst, err := getPaths(&amp;goGetter)
                if err != nil </span><span class="cov4" title="2">{
                        log.Error().Msgf("%s", err)
                        return ExtractedPath{}, err
                }</span>
                <span class="cov7" title="3">tempDst, local := checkSymLink(getterDst, path)

                extrStruct.ExtractionMap[getterDst] = model.ExtractedPathObject{
                        Path:      path,
                        LocalPath: local,
                }

                extrStruct.Path = append(extrStruct.Path, tempDst)</span>
        }

        <span class="cov7" title="3">return extrStruct, nil</span>
}

func getPaths(g *getterStruct) (string, error) <span class="cov10" title="5">{
        if isEncrypted(g.source) </span><span class="cov1" title="1">{
                err := errors.New("zip encrypted files are not supported")
                log.Err(err)
                return "", err
        }</span>

        // Build the client
        <span class="cov8" title="4">client := &amp;getter.Client{
                Ctx:     g.ctx,
                Src:     g.source,
                Dst:     g.destination,
                Pwd:     g.pwd,
                Mode:    g.mode,
                Options: g.opts,
        }

        wg := sync.WaitGroup{}
        wg.Add(1)
        errChan := make(chan error, channelLength)
        go func() </span><span class="cov8" title="4">{
                defer wg.Done()
                defer g.cancel()
                if err := client.Get(); err != nil </span><span class="cov1" title="1">{
                        errChan &lt;- err
                }</span>
        }()

        <span class="cov8" title="4">c := make(chan os.Signal, channelLength)
        signal.Notify(c, os.Interrupt)

        select </span>{
        case &lt;-c:<span class="cov0" title="0">
                signal.Reset(os.Interrupt)
                g.cancel()
                wg.Wait()</span>
        case &lt;-g.ctx.Done():<span class="cov7" title="3">
                wg.Wait()</span>
        case err := &lt;-errChan:<span class="cov1" title="1">
                wg.Wait()
                return "", err</span>
        }

        <span class="cov7" title="3">return g.destination, nil</span>
}

// check if the dst is a symbolic link
func checkSymLink(getterDst, pathFile string) (string, bool) <span class="cov7" title="3">{
        var local bool
        _, err := os.Stat(pathFile)
        if err == nil </span><span class="cov7" title="3">{ // check if file exist locally
                local = true
        }</span>

        <span class="cov7" title="3">info, err := os.Lstat(getterDst)
        if err != nil </span><span class="cov0" title="0">{
                log.Error().Msgf("failed lstat for %s: %v", getterDst, err)
        }</span>

        <span class="cov7" title="3">fileInfo := getFileInfo(info, getterDst, pathFile)

        if info.Mode()&amp;os.ModeSymlink != 0 </span><span class="cov4" title="2">{ // if it's a symbolic Link
                path, err := os.Readlink(getterDst) // get location of symbolic Link
                if err != nil </span><span class="cov0" title="0">{
                        log.Error().Msgf("failed Readlink for %s: %v", getterDst, err)
                }</span>
                <span class="cov4" title="2">getterDst = path</span> // change path to local path
        } else<span class="cov1" title="1"> if !fileInfo.IsDir() </span><span class="cov0" title="0">{ // symbolic links are not created for single files
                if local </span><span class="cov0" title="0">{ // check if file exist locally
                        getterDst = pathFile
                }</span>
        }
        <span class="cov7" title="3">return getterDst, local</span>
}

func getFileInfo(info fs.FileInfo, dst, pathFile string) fs.FileInfo <span class="cov7" title="3">{
        var extension = filepath.Ext(pathFile)
        var path string
        if extension == "" </span><span class="cov4" title="2">{
                path = filepath.Join(dst, filepath.Base(pathFile[0:len(pathFile)-len(extension)])) // for single file
        }</span> else<span class="cov1" title="1"> {
                path = filepath.Join(dst, filepath.Base(pathFile)) // for directories
        }</span>
        <span class="cov7" title="3">fileInfo, err := os.Lstat(path)
        if err != nil </span><span class="cov7" title="3">{
                fileInfo = info
        }</span>
        <span class="cov7" title="3">return fileInfo</span>
}

func isEncrypted(sourceFile string) bool <span class="cov10" title="5">{
        if filepath.Ext(sourceFile) != ".zip" </span><span class="cov7" title="3">{
                return false
        }</span>
        <span class="cov4" title="2">zipFile, err := zip.OpenReader(sourceFile)
        if err != nil </span><span class="cov0" title="0">{
                log.Error().Msgf("failed to open %s: %v", sourceFile, err)
                return false
        }</span>
        <span class="cov4" title="2">defer zipFile.Close()
        for _, file := range zipFile.File </span><span class="cov7" title="3">{
                if file.IsEncrypted() </span><span class="cov1" title="1">{
                        log.Error().Msgf("file %s is encrypted", sourceFile)
                        return true
                }</span>
        }
        <span class="cov1" title="1">return false</span>
}
</pre>
		
		<pre class="file" id="file36" style="display: none">package provider

import (
        "context"
        "fmt"
        "os"
        "path/filepath"
        "strings"
        "sync"

        sentryReport "github.com/Checkmarx/kics/internal/sentry"
        "github.com/Checkmarx/kics/pkg/model"
        "github.com/Checkmarx/kics/pkg/utils"
        "github.com/pkg/errors"
        "github.com/rs/zerolog/log"
        "github.com/yargevad/filepathx"
)

// FileSystemSourceProvider provides a path to be scanned
// and a list of files which will not be scanned
type FileSystemSourceProvider struct {
        paths    []string
        excludes map[string][]os.FileInfo
        mu       sync.RWMutex
}

// ErrNotSupportedFile - error representing when a file format is not supported by KICS
var ErrNotSupportedFile = errors.New("invalid file format")

// NewFileSystemSourceProvider initializes a FileSystemSourceProvider with path and files that will be ignored
func NewFileSystemSourceProvider(paths, excludes []string) (*FileSystemSourceProvider, error) <span class="cov2" title="5">{
        log.Debug().Msgf("provider.NewFileSystemSourceProvider()")
        ex := make(map[string][]os.FileInfo, len(excludes))
        osPaths := make([]string, len(paths))
        for idx, path := range paths </span><span class="cov2" title="7">{
                osPaths[idx] = filepath.FromSlash(path)
        }</span>
        <span class="cov2" title="5">fs := &amp;FileSystemSourceProvider{
                paths:    osPaths,
                excludes: ex,
        }
        for _, exclude := range excludes </span><span class="cov1" title="2">{
                excludePaths, err := GetExcludePaths(exclude)
                if err != nil </span><span class="cov0" title="0">{
                        return nil, err
                }</span>
                <span class="cov1" title="2">if err := fs.AddExcluded(excludePaths); err != nil </span><span class="cov0" title="0">{
                        return nil, err
                }</span>
        }

        <span class="cov2" title="5">return fs, nil</span>
}

// AddExcluded add new excluded files to the File System Source Provider
func (s *FileSystemSourceProvider) AddExcluded(excludePaths []string) error <span class="cov2" title="4">{
        for _, excludePath := range excludePaths </span><span class="cov1" title="3">{
                info, err := os.Stat(excludePath)
                if err != nil </span><span class="cov1" title="2">{
                        if os.IsNotExist(err) </span><span class="cov1" title="2">{
                                continue</span>
                        }
                        <span class="cov0" title="0">return errors.Wrap(err, "failed to open excluded file")</span>
                }
                <span class="cov1" title="1">s.mu.Lock()
                if _, ok := s.excludes[info.Name()]; !ok </span><span class="cov1" title="1">{
                        s.excludes[info.Name()] = make([]os.FileInfo, 0)
                }</span>
                <span class="cov1" title="1">s.excludes[info.Name()] = append(s.excludes[info.Name()], info)
                s.mu.Unlock()</span>
        }
        <span class="cov2" title="4">return nil</span>
}

// GetExcludePaths gets all the files that should be excluded
func GetExcludePaths(pathExpressions string) ([]string, error) <span class="cov2" title="4">{
        if strings.ContainsAny(pathExpressions, "*?[") </span><span class="cov1" title="2">{
                info, err := filepathx.Glob(pathExpressions)
                if err != nil </span><span class="cov0" title="0">{
                        log.Error().Msgf("failed to get exclude path %s: %s", pathExpressions, err)
                        return []string{pathExpressions}, nil
                }</span>
                <span class="cov1" title="2">return info, nil</span>
        }
        <span class="cov1" title="2">return []string{pathExpressions}, nil</span>
}

// GetBasePaths returns base path of FileSystemSourceProvider
func (s *FileSystemSourceProvider) GetBasePaths() []string <span class="cov1" title="2">{
        return s.paths
}</span>

// ignoreDamagedFiles checks whether we should ignore a damaged file from a scan or not.
func ignoreDamagedFiles(path string) bool <span class="cov0" title="0">{
        shouldIgnoreFile := false
        fileInfo, err := os.Lstat(path)
        if err != nil </span><span class="cov0" title="0">{
                log.Warn().Msgf("Failed getting the file info for file '%s'", path)
                return shouldIgnoreFile
        }</span>
        <span class="cov0" title="0">log.Info().Msgf("No mode type bits are set( is a regular file ) for file '%s' : %t ", path, fileInfo.Mode().IsRegular())

        if fileInfo.Mode()&amp;os.ModeSymlink == os.ModeSymlink </span><span class="cov0" title="0">{
                log.Warn().Msgf("File '%s' is a symbolic link - but seems not to be accessible", path)
                shouldIgnoreFile = true
        }</span>

        <span class="cov0" title="0">return shouldIgnoreFile</span>
}

// GetSources tries to open file or directory and execute sink function on it
func (s *FileSystemSourceProvider) GetSources(ctx context.Context,
        extensions model.Extensions, sink Sink, resolverSink ResolverSink) error <span class="cov2" title="7">{
        for _, scanPath := range s.paths </span><span class="cov2" title="7">{
                resolved := false
                fileInfo, err := os.Stat(scanPath)
                if err != nil </span><span class="cov1" title="3">{
                        return errors.Wrap(err, "failed to open path")
                }</span>

                <span class="cov2" title="4">if !fileInfo.IsDir() </span><span class="cov1" title="1">{
                        c, openFileErr := openScanFile(scanPath, extensions)
                        if openFileErr != nil </span><span class="cov0" title="0">{
                                if openFileErr == ErrNotSupportedFile || ignoreDamagedFiles(scanPath) </span><span class="cov0" title="0">{
                                        continue</span>
                                }
                                <span class="cov0" title="0">return openFileErr</span>
                        }
                        <span class="cov1" title="1">if sinkErr := sink(ctx, scanPath, c); sinkErr != nil </span><span class="cov0" title="0">{
                                return sinkErr
                        }</span>
                        <span class="cov1" title="1">continue</span>
                }

                <span class="cov1" title="3">err = s.walkDir(ctx, scanPath, resolved, sink, resolverSink, extensions)
                if err != nil </span><span class="cov0" title="0">{
                        return errors.Wrap(err, "failed to walk directory")
                }</span>
                <span class="cov1" title="3">continue</span>
        }
        <span class="cov2" title="4">return nil</span>
}

func (s *FileSystemSourceProvider) walkDir(ctx context.Context, scanPath string, resolved bool,
        sink Sink, resolverSink ResolverSink, extensions model.Extensions) error <span class="cov1" title="3">{
        return filepath.Walk(scanPath, func(path string, info os.FileInfo, err error) error </span><span class="cov9" title="29765">{
                if err != nil </span><span class="cov0" title="0">{
                        return err
                }</span>

                <span class="cov9" title="29765">if shouldSkip, skipFolder := s.checkConditions(info, extensions, path, resolved); shouldSkip </span><span class="cov9" title="29484">{
                        return skipFolder
                }</span>

                // ------------------ Helm resolver --------------------------------
                <span class="cov5" title="281">if info.IsDir() </span><span class="cov1" title="1">{
                        excluded, errRes := resolverSink(ctx, strings.ReplaceAll(path, "\\", "/"))
                        if errRes != nil </span><span class="cov0" title="0">{
                                sentryReport.ReportSentry(&amp;sentryReport.Report{
                                        Message:  fmt.Sprintf("Filesystem files provider couldn't Resolve Directory, file=%s", info.Name()),
                                        Err:      errRes,
                                        Location: "func walkDir()",
                                        FileName: info.Name(),
                                }, true)
                                return nil
                        }</span>
                        <span class="cov1" title="1">if errAdd := s.AddExcluded(excluded); errAdd != nil </span><span class="cov0" title="0">{
                                log.Err(errAdd).Msgf("Filesystem files provider couldn't exclude rendered Chart files, Chart=%s", info.Name())
                        }</span>
                        <span class="cov1" title="1">resolved = true
                        return nil</span>
                }
                // -----------------------------------------------------------------

                <span class="cov5" title="280">c, err := os.Open(filepath.Clean(path))
                if err != nil </span><span class="cov0" title="0">{
                        if ignoreDamagedFiles(filepath.Clean(path)) </span><span class="cov0" title="0">{
                                return nil
                        }</span>
                        <span class="cov0" title="0">return errors.Wrap(err, "failed to open file")</span>
                }
                <span class="cov5" title="280">defer closeFile(c, info)

                err = sink(ctx, strings.ReplaceAll(path, "\\", "/"), c)
                if err != nil </span><span class="cov5" title="140">{
                        sentryReport.ReportSentry(&amp;sentryReport.Report{
                                Message:  fmt.Sprintf("Filesystem files provider couldn't parse file, file=%s", info.Name()),
                                Err:      err,
                                Location: "func walkDir()",
                                FileName: info.Name(),
                        }, true)
                }</span>
                <span class="cov5" title="280">return nil</span>
        })
}

func openScanFile(scanPath string, extensions model.Extensions) (*os.File, error) <span class="cov1" title="1">{
        ext := utils.GetExtension(scanPath)

        if !extensions.Include(ext) </span><span class="cov0" title="0">{
                return nil, ErrNotSupportedFile
        }</span>

        <span class="cov1" title="1">c, errOpenFile := os.Open(scanPath)
        if errOpenFile != nil </span><span class="cov0" title="0">{
                return nil, errors.Wrap(errOpenFile, "failed to open path")
        }</span>
        <span class="cov1" title="1">return c, nil</span>
}

func closeFile(file *os.File, info os.FileInfo) <span class="cov5" title="280">{
        if err := file.Close(); err != nil </span><span class="cov0" title="0">{
                sentryReport.ReportSentry(&amp;sentryReport.Report{
                        Message:  fmt.Sprintf("Filesystem couldn't close file, file=%s", info.Name()),
                        Err:      err,
                        Location: "func closeFile()",
                        FileName: info.Name(),
                }, true)
        }</span>
}

func (s *FileSystemSourceProvider) checkConditions(info os.FileInfo, extensions model.Extensions,
        path string, resolved bool) (bool, error) <span class="cov10" title="29768">{
        s.mu.RLock()
        defer s.mu.RUnlock()
        if info.IsDir() </span><span class="cov8" title="6614">{
                if f, ok := s.excludes[info.Name()]; ok &amp;&amp; containsFile(f, info) </span><span class="cov1" title="1">{
                        log.Info().Msgf("Directory ignored: %s", path)
                        return true, filepath.SkipDir
                }</span>
                <span class="cov8" title="6613">_, err := os.Stat(filepath.Join(path, "Chart.yaml"))
                if err != nil || resolved </span><span class="cov8" title="6611">{
                        return true, nil
                }</span>
                <span class="cov1" title="2">return false, nil</span>
        }

        <span class="cov9" title="23154">if f, ok := s.excludes[info.Name()]; ok &amp;&amp; containsFile(f, info) </span><span class="cov0" title="0">{
                log.Trace().Msgf("File ignored: %s", path)
                return true, nil
        }</span>
        <span class="cov9" title="23154">ext := utils.GetExtension(path)
        if !extensions.Include(ext) </span><span class="cov9" title="22874">{
                log.Trace().Msgf("File ignored: %s", path)
                return true, nil
        }</span>
        <span class="cov5" title="280">return false, nil</span>
}

func containsFile(fileList []os.FileInfo, target os.FileInfo) bool <span class="cov1" title="1">{
        for _, file := range fileList </span><span class="cov1" title="1">{
                if os.SameFile(file, target) </span><span class="cov1" title="1">{
                        return true
                }</span>
        }
        <span class="cov0" title="0">return false</span>
}
</pre>
		
		<pre class="file" id="file37" style="display: none">package secrets

import (
        "context"
        _ "embed" // Embed KICS regex rules
        "encoding/json"
        "fmt"
        "math"
        "regexp"
        "strings"
        "sync"
        "time"

        "github.com/Checkmarx/kics/assets"
        "github.com/Checkmarx/kics/pkg/detector"
        "github.com/Checkmarx/kics/pkg/detector/docker"
        "github.com/Checkmarx/kics/pkg/detector/helm"
        engine "github.com/Checkmarx/kics/pkg/engine"
        "github.com/Checkmarx/kics/pkg/engine/similarity"
        "github.com/Checkmarx/kics/pkg/engine/source"
        "github.com/Checkmarx/kics/pkg/model"
        "github.com/rs/zerolog/log"
)

const (
        Base64Chars = "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/="
        HexChars    = "1234567890abcdefABCDEF"
)

var (
        SecretsQueryMetadata map[string]string
)

// SecretTracker is Struct created to keep track of the secrets found in the inspector
// it used for masking all the secrets in the vulnerability preview in the different report formats
type SecretTracker struct {
        ResolvedFilePath string
        Line             int
        OriginalContent  string
        MaskedContent    string
}

type Inspector struct {
        ctx                   context.Context
        tracker               engine.Tracker
        detector              *detector.DetectLine
        excludeResults        map[string]bool
        regexQueries          []RegexQuery
        allowRules            []AllowRule
        vulnerabilities       []model.Vulnerability
        queryExecutionTimeout time.Duration
        foundLines            []int
        mu                    sync.RWMutex
        SecretTracker         []SecretTracker
}

type Entropy struct {
        Group int     `json:"group"`
        Min   float64 `json:"min"`
        Max   float64 `json:"max"`
}

type MultilineResult struct {
        DetectLineGroup int `json:"detectLineGroup"`
}

type AllowRule struct {
        Description string `json:"description"`
        RegexStr    string `json:"regex"`
        Regex       *regexp.Regexp
}

type RegexQuery struct {
        ID          string          `json:"id"`
        Name        string          `json:"name"`
        Multiline   MultilineResult `json:"multiline"`
        RegexStr    string          `json:"regex"`
        SpecialMask string          `json:"specialMask"`
        Entropies   []Entropy       `json:"entropies"`
        AllowRules  []AllowRule     `json:"allowRules"`
        Regex       *regexp.Regexp
}

type RegexRuleStruct struct {
        Rules      []RegexQuery `json:"rules"`
        AllowRules []AllowRule  `json:"allowRules"`
}

type RuleMatch struct {
        File     string
        RuleName string
        Matches  []string
        Line     int
        Entropy  float64
}

type lineVulneInfo struct {
        lineContent string
        lineNumber  int
        groups      []string
}

func NewInspector(
        ctx context.Context,
        excludeResults map[string]bool,
        tracker engine.Tracker,
        queryFilter *source.QueryInspectorParameters,
        disableSecretsQuery bool,
        executionTimeout int,
        regexRulesContent string,
        isCustomSecretsRegexes bool,
) (*Inspector, error) <span class="cov3" title="13">{
        passwordsAndSecretsQueryID, err := getPasswordsAndSecretsQueryID()
        if err != nil </span><span class="cov1" title="1">{
                return nil, err
        }</span>
        <span class="cov3" title="12">excludeSecretsQuery := isValueInArray(passwordsAndSecretsQueryID, queryFilter.ExcludeQueries.ByIDs)
        if disableSecretsQuery || excludeSecretsQuery &amp;&amp; !isCustomSecretsRegexes </span><span class="cov1" title="1">{
                return &amp;Inspector{
                        ctx:                   ctx,
                        tracker:               tracker,
                        excludeResults:        excludeResults,
                        regexQueries:          make([]RegexQuery, 0),
                        allowRules:            make([]AllowRule, 0),
                        vulnerabilities:       make([]model.Vulnerability, 0),
                        queryExecutionTimeout: time.Duration(executionTimeout) * time.Second,
                        SecretTracker:         make([]SecretTracker, 0),
                }, nil
        }</span>

        <span class="cov3" title="11">lineDetector := detector.NewDetectLine(tracker.GetOutputLines()).
                Add(helm.DetectKindLine{}, model.KindHELM).
                Add(docker.DetectKindLine{}, model.KindDOCKER)

        err = json.Unmarshal([]byte(assets.SecretsQueryMetadataJSON), &amp;SecretsQueryMetadata)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov3" title="11">queryExecutionTimeout := time.Duration(executionTimeout) * time.Second

        var allRegexQueries RegexRuleStruct
        err = json.Unmarshal([]byte(regexRulesContent), &amp;allRegexQueries)
        if err != nil </span><span class="cov1" title="1">{
                return nil, err
        }</span>

        <span class="cov3" title="10">if isCustomSecretsRegexes </span><span class="cov0" title="0">{
                err = validateCustomSecretsQueriesID(allRegexQueries.Rules)
                if err != nil </span><span class="cov0" title="0">{
                        return nil, err
                }</span>
        }

        <span class="cov3" title="10">regexQueries, err := compileRegexQueries(queryFilter, allRegexQueries.Rules, isCustomSecretsRegexes, passwordsAndSecretsQueryID)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>

        <span class="cov3" title="10">allowRules, err := compileRegex(allRegexQueries.AllowRules)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>

        <span class="cov3" title="10">return &amp;Inspector{
                ctx:                   ctx,
                detector:              lineDetector,
                excludeResults:        excludeResults,
                tracker:               tracker,
                regexQueries:          regexQueries,
                allowRules:            allowRules,
                vulnerabilities:       make([]model.Vulnerability, 0),
                queryExecutionTimeout: queryExecutionTimeout,
                foundLines:            make([]int, 0),
        }, nil</span>
}

func (c *Inspector) inspectQuery(ctx context.Context, basePaths []string,
        files model.FileMetadatas, i int) ([]model.Vulnerability, error) <span class="cov5" title="264">{
        timeoutCtx, cancel := context.WithTimeout(ctx, c.queryExecutionTimeout)
        defer cancel()

        cleanFiles := cleanFiles(files)

        for idx := range cleanFiles </span><span class="cov5" title="264">{
                if _, ok := cleanFiles[idx].Commands["ignore"]; !ok </span><span class="cov5" title="231">{
                        select </span>{
                        case &lt;-timeoutCtx.Done():<span class="cov0" title="0">
                                return c.vulnerabilities, timeoutCtx.Err()</span>
                        default:<span class="cov5" title="231">
                                c.checkContent(i, idx, basePaths, cleanFiles)</span>
                        }
                }
        }
        <span class="cov5" title="264">return c.vulnerabilities, nil</span>
}

// Inspect inspects the source code for passwords &amp; secrets and returns the list of vulnerabilities
func (c *Inspector) Inspect(ctx context.Context, basePaths []string,
        files model.FileMetadatas, currentQuery chan&lt;- int64) ([]model.Vulnerability, error) <span class="cov2" title="8">{
        for i := range c.regexQueries </span><span class="cov5" title="264">{
                currentQuery &lt;- 1

                vulns, err := c.inspectQuery(ctx, basePaths, files, i)

                if err != nil </span><span class="cov0" title="0">{
                        return vulns, err
                }</span>
        }
        <span class="cov2" title="8">return c.vulnerabilities, nil</span>
}

func compileRegexQueries(
        queryFilter *source.QueryInspectorParameters,
        allRegexQueries []RegexQuery,
        isCustom bool,
        passwordsAndSecretsQueryID string,
) ([]RegexQuery, error) <span class="cov3" title="15">{
        var regexQueries []RegexQuery
        var includeSpecificSecretQuery bool

        allSecretsQueryAndCustom := false

        includeAllSecretsQuery := isValueInArray(passwordsAndSecretsQueryID, queryFilter.IncludeQueries.ByIDs)

        if includeAllSecretsQuery &amp;&amp; isCustom </span><span class="cov0" title="0">{ // merge case
                var kicsRegexQueries RegexRuleStruct
                err := json.Unmarshal([]byte(assets.SecretsQueryRegexRulesJSON), &amp;kicsRegexQueries)
                if err != nil </span><span class="cov0" title="0">{
                        return nil, err
                }</span>
                <span class="cov0" title="0">allSecretsQueryAndCustom = true
                regexQueries = kicsRegexQueries.Rules</span>
        }

        <span class="cov3" title="15">for i := range allRegexQueries </span><span class="cov5" title="276">{
                includeSpecificSecretQuery = isValueInArray(allRegexQueries[i].ID, queryFilter.IncludeQueries.ByIDs)
                if len(queryFilter.IncludeQueries.ByIDs) &gt; 0 &amp;&amp; !allSecretsQueryAndCustom </span><span class="cov1" title="3">{
                        if includeAllSecretsQuery || includeSpecificSecretQuery </span><span class="cov1" title="1">{
                                regexQueries = append(regexQueries, allRegexQueries[i])
                        }</span>
                } else<span class="cov5" title="273"> {
                        if !shouldExecuteQuery(
                                allRegexQueries[i].ID,
                                allRegexQueries[i].ID,
                                SecretsQueryMetadata["category"],
                                SecretsQueryMetadata["severity"],
                                queryFilter.ExcludeQueries.ByIDs,
                        ) </span><span class="cov1" title="1">{
                                continue</span>
                        }
                        <span class="cov5" title="272">if !shouldExecuteQuery(
                                SecretsQueryMetadata["category"],
                                allRegexQueries[i].ID,
                                SecretsQueryMetadata["category"],
                                SecretsQueryMetadata["severity"],
                                queryFilter.ExcludeQueries.ByCategories,
                        ) </span><span class="cov0" title="0">{
                                continue</span>
                        }
                        <span class="cov5" title="272">if !shouldExecuteQuery(
                                SecretsQueryMetadata["severity"],
                                allRegexQueries[i].ID,
                                SecretsQueryMetadata["category"],
                                SecretsQueryMetadata["severity"],
                                queryFilter.ExcludeQueries.BySeverities,
                        ) </span><span class="cov0" title="0">{
                                continue</span>
                        }
                        <span class="cov5" title="272">regexQueries = append(regexQueries, allRegexQueries[i])</span>
                }
        }
        <span class="cov3" title="15">for i := range regexQueries </span><span class="cov5" title="273">{
                compiledRegexp, err := regexp.Compile(regexQueries[i].RegexStr)
                if err != nil </span><span class="cov0" title="0">{
                        return regexQueries, err
                }</span>
                <span class="cov5" title="273">regexQueries[i].Regex = compiledRegexp
                for j := range regexQueries[i].AllowRules </span><span class="cov5" title="120">{
                        regexQueries[i].AllowRules[j].Regex = regexp.MustCompile(regexQueries[i].AllowRules[j].RegexStr)
                }</span>
        }
        <span class="cov3" title="15">return regexQueries, nil</span>
}

func compileRegex(allowRules []AllowRule) ([]AllowRule, error) <span class="cov3" title="10">{
        for j := range allowRules </span><span class="cov4" title="80">{
                compiledRegex, err := regexp.Compile(allowRules[j].RegexStr)
                if err != nil </span><span class="cov0" title="0">{
                        return nil, err
                }</span>
                <span class="cov4" title="80">allowRules[j].Regex = compiledRegex</span>
        }
        <span class="cov3" title="10">return allowRules, nil</span>
}

func (c *Inspector) GetQueriesLength() int <span class="cov2" title="8">{
        return len(c.regexQueries)
}</span>

func isValueInArray(value string, array []string) bool <span class="cov7" title="1120">{
        for i := range array </span><span class="cov2" title="7">{
                if strings.EqualFold(value, array[i]) </span><span class="cov1" title="2">{
                        return true
                }</span>
        }
        <span class="cov7" title="1118">return false</span>
}

func (c *Inspector) isSecret(s string, query *RegexQuery) (isSecretRet bool, groups [][]string) <span class="cov7" title="2871">{
        if isAllowRule(s, query.AllowRules) || isAllowRule(s, c.allowRules) </span><span class="cov4" title="66">{
                return false, [][]string{}
        }</span>

        <span class="cov7" title="2805">groups = query.Regex.FindAllStringSubmatch(s, -1)

        for _, group := range groups </span><span class="cov2" title="6">{
                splitedText := strings.Split(s, "\n")
                max := -1
                for i, splited := range splitedText </span><span class="cov3" title="21">{
                        if len(groups) &lt; query.Multiline.DetectLineGroup </span><span class="cov3" title="16">{
                                if strings.Contains(splited, group[query.Multiline.DetectLineGroup]) &amp;&amp; i &gt; max </span><span class="cov0" title="0">{
                                        max = i
                                }</span>
                        }
                }
                <span class="cov2" title="6">if max == -1 </span><span class="cov2" title="6">{
                        continue</span>
                }
                <span class="cov0" title="0">secret, newGroups := c.isSecret(strings.Join(append(splitedText[:max], splitedText[max+1:]...), "\n"), query)
                if !secret </span><span class="cov0" title="0">{
                        continue</span>
                }
                <span class="cov0" title="0">groups = append(groups, newGroups...)</span>
        }

        <span class="cov7" title="2805">if len(groups) &gt; 0 </span><span class="cov2" title="6">{
                return true, groups
        }</span>
        <span class="cov7" title="2799">return false, [][]string{}</span>
}

func isAllowRule(s string, allowRules []AllowRule) bool <span class="cov8" title="5742">{
        for i := range allowRules </span><span class="cov10" title="29805">{
                if allowRules[i].Regex.MatchString(s) </span><span class="cov4" title="66">{
                        return true
                }</span>
        }
        <span class="cov8" title="5676">return false</span>
}

func (c *Inspector) checkFileContent(query *RegexQuery, basePaths []string, file *model.FileMetadata) <span class="cov3" title="21">{
        isSecret, groups := c.isSecret(file.OriginalData, query)
        if !isSecret </span><span class="cov3" title="20">{
                return
        }</span>

        <span class="cov1" title="1">lineVulns := c.secretsDetectLine(query, file, groups)

        for _, lineVuln := range lineVulns </span><span class="cov1" title="1">{
                if len(query.Entropies) == 0 </span><span class="cov0" title="0">{
                        c.addVulnerability(
                                basePaths,
                                file,
                                query,
                                lineVuln.lineNumber,
                                lineVuln.lineContent,
                        )
                }</span>

                <span class="cov1" title="1">if len(lineVuln.groups) &gt; 0 </span><span class="cov1" title="1">{
                        for _, entropy := range query.Entropies </span><span class="cov1" title="1">{
                                // if matched group does not exist continue
                                if len(lineVuln.groups) &lt;= entropy.Group </span><span class="cov0" title="0">{
                                        return
                                }</span>
                                <span class="cov1" title="1">isMatch, entropyFloat := CheckEntropyInterval(
                                        entropy,
                                        lineVuln.groups[entropy.Group],
                                )
                                log.Debug().Msgf("match: %v :: %v", isMatch, fmt.Sprint(entropyFloat))

                                if isMatch </span><span class="cov1" title="1">{
                                        c.addVulnerability(
                                                basePaths,
                                                file,
                                                query,
                                                lineVuln.lineNumber,
                                                lineVuln.lineContent,
                                        )
                                }</span>
                        }
                }
        }
}

func (c *Inspector) secretsDetectLine(query *RegexQuery, file *model.FileMetadata, vulnGroups [][]string) []lineVulneInfo <span class="cov1" title="1">{
        content := file.OriginalData
        lines := *file.LinesOriginalData
        lineVulneInfoSlice := make([]lineVulneInfo, 0)
        realLineUpdater := 0
        for _, groups := range vulnGroups </span><span class="cov1" title="1">{
                lineVulneInfoObject := lineVulneInfo{
                        lineNumber:  -1,
                        lineContent: "-",
                        groups:      groups,
                }

                if len(groups) &lt;= query.Multiline.DetectLineGroup </span><span class="cov0" title="0">{
                        log.Warn().Msgf("Unable to detect line in file %v Multiline group not found: %v", file.FilePath, query.Multiline.DetectLineGroup)
                        lineVulneInfoSlice = append(lineVulneInfoSlice, lineVulneInfoObject)
                        continue</span>
                }

                <span class="cov1" title="1">contentMatchRemoved := strings.Replace(content, groups[query.Multiline.DetectLineGroup], "", 1)

                text := strings.ReplaceAll(contentMatchRemoved, "\r", "")
                contentMatchRemovedLines := strings.Split(text, "\n")
                for i := 0; i &lt; len(lines); i++ </span><span class="cov2" title="7">{
                        if lines[i] != contentMatchRemovedLines[i] </span><span class="cov1" title="1">{
                                lineVulneInfoObject.lineNumber = i + realLineUpdater
                                lineVulneInfoObject.lineContent = lines[i]
                                break</span>
                        }
                }

                <span class="cov1" title="1">realLineUpdater += len(lines) - len(contentMatchRemovedLines)
                content = contentMatchRemoved
                lines = contentMatchRemovedLines

                lineVulneInfoSlice = append(lineVulneInfoSlice, lineVulneInfoObject)</span>
        }

        <span class="cov1" title="1">return lineVulneInfoSlice</span>
}

func (c *Inspector) checkLineByLine(wg *sync.WaitGroup, query *RegexQuery,
        basePaths []string, file *model.FileMetadata, lineNumber int, currentLine string) <span class="cov7" title="2850">{
        defer wg.Done()
        isSecret, groups := c.isSecret(currentLine, query)
        if !isSecret </span><span class="cov7" title="2845">{
                return
        }</span>

        <span class="cov2" title="5">if len(query.Entropies) == 0 </span><span class="cov2" title="4">{
                c.addVulnerability(
                        basePaths,
                        file,
                        query,
                        lineNumber,
                        currentLine,
                )
        }</span>

        <span class="cov2" title="5">for i := range query.Entropies </span><span class="cov1" title="1">{
                entropy := query.Entropies[i]

                // if matched group does not exist continue
                if len(groups[0]) &lt;= entropy.Group </span><span class="cov0" title="0">{
                        return
                }</span>

                <span class="cov1" title="1">isMatch, entropyFloat := CheckEntropyInterval(
                        entropy,
                        groups[0][entropy.Group],
                )
                log.Debug().Msgf("match: %v :: %v", isMatch, fmt.Sprint(entropyFloat))

                if isMatch </span><span class="cov1" title="1">{
                        c.addVulnerability(
                                basePaths,
                                file,
                                query,
                                lineNumber,
                                currentLine,
                        )
                }</span>
        }
}

func (c *Inspector) addVulnerability(basePaths []string, file *model.FileMetadata, query *RegexQuery, lineNumber int, issueLine string) <span class="cov2" title="6">{
        if engine.ShouldSkipVulnerability(file.Commands, query.ID) </span><span class="cov1" title="1">{
                log.Debug().Msgf("Skipping vulnerability in file %s for query '%s':%s", file.FilePath, query.Name, query.ID)
                return
        }</span>
        <span class="cov2" title="5">simID, err := similarity.ComputeSimilarityID(
                basePaths,
                file.FilePath,
                query.ID,
                fmt.Sprintf("%d", lineNumber),
                "",
        )
        if err != nil </span><span class="cov0" title="0">{
                log.Error().Msg("unable to compute similarity ID")
        }</span>

        <span class="cov2" title="5">c.mu.Lock()
        if _, ok := c.excludeResults[engine.PtrStringToString(simID)]; !ok </span><span class="cov2" title="5">{
                linesVuln := c.detector.GetAdjecent(file, lineNumber+1)
                if !ignoreLine(linesVuln.Line, file.LinesIgnore) </span><span class="cov1" title="3">{
                        vuln := model.Vulnerability{
                                QueryID:          query.ID,
                                QueryName:        SecretsQueryMetadata["queryName"] + " - " + query.Name,
                                SimilarityID:     engine.PtrStringToString(simID),
                                FileID:           file.ID,
                                FileName:         file.FilePath,
                                Line:             linesVuln.Line,
                                VulnLines:        hideSecret(&amp;linesVuln, issueLine, query, &amp;c.SecretTracker),
                                IssueType:        "RedundantAttribute",
                                Platform:         SecretsQueryMetadata["platform"],
                                Severity:         model.SeverityHigh,
                                QueryURI:         SecretsQueryMetadata["descriptionUrl"],
                                Category:         SecretsQueryMetadata["category"],
                                Description:      SecretsQueryMetadata["descriptionText"],
                                DescriptionID:    SecretsQueryMetadata["descriptionID"],
                                KeyExpectedValue: "Hardcoded secret key should not appear in source",
                                KeyActualValue:   "Hardcoded secret key appears in source",
                                CloudProvider:    SecretsQueryMetadata["cloudProvider"],
                        }
                        c.vulnerabilities = append(c.vulnerabilities, vuln)
                }</span>
        }
        <span class="cov2" title="5">c.mu.Unlock()</span>
}

// CheckEntropyInterval - verifies if a given token's entropy is within expected bounds
func CheckEntropyInterval(entropy Entropy, token string) (isEntropyInInterval bool, entropyLevel float64) <span class="cov2" title="8">{
        base64Entropy := calculateEntropy(token, Base64Chars)
        hexEntropy := calculateEntropy(token, HexChars)
        highestEntropy := math.Max(base64Entropy, hexEntropy)
        if insideInterval(entropy, base64Entropy) || insideInterval(entropy, hexEntropy) </span><span class="cov2" title="5">{
                return true, highestEntropy
        }</span>
        <span class="cov1" title="3">return false, highestEntropy</span>
}

func insideInterval(entropy Entropy, floatEntropy float64) bool <span class="cov3" title="12">{
        return floatEntropy &gt;= entropy.Min &amp;&amp; floatEntropy &lt;= entropy.Max
}</span>

// calculateEntropy - calculates the entropy of a string based on the Shannon formula
func calculateEntropy(token, charSet string) float64 <span class="cov3" title="16">{
        if token == "" </span><span class="cov2" title="4">{
                return 0
        }</span>
        <span class="cov3" title="12">charMap := map[rune]float64{}
        for _, char := range token </span><span class="cov7" title="1234">{
                if strings.Contains(charSet, string(char)) </span><span class="cov6" title="909">{
                        charMap[char]++
                }</span>
        }

        <span class="cov3" title="12">var freq float64
        length := float64(len(token))
        for _, count := range charMap </span><span class="cov5" title="191">{
                freq += count * math.Log2(count)
        }</span>

        <span class="cov3" title="12">return math.Log2(length) - freq/length</span>
}

func shouldExecuteQuery(filterTarget, id, category, severity string, filter []string) bool <span class="cov6" title="817">{
        if isValueInArray(filterTarget, filter) </span><span class="cov1" title="1">{
                log.Debug().
                        Msgf("Excluding query ID: %s category: %s severity: %s",
                                id,
                                category,
                                severity)
                return false
        }</span>
        <span class="cov6" title="816">return true</span>
}

func getPasswordsAndSecretsQueryID() (string, error) <span class="cov3" title="13">{
        var metadata = make(map[string]string)
        err := json.Unmarshal([]byte(assets.SecretsQueryMetadataJSON), &amp;metadata)
        if err != nil </span><span class="cov1" title="1">{
                return "", err
        }</span>
        <span class="cov3" title="12">return metadata["id"], nil</span>
}

func validateCustomSecretsQueriesID(allRegexQueries []RegexQuery) error <span class="cov0" title="0">{
        for i := range allRegexQueries </span><span class="cov0" title="0">{
                re := regexp.MustCompile(`^[0-9a-fA-F]{8}\b-[0-9a-fA-F]{4}\b-[0-9a-fA-F]{4}\b-[0-9a-fA-F]{4}\b-[0-9a-fA-F]{12}$`)
                if !(re.MatchString(allRegexQueries[i].ID)) </span><span class="cov0" title="0">{
                        return fmt.Errorf("the query %s defines an invalid query ID (%s)", allRegexQueries[i].Name, allRegexQueries[i].ID)
                }</span>
        }
        <span class="cov0" title="0">return nil</span>
}

func (c *Inspector) checkContent(i, idx int, basePaths []string, files model.FileMetadatas) <span class="cov5" title="231">{
        // lines ignore can have the lines from the resolved files
        // since inspector secrets only looks to original data, the lines ignore should be replaced
        files[idx].LinesIgnore = model.GetIgnoreLines(&amp;files[idx])

        wg := &amp;sync.WaitGroup{}
        // check file content line by line
        if c.regexQueries[i].Multiline == (MultilineResult{}) </span><span class="cov5" title="210">{
                lines := (&amp;files[idx]).LinesOriginalData
                for lineNumber, currentLine := range *lines </span><span class="cov7" title="2850">{
                        wg.Add(1)
                        go c.checkLineByLine(wg, &amp;c.regexQueries[i], basePaths, &amp;files[idx], lineNumber, currentLine)
                }</span>
                <span class="cov5" title="210">wg.Wait()
                return</span>
        }

        // check file content as a whole
        <span class="cov3" title="21">c.checkFileContent(&amp;c.regexQueries[i], basePaths, &amp;files[idx])</span>
}

func ignoreLine(lineNumber int, linesIgnore []int) bool <span class="cov2" title="5">{
        for _, ignoreLine := range linesIgnore </span><span class="cov1" title="3">{
                if lineNumber == ignoreLine </span><span class="cov1" title="2">{
                        return true
                }</span>
        }
        <span class="cov1" title="3">return false</span>
}

// cleanFiles keeps one file per filePath
func cleanFiles(files model.FileMetadatas) model.FileMetadatas <span class="cov5" title="264">{
        keys := make(map[string]bool)

        cleanFiles := model.FileMetadatas{}

        for i := range files </span><span class="cov5" title="264">{
                filePath := files[i].FilePath
                if _, value := keys[filePath]; !value </span><span class="cov5" title="264">{
                        keys[filePath] = true
                        cleanFiles = append(cleanFiles, files[i])
                }</span>
        }

        <span class="cov5" title="264">return cleanFiles</span>
}

func hideSecret(linesVuln *model.VulnerabilityLines,
        issueLine string,
        query *RegexQuery,
        secretTracker *[]SecretTracker) *[]model.CodeLine <span class="cov1" title="3">{
        for idx := range *linesVuln.VulnLines </span><span class="cov1" title="2">{
                if query.SpecialMask == "all" </span><span class="cov1" title="1">{
                        addToSecretTracker(secretTracker, linesVuln.ResolvedFile, linesVuln.Line, (*linesVuln.VulnLines)[idx].Line, "&lt;SECRET-MASKED-ON-PURPOSE&gt;")
                        (*linesVuln.VulnLines)[idx].Line = "&lt;SECRET-MASKED-ON-PURPOSE&gt;"
                        continue</span>
                }

                <span class="cov1" title="1">if (*linesVuln.VulnLines)[idx].Line == issueLine </span><span class="cov1" title="1">{
                        regex := query.RegexStr

                        if len(query.SpecialMask) &gt; 0 </span><span class="cov1" title="1">{
                                regex = "(.+)" + query.SpecialMask // get key
                        }</span>

                        <span class="cov1" title="1">var re = regexp.MustCompile(regex)
                        match := re.FindString(issueLine)

                        if len(query.SpecialMask) &gt; 0 </span><span class="cov1" title="1">{
                                match = issueLine[len(match):] // get value
                        }</span>

                        <span class="cov1" title="1">if match != "" </span><span class="cov1" title="1">{
                                originalCntAux := (*linesVuln.VulnLines)[idx].Line
                                (*linesVuln.VulnLines)[idx].Line = strings.Replace(issueLine, match, "&lt;SECRET-MASKED-ON-PURPOSE&gt;", 1)
                                addToSecretTracker(secretTracker, linesVuln.ResolvedFile, linesVuln.Line, originalCntAux, (*linesVuln.VulnLines)[idx].Line)
                        }</span> else<span class="cov0" title="0"> {
                                addToSecretTracker(secretTracker,
                                        linesVuln.ResolvedFile,
                                        linesVuln.Line,
                                        (*linesVuln.VulnLines)[idx].Line,
                                        "&lt;SECRET-MASKED-ON-PURPOSE&gt;")
                                (*linesVuln.VulnLines)[idx].Line = "&lt;SECRET-MASKED-ON-PURPOSE&gt;"
                        }</span>
                }
        }
        <span class="cov1" title="3">return linesVuln.VulnLines</span>
}

func addToSecretTracker(secretTracker *[]SecretTracker, path string, line int, originalCnt, maskedCnt string) <span class="cov1" title="2">{
        *secretTracker = append(*secretTracker, SecretTracker{
                ResolvedFilePath: path,
                Line:             line,
                OriginalContent:  originalCnt,
                MaskedContent:    maskedCnt,
        })
}</span>
</pre>
		
		<pre class="file" id="file38" style="display: none">package similarity

import (
        "crypto/sha256"
        "encoding/hex"
        "path/filepath"
        "strings"

        "github.com/rs/zerolog/log"
)

// ComputeSimilarityID This function receives four string parameters and computes a sha256 hash
func ComputeSimilarityID(basePaths []string, filePath, queryID, searchKey, searchValue string) (*string, error) <span class="cov9" title="18">{
        basePath := ""
        for _, path := range basePaths </span><span class="cov9" title="18">{
                if strings.Contains(filepath.ToSlash(filePath), filepath.ToSlash(path)) </span><span class="cov8" title="14">{
                        basePath = filepath.ToSlash(path)
                        break</span>
                }
        }
        <span class="cov9" title="18">standardizedPath, err := standardizeToRelativePath(basePath, filePath)
        if err != nil </span><span class="cov0" title="0">{
                log.Debug().Msgf("Error while standardizing path: %s", err)
        }</span>

        <span class="cov9" title="18">var stringNode = standardizedPath + queryID + searchKey + searchValue

        hashSum := sha256.Sum256([]byte(stringNode))

        similarity := hex.EncodeToString(hashSum[:])
        return &amp;similarity, nil</span>
}

func standardizeToRelativePath(basePath, path string) (string, error) <span class="cov10" title="22">{
        cleanPath := filepath.Clean(path)
        standardPath := filepath.ToSlash(cleanPath)
        basePath = filepath.ToSlash(basePath)
        relativeStandardPath, err := filepath.Rel(basePath, standardPath)
        if err != nil </span><span class="cov1" title="1">{
                return "", err
        }</span>
        <span class="cov9" title="21">return filepath.ToSlash(relativeStandardPath), nil</span>
}
</pre>
		
		<pre class="file" id="file39" style="display: none">package source

import (
        "encoding/json"
        "fmt"
        "os"
        "path"
        "path/filepath"
        "sort"
        "strings"

        "github.com/Checkmarx/kics/assets"
        "github.com/Checkmarx/kics/internal/constants"
        sentryReport "github.com/Checkmarx/kics/internal/sentry"
        "github.com/Checkmarx/kics/pkg/model"
        "github.com/pkg/errors"
        "github.com/rs/zerolog/log"
)

// FilesystemSource this type defines a struct with a path to a filesystem source of queries
// Source is the path to the queries
// Types are the types given by the flag --type for query selection mechanism
type FilesystemSource struct {
        Source         []string
        Types          []string
        CloudProviders []string
        Library        string
}

const (
        // QueryFileName The default query file name
        QueryFileName = "query.rego"
        // MetadataFileName The default metadata file name
        MetadataFileName = "metadata.json"
        // LibrariesDefaultBasePath the path to rego libraries
        LibrariesDefaultBasePath = "./assets/libraries"

        emptyInputData = "{}"

        common = "Common"

        kicsDefault = "default"
)

// NewFilesystemSource initializes a NewFilesystemSource with source to queries and types of queries to load
func NewFilesystemSource(source, types, cloudProviders []string, libraryPath string) *FilesystemSource <span class="cov7" title="17">{
        log.Debug().Msg("source.NewFilesystemSource()")

        if len(types) == 0 </span><span class="cov0" title="0">{
                types = []string{""}
        }</span>

        <span class="cov7" title="17">if len(cloudProviders) == 0 </span><span class="cov0" title="0">{
                cloudProviders = []string{""}
        }</span>

        <span class="cov7" title="17">for s := range source </span><span class="cov7" title="18">{
                source[s] = filepath.FromSlash(source[s])
        }</span>

        <span class="cov7" title="17">return &amp;FilesystemSource{
                Source:         source,
                Types:          types,
                CloudProviders: cloudProviders,
                Library:        filepath.FromSlash(libraryPath),
        }</span>
}

// ListSupportedPlatforms returns a list of supported platforms
func ListSupportedPlatforms() []string <span class="cov1" title="1">{
        keys := make([]string, len(constants.AvailablePlatforms))
        i := 0
        for k := range constants.AvailablePlatforms </span><span class="cov6" title="15">{
                keys[i] = k
                i++
        }</span>
        <span class="cov1" title="1">sort.Strings(keys)
        return keys</span>
}

// ListSupportedCloudProviders returns a list of supported cloud providers
func ListSupportedCloudProviders() []string <span class="cov1" title="1">{
        return []string{"alicloud", "aws", "azure", "gcp"}
}</span>

func getLibraryInDir(platform, libraryDirPath string) string <span class="cov2" title="2">{
        var libraryFilePath string
        err := filepath.Walk(libraryDirPath, func(path string, info os.FileInfo, err error) error </span><span class="cov8" title="36">{
                if err != nil </span><span class="cov0" title="0">{
                        return err
                }</span>
                <span class="cov8" title="36">if strings.EqualFold(filepath.Base(path), platform+".rego") </span><span class="cov1" title="1">{ // try to find the library file &lt;platform&gt;.rego
                        libraryFilePath = path
                }</span>
                <span class="cov8" title="36">return nil</span>
        })
        <span class="cov2" title="2">if err != nil </span><span class="cov0" title="0">{
                log.Error().Msgf("Failed to analize path %s: %s", libraryDirPath, err)
        }</span>
        <span class="cov2" title="2">return libraryFilePath</span>
}

func isDefaultLibrary(libraryPath string) bool <span class="cov5" title="7">{
        return filepath.FromSlash(libraryPath) == filepath.FromSlash(LibrariesDefaultBasePath)
}</span>

// GetPathToCustomLibrary - returns the libraries path for a given platform
func GetPathToCustomLibrary(platform, libraryPathFlag string) string <span class="cov5" title="7">{
        libraryFilePath := kicsDefault

        if !isDefaultLibrary(libraryPathFlag) </span><span class="cov0" title="0">{
                log.Debug().Msgf("Trying to load custom libraries from %s", libraryPathFlag)

                library := getLibraryInDir(platform, libraryPathFlag)
                // found a library named according to the platform
                if library != "" </span><span class="cov0" title="0">{
                        libraryFilePath = library
                }</span>
        }

        <span class="cov5" title="7">return libraryFilePath</span>
}

// GetQueryLibrary returns the library.rego for the platform passed in the argument
func (s *FilesystemSource) GetQueryLibrary(platform string) (RegoLibraries, error) <span class="cov5" title="7">{
        library := GetPathToCustomLibrary(platform, s.Library)
        customLibraryCode := ""
        customLibraryData := emptyInputData

        if library == "" </span><span class="cov0" title="0">{
                return RegoLibraries{}, errors.New("unable to get libraries path")
        }</span>

        <span class="cov5" title="7">if library != kicsDefault </span><span class="cov0" title="0">{
                byteContent, err := os.ReadFile(library)
                if err != nil </span><span class="cov0" title="0">{
                        return RegoLibraries{}, err
                }</span>
                <span class="cov0" title="0">customLibraryCode = string(byteContent)
                customLibraryData, err = readInputData(strings.TrimSuffix(library, filepath.Ext(library)) + ".json")
                if err != nil </span><span class="cov0" title="0">{
                        log.Debug().Msg(err.Error())
                }</span>
        } else<span class="cov5" title="7"> {
                log.Debug().Msgf("Custom library %s not provided. Loading embedded library instead", platform)
        }</span>
        // getting embedded library
        <span class="cov5" title="7">embeddedLibraryCode, errGettingEmbeddedLibrary := assets.GetEmbeddedLibrary(strings.ToLower(platform))
        if errGettingEmbeddedLibrary != nil </span><span class="cov1" title="1">{
                return RegoLibraries{}, errGettingEmbeddedLibrary
        }</span>

        <span class="cov4" title="6">mergedLibraryCode, errMergeLibs := mergeLibraries(customLibraryCode, embeddedLibraryCode)
        if errMergeLibs != nil </span><span class="cov0" title="0">{
                return RegoLibraries{}, errMergeLibs
        }</span>

        <span class="cov4" title="6">embeddedLibraryData, errGettingEmbeddedLibraryCode := assets.GetEmbeddedLibraryData(strings.ToLower(platform))
        if errGettingEmbeddedLibraryCode != nil </span><span class="cov4" title="5">{
                log.Debug().Msgf("Could not open embedded library data for %s platform", platform)
                embeddedLibraryData = emptyInputData
        }</span>
        <span class="cov4" title="6">mergedLibraryData, errMergingLibraryData := MergeInputData(embeddedLibraryData, customLibraryData)
        if errMergingLibraryData != nil </span><span class="cov0" title="0">{
                log.Debug().Msgf("Could not merge library data for %s platform", platform)
        }</span>

        <span class="cov4" title="6">regoLibrary := RegoLibraries{
                LibraryCode:      mergedLibraryCode,
                LibraryInputData: mergedLibraryData,
        }
        return regoLibrary, nil</span>
}

// CheckType checks if the queries have the type passed as an argument in '--type' flag to be loaded
func (s *FilesystemSource) CheckType(queryPlatform interface{}) bool <span class="cov5" title="8">{
        if queryPlatform.(string) == common </span><span class="cov0" title="0">{
                return true
        }</span>
        <span class="cov5" title="8">if s.Types[0] != "" </span><span class="cov0" title="0">{
                return strings.Contains(strings.ToUpper(strings.Join(s.Types, ",")), strings.ToUpper(queryPlatform.(string)))
        }</span>
        <span class="cov5" title="8">return true</span>
}

// CheckCloudProvider checks if the queries have the cloud provider passed as an argument in '--cloud-provider' flag to be loaded
func (s *FilesystemSource) CheckCloudProvider(cloudProvider interface{}) bool <span class="cov5" title="8">{
        if cloudProvider != nil </span><span class="cov0" title="0">{
                if strings.EqualFold(cloudProvider.(string), common) </span><span class="cov0" title="0">{
                        return true
                }</span>
                <span class="cov0" title="0">if s.CloudProviders[0] != "" </span><span class="cov0" title="0">{
                        return strings.Contains(strings.ToUpper(strings.Join(s.CloudProviders, ",")), strings.ToUpper(cloudProvider.(string)))
                }</span>
        }

        <span class="cov5" title="8">if s.CloudProviders[0] == "" </span><span class="cov5" title="8">{
                return true
        }</span>

        <span class="cov0" title="0">return false</span>
}

func checkQueryInclude(id interface{}, includedQueries []string) bool <span class="cov2" title="2">{
        queryMetadataKey, ok := id.(string)
        if !ok </span><span class="cov0" title="0">{
                log.Warn().
                        Msgf("Can't cast query metadata key = %v", id)
                return false
        }</span>
        <span class="cov2" title="2">for _, includedQuery := range includedQueries </span><span class="cov2" title="2">{
                if queryMetadataKey == includedQuery </span><span class="cov1" title="1">{
                        return true
                }</span>
        }
        <span class="cov1" title="1">return false</span>
}

func checkQueryExcludeField(id interface{}, excludeQueries []string) bool <span class="cov6" title="15">{
        queryMetadataKey, ok := id.(string)
        if !ok </span><span class="cov0" title="0">{
                log.Warn().
                        Msgf("Can't cast query metadata key = %v", id)
                return false
        }</span>
        <span class="cov6" title="15">for _, excludedQuery := range excludeQueries </span><span class="cov4" title="4">{
                if strings.EqualFold(queryMetadataKey, excludedQuery) </span><span class="cov3" title="3">{
                        return true
                }</span>
        }
        <span class="cov6" title="12">return false</span>
}

func checkQueryExclude(metadata map[string]interface{}, queryParameters *QueryInspectorParameters) bool <span class="cov4" title="6">{
        return checkQueryExcludeField(metadata["id"], queryParameters.ExcludeQueries.ByIDs) ||
                checkQueryExcludeField(metadata["category"], queryParameters.ExcludeQueries.ByCategories) ||
                checkQueryExcludeField(metadata["severity"], queryParameters.ExcludeQueries.BySeverities) ||
                (!queryParameters.BomQueries &amp;&amp; metadata["severity"] == model.SeverityTrace)
}</span>

// GetQueries walks a given filesource path returns all queries found in an array of
// QueryMetadata struct
func (s *FilesystemSource) GetQueries(queryParameters *QueryInspectorParameters) ([]model.QueryMetadata, error) <span class="cov6" title="10">{
        queryDirs := make([]string, 0)
        var err error

        for _, source := range s.Source </span><span class="cov6" title="11">{
                err = filepath.Walk(source,
                        func(p string, f os.FileInfo, err error) error </span><span class="cov10" title="59">{
                                if err != nil </span><span class="cov3" title="3">{
                                        return err
                                }</span>

                                <span class="cov9" title="56">if f.IsDir() || f.Name() != QueryFileName </span><span class="cov9" title="48">{
                                        return nil
                                }</span>

                                <span class="cov5" title="8">queryDirs = append(queryDirs, filepath.Dir(p))
                                return nil</span>
                        })
                <span class="cov6" title="11">if err != nil </span><span class="cov3" title="3">{
                        return nil, errors.Wrap(err, "failed to get query Source")
                }</span>
        }

        <span class="cov5" title="7">queries := make([]model.QueryMetadata, 0, len(queryDirs))
        for _, queryDir := range queryDirs </span><span class="cov5" title="8">{
                query, errRQ := ReadQuery(queryDir)
                if errRQ != nil </span><span class="cov0" title="0">{
                        sentryReport.ReportSentry(&amp;sentryReport.Report{
                                Message:  fmt.Sprintf("Query provider failed to read query, query=%s", path.Base(queryDir)),
                                Err:      errRQ,
                                Location: "func GetQueries()",
                                FileName: path.Base(queryDir),
                        }, true)
                        continue</span>
                }

                <span class="cov5" title="8">if !s.CheckType(query.Metadata["platform"]) </span><span class="cov0" title="0">{
                        continue</span>
                }

                <span class="cov5" title="8">if !s.CheckCloudProvider(query.Metadata["cloudProvider"]) </span><span class="cov0" title="0">{
                        continue</span>
                }

                <span class="cov5" title="8">customInputData, readInputErr := readInputData(filepath.Join(queryParameters.InputDataPath, query.Metadata["id"].(string)+".json"))
                if readInputErr != nil </span><span class="cov0" title="0">{
                        log.Err(errRQ).
                                Msgf("failed to read input data, query=%s", path.Base(queryDir))
                        continue</span>
                }

                <span class="cov5" title="8">inputData, mergeError := MergeInputData(query.InputData, customInputData)
                if mergeError != nil </span><span class="cov0" title="0">{
                        log.Err(mergeError).
                                Msgf("failed to merge input data, query=%s", path.Base(queryDir))
                        continue</span>
                }
                <span class="cov5" title="8">query.InputData = inputData

                if len(queryParameters.IncludeQueries.ByIDs) &gt; 0 </span><span class="cov2" title="2">{
                        if checkQueryInclude(query.Metadata["id"], queryParameters.IncludeQueries.ByIDs) </span><span class="cov1" title="1">{
                                queries = append(queries, query)
                        }</span>
                } else<span class="cov4" title="6"> {
                        if checkQueryExclude(query.Metadata, queryParameters) </span><span class="cov3" title="3">{
                                log.Debug().
                                        Msgf("Excluding query ID: %s category: %s severity: %s", query.Metadata["id"], query.Metadata["category"], query.Metadata["severity"])
                                continue</span>
                        }

                        <span class="cov3" title="3">queries = append(queries, query)</span>
                }
        }

        <span class="cov5" title="7">return queries, err</span>
}

// validateMetadata prevents panics when KICS queries metadata fields are missing
func validateMetadata(metadata map[string]interface{}) (exist bool, field string) <span class="cov6" title="11">{
        fields := []string{
                "id",
                "platform",
        }
        for _, field = range fields </span><span class="cov7" title="21">{
                if _, exist = metadata[field]; !exist </span><span class="cov2" title="2">{
                        return
                }</span>
        }
        <span class="cov5" title="9">return</span>
}

// ReadQuery reads query's files for a given path and returns a QueryMetadata struct with it's
// content
func ReadQuery(queryDir string) (model.QueryMetadata, error) <span class="cov5" title="8">{
        queryContent, err := os.ReadFile(filepath.Clean(path.Join(queryDir, QueryFileName)))
        if err != nil </span><span class="cov0" title="0">{
                return model.QueryMetadata{}, errors.Wrapf(err, "failed to read query %s", path.Base(queryDir))
        }</span>

        <span class="cov5" title="8">metadata, err := ReadMetadata(queryDir)
        if err != nil </span><span class="cov0" title="0">{
                return model.QueryMetadata{}, errors.Wrapf(err, "failed to read query %s", path.Base(queryDir))
        }</span>

        <span class="cov5" title="8">if valid, missingField := validateMetadata(metadata); !valid </span><span class="cov0" title="0">{
                return model.QueryMetadata{}, fmt.Errorf("failed to read metadata field: %s", missingField)
        }</span>

        <span class="cov5" title="8">platform := getPlatform(metadata["platform"].(string))

        inputData, errInputData := readInputData(filepath.Join(queryDir, "data.json"))
        if errInputData != nil </span><span class="cov0" title="0">{
                log.Err(errInputData).
                        Msgf("Query provider failed to read input data, query=%s", path.Base(queryDir))
        }</span>

        <span class="cov5" title="8">aggregation := 1
        if agg, ok := metadata["aggregation"]; ok </span><span class="cov0" title="0">{
                aggregation = int(agg.(float64))
        }</span>

        <span class="cov5" title="8">return model.QueryMetadata{
                Query:       path.Base(filepath.ToSlash(queryDir)),
                Content:     string(queryContent),
                Metadata:    metadata,
                Platform:    platform,
                InputData:   inputData,
                Aggregation: aggregation,
        }, nil</span>
}

// ReadMetadata read query's metadata file inside the query directory
func ReadMetadata(queryDir string) (map[string]interface{}, error) <span class="cov6" title="10">{
        f, err := os.Open(filepath.Clean(path.Join(queryDir, MetadataFileName)))
        if err != nil </span><span class="cov1" title="1">{
                sentryReport.ReportSentry(&amp;sentryReport.Report{
                        Message:  fmt.Sprintf("Queries provider can't read metadata, query=%s", path.Base(queryDir)),
                        Err:      err,
                        Location: "func ReadMetadata()",
                        FileName: path.Base(queryDir),
                }, true)

                return nil, err
        }</span>
        <span class="cov5" title="9">defer func() </span><span class="cov5" title="9">{
                if err := f.Close(); err != nil </span><span class="cov0" title="0">{
                        log.Err(err).
                                Msgf("Queries provider can't close file, file=%s", filepath.Clean(path.Join(queryDir, MetadataFileName)))
                }</span>
        }()

        <span class="cov5" title="9">var metadata map[string]interface{}
        if err := json.NewDecoder(f).Decode(&amp;metadata); err != nil </span><span class="cov0" title="0">{
                sentryReport.ReportSentry(&amp;sentryReport.Report{
                        Message:  fmt.Sprintf("Queries provider can't unmarshal metadata, query=%s", path.Base(queryDir)),
                        Err:      err,
                        Location: "func ReadMetadata()",
                        FileName: path.Base(queryDir),
                }, true)

                return nil, err
        }</span>

        <span class="cov5" title="9">return metadata, nil</span>
}

type supportedPlatforms map[string]string

var supPlatforms = &amp;supportedPlatforms{
        "Ansible":                 "ansible",
        "CloudFormation":          "cloudFormation",
        "Common":                  "common",
        "Crossplane":              "crossplane",
        "Dockerfile":              "dockerfile",
        "DockerCompose":           "dockerCompose",
        "Knative":                 "knative",
        "Kubernetes":              "k8s",
        "OpenAPI":                 "openAPI",
        "Terraform":               "terraform",
        "AzureResourceManager":    "azureResourceManager",
        "GRPC":                    "grpc",
        "GoogleDeploymentManager": "googleDeploymentManager",
        "Buildah":                 "buildah",
        "Pulumi":                  "pulumi",
        "ServerlessFW":            "serverlessFW",
}

func getPlatform(metadataPlatform string) string <span class="cov7" title="17">{
        if p, ok := (*supPlatforms)[metadataPlatform]; ok </span><span class="cov7" title="16">{
                return p
        }</span>
        <span class="cov1" title="1">return "unknown"</span>
}

func readInputData(inputDataPath string) (string, error) <span class="cov7" title="17">{
        inputData, err := os.ReadFile(filepath.Clean(inputDataPath))
        if err != nil </span><span class="cov7" title="16">{
                if os.IsNotExist(err) </span><span class="cov7" title="16">{
                        return emptyInputData, nil
                }</span>
                <span class="cov0" title="0">return emptyInputData, errors.Wrapf(err, "failed to read query input data %s", path.Base(inputDataPath))</span>
        }
        <span class="cov1" title="1">return string(inputData), nil</span>
}
</pre>
		
		<pre class="file" id="file40" style="display: none">// Package source (go:generate go run -mod=mod github.com/golang/mock/mockgen -package mock -source=./$GOFILE -destination=../mock/$GOFILE)
package source

import (
        "encoding/json"
        "strings"

        "github.com/Checkmarx/kics/pkg/model"
        "github.com/open-policy-agent/opa/ast"
        "github.com/pkg/errors"
        "github.com/rs/zerolog/log"
)

// QueryInspectorParameters is a struct that represents the optionn to select queries to be executed
type QueryInspectorParameters struct {
        IncludeQueries IncludeQueries
        ExcludeQueries ExcludeQueries
        InputDataPath  string
        BomQueries     bool
}

// ExcludeQueries is a struct that represents the option to exclude queries by ids or by categories
type ExcludeQueries struct {
        ByIDs        []string
        ByCategories []string
        BySeverities []string
}

// IncludeQueries is a struct that represents the option to include queries by ID taking precedence over exclusion
type IncludeQueries struct {
        ByIDs []string
}

// RegoLibraries is a struct that contains the library code and its input data
type RegoLibraries struct {
        LibraryCode      string
        LibraryInputData string
}

// QueriesSource wraps an interface that contains basic methods: GetQueries and GetQueryLibrary
// GetQueries gets all queries from a QueryMetadata list
// GetQueryLibrary gets a library of rego functions given a plataform's name
type QueriesSource interface {
        GetQueries(querySelection *QueryInspectorParameters) ([]model.QueryMetadata, error)
        GetQueryLibrary(platform string) (RegoLibraries, error)
}

// mergeLibraries return custom library and embedded library merged, overwriting embedded library functions, if necessary
func mergeLibraries(customLib, embeddedLib string) (string, error) <span class="cov7" title="12">{
        if customLib == "" </span><span class="cov6" title="7">{
                return embeddedLib, nil
        }</span>
        <span class="cov5" title="5">statements, _, err := ast.NewParser().WithReader(strings.NewReader(customLib)).Parse()
        if err != nil </span><span class="cov1" title="1">{
                log.Err(err).Msg("Could not parse custom library")
                return "", err
        }</span>
        <span class="cov4" title="4">headers := make(map[string]string)
        variables := make(map[string]string)
        for _, st := range statements </span><span class="cov4" title="4">{
                if rule, ok := st.(*ast.Rule); ok </span><span class="cov4" title="4">{
                        headers[string(rule.Head.Name)] = ""
                }</span>
                <span class="cov4" title="4">if regoPackage, ok := st.(ast.Body); ok </span><span class="cov0" title="0">{
                        variableSet := regoPackage.Vars(ast.SafetyCheckVisitorParams)
                        for variable := range variableSet </span><span class="cov0" title="0">{
                                variables[variable.String()] = ""
                        }</span>
                }
        }
        <span class="cov4" title="4">statements, _, err = ast.NewParser().WithReader(strings.NewReader(embeddedLib)).Parse()
        if err != nil </span><span class="cov1" title="1">{
                log.Err(err).Msg("Could not parse default library")
                return "", err
        }</span>
        <span class="cov3" title="3">for _, st := range statements </span><span class="cov4" title="4">{
                if rule, ok := st.(*ast.Rule); ok </span><span class="cov4" title="4">{
                        if _, remove := headers[string(rule.Head.Name)]; remove </span><span class="cov2" title="2">{
                                embeddedLib = strings.Replace(embeddedLib, string(rule.Location.Text), "", 1)
                        }</span>
                        <span class="cov4" title="4">continue</span>
                }
                <span class="cov0" title="0">if regoPackage, ok := st.(*ast.Package); ok </span><span class="cov0" title="0">{
                        firstHalf := strings.Join(strings.Split(embeddedLib, "\n")[:regoPackage.Location.Row-1], "\n")
                        secondHalf := strings.Join(strings.Split(embeddedLib, "\n")[regoPackage.Location.Row+1:], "\n")
                        embeddedLib = firstHalf + "\n" + secondHalf
                        continue</span>
                }
                <span class="cov0" title="0">if body, ok := st.(ast.Body); ok </span><span class="cov0" title="0">{
                        variableSet := body.Vars(ast.SafetyCheckVisitorParams)
                        for variable := range variableSet </span><span class="cov0" title="0">{
                                if _, remove := variables[variable.String()]; remove </span><span class="cov0" title="0">{
                                        embeddedLib = strings.Replace(embeddedLib, string(body.Loc().Text), "", 1)
                                        break</span>
                                }
                        }
                }
        }
        <span class="cov3" title="3">customLib += "\n" + embeddedLib

        return customLib, nil</span>
}

// MergeInputData merges KICS input data with custom input data user defined
func MergeInputData(defaultInputData, customInputData string) (string, error) <span class="cov7" title="15">{
        if checkEmptyInputdata(customInputData) &amp;&amp; checkEmptyInputdata(defaultInputData) </span><span class="cov7" title="13">{
                return emptyInputData, nil
        }</span>
        <span class="cov2" title="2">if checkEmptyInputdata(defaultInputData) </span><span class="cov0" title="0">{
                return customInputData, nil
        }</span>
        <span class="cov2" title="2">if checkEmptyInputdata(customInputData) </span><span class="cov1" title="1">{
                return defaultInputData, nil
        }</span>

        <span class="cov1" title="1">dataJSON := map[string]interface{}{}
        customDataJSON := map[string]interface{}{}
        if unmarshalError := json.Unmarshal([]byte(defaultInputData), &amp;dataJSON); unmarshalError != nil </span><span class="cov0" title="0">{
                return "", errors.Wrapf(unmarshalError, "failed to merge query input data")
        }</span>
        <span class="cov1" title="1">if unmarshalError := json.Unmarshal([]byte(customInputData), &amp;customDataJSON); unmarshalError != nil </span><span class="cov0" title="0">{
                return "", errors.Wrapf(unmarshalError, "failed to merge query input data")
        }</span>

        <span class="cov1" title="1">for key, value := range customDataJSON </span><span class="cov2" title="2">{
                dataJSON[key] = value
        }</span>
        <span class="cov1" title="1">mergedJSON, mergeErr := json.Marshal(dataJSON)
        if mergeErr != nil </span><span class="cov0" title="0">{
                return "", errors.Wrapf(mergeErr, "failed to merge query input data")
        }</span>
        <span class="cov1" title="1">return string(mergedJSON), nil</span>
}

func checkEmptyInputdata(inputData string) bool <span class="cov10" title="33">{
        return inputData == emptyInputData || inputData == ""
}</span>
</pre>
		
		<pre class="file" id="file41" style="display: none">package engine

import (
        "encoding/json"
        "strings"

        dec "github.com/Checkmarx/kics/pkg/detector"
        "github.com/Checkmarx/kics/pkg/engine/similarity"
        "github.com/Checkmarx/kics/pkg/model"
        "github.com/pkg/errors"
        "github.com/rs/zerolog"
        "github.com/rs/zerolog/log"
)

const (
        formatFloat64 = 64
)

// DefaultVulnerabilityBuilder defines a vulnerability builder to execute default actions of scan
var DefaultVulnerabilityBuilder = func(ctx *QueryContext, tracker Tracker,
        v interface{}, detector *dec.DetectLine) (*model.Vulnerability, error) <span class="cov10" title="5">{
        vObj, ok := v.(map[string]interface{})
        if !ok </span><span class="cov0" title="0">{
                return &amp;model.Vulnerability{}, ErrInvalidResult
        }</span>

        <span class="cov10" title="5">vObj = mergeWithMetadata(vObj, ctx.Query.Metadata.Metadata)

        var err error
        var output []byte

        output, err = json.Marshal(vObj)
        if err != nil </span><span class="cov0" title="0">{
                return &amp;model.Vulnerability{}, errors.Wrap(err, "failed to marshall query output")
        }</span>

        <span class="cov10" title="5">var fileID *string

        fileID, err = mapKeyToString(vObj, "documentId", false)
        if err != nil </span><span class="cov0" title="0">{
                return &amp;model.Vulnerability{}, errors.Wrap(err, "failed to recognize file id")
        }</span>

        <span class="cov10" title="5">file, ok := ctx.Files[*fileID]
        if !ok </span><span class="cov0" title="0">{
                return &amp;model.Vulnerability{}, errors.New("failed to find file from query response")
        }</span>

        <span class="cov10" title="5">logWithFields := log.With().
                Str("scanID", ctx.scanID).
                Str("fileName", file.FilePath).
                Str("queryName", ctx.Query.Metadata.Query).
                Logger()

        detector.SetupLogs(&amp;logWithFields)

        linesVulne := model.VulnerabilityLines{
                Line:      -1,
                VulnLines: &amp;[]model.CodeLine{},
        }

        similarityIDLineInfo := ""
        searchKey := ""
        if s, ok := vObj["searchKey"]; ok </span><span class="cov10" title="5">{
                searchKey = s.(string)
                similarityIDLineInfo = searchKey
                linesVulne = detector.DetectLine(&amp;file, searchKey, &amp;logWithFields)
        }</span> else<span class="cov0" title="0"> {
                logWithFields.Error().Msg("Saving result. failed to detect line")
        }</span>

        <span class="cov10" title="5">lineNumber := 0
        if file.Kind != model.KindHELM &amp;&amp; len(file.ResolvedFiles) == 0 </span><span class="cov10" title="5">{
                searchLineCalc := &amp;searchLineCalculator{
                        lineNr:               -1,
                        vObj:                 vObj,
                        file:                 file,
                        detector:             detector,
                        similarityIDLineInfo: similarityIDLineInfo,
                        linesVulne:           linesVulne,
                }
                // calculate search Line if possible (default uses values of search key)
                lineNumber, similarityIDLineInfo, linesVulne = calculeSearchLine(searchLineCalc)
        }</span>

        <span class="cov10" title="5">if linesVulne.Line == -1 </span><span class="cov10" title="5">{
                logWithFields.Warn().Msgf("Failed to detect line, query response %s", searchKey)
                linesVulne.Line = 1
        }</span>

        <span class="cov10" title="5">searchValue := ""
        if s, ok := vObj["searchValue"]; ok </span><span class="cov0" title="0">{
                searchValue = s.(string)
        }</span>

        <span class="cov10" title="5">overrideKey := ""
        if s, ok := vObj["overrideKey"]; ok </span><span class="cov4" title="2">{
                overrideKey = s.(string)
        }</span>

        <span class="cov10" title="5">queryID := getStringFromMap("id", DefaultQueryID, overrideKey, vObj, &amp;logWithFields)

        severity := getResolvedSeverity(vObj, &amp;logWithFields, overrideKey)

        issueType := DefaultIssueType
        if v := mustMapKeyToString(vObj, "issueType"); v != nil </span><span class="cov10" title="5">{
                issueType = model.IssueType(*v)
        }</span>

        <span class="cov10" title="5">var similarityID *string

        similarityID, err = similarity.ComputeSimilarityID(ctx.BaseScanPaths, linesVulne.ResolvedFile, queryID, similarityIDLineInfo, searchValue)
        if err != nil </span><span class="cov0" title="0">{
                logWithFields.Err(err).Send()
                tracker.FailedComputeSimilarityID()
        }</span>

        <span class="cov10" title="5">platform := getStringFromMap("platform", "", overrideKey, vObj, &amp;logWithFields)

        return &amp;model.Vulnerability{
                ID:               0,
                SimilarityID:     PtrStringToString(similarityID),
                ScanID:           ctx.scanID,
                FileID:           file.ID,
                FileName:         linesVulne.ResolvedFile,
                QueryName:        getStringFromMap("queryName", DefaultQueryName, overrideKey, vObj, &amp;logWithFields),
                QueryID:          queryID,
                QueryURI:         getStringFromMap("descriptionUrl", DefaultQueryURI, overrideKey, vObj, &amp;logWithFields),
                Category:         getStringFromMap("category", "", overrideKey, vObj, &amp;logWithFields),
                Description:      getStringFromMap("descriptionText", "", overrideKey, vObj, &amp;logWithFields),
                DescriptionID:    getStringFromMap("descriptionID", DefaultQueryDescriptionID, overrideKey, vObj, &amp;logWithFields),
                Severity:         severity,
                Platform:         getStringFromMap("platform", "", overrideKey, vObj, &amp;logWithFields),
                Line:             linesVulne.Line,
                VulnLines:        linesVulne.VulnLines,
                ResourceType:     PtrStringToString(mustMapKeyToString(vObj, "resourceType")),
                ResourceName:     PtrStringToString(mustMapKeyToString(vObj, "resourceName")),
                IssueType:        issueType,
                SearchKey:        searchKey,
                SearchLine:       lineNumber,
                SearchValue:      searchValue,
                KeyExpectedValue: PtrStringToString(mustMapKeyToString(vObj, "keyExpectedValue")),
                KeyActualValue:   PtrStringToString(mustMapKeyToString(vObj, "keyActualValue")),
                Value:            mustMapKeyToString(vObj, "value"),
                Output:           string(output),
                CloudProvider:    getCloudProvider(platform, overrideKey, vObj, &amp;logWithFields),
                Remediation:      PtrStringToString(mustMapKeyToString(vObj, "remediation")),
                RemediationType:  PtrStringToString(mustMapKeyToString(vObj, "remediationType")),
        }, nil</span>
}

func getCloudProvider(platform, overrideKey string, vObj map[string]interface{}, logWithFields *zerolog.Logger) string <span class="cov10" title="5">{
        cloudProvider := ""
        if platform == "Terraform" || platform == "CloudFormation" || platform == "Ansible" </span><span class="cov0" title="0">{
                cloudProvider = getStringFromMap("cloudProvider", "", overrideKey, vObj, logWithFields)
        }</span>

        <span class="cov10" title="5">return cloudProvider</span>
}

// calculate search Line if possible (default uses values of search key)
func calculeSearchLine(searchLineCalc *searchLineCalculator) (lineNumber int,
        similarityIDLineInfo string, linesVulne model.VulnerabilityLines) <span class="cov10" title="5">{
        searchLineCalc.calculate()
        lineNumber = searchLineCalc.lineNr
        similarityIDLineInfo = searchLineCalc.similarityIDLineInfo
        linesVulne = searchLineCalc.linesVulne

        return lineNumber, similarityIDLineInfo, linesVulne
}</span>

func getResolvedSeverity(vObj map[string]interface{}, logWithFields *zerolog.Logger, overrideKey string) model.Severity <span class="cov10" title="5">{
        var severity model.Severity = model.SeverityInfo
        s, err := mapKeyToString(vObj, "severity", false)
        if err == nil </span><span class="cov7" title="3">{
                sev := getSeverity(strings.ToUpper(*s))
                if sev == "" </span><span class="cov0" title="0">{
                        logWithFields.Warn().Str("severity", *s).Msg("Saving result. invalid severity constant value")
                }</span> else<span class="cov7" title="3"> {
                        severity = sev
                        overrideValue := tryOverride(overrideKey, "severity", vObj)
                        if overrideValue != nil </span><span class="cov1" title="1">{
                                sev = getSeverity(strings.ToUpper(*overrideValue))
                                if sev != "" </span><span class="cov1" title="1">{
                                        severity = sev
                                }</span>
                        }
                }
        } else<span class="cov4" title="2"> {
                logWithFields.Info().Msg("Saving result. failed to detect severity")
        }</span>

        <span class="cov10" title="5">return severity</span>
}
</pre>
		
		<pre class="file" id="file42" style="display: none">package engine

import (
        "encoding/json"
        "fmt"
        "strconv"

        dec "github.com/Checkmarx/kics/pkg/detector"
        "github.com/Checkmarx/kics/pkg/model"
        "github.com/Checkmarx/kics/pkg/utils"
        "github.com/rs/zerolog"
        "github.com/rs/zerolog/log"
)

type searchLineCalculator struct {
        lineNr               int
        vObj                 map[string]interface{}
        file                 model.FileMetadata
        detector             *dec.DetectLine
        similarityIDLineInfo string
        linesVulne           model.VulnerabilityLines
}

func (s *searchLineCalculator) calculate() <span class="cov4" title="7">{
        if searchLine, ok := s.vObj["searchLine"]; ok </span><span class="cov1" title="1">{
                line := make([]string, 0, len(searchLine.([]interface{})))
                for _, strElement := range searchLine.([]interface{}) </span><span class="cov3" title="3">{
                        line = append(line, strElement.(string))
                }</span>
                <span class="cov1" title="1">var err error
                s.lineNr, err = dec.GetLineBySearchLine(line, &amp;s.file)
                if err != nil </span><span class="cov0" title="0">{
                        log.Error().Msgf("failed to get line information from searchLine, using searchKey")
                }</span>
                <span class="cov1" title="1">if s.lineNr &gt;= 0 </span><span class="cov1" title="1">{
                        s.similarityIDLineInfo = strconv.Itoa(s.lineNr)
                        s.linesVulne = s.detector.GetAdjecent(&amp;s.file, s.lineNr)
                }</span>
        }
}
func mergeWithMetadata(base, additional map[string]interface{}) map[string]interface{} <span class="cov4" title="7">{
        for k, v := range additional </span><span class="cov6" title="19">{
                if _, ok := base[k]; ok </span><span class="cov1" title="1">{
                        continue</span>
                }
                <span class="cov6" title="18">base[k] = v</span>
        }
        <span class="cov4" title="7">return base</span>
}
func mustMapKeyToString(m map[string]interface{}, key string) *string <span class="cov8" title="41">{
        res, err := mapKeyToString(m, key, true)
        excludedFields := []string{"value", "resourceName", "resourceType", "remediation", "remediationType"}
        if err != nil &amp;&amp; !utils.Contains(key, excludedFields) </span><span class="cov4" title="6">{
                log.Warn().
                        Str("reason", err.Error()).
                        Msgf("Failed to get key %s in map", key)
        }</span>
        <span class="cov8" title="41">return res</span>
}
func mapKeyToString(m map[string]interface{}, key string, allowNil bool) (*string, error) <span class="cov10" title="103">{
        v, ok := m[key]
        if !ok </span><span class="cov9" title="77">{
                return nil, fmt.Errorf("key '%s' not found in map", key)
        }</span>
        <span class="cov7" title="26">switch vv := v.(type) </span>{
        case json.Number:<span class="cov0" title="0">
                return stringToPtrString(vv.String()), nil</span>
        case string:<span class="cov6" title="21">
                return stringToPtrString(vv), nil</span>
        case int, int32, int64:<span class="cov2" title="2">
                return stringToPtrString(fmt.Sprintf("%d", vv)), nil</span>
        case float32:<span class="cov0" title="0">
                return stringToPtrString(strconv.FormatFloat(float64(vv), 'f', -1, formatFloat64)), nil</span>
        case float64:<span class="cov1" title="1">
                return stringToPtrString(strconv.FormatFloat(vv, 'f', -1, formatFloat64)), nil</span>
        case nil:<span class="cov1" title="1">
                if allowNil </span><span class="cov0" title="0">{
                        return nil, nil
                }</span>
                <span class="cov1" title="1">return stringToPtrString("null"), nil</span>
        case bool:<span class="cov1" title="1">
                return stringToPtrString(fmt.Sprintf("%v", vv)), nil</span>
        }
        <span class="cov0" title="0">log.Debug().
                Msg("Detecting line. can't format item to string")
        if allowNil </span><span class="cov0" title="0">{
                return nil, nil
        }</span>
        <span class="cov0" title="0">return stringToPtrString(""), nil</span>
}
func stringToPtrString(v string) *string <span class="cov7" title="26">{
        return &amp;v
}</span>

// PtrStringToString - converts a pointer to string to a string
func PtrStringToString(v *string) string <span class="cov8" title="37">{
        if v == nil </span><span class="cov7" title="27">{
                return ""
        }</span>
        <span class="cov5" title="10">return *v</span>
}
func tryOverride(overrideKey, vulnParam string, vObj map[string]interface{}) *string <span class="cov3" title="4">{
        if overrideKey != "" </span><span class="cov3" title="3">{
                if override, ok := vObj["override"].(map[string]interface{}); ok </span><span class="cov3" title="3">{
                        if overrideObject, ok := override[overrideKey].(map[string]interface{}); ok </span><span class="cov3" title="3">{
                                if _, ok := overrideObject[vulnParam]; ok </span><span class="cov2" title="2">{
                                        overrideValue, err := mapKeyToString(overrideObject, vulnParam, true)
                                        if err != nil </span><span class="cov0" title="0">{
                                                return nil
                                        }</span> else<span class="cov2" title="2"> if overrideValue != nil </span><span class="cov2" title="2">{
                                                return overrideValue
                                        }</span>
                                }
                        }
                }
        }
        <span class="cov2" title="2">return nil</span>
}
func getStringFromMap(vulnParam, defaultParam, overrideKey string, vObj map[string]interface{}, logWithFields *zerolog.Logger) string <span class="cov8" title="40">{
        ts, err := mapKeyToString(vObj, vulnParam, false)
        if err != nil </span><span class="cov8" title="39">{
                logWithFields.Err(err).
                        Msgf("Saving result. failed to detect %s", vulnParam)
                return defaultParam
        }</span>
        <span class="cov1" title="1">overrideValue := tryOverride(overrideKey, vulnParam, vObj)
        if overrideValue != nil </span><span class="cov1" title="1">{
                ts = overrideValue
        }</span>
        <span class="cov1" title="1">return *ts</span>
}
func getSeverity(severity string) model.Severity <span class="cov3" title="4">{
        for _, si := range model.AllSeverities </span><span class="cov5" title="13">{
                if severity == string(si) </span><span class="cov3" title="4">{
                        return si
                }</span>
        }
        <span class="cov0" title="0">return ""</span>
}
</pre>
		
		<pre class="file" id="file43" style="display: none">package kics

import (
        "bytes"
        "context"
        "encoding/json"
        "fmt"
        "sort"

        sentryReport "github.com/Checkmarx/kics/internal/sentry"
        "github.com/Checkmarx/kics/pkg/model"
        "github.com/Checkmarx/kics/pkg/utils"
        "github.com/google/uuid"
        "github.com/rs/zerolog/log"
)

func (s *Service) resolverSink(ctx context.Context, filename, scanID string) ([]string, error) <span class="cov0" title="0">{
        kind := s.Resolver.GetType(filename)
        if kind == model.KindCOMMON </span><span class="cov0" title="0">{
                return []string{}, nil
        }</span>
        <span class="cov0" title="0">resFiles, err := s.Resolver.Resolve(filename, kind)
        if err != nil </span><span class="cov0" title="0">{
                log.Err(err).Msgf("failed to render file content")
                return []string{}, nil
        }</span>

        <span class="cov0" title="0">for _, rfile := range resFiles.File </span><span class="cov0" title="0">{
                s.Tracker.TrackFileFound()
                countLines := bytes.Count(rfile.Content, []byte{'\n'}) + 1
                s.Tracker.TrackFileFoundCountLines(countLines)

                documents, err := s.Parser.Parse(rfile.FileName, rfile.Content)
                if err != nil </span><span class="cov0" title="0">{
                        if documents.Kind == "break" </span><span class="cov0" title="0">{
                                return []string{}, nil
                        }</span>
                        <span class="cov0" title="0">log.Err(err).Msgf("failed to parse file content")
                        return []string{}, nil</span>
                }
                <span class="cov0" title="0">for _, document := range documents.Docs </span><span class="cov0" title="0">{
                        _, err = json.Marshal(document)
                        if err != nil </span><span class="cov0" title="0">{
                                sentryReport.ReportSentry(&amp;sentryReport.Report{
                                        Message:  fmt.Sprintf("failed to marshal content in file: %s", rfile.FileName),
                                        Err:      err,
                                        Location: "func resolverSink()",
                                        FileName: rfile.FileName,
                                        Kind:     kind,
                                }, true)
                                continue</span>
                        }

                        <span class="cov0" title="0">if len(documents.IgnoreLines) &gt; 0 </span><span class="cov0" title="0">{
                                sort.Ints(documents.IgnoreLines)
                        }</span>

                        <span class="cov0" title="0">file := model.FileMetadata{
                                ID:                uuid.New().String(),
                                ScanID:            scanID,
                                Document:          PrepareScanDocument(document, kind),
                                OriginalData:      string(rfile.OriginalData),
                                LineInfoDocument:  document,
                                Kind:              kind,
                                FilePath:          rfile.FileName,
                                Content:           string(rfile.Content),
                                HelmID:            rfile.SplitID,
                                IDInfo:            rfile.IDInfo,
                                LinesIgnore:       documents.IgnoreLines,
                                ResolvedFiles:     documents.ResolvedFiles,
                                LinesOriginalData: utils.SplitLines(string(rfile.OriginalData)),
                        }
                        s.saveToFile(ctx, &amp;file)</span>
                }
                <span class="cov0" title="0">s.Tracker.TrackFileParse()
                s.Tracker.TrackFileParseCountLines(documents.CountLines)</span>
        }
        <span class="cov0" title="0">return resFiles.Excluded, nil</span>
}
</pre>
		
		<pre class="file" id="file44" style="display: none">package kics

import (
        "bytes"
        "context"
        "encoding/json"
        "io"
        "sync"

        "github.com/Checkmarx/kics/pkg/engine"
        "github.com/Checkmarx/kics/pkg/engine/provider"
        "github.com/Checkmarx/kics/pkg/engine/secrets"
        "github.com/Checkmarx/kics/pkg/model"
        "github.com/Checkmarx/kics/pkg/parser"
        "github.com/Checkmarx/kics/pkg/resolver"

        "github.com/Checkmarx/kics/pkg/utils"
        "github.com/pkg/errors"
        "github.com/rs/zerolog/log"
)

const (
        mbConst = 1048576
)

// Storage is the interface that wraps following basic methods: SaveFile, SaveVulnerability, GetVulnerability and GetScanSummary
// SaveFile should append metadata to a file
// SaveVulnerabilities should append vulnerabilities list to current storage
// GetVulnerabilities should returns all vulnerabilities associated to a scan ID
// GetScanSummary should return a list of summaries based on their scan IDs
type Storage interface {
        SaveFile(ctx context.Context, metadata *model.FileMetadata) error
        SaveVulnerabilities(ctx context.Context, vulnerabilities []model.Vulnerability) error
        GetVulnerabilities(ctx context.Context, scanID string) ([]model.Vulnerability, error)
        GetScanSummary(ctx context.Context, scanIDs []string) ([]model.SeveritySummary, error)
}

// Tracker is the interface that wraps the basic methods: TrackFileFound and TrackFileParse
// TrackFileFound should increment the number of files to be scanned
// TrackFileParse should increment the number of files parsed successfully to be scanned
type Tracker interface {
        TrackFileFound()
        TrackFileParse()
        TrackFileFoundCountLines(countLines int)
        TrackFileParseCountLines(countLines int)
}

// Service is a struct that contains a SourceProvider to receive sources, a storage to save and retrieve scanning informations
// a parser to parse and provide files in format that KICS understand, a inspector that runs the scanning and a tracker to
// update scanning numbers
type Service struct {
        SourceProvider   provider.SourceProvider
        Storage          Storage
        Parser           *parser.Parser
        Inspector        *engine.Inspector
        SecretsInspector *secrets.Inspector
        Tracker          Tracker
        Resolver         *resolver.Resolver
        files            model.FileMetadatas
}

// PrepareSources will prepare the sources to be scanned
func (s *Service) PrepareSources(ctx context.Context, scanID string, wg *sync.WaitGroup, errCh chan&lt;- error) <span class="cov0" title="0">{
        defer wg.Done()
        // CxSAST query under review
        data := make([]byte, mbConst)
        if err := s.SourceProvider.GetSources(
                ctx,
                s.Parser.SupportedExtensions(),
                func(ctx context.Context, filename string, rc io.ReadCloser) error </span><span class="cov0" title="0">{
                        return s.sink(ctx, filename, scanID, rc, data)
                }</span>,
                func(ctx context.Context, filename string) ([]string, error) <span class="cov0" title="0">{ // Sink used for resolver files and templates
                        return s.resolverSink(ctx, filename, scanID)
                }</span>,
        ); err != nil <span class="cov0" title="0">{
                errCh &lt;- errors.Wrap(err, "failed to read sources")
        }</span>
}

// StartScan executes scan over the context, using the scanID as reference
func (s *Service) StartScan(
        ctx context.Context,
        scanID string,
        errCh chan&lt;- error,
        wg *sync.WaitGroup,
        currentQuery chan&lt;- int64) <span class="cov6" title="4">{
        log.Debug().Msg("service.StartScan()")
        defer wg.Done()

        secretsVulnerabilities, err := s.SecretsInspector.Inspect(
                ctx,
                s.SourceProvider.GetBasePaths(),
                s.files,
                currentQuery,
        )
        if err != nil </span><span class="cov0" title="0">{
                errCh &lt;- errors.Wrap(err, "failed to inspect secrets")
        }</span>

        <span class="cov6" title="4">vulnerabilities, err := s.Inspector.Inspect(
                ctx,
                scanID,
                s.files,
                s.SourceProvider.GetBasePaths(),
                s.Parser.Platform,
                currentQuery,
        )
        if err != nil </span><span class="cov0" title="0">{
                errCh &lt;- errors.Wrap(err, "failed to inspect files")
        }</span>
        <span class="cov6" title="4">vulnerabilities = append(vulnerabilities, secretsVulnerabilities...)

        updateMaskedSecrets(&amp;vulnerabilities, s.SecretsInspector.SecretTracker)

        err = s.Storage.SaveVulnerabilities(ctx, vulnerabilities)
        if err != nil </span><span class="cov0" title="0">{
                errCh &lt;- errors.Wrap(err, "failed to save vulnerabilities")
        }</span>
}

// Content keeps the content of the file and the number of lines
type Content struct {
        Content    *[]byte
        CountLines int
}

/*
   getContent will read the passed file 1MB at a time
   to prevent resource exhaustion and return its content
*/
func getContent(rc io.Reader, data []byte) (*Content, error) <span class="cov0" title="0">{
        maxSizeMB := 5 // Max size of file in MBs
        var content []byte
        countLines := 0

        c := &amp;Content{
                Content:    &amp;[]byte{},
                CountLines: 0,
        }

        for </span><span class="cov0" title="0">{
                if maxSizeMB &lt; 0 </span><span class="cov0" title="0">{
                        return c, errors.New("file size limit exceeded")
                }</span>
                <span class="cov0" title="0">data = data[:cap(data)]
                n, err := rc.Read(data)
                if err != nil </span><span class="cov0" title="0">{
                        if err == io.EOF </span><span class="cov0" title="0">{
                                break</span>
                        }
                        <span class="cov0" title="0">return c, err</span>
                }
                <span class="cov0" title="0">countLines += bytes.Count(data[:n], []byte{'\n'}) + 1
                content = append(content, data[:n]...)
                maxSizeMB--</span>
        }
        <span class="cov0" title="0">c.Content = &amp;content
        c.CountLines = countLines

        return c, nil</span>
}

// GetVulnerabilities returns a list of scan detected vulnerabilities
func (s *Service) GetVulnerabilities(ctx context.Context, scanID string) ([]model.Vulnerability, error) <span class="cov6" title="4">{
        return s.Storage.GetVulnerabilities(ctx, scanID)
}</span>

// GetScanSummary returns how many vulnerabilities of each severity was found
func (s *Service) GetScanSummary(ctx context.Context, scanIDs []string) ([]model.SeveritySummary, error) <span class="cov6" title="4">{
        return s.Storage.GetScanSummary(ctx, scanIDs)
}</span>

func (s *Service) saveToFile(ctx context.Context, file *model.FileMetadata) <span class="cov0" title="0">{
        err := s.Storage.SaveFile(ctx, file)
        if err == nil </span><span class="cov0" title="0">{
                s.files = append(s.files, *file)
        }</span>
}

// PrepareScanDocument removes _kics_lines from payload and parses json filters
func PrepareScanDocument(body map[string]interface{}, kind model.FileKind) map[string]interface{} <span class="cov1" title="1">{
        var bodyMap map[string]interface{}
        j, err := json.Marshal(body)
        if err != nil </span><span class="cov0" title="0">{
                log.Error().Msgf("failed to remove kics line information")
                return body
        }</span>
        <span class="cov1" title="1">if err := json.Unmarshal(j, &amp;bodyMap); err != nil </span><span class="cov0" title="0">{
                log.Error().Msgf("failed to remove kics line information: '%s'", err)
                return body
        }</span>
        <span class="cov1" title="1">prepareScanDocumentRoot(bodyMap, kind)
        return bodyMap</span>
}

func prepareScanDocumentRoot(body interface{}, kind model.FileKind) <span class="cov7" title="6">{
        switch bodyType := body.(type) </span>{
        case map[string]interface{}:<span class="cov7" title="6">
                prepareScanDocumentValue(bodyType, kind)</span>
        case []interface{}:<span class="cov0" title="0">
                for _, indx := range bodyType </span><span class="cov0" title="0">{
                        prepareScanDocumentRoot(indx, kind)
                }</span>
        }
}

func prepareScanDocumentValue(bodyType map[string]interface{}, kind model.FileKind) <span class="cov7" title="6">{
        delete(bodyType, "_kics_lines")
        for key, v := range bodyType </span><span class="cov10" title="11">{
                switch value := v.(type) </span>{
                case map[string]interface{}:<span class="cov6" title="4">
                        prepareScanDocumentRoot(value, kind)</span>
                case []interface{}:<span class="cov1" title="1">
                        for _, indx := range value </span><span class="cov1" title="1">{
                                prepareScanDocumentRoot(indx, kind)
                        }</span>
                case string:<span class="cov7" title="6">
                        if field, ok := lines[kind]; ok &amp;&amp; utils.Contains(key, field) </span><span class="cov1" title="1">{
                                bodyType[key] = resolveJSONFilter(value)
                        }</span>
                }
        }
}

func updateMaskedSecrets(vulnerabilities *[]model.Vulnerability, maskedSecretsTracked []secrets.SecretTracker) <span class="cov6" title="4">{
        for idx := range *vulnerabilities </span><span class="cov0" title="0">{
                for _, secretT := range maskedSecretsTracked </span><span class="cov0" title="0">{
                        updateMaskedSecretLine(&amp;(*vulnerabilities)[idx], secretT)
                }</span>
        }
}

func updateMaskedSecretLine(vulnerability *model.Vulnerability, secretT secrets.SecretTracker) <span class="cov0" title="0">{
        if vulnerability.FileName == secretT.ResolvedFilePath </span><span class="cov0" title="0">{
                for vlidx := range *vulnerability.VulnLines </span><span class="cov0" title="0">{
                        if (*vulnerability.VulnLines)[vlidx].Position == secretT.Line </span><span class="cov0" title="0">{
                                (*vulnerability.VulnLines)[vlidx].Line = secretT.MaskedContent
                        }</span>
                }
        }
}
</pre>
		
		<pre class="file" id="file45" style="display: none">package kics

import (
        "context"
        "encoding/json"
        "fmt"
        "io"
        "sort"

        sentryReport "github.com/Checkmarx/kics/internal/sentry"
        "github.com/Checkmarx/kics/pkg/model"
        "github.com/Checkmarx/kics/pkg/parser/jsonfilter/parser"
        "github.com/Checkmarx/kics/pkg/utils"
        "github.com/antlr/antlr4/runtime/Go/antlr"
        "github.com/google/uuid"
        "github.com/pkg/errors"
        "github.com/rs/zerolog/log"
)

var (
        lines = map[model.FileKind][]string{
                "TF":   {"pattern"},
                "JSON": {"FilterPattern"},
                "YAML": {"filter_pattern", "FilterPattern"},
        }
)

func (s *Service) sink(ctx context.Context, filename, scanID string, rc io.Reader, data []byte) error <span class="cov0" title="0">{
        s.Tracker.TrackFileFound()
        log.Debug().Msgf("Starting to process file %s", filename)

        c, err := getContent(rc, data)

        content := c.Content

        s.Tracker.TrackFileFoundCountLines(c.CountLines)

        if err != nil </span><span class="cov0" title="0">{
                return errors.Wrapf(err, "failed to get file content: %s", filename)
        }</span>

        <span class="cov0" title="0">documents, err := s.Parser.Parse(filename, *content)
        if err != nil </span><span class="cov0" title="0">{
                log.Err(err).Msgf("failed to parse file content: %s", filename)
                return nil
        }</span>

        <span class="cov0" title="0">fileCommands := s.Parser.CommentsCommands(filename, *content)

        for _, document := range documents.Docs </span><span class="cov0" title="0">{
                _, err = json.Marshal(document)
                if err != nil </span><span class="cov0" title="0">{
                        sentryReport.ReportSentry(&amp;sentryReport.Report{
                                Message:  fmt.Sprintf("failed to marshal content in file: %s", filename),
                                Err:      err,
                                Location: "func sink()",
                                FileName: filename,
                                Kind:     documents.Kind,
                        }, true)
                        continue</span>
                }

                <span class="cov0" title="0">if len(documents.IgnoreLines) &gt; 0 </span><span class="cov0" title="0">{
                        sort.Ints(documents.IgnoreLines)
                }</span>

                <span class="cov0" title="0">file := model.FileMetadata{
                        ID:                uuid.New().String(),
                        ScanID:            scanID,
                        Document:          PrepareScanDocument(document, documents.Kind),
                        LineInfoDocument:  document,
                        OriginalData:      documents.Content,
                        Kind:              documents.Kind,
                        FilePath:          filename,
                        Commands:          fileCommands,
                        LinesIgnore:       documents.IgnoreLines,
                        ResolvedFiles:     documents.ResolvedFiles,
                        LinesOriginalData: utils.SplitLines(documents.Content),
                }

                s.saveToFile(ctx, &amp;file)</span>
        }
        <span class="cov0" title="0">s.Tracker.TrackFileParse()
        log.Debug().Msgf("Finished to process file %s", filename)
        s.Tracker.TrackFileParseCountLines(documents.CountLines)

        return errors.Wrap(err, "failed to save file content")</span>
}

func resolveJSONFilter(jsonFilter string) string <span class="cov8" title="1">{
        is := antlr.NewInputStream(jsonFilter)

        // lexer build
        lexer := parser.NewJSONFilterLexer(is)
        lexer.RemoveErrorListeners()
        stream := antlr.NewCommonTokenStream(lexer, antlr.TokenDefaultChannel)
        errorListener := parser.NewCustomErrorListener()
        lexer.RemoveErrorListeners()
        lexer.AddErrorListener(errorListener)

        // parser build
        p := parser.NewJSONFilterParser(stream)
        p.RemoveErrorListeners()
        p.AddErrorListener(errorListener)
        p.BuildParseTrees = true
        tree := p.Awsjsonfilter()

        // parse
        visitor := parser.NewJSONFilterPrinterVisitor()
        if errorListener.HasErrors() </span><span class="cov0" title="0">{
                return jsonFilter
        }</span>

        <span class="cov8" title="1">parsed := visitor.VisitAll(tree)

        parsedByte, err := json.Marshal(parsed)
        if err != nil </span><span class="cov0" title="0">{
                return jsonFilter
        }</span>

        <span class="cov8" title="1">return string(parsedByte)</span>
}
</pre>
		
		<pre class="file" id="file46" style="display: none">/*
Package kuberneter implements calls to the Kubernetes API in order to scan the runtime information of the resources
*/
package kuberneter

import (
        "os"

        b64 "encoding/base64"

        "github.com/pkg/errors"
        "github.com/rs/zerolog/log"
        "k8s.io/client-go/rest"
        "k8s.io/client-go/tools/clientcmd"
        "sigs.k8s.io/controller-runtime/pkg/client"
)

// K8sConfig saves the config for k8s auth
type K8sConfig struct {
        Config *rest.Config
}

func getK8sClient() (client.Client, error) <span class="cov9" title="6">{
        // authentication through k8s config file
        if len(os.Getenv("K8S_CONFIG_FILE")) &gt; 0 </span><span class="cov4" title="2">{
                config, err := clientcmd.BuildConfigFromFlags("", os.Getenv("K8S_CONFIG_FILE"))

                if err != nil </span><span class="cov1" title="1">{
                        log.Error().Msgf("failed to get k8s client through k8s config file: %s", err)
                        return nil, err
                }</span>

                <span class="cov1" title="1">log.Info().Msg("auth to k8s API through k8s config file")

                config.QPS = 100
                config.Burst = 100

                return client.New(config, client.Options{})</span>
        }

        <span class="cov7" title="4">c := &amp;K8sConfig{
                Config: &amp;rest.Config{
                        QPS:   100,
                        Burst: 100,
                },
        }

        // authentication through k8s service account token or k8s client certificate
        if len(os.Getenv("K8S_HOST")) &gt; 0 &amp;&amp; c.hasCertificateAuthority() </span><span class="cov4" title="2">{
                c.Config.Host = os.Getenv("K8S_HOST")

                // authentication through k8s service account token
                if c.hasServiceAccountToken() </span><span class="cov1" title="1">{
                        log.Info().Msg("auth to k8s API through k8s service account token")
                        return client.New(c.Config, client.Options{})
                }</span>

                // authentication through k8s client certificate
                <span class="cov1" title="1">if c.hasClientCertificate() </span><span class="cov1" title="1">{
                        log.Info().Msg("auth to k8s API through k8s client certificate")
                        return client.New(c.Config, client.Options{})
                }</span>
        }

        <span class="cov4" title="2">log.Error().Msg("failed to get k8s client. check the k8s cluster auth information")
        return nil, errors.New("failed to get k8s client")</span>
}

func (c *K8sConfig) hasCertificateAuthority() bool <span class="cov9" title="6">{
        if len(os.Getenv("K8S_CA_FILE")) &gt; 0 </span><span class="cov6" title="3">{
                c.Config.TLSClientConfig.CAFile = os.Getenv("K8S_CA_FILE")
                return true
        }</span>

        <span class="cov6" title="3">if len(os.Getenv("K8S_CA_DATA")) &gt; 0 </span><span class="cov4" title="2">{
                caDataDecoded, err := b64.StdEncoding.DecodeString(os.Getenv("K8S_CA_DATA"))
                if err != nil </span><span class="cov1" title="1">{
                        log.Error().Msgf("failed to decode K8S_CA_DATA: %s", err)
                        return false
                }</span>
                <span class="cov1" title="1">c.Config.TLSClientConfig.CAData = caDataDecoded
                return true</span>
        }

        <span class="cov1" title="1">return false</span>
}

func (c *K8sConfig) hasServiceAccountToken() bool <span class="cov8" title="5">{
        if len(os.Getenv("K8S_SA_TOKEN_FILE")) &gt; 0 </span><span class="cov1" title="1">{
                c.Config.BearerTokenFile = os.Getenv("K8S_SA_TOKEN_FILE")
                return true
        }</span>

        <span class="cov7" title="4">if len(os.Getenv("K8S_SA_TOKEN_DATA")) &gt; 0 </span><span class="cov4" title="2">{
                c.Config.BearerToken = os.Getenv("K8S_SA_TOKEN_DATA")
                return true
        }</span>

        <span class="cov4" title="2">return false</span>
}

func (c *K8sConfig) hasClientCertificate() bool <span class="cov10" title="7">{
        hasCert := false

        if len(os.Getenv("K8S_CERT_FILE")) &gt; 0 </span><span class="cov7" title="4">{
                c.Config.TLSClientConfig.CertFile = os.Getenv("K8S_CERT_FILE")
                hasCert = true
        }</span>

        <span class="cov10" title="7">if len(os.Getenv("K8S_CERT_DATA")) &gt; 0 </span><span class="cov4" title="2">{
                certDataDecoded, err := b64.StdEncoding.DecodeString(os.Getenv("K8S_CERT_DATA"))
                if err != nil </span><span class="cov1" title="1">{
                        log.Error().Msgf("failed to decode K8S_CERT_DATA: %s", err)
                        return false
                }</span>
                <span class="cov1" title="1">c.Config.TLSClientConfig.CertData = certDataDecoded
                hasCert = true</span>
        }

        <span class="cov9" title="6">if hasCert </span><span class="cov8" title="5">{
                if len(os.Getenv("K8S_KEY_FILE")) &gt; 0 </span><span class="cov6" title="3">{
                        c.Config.TLSClientConfig.KeyFile = os.Getenv("K8S_KEY_FILE")
                        return true
                }</span>

                <span class="cov4" title="2">if len(os.Getenv("K8S_KEY_DATA")) &gt; 0 </span><span class="cov4" title="2">{
                        keyDataDecoded, err := b64.StdEncoding.DecodeString(os.Getenv("K8S_KEY_DATA"))
                        if err != nil </span><span class="cov1" title="1">{
                                log.Error().Msgf("failed to decode K8S_KEY_DATA: %s", err)
                                return false
                        }</span>
                        <span class="cov1" title="1">c.Config.TLSClientConfig.KeyData = keyDataDecoded
                        return true</span>
                }
        }

        <span class="cov1" title="1">return false</span>
}
</pre>
		
		<pre class="file" id="file47" style="display: none">/*
Package kuberneter implements calls to the Kubernetes API in order to scan the runtime information of the resources
*/
package kuberneter

import (
        "context"
        "os"
        "path/filepath"
        "strings"
        "sync"

        "github.com/pkg/errors"
        "github.com/rs/zerolog/log"
        "k8s.io/apimachinery/pkg/api/meta"
        "sigs.k8s.io/controller-runtime/pkg/client"
)

type k8sAPICall struct {
        client           client.Client
        options          *K8sAPIOptions
        ctx              *context.Context
        destionationPath string
}

type supportedKinds map[string]map[string]interface{}

var getK8sClientFunc = getK8sClient // for testing purposes

// Import imports the k8s cluster resources into the destination using kuberneter path
func Import(ctx context.Context, kuberneterPath, destinationPath string) (string, error) <span class="cov10" title="2">{
        log.Info().Msg("importing k8s cluster resources")

        supportedKinds := buildSupportedKinds()
        defer func() </span><span class="cov10" title="2">{ supportedKinds = nil }</span>()

        // extract k8s API options
        <span class="cov10" title="2">k8sAPIOptions, err := extractK8sAPIOptions(kuberneterPath, supportedKinds)
        if err != nil </span><span class="cov1" title="1">{
                return "", err
        }</span>

        // get the k8s client
        <span class="cov1" title="1">c, err := getK8sClientFunc()
        if err != nil </span><span class="cov0" title="0">{
                return "", err
        }</span>

        // create folder to save k8s resources
        <span class="cov1" title="1">destination, err := getDestinationFolder(destinationPath)
        if err != nil </span><span class="cov0" title="0">{
                return "", err
        }</span>

        <span class="cov1" title="1">if c == nil </span><span class="cov1" title="1">{
                return destination, errors.New("failed to get client")
        }</span>

        <span class="cov0" title="0">info := &amp;k8sAPICall{
                client:           c,
                options:          k8sAPIOptions,
                ctx:              &amp;ctx,
                destionationPath: destination,
        }

        // list and save k8s resources
        for i := range k8sAPIOptions.Namespaces </span><span class="cov0" title="0">{
                info.listK8sResources(i, supportedKinds)
        }</span>

        <span class="cov0" title="0">return destination, nil</span>
}

func (info *k8sAPICall) listK8sResources(idx int, supKinds *supportedKinds) <span class="cov0" title="0">{
        var wg sync.WaitGroup
        for apiVersion := range *supKinds </span><span class="cov0" title="0">{
                kinds := (*supKinds)[apiVersion]

                if isTarget(apiVersion, info.options.APIVersions) </span><span class="cov0" title="0">{
                        wg.Add(1)
                        go info.listKinds(apiVersion, kinds, info.options.Namespaces[idx], &amp;wg)
                }</span>
        }
        <span class="cov0" title="0">wg.Wait()</span>
}

func (info *k8sAPICall) listKinds(apiVersion string, kinds map[string]interface{}, namespace string, wg *sync.WaitGroup) <span class="cov0" title="0">{
        defer wg.Done()
        sb := &amp;strings.Builder{}

        apiVersionFolder := filepath.Join(info.destionationPath, apiVersion)

        if err := os.MkdirAll(apiVersionFolder, os.ModePerm); err != nil </span><span class="cov0" title="0">{
                log.Error().Msgf("unable to create folder %s: %s", apiVersionFolder, err)
                return
        }</span>

        <span class="cov0" title="0">for kind := range kinds </span><span class="cov0" title="0">{
                kindList := kinds[kind]

                if !isTarget(kind, info.options.Kinds) </span><span class="cov0" title="0">{
                        continue</span>
                }

                <span class="cov0" title="0">if _, ok := kindList.(client.ObjectList); !ok </span><span class="cov0" title="0">{
                        continue</span>
                }

                <span class="cov0" title="0">resource := kindList.(client.ObjectList)
                err := info.client.List(*info.ctx, resource, client.InNamespace(namespace))
                if err != nil </span><span class="cov0" title="0">{
                        log.Info().Msgf("failed to list %s: %s", apiVersion, err)
                }</span>

                <span class="cov0" title="0">objList, err := meta.ExtractList(resource)
                if err != nil </span><span class="cov0" title="0">{
                        log.Info().Msgf("failed to extract list: %s", err)
                }</span>

                <span class="cov0" title="0">log.Info().Msgf("KICS found %d %s(s) in %s from %s", len(objList), kind, getNamespace(namespace), apiVersion)

                for i := range objList </span><span class="cov0" title="0">{
                        item := objList[i]
                        sb = info.getResource(item, apiVersion, kind, sb)
                }</span>

                <span class="cov0" title="0">if len(sb.String()) &gt; 0 </span><span class="cov0" title="0">{
                        info.saveK8sResources(kind, sb.String(), apiVersionFolder)
                }</span>
                <span class="cov0" title="0">sb.Reset()</span>
        }
}
</pre>
		
		<pre class="file" id="file48" style="display: none">package kuberneter

import (
        "fmt"
        "os"
        "path/filepath"
        "strings"
        "time"

        "github.com/Checkmarx/kics/pkg/utils"
        "github.com/pkg/errors"
        "github.com/rs/zerolog/log"
        appsv1 "k8s.io/api/apps/v1"
        appsv1beta1 "k8s.io/api/apps/v1beta1"
        appsv1beta2 "k8s.io/api/apps/v1beta2"
        batchv1 "k8s.io/api/batch/v1"
        batchv1beta1 "k8s.io/api/batch/v1beta1"
        corev1 "k8s.io/api/core/v1"
        networkingv1 "k8s.io/api/networking/v1"
        networkingv1beta1 "k8s.io/api/networking/v1beta1"
        policyv1 "k8s.io/api/policy/v1"
        policyv1beta1 "k8s.io/api/policy/v1beta1"
        rbacv1 "k8s.io/api/rbac/v1"
        rbacv1alpha1 "k8s.io/api/rbac/v1alpha1"
        rbacv1beta1 "k8s.io/api/rbac/v1beta1"
        "k8s.io/apimachinery/pkg/runtime"
        "k8s.io/apimachinery/pkg/runtime/serializer/json"
        "k8s.io/client-go/kubernetes/scheme"
)

// K8sAPIOptions saves all the necessary information to list the resources
type K8sAPIOptions struct {
        Namespaces  []string
        APIVersions []string
        Kinds       []string
}

const kuberneterPathLength = 3

func (info *k8sAPICall) saveK8sResources(kind, k8sResourcesContent, apiVersionFolder string) <span class="cov0" title="0">{
        file := filepath.Join(apiVersionFolder, kind+"s"+".yaml")

        f, err := os.OpenFile(filepath.Clean(file), os.O_WRONLY|os.O_CREATE|os.O_TRUNC, os.ModePerm)

        if err != nil </span><span class="cov0" title="0">{
                log.Error().Msgf("failed to open file '%s': %s", file, err)
        }</span>

        <span class="cov0" title="0">if _, err = f.WriteString(k8sResourcesContent); err != nil </span><span class="cov0" title="0">{
                log.Error().Msgf("failed to write file '%s': %s", file, err)
        }</span>

        <span class="cov0" title="0">err = f.Close()
        if err != nil </span><span class="cov0" title="0">{
                log.Err(err).Msgf("failed to close file: %s", file)
        }</span>
}

func (info *k8sAPICall) getResource(o runtime.Object, apiVersion, kind string, sb *strings.Builder) *strings.Builder <span class="cov0" title="0">{
        e := json.NewYAMLSerializer(json.DefaultMetaFactory, scheme.Scheme, scheme.Scheme)

        begin := fmt.Sprintf("\n---\napiVersion: %s\nkind: %s\n", getAPIVersion(apiVersion), kind)

        if _, err := sb.WriteString(begin); err != nil </span><span class="cov0" title="0">{
                log.Err(err).Msg("failed to write")
        }</span>

        <span class="cov0" title="0">if err := e.Encode(o, sb); err != nil </span><span class="cov0" title="0">{
                log.Err(err).Msg("failed to encode")
        }</span>

        <span class="cov0" title="0">return sb</span>
}

func extractK8sAPIOptions(path string, supportedKinds *supportedKinds) (*K8sAPIOptions, error) <span class="cov4" title="7">{
        pathInfo := strings.Split(path, ":")
        if len(pathInfo) != kuberneterPathLength </span><span class="cov2" title="2">{
                return &amp;K8sAPIOptions{}, errors.New("wrong kuberneter path syntax")
        }</span>

        <span class="cov3" title="5">k8sAPIOptions := &amp;K8sAPIOptions{
                Namespaces:  strings.Split(pathInfo[0], "+"),
                APIVersions: strings.Split(pathInfo[1], "+"),
                Kinds:       strings.Split(pathInfo[2], "+"),
        }

        supAPIVersions, supKinds := getSupportedOptions(supportedKinds)

        for i := range k8sAPIOptions.APIVersions </span><span class="cov4" title="6">{
                if !utils.Contains(k8sAPIOptions.APIVersions[i], *supAPIVersions) </span><span class="cov1" title="1">{
                        return &amp;K8sAPIOptions{}, errors.New("wrong apiVersion: " + k8sAPIOptions.APIVersions[i])
                }</span>
        }

        <span class="cov3" title="4">for i := range k8sAPIOptions.Kinds </span><span class="cov3" title="5">{
                if !utils.Contains(k8sAPIOptions.Kinds[i], *supKinds) </span><span class="cov1" title="1">{
                        return &amp;K8sAPIOptions{}, errors.New("wrong kind: " + k8sAPIOptions.Kinds[i])
                }</span>
        }

        <span class="cov2" title="3">if k8sAPIOptions.Namespaces[0] == "*" </span><span class="cov2" title="2">{
                k8sAPIOptions.Namespaces[0] = ""
        }</span>

        <span class="cov2" title="3">return k8sAPIOptions, nil</span>
}

func getNamespace(namespace string) string <span class="cov2" title="2">{
        if namespace == "" </span><span class="cov1" title="1">{
                return "all namespaces"
        }</span>

        <span class="cov1" title="1">return fmt.Sprintf("the namespace %s", namespace)</span>
}

func buildSupportedKinds() *supportedKinds <span class="cov2" title="3">{
        supportedKinds := &amp;supportedKinds{
                "apps/v1": {
                        "DaemonSet":   &amp;appsv1.DaemonSetList{},
                        "Deployment":  &amp;appsv1.DeploymentList{},
                        "ReplicaSet":  &amp;appsv1.ReplicaSetList{},
                        "StatefulSet": &amp;appsv1.StatefulSetList{},
                },
                "core/v1": {
                        "LimitRange":            &amp;corev1.LimitRangeList{},
                        "Pod":                   &amp;corev1.PodList{},
                        "PersistentVolume":      &amp;corev1.PersistentVolumeList{},
                        "PersistentVolumeClaim": &amp;corev1.PersistentVolumeClaimList{},
                        "ReplicationController": &amp;corev1.ReplicationControllerList{},
                        "ResourceQuota":         &amp;corev1.ResourceQuotaList{},
                        "Secret":                &amp;corev1.SecretList{},
                        "ServiceAccount":        &amp;corev1.ServiceAccountList{},
                        "Service":               &amp;corev1.ServiceList{},
                },
                "batch/v1": {
                        "CronJob": &amp;batchv1.CronJobList{},
                        "Job":     &amp;batchv1.JobList{},
                },
                "networking.k8s.io/v1": {
                        "IngressClass":  &amp;networkingv1.IngressClassList{},
                        "Ingress":       &amp;networkingv1.IngressList{},
                        "NetworkPolicy": &amp;networkingv1.NetworkPolicyList{},
                },
                "policy/v1": {
                        "PodDisruptionBudget": &amp;policyv1.PodDisruptionBudgetList{},
                },
                "rbac.authorization.k8s.io/v1": {
                        "ClusterRoleBinding": &amp;rbacv1.ClusterRoleBindingList{},
                        "ClusterRole":        &amp;rbacv1.ClusterRoleList{},
                        "RoleBinding":        &amp;rbacv1.RoleBindingList{},
                        "Role":               &amp;rbacv1.RoleList{},
                },
                "apps/v1beta1": {
                        "Deployment":  &amp;appsv1beta1.DeploymentList{},
                        "StatefulSet": &amp;appsv1beta1.StatefulSetList{},
                },
                "apps/v1beta2": {
                        "DaemonSet":   &amp;appsv1beta2.DaemonSetList{},
                        "Deployment":  &amp;appsv1beta2.DeploymentList{},
                        "ReplicaSet":  &amp;appsv1beta2.ReplicaSetList{},
                        "StatefulSet": &amp;appsv1beta2.StatefulSet{},
                },
                "batch/v1beta1": {
                        "CronJob": &amp;batchv1beta1.CronJobList{},
                },
                "networking.k8s.io/v1beta1": {
                        "IngressClass": &amp;networkingv1beta1.IngressClassList{},
                        "Ingress":      &amp;networkingv1beta1.IngressList{},
                },
                "policy/v1beta1": {
                        "PodDisruptionBudget": &amp;policyv1beta1.PodDisruptionBudgetList{},
                        "PodSecurityPolicy":   &amp;policyv1beta1.PodSecurityPolicyList{},
                },
                "rbac.authorization.k8s.io/v1alpha1": {
                        "ClusterRoleBinding": &amp;rbacv1alpha1.ClusterRoleBindingList{},
                        "ClusterRole":        &amp;rbacv1alpha1.ClusterRoleList{},
                        "RoleBinding":        &amp;rbacv1alpha1.RoleBindingList{},
                        "Role":               &amp;rbacv1alpha1.RoleList{},
                },
                "rbac.authorization.k8s.io/v1beta1": {
                        "ClusterRoleBinding": &amp;rbacv1beta1.ClusterRoleBindingList{},
                        "ClusterRole":        &amp;rbacv1beta1.ClusterRoleList{},
                        "RoleBinding":        &amp;rbacv1beta1.RoleBindingList{},
                        "Role":               &amp;rbacv1beta1.RoleList{},
                },
        }

        return supportedKinds
}</span>

func isTarget(target string, targetOptions []string) bool <span class="cov2" title="3">{
        if targetOptions[0] == "*" || utils.Contains(target, targetOptions) </span><span class="cov2" title="2">{
                return true
        }</span>
        <span class="cov1" title="1">return false</span>
}

func getDestinationFolder(destinationPath string) (string, error) <span class="cov1" title="1">{
        var err error
        if destinationPath == "" </span><span class="cov1" title="1">{
                destinationPath, err = os.Getwd()
                if err != nil </span><span class="cov0" title="0">{
                        return "", errors.Wrap(err, "failed to get working directory")
                }</span>
        }
        <span class="cov1" title="1">destFolderName := fmt.Sprintf("kics-extract-kuberneter-%s", time.Now().Format("01-02-2006"))
        destination := filepath.Join(destinationPath, destFolderName)

        if err := os.MkdirAll(destination, os.ModePerm); err != nil </span><span class="cov0" title="0">{
                return "", err
        }</span>

        <span class="cov1" title="1">return destination, nil</span>
}

func getAPIVersion(apiVersion string) string <span class="cov2" title="2">{
        if apiVersion == "core/v1" </span><span class="cov1" title="1">{
                return "v1"
        }</span>
        <span class="cov1" title="1">return apiVersion</span>
}

func getSupportedOptions(supportedKinds *supportedKinds) (v, k *[]string) <span class="cov3" title="5">{
        supportedAPIVersions := make([]string, 0)
        supKinds := make([]string, 0)

        for apiVersion := range *supportedKinds </span><span class="cov8" title="65">{
                supportedAPIVersions = append(supportedAPIVersions, apiVersion)
                for kind := range (*supportedKinds)[apiVersion] </span><span class="cov10" title="210">{
                        supKinds = append(supKinds, kind)
                }</span>
        }

        <span class="cov3" title="5">supportedAPIVersions = append(supportedAPIVersions, "*")
        supKinds = append(supKinds, "*")

        return &amp;supportedAPIVersions, &amp;supKinds</span>
}
</pre>
		
		<pre class="file" id="file49" style="display: none">package model

import (
        "strings"
        "sync"

        "gopkg.in/yaml.v3"
)

// comment is a struct that holds the comment
type comment string

// Ignore is a struct that holds the lines to ignore
type Ignore struct {
        // Lines is the lines to ignore
        Lines []int
}

var (
        // NewIgnore is the ignore struct
        NewIgnore = &amp;Ignore{}
        memoryMu  sync.Mutex
)

// build builds the ignore struct
func (i *Ignore) build(lines []int) <span class="cov7" title="29">{
        defer memoryMu.Unlock()
        memoryMu.Lock()
        i.Lines = append(i.Lines, lines...)
}</span>

// GetLines returns the lines to ignore
func (i *Ignore) GetLines() []int <span class="cov4" title="6">{
        return RemoveDuplicates(i.Lines)
}</span>

// Reset resets the ignore struct
func (i *Ignore) Reset() <span class="cov4" title="6">{
        i.Lines = make([]int, 0)
}</span>

// ignoreCommentsYAML sets the lines to ignore for a yaml file
func ignoreCommentsYAML(node *yaml.Node) <span class="cov7" title="29">{
        linesIgnore := make([]int, 0)
        if node.HeadComment != "" </span><span class="cov1" title="1">{
                // Squence Node - Head Comment comes in root node
                linesIgnore = append(linesIgnore, processCommentYAML((*comment)(&amp;node.HeadComment), 0, node, node.Kind, false)...)
                NewIgnore.build(linesIgnore)
                return
        }</span>
        // check if comment is in the content
        <span class="cov7" title="28">for i, content := range node.Content </span><span class="cov10" title="107">{
                if content.FootComment != "" &amp;&amp; i+2 &lt; len(node.Content) </span><span class="cov0" title="0">{
                        linesIgnore = append(linesIgnore, processCommentYAML((*comment)(&amp;content.FootComment), i+2, node, node.Kind, true)...)
                }</span>
                <span class="cov10" title="107">if content.HeadComment == "" </span><span class="cov9" title="102">{
                        continue</span>
                }
                <span class="cov4" title="5">linesIgnore = append(linesIgnore, processCommentYAML((*comment)(&amp;content.HeadComment), i, node, node.Kind, false)...)</span>
        }

        <span class="cov7" title="28">NewIgnore.build(linesIgnore)</span>
}

// processCommentYAML returns the lines to ignore
func processCommentYAML(comment *comment, position int, content *yaml.Node, kind yaml.Kind, isFooter bool) (linesIgnore []int) <span class="cov4" title="6">{
        linesIgnore = make([]int, 0)
        switch com := (*comment).value(); com </span>{
        case IgnoreLine:<span class="cov2" title="2">
                linesIgnore = append(linesIgnore, processLine(kind, content, position)...)</span>
        case IgnoreBlock:<span class="cov3" title="3">
                linesIgnore = append(linesIgnore, processBlock(kind, content.Content, position)...)</span>
        default:<span class="cov1" title="1">
                linesIgnore = append(linesIgnore, processRegularLine(string(*comment), content, position, isFooter)...)</span>
        }

        <span class="cov4" title="6">return</span>
}

func getSeqLastLine(content *yaml.Node) int <span class="cov0" title="0">{
        if len(content.Content) == 0 </span><span class="cov0" title="0">{
                return content.Line
        }</span>

        <span class="cov0" title="0">return content.Content[len(content.Content)-1].Line</span>
}

func getFootComments(comment string, content *yaml.Node, position, commentsNumber int) (linesIgnore []int) <span class="cov0" title="0">{
        for </span><span class="cov0" title="0">{ // get the right position where the comment is a foot comment
                if content.Content[position].FootComment == comment </span><span class="cov0" title="0">{
                        break</span>
                }
                <span class="cov0" title="0">position--</span>
        }

        <span class="cov0" title="0">line := content.Content[position].Line

        if content.Content[position+1].Kind == yaml.SequenceNode </span><span class="cov0" title="0">{
                // get the last line of the sequence through the sequence after the content that has the comment as a foot comment
                // example:
                // - proto: tcp  // content.Content[position]
                //   ports:      // content.Content[position+1]
                //     - 80
                //     - 443    //  last line of the sequence
                //   # public ALB 80 + 443 must be access able from everywhere
                line = getSeqLastLine(content.Content[position+1])
        }</span>

        <span class="cov0" title="0">for i := 1; i &lt;= commentsNumber; i++ </span><span class="cov0" title="0">{
                linesIgnore = append(linesIgnore, line+i)
        }</span>

        <span class="cov0" title="0">return</span>
}

func processRegularLine(comment string, content *yaml.Node, position int, isFooter bool) (linesIgnore []int) <span class="cov1" title="1">{
        linesIgnore = make([]int, 0)

        if len(content.Content) == 0 </span><span class="cov0" title="0">{
                return linesIgnore
        }</span>

        <span class="cov1" title="1">line := content.Content[position].Line
        commentsNumber := strings.Count(comment, "#") // number of comments (coverage of nested comments)

        if isFooter </span><span class="cov0" title="0">{ // comment is a foot comment
                return getFootComments(comment, content, position, commentsNumber)
        }</span>

        // comment is not a foot comment

        <span class="cov1" title="1">if KICSCommentRgxpYaml.MatchString(comment) </span><span class="cov0" title="0">{
                // has kics-scan ignore at the end of the comment
                linesIgnore = append(linesIgnore, line)
        }</span>

        <span class="cov1" title="1">for i := 1; i &lt;= commentsNumber; i++ </span><span class="cov1" title="1">{
                linesIgnore = append(linesIgnore, line-i)
        }</span>

        <span class="cov1" title="1">return linesIgnore</span>
}

// processLine returns the lines to ignore for a line
func processLine(kind yaml.Kind, content *yaml.Node, position int) (linesIgnore []int) <span class="cov2" title="2">{
        linesIgnore = make([]int, 0)
        var nodeToIgnore *yaml.Node
        if kind == yaml.ScalarNode </span><span class="cov0" title="0">{
                nodeToIgnore = content
        }</span> else<span class="cov2" title="2"> {
                nodeToIgnore = content.Content[position]
        }</span>
        <span class="cov2" title="2">linesIgnore = append(linesIgnore, nodeToIgnore.Line-1, nodeToIgnore.Line)
        return</span>
}

// processBlock returns the lines to ignore for a block
func processBlock(kind yaml.Kind, content []*yaml.Node, position int) (linesIgnore []int) <span class="cov3" title="3">{
        linesIgnore = make([]int, 0)
        var contentToIgnore []*yaml.Node
        if kind == yaml.SequenceNode </span><span class="cov0" title="0">{
                contentToIgnore = content[position].Content
        }</span> else<span class="cov3" title="3"> if position == 0 </span><span class="cov1" title="1">{
                contentToIgnore = content
        }</span> else<span class="cov2" title="2"> {
                contentToIgnore = content[position+1].Content
        }</span>

        <span class="cov3" title="3">linesIgnore = append(linesIgnore, content[position].Line, content[position].Line-1)
        linesIgnore = append(linesIgnore, Range(contentToIgnore[0].Line,
                getNodeLastLine(contentToIgnore[len(contentToIgnore)-1]))...)
        return</span>
}

// getNodeLastLine returns the last line of a node
func getNodeLastLine(node *yaml.Node) (lastLine int) <span class="cov7" title="33">{
        lastLine = node.Line
        for _, content := range node.Content </span><span class="cov7" title="30">{
                if content.Line &gt; lastLine </span><span class="cov5" title="13">{
                        lastLine = content.Line
                }</span>
                <span class="cov7" title="30">if lineContent := getNodeLastLine(content); lineContent &gt; lastLine </span><span class="cov4" title="5">{
                        lastLine = lineContent
                }</span>
        }

        <span class="cov7" title="33">return</span>
}

// value returns the value of the comment
func (c *comment) value() (value CommentCommand) <span class="cov4" title="6">{
        comment := strings.ToLower(string(*c))
        // check if we are working with kics command
        if KICSCommentRgxp.MatchString(comment) </span><span class="cov4" title="6">{
                comment = KICSCommentRgxp.ReplaceAllString(comment, "")
                comment = strings.Trim(comment, "\n")
                commands := strings.Split(strings.Trim(comment, "\r"), " ")
                value = ProcessCommands(commands)
                return
        }</span>
        <span class="cov0" title="0">return CommentCommand(comment)</span>
}
</pre>
		
		<pre class="file" id="file50" style="display: none">package model

// RemoveDuplicates removes duplicate lines from a slice of lines.
func RemoveDuplicates(lines []int) []int <span class="cov5" title="7">{
        seen := make(map[int]bool)
        var result []int
        for _, line := range lines </span><span class="cov10" title="37">{
                if !seen[line] </span><span class="cov9" title="35">{
                        result = append(result, line)
                        seen[line] = true
                }</span>
        }
        <span class="cov5" title="7">return result</span>
}

// ProcessCommands processes a slice of commands.
func ProcessCommands(commands []string) CommentCommand <span class="cov6" title="9">{
        for _, command := range commands </span><span class="cov6" title="10">{
                switch com := CommentCommand(command); com </span>{
                case IgnoreLine:<span class="cov3" title="3">
                        return IgnoreLine</span>
                case IgnoreBlock:<span class="cov4" title="4">
                        return IgnoreBlock</span>
                default:<span class="cov3" title="3">
                        continue</span>
                }
        }

        <span class="cov2" title="2">return CommentCommand(commands[0])</span>
}

// Range returns a slice of lines between the start and end line numbers.
func Range(start, end int) (lines []int) <span class="cov5" title="5">{
        lines = make([]int, end-start+1)
        for i := range lines </span><span class="cov9" title="26">{
                lines[i] = start + i
        }</span>
        <span class="cov5" title="5">return</span>
}
</pre>
		
		<pre class="file" id="file51" style="display: none">// Package model (go:generate go run -mod=mod github.com/mailru/easyjson/easyjson ./$GOFILE)
package model

import (
        "regexp"
        "sort"
        "strings"

        _ "github.com/mailru/easyjson/gen" // easyjson unmarshaler
        "github.com/rs/zerolog/log"
)

// Constants to describe what kind of file refers
const (
        KindTerraform FileKind = "TF"
        KindJSON      FileKind = "JSON"
        KindYAML      FileKind = "YAML"
        KindYML       FileKind = "YML"
        KindDOCKER    FileKind = "DOCKERFILE"
        KindPROTO     FileKind = "PROTO"
        KindCOMMON    FileKind = "*"
        KindHELM      FileKind = "HELM"
        KindBUILDAH   FileKind = "SH"
)

// Constants to describe commands given from comments
const (
        IgnoreLine    CommentCommand = "ignore-line"
        IgnoreBlock   CommentCommand = "ignore-block"
        IgnoreComment CommentCommand = "ignore-comment"
)

// Constants to describe vulnerability's severity
const (
        SeverityHigh   = "HIGH"
        SeverityMedium = "MEDIUM"
        SeverityLow    = "LOW"
        SeverityInfo   = "INFO"
        SeverityTrace  = "TRACE"
)

// Constants to describe issue's type
const (
        IssueTypeMissingAttribute   IssueType = "MissingAttribute"
        IssueTypeRedundantAttribute IssueType = "RedundantAttribute"
        IssueTypeIncorrectValue     IssueType = "IncorrectValue"
)

// Arrays to group all constants of one type
var (
        AllSeverities = []Severity{
                SeverityHigh,
                SeverityMedium,
                SeverityLow,
                SeverityInfo,
                SeverityTrace,
        }

        AllIssueTypesAsString = []string{
                string(IssueTypeMissingAttribute),
                string(IssueTypeRedundantAttribute),
                string(IssueTypeIncorrectValue),
        }
)

var (
        // KICSCommentRgxp is the regexp to identify if a comment is a KICS comment
        KICSCommentRgxp = regexp.MustCompile(`^((/{2})|#)*\s*kics-scan\s*`)
        // KICSCommentRgxpYaml is the regexp to identify if the comment has KICS comment at the end of the comment in YAML
        KICSCommentRgxpYaml = regexp.MustCompile(`((/{2})|#)*\s*kics-scan\s*(ignore-line|ignore-block)\s*\n*$`)
)

// Version - is the model for the version response
type Version struct {
        Latest           bool   `json:"is_latest"`
        LatestVersionTag string `json:"latest_version"`
}

// VulnerabilityLines is the representation of the found line for issue
type VulnerabilityLines struct {
        Line                 int
        VulnLines            *[]CodeLine
        LineWithVulnerabilty string
        ResolvedFile         string
}

// CommentCommand represents a command given from a comment
type CommentCommand string

// FileKind is the extension of a file
type FileKind string

// Severity of the vulnerability
type Severity string

// IssueType is the issue's type string representation
type IssueType string

// CodeLine is the lines containing and adjecent to the vulnerability line with their respective positions
type CodeLine struct {
        Position int
        Line     string
}

// ExtractedPathObject is the struct that contains the path location of extracted source
// and a boolean to check if it is a local source
type ExtractedPathObject struct {
        Path      string
        LocalPath bool
}

// CommentsCommands list of commands on a file that will be parsed
type CommentsCommands map[string]string

// FileMetadata is a representation of basic information and content of a file
type FileMetadata struct {
        ID                string `db:"id"`
        ScanID            string `db:"scan_id"`
        Document          Document
        LineInfoDocument  map[string]interface{}
        OriginalData      string   `db:"orig_data"`
        Kind              FileKind `db:"kind"`
        FilePath          string   `db:"file_path"`
        Content           string
        HelmID            string
        IDInfo            map[int]interface{}
        Commands          CommentsCommands
        LinesIgnore       []int
        ResolvedFiles     map[string]ResolvedFile
        LinesOriginalData *[]string
}

// QueryMetadata is a representation of general information about a query
type QueryMetadata struct {
        InputData string
        Query     string
        Content   string
        Metadata  map[string]interface{}
        Platform  string
        // special field for generic queries
        // represents how many queries are aggregated into a single rego file
        Aggregation int
}

// Vulnerability is a representation of a detected vulnerability in scanned files
// after running a query
type Vulnerability struct {
        ID               int         `json:"id"`
        ScanID           string      `db:"scan_id" json:"-"`
        SimilarityID     string      `db:"similarity_id" json:"similarityID"`
        FileID           string      `db:"file_id" json:"-"`
        FileName         string      `db:"file_name" json:"fileName"`
        QueryID          string      `db:"query_id" json:"queryID"`
        QueryName        string      `db:"query_name" json:"queryName"`
        QueryURI         string      `json:"-"`
        Category         string      `json:"category"`
        Description      string      `json:"description"`
        DescriptionID    string      `json:"descriptionID"`
        Platform         string      `db:"platform" json:"platform"`
        Severity         Severity    `json:"severity"`
        Line             int         `json:"line"`
        VulnLines        *[]CodeLine `json:"vulnLines"`
        ResourceType     string      `db:"resource_type" json:"resourceType"`
        ResourceName     string      `db:"resource_name" json:"resourceName"`
        IssueType        IssueType   `db:"issue_type" json:"issueType"`
        SearchKey        string      `db:"search_key" json:"searchKey"`
        SearchLine       int         `db:"search_line" json:"searchLine"`
        SearchValue      string      `db:"search_value" json:"searchValue"`
        KeyExpectedValue string      `db:"key_expected_value" json:"expectedValue"`
        KeyActualValue   string      `db:"key_actual_value" json:"actualValue"`
        Value            *string     `db:"value" json:"value"`
        Output           string      `json:"-"`
        CloudProvider    string      `json:"cloud_provider"`
        Remediation      string      `db:"remediation" json:"remediation"`
        RemediationType  string      `db:"remediation_type" json:"remediation_type"`
}

// QueryConfig is a struct that contains the fileKind and platform of the rego query
type QueryConfig struct {
        FileKind []FileKind
        Platform string
}

// ResolvedFiles keeps the information of all file/template resolved
type ResolvedFiles struct {
        File     []ResolvedHelm
        Excluded []string
}

// ResolvedHelm keeps the information of a file/template resolved
type ResolvedHelm struct {
        FileName     string
        Content      []byte
        OriginalData []byte
        SplitID      string
        IDInfo       map[int]interface{}
}

// Extensions represents a list of supported extensions
type Extensions map[string]struct{}

// Include returns true if an extension is included in supported extensions listed
// otherwise returns false
func (e Extensions) Include(ext string) bool <span class="cov1" title="1">{
        _, b := e[ext]

        return b
}</span>

// LineObject is the struct that will hold line information for each key
type LineObject struct {
        Line int                      `json:"_kics_line"`
        Arr  []map[string]*LineObject `json:"_kics_arr,omitempty"`
}

// MatchedFilesRegex returns the regex rule to identify if an extension is supported or not
func (e Extensions) MatchedFilesRegex() string <span class="cov10" title="4">{
        if len(e) == 0 </span><span class="cov5" title="2">{
                return "NO_MATCHED_FILES"
        }</span>

        <span class="cov5" title="2">var parts []string
        for ext := range e </span><span class="cov8" title="3">{
                parts = append(parts, "\\"+ext)
        }</span>

        <span class="cov5" title="2">sort.Strings(parts)

        return "(.*)(" + strings.Join(parts, "|") + ")$"</span>
}

// FileMetadatas is a slice of FileMetadata
type FileMetadatas []FileMetadata

// ToMap creates a map of FileMetadatas, which the key is the FileMedata ID and the value is the FileMetadata
func (m FileMetadatas) ToMap() map[string]FileMetadata <span class="cov1" title="1">{
        c := make(map[string]FileMetadata, len(m))
        for i := 0; i &lt; len(m); i++ </span><span class="cov1" title="1">{
                c[m[i].ID] = m[i]
        }</span>
        <span class="cov1" title="1">return c</span>
}

// Documents (easyjson:json)
type Documents struct {
        Documents []Document `json:"document"`
}

// Document (easyjson:json)
type Document map[string]interface{}

// Combine merge documents from FileMetadatas using the ID as reference for Document ID and FileName as reference for file
func (m FileMetadatas) Combine(lineInfo bool) Documents <span class="cov8" title="3">{
        documents := Documents{Documents: make([]Document, 0, len(m))}
        for i := 0; i &lt; len(m); i++ </span><span class="cov8" title="3">{
                _, ignore := m[i].Commands["ignore"]
                if len(m[i].Document) == 0 </span><span class="cov1" title="1">{
                        continue</span>
                }
                <span class="cov5" title="2">if ignore </span><span class="cov1" title="1">{
                        log.Debug().Msgf("Ignoring file %s", m[i].FilePath)
                        continue</span>
                }
                <span class="cov1" title="1">if lineInfo </span><span class="cov0" title="0">{
                        m[i].LineInfoDocument["id"] = m[i].ID
                        m[i].LineInfoDocument["file"] = m[i].FilePath
                        documents.Documents = append(documents.Documents, m[i].LineInfoDocument)
                }</span> else<span class="cov1" title="1"> {
                        m[i].Document["id"] = m[i].ID
                        m[i].Document["file"] = m[i].FilePath
                        documents.Documents = append(documents.Documents, m[i].Document)
                }</span>
        }
        <span class="cov8" title="3">return documents</span>
}

// AnalyzedPaths is a slice of types and excluded files obtained from the Analyzer
type AnalyzedPaths struct {
        Types []string
        Exc   []string
}

// ResolvedFileSplit is a struct that contains the information of a resolved file, the path and the lines of the file
type ResolvedFileSplit struct {
        Path  string
        Lines []string
}

// ResolvedFile is a struct that contains the information of a resolved file, the path and the content in bytes of the file
type ResolvedFile struct {
        Path         string
        Content      []byte
        LinesContent *[]string
}
</pre>
		
		<pre class="file" id="file52" style="display: none">// Code generated by easyjson for marshaling/unmarshaling. DO NOT EDIT.

package model

import (
        json "encoding/json"
        easyjson "github.com/mailru/easyjson"
        jlexer "github.com/mailru/easyjson/jlexer"
        jwriter "github.com/mailru/easyjson/jwriter"
)

// suppress unused package warning
var (
        _ *json.RawMessage
        _ *jlexer.Lexer
        _ *jwriter.Writer
        _ easyjson.Marshaler
)

func easyjsonC80ae7adDecodeGithubComCheckmarxKicsPkgModel(in *jlexer.Lexer, out *Documents) <span class="cov0" title="0">{
        isTopLevel := in.IsStart()
        if in.IsNull() </span><span class="cov0" title="0">{
                if isTopLevel </span><span class="cov0" title="0">{
                        in.Consumed()
                }</span>
                <span class="cov0" title="0">in.Skip()
                return</span>
        }
        <span class="cov0" title="0">in.Delim('{')
        for !in.IsDelim('}') </span><span class="cov0" title="0">{
                key := in.UnsafeFieldName(false)
                in.WantColon()
                if in.IsNull() </span><span class="cov0" title="0">{
                        in.Skip()
                        in.WantComma()
                        continue</span>
                }
                <span class="cov0" title="0">switch key </span>{
                case "document":<span class="cov0" title="0">
                        if in.IsNull() </span><span class="cov0" title="0">{
                                in.Skip()
                                out.Documents = nil
                        }</span> else<span class="cov0" title="0"> {
                                in.Delim('[')
                                if out.Documents == nil </span><span class="cov0" title="0">{
                                        if !in.IsDelim(']') </span><span class="cov0" title="0">{
                                                out.Documents = make([]Document, 0, 8)
                                        }</span> else<span class="cov0" title="0"> {
                                                out.Documents = []Document{}
                                        }</span>
                                } else<span class="cov0" title="0"> {
                                        out.Documents = (out.Documents)[:0]
                                }</span>
                                <span class="cov0" title="0">for !in.IsDelim(']') </span><span class="cov0" title="0">{
                                        var v1 Document
                                        (v1).UnmarshalEasyJSON(in)
                                        out.Documents = append(out.Documents, v1)
                                        in.WantComma()
                                }</span>
                                <span class="cov0" title="0">in.Delim(']')</span>
                        }
                default:<span class="cov0" title="0">
                        in.SkipRecursive()</span>
                }
                <span class="cov0" title="0">in.WantComma()</span>
        }
        <span class="cov0" title="0">in.Delim('}')
        if isTopLevel </span><span class="cov0" title="0">{
                in.Consumed()
        }</span>
}
func easyjsonC80ae7adEncodeGithubComCheckmarxKicsPkgModel(out *jwriter.Writer, in Documents) <span class="cov0" title="0">{
        out.RawByte('{')
        first := true
        _ = first
        </span><span class="cov0" title="0">{
                const prefix string = ",\"document\":"
                out.RawString(prefix[1:])
                if in.Documents == nil &amp;&amp; (out.Flags&amp;jwriter.NilSliceAsEmpty) == 0 </span><span class="cov0" title="0">{
                        out.RawString("null")
                }</span> else<span class="cov0" title="0"> {
                        out.RawByte('[')
                        for v2, v3 := range in.Documents </span><span class="cov0" title="0">{
                                if v2 &gt; 0 </span><span class="cov0" title="0">{
                                        out.RawByte(',')
                                }</span>
                                <span class="cov0" title="0">(v3).MarshalEasyJSON(out)</span>
                        }
                        <span class="cov0" title="0">out.RawByte(']')</span>
                }
        }
        <span class="cov0" title="0">out.RawByte('}')</span>
}

// MarshalJSON supports json.Marshaler interface
func (v Documents) MarshalJSON() ([]byte, error) <span class="cov0" title="0">{
        w := jwriter.Writer{}
        easyjsonC80ae7adEncodeGithubComCheckmarxKicsPkgModel(&amp;w, v)
        return w.Buffer.BuildBytes(), w.Error
}</span>

// MarshalEasyJSON supports easyjson.Marshaler interface
func (v Documents) MarshalEasyJSON(w *jwriter.Writer) <span class="cov0" title="0">{
        easyjsonC80ae7adEncodeGithubComCheckmarxKicsPkgModel(w, v)
}</span>

// UnmarshalJSON supports json.Unmarshaler interface
func (v *Documents) UnmarshalJSON(data []byte) error <span class="cov0" title="0">{
        r := jlexer.Lexer{Data: data}
        easyjsonC80ae7adDecodeGithubComCheckmarxKicsPkgModel(&amp;r, v)
        return r.Error()
}</span>

// UnmarshalEasyJSON supports easyjson.Unmarshaler interface
func (v *Documents) UnmarshalEasyJSON(l *jlexer.Lexer) <span class="cov0" title="0">{
        easyjsonC80ae7adDecodeGithubComCheckmarxKicsPkgModel(l, v)
}</span>
func easyjsonC80ae7adDecodeGithubComCheckmarxKicsPkgModel1(in *jlexer.Lexer, out *Document) <span class="cov6" title="3">{
        isTopLevel := in.IsStart()
        if in.IsNull() </span><span class="cov0" title="0">{
                in.Skip()
        }</span> else<span class="cov6" title="3"> {
                in.Delim('{')
                *out = make(Document)
                for !in.IsDelim('}') </span><span class="cov10" title="7">{
                        key := string(in.String())
                        in.WantColon()
                        var v4 interface{}
                        if m, ok := v4.(easyjson.Unmarshaler); ok </span><span class="cov0" title="0">{
                                m.UnmarshalEasyJSON(in)
                        }</span> else<span class="cov10" title="7"> if m, ok := v4.(json.Unmarshaler); ok </span><span class="cov0" title="0">{
                                _ = m.UnmarshalJSON(in.Raw())
                        }</span> else<span class="cov10" title="7"> {
                                v4 = in.Interface()
                        }</span>
                        <span class="cov10" title="7">(*out)[key] = v4
                        in.WantComma()</span>
                }
                <span class="cov6" title="3">in.Delim('}')</span>
        }
        <span class="cov6" title="3">if isTopLevel </span><span class="cov6" title="3">{
                in.Consumed()
        }</span>
}
func easyjsonC80ae7adEncodeGithubComCheckmarxKicsPkgModel1(out *jwriter.Writer, in Document) <span class="cov6" title="3">{
        if in == nil &amp;&amp; (out.Flags&amp;jwriter.NilMapAsEmpty) == 0 </span><span class="cov0" title="0">{
                out.RawString(`null`)
        }</span> else<span class="cov6" title="3"> {
                out.RawByte('{')
                v5First := true
                for v5Name, v5Value := range in </span><span class="cov10" title="7">{
                        if v5First </span><span class="cov6" title="3">{
                                v5First = false
                        }</span> else<span class="cov7" title="4"> {
                                out.RawByte(',')
                        }</span>
                        <span class="cov10" title="7">out.String(string(v5Name))
                        out.RawByte(':')
                        if m, ok := v5Value.(easyjson.Marshaler); ok </span><span class="cov0" title="0">{
                                m.MarshalEasyJSON(out)
                        }</span> else<span class="cov10" title="7"> if m, ok := v5Value.(json.Marshaler); ok </span><span class="cov0" title="0">{
                                out.Raw(m.MarshalJSON())
                        }</span> else<span class="cov10" title="7"> {
                                out.Raw(json.Marshal(v5Value))
                        }</span>
                }
                <span class="cov6" title="3">out.RawByte('}')</span>
        }
}

// MarshalJSON supports json.Marshaler interface
func (v Document) MarshalJSON() ([]byte, error) <span class="cov6" title="3">{
        w := jwriter.Writer{}
        easyjsonC80ae7adEncodeGithubComCheckmarxKicsPkgModel1(&amp;w, v)
        return w.Buffer.BuildBytes(), w.Error
}</span>

// MarshalEasyJSON supports easyjson.Marshaler interface
func (v Document) MarshalEasyJSON(w *jwriter.Writer) <span class="cov0" title="0">{
        easyjsonC80ae7adEncodeGithubComCheckmarxKicsPkgModel1(w, v)
}</span>

// UnmarshalJSON supports json.Unmarshaler interface
func (v *Document) UnmarshalJSON(data []byte) error <span class="cov6" title="3">{
        r := jlexer.Lexer{Data: data}
        easyjsonC80ae7adDecodeGithubComCheckmarxKicsPkgModel1(&amp;r, v)
        return r.Error()
}</span>

// UnmarshalEasyJSON supports easyjson.Unmarshaler interface
func (v *Document) UnmarshalEasyJSON(l *jlexer.Lexer) <span class="cov0" title="0">{
        easyjsonC80ae7adDecodeGithubComCheckmarxKicsPkgModel1(l, v)
}</span>
</pre>
		
		<pre class="file" id="file53" style="display: none">package model

import (
        json "encoding/json"
        "errors"
        "path/filepath"
        "strconv"

        "github.com/Checkmarx/kics/pkg/utils"
        "github.com/rs/zerolog/log"
        "gopkg.in/yaml.v3"
)

// UnmarshalYAML is a custom yaml parser that places line information in the payload
func (m *Document) UnmarshalYAML(value *yaml.Node) error <span class="cov3" title="3">{
        dpc := unmarshal(value)
        if mapDcp, ok := dpc.(map[string]interface{}); ok </span><span class="cov3" title="3">{
                // set line information for root level objects
                mapDcp["_kics_lines"] = getLines(value, 0)

                // place the payload in the Document struct
                tmp, _ := json.Marshal(mapDcp)
                _ = json.Unmarshal(tmp, m)
                return nil
        }</span>
        <span class="cov0" title="0">return errors.New("failed to parse yaml content")</span>
}

// GetIgnoreLines get the lines to ignore in the KICS results
// lines ignore can have the lines from the resolved files
// since inspector secrets only looks to original data, the lines ignore should be replaced in yaml cases
func GetIgnoreLines(file *FileMetadata) []int <span class="cov1" title="1">{
        ignoreLines := file.LinesIgnore

        if utils.Contains(filepath.Ext(file.FilePath), []string{".yml", ".yaml"}) </span><span class="cov1" title="1">{
                NewIgnore.Reset()
                var node yaml.Node

                if err := yaml.Unmarshal([]byte(file.OriginalData), &amp;node); err != nil </span><span class="cov0" title="0">{
                        log.Info().Msgf("failed to unmarshal file: %s", err)
                        return ignoreLines
                }</span>

                <span class="cov1" title="1">if node.Kind == 1 &amp;&amp; len(node.Content) == 1 </span><span class="cov1" title="1">{
                        _ = unmarshal(node.Content[0])
                        ignoreLines = NewIgnore.GetLines()
                }</span>
        }

        <span class="cov1" title="1">return ignoreLines</span>
}

/*
        YAML Node TYPES

        SequenceNode -&gt; array
        ScalarNode -&gt; generic (execpt for arrays, objects and maps)
        MappingNode -&gt; map

*/
// unmarshal is the function that will parse the yaml elements and call the functions needed
// to place their line information in the payload
func unmarshal(val *yaml.Node) interface{} <span class="cov8" title="24">{
        tmp := make(map[string]interface{})
        ignoreCommentsYAML(val)

        // if Yaml Node is an Array than we are working with ansible
        // which need to be placed inside "playbooks"
        if val.Kind == yaml.SequenceNode </span><span class="cov2" title="2">{
                contentArray := make([]interface{}, 0)
                for _, contentEntry := range val.Content </span><span class="cov3" title="3">{
                        contentArray = append(contentArray, unmarshal(contentEntry))
                }</span>
                <span class="cov2" title="2">tmp["playbooks"] = contentArray</span>
        } else<span class="cov8" title="22"> if val.Kind == yaml.ScalarNode </span><span class="cov4" title="4">{
                // resolve Scalar Node
                return scalarNodeResolver(val)
        }</span> else<span class="cov7" title="18"> {
                // iterate two by two, since first iteration is the key and the second is the value
                for i := 0; i &lt; len(val.Content); i += 2 </span><span class="cov10" title="44">{
                        if val.Content[i].Kind == yaml.ScalarNode </span><span class="cov10" title="44">{
                                switch val.Content[i+1].Kind </span>{
                                case yaml.ScalarNode:<span class="cov9" title="32">
                                        tmp[val.Content[i].Value] = scalarNodeResolver(val.Content[i+1])</span>
                                // in case value iteration is a map
                                case yaml.MappingNode:<span class="cov5" title="8">
                                        // unmarshall map value and get its line information
                                        tt := unmarshal(val.Content[i+1]).(map[string]interface{})
                                        tt["_kics_lines"] = getLines(val.Content[i+1], val.Content[i].Line)
                                        tmp[val.Content[i].Value] = tt</span>
                                // in case value iteration is an array
                                case yaml.SequenceNode:<span class="cov4" title="4">
                                        contentArray := make([]interface{}, 0)
                                        // unmarshall each iteration of the array
                                        for _, contentEntry := range val.Content[i+1].Content </span><span class="cov6" title="9">{
                                                contentArray = append(contentArray, unmarshal(contentEntry))
                                        }</span>
                                        <span class="cov4" title="4">tmp[val.Content[i].Value] = contentArray</span>
                                case yaml.AliasNode:<span class="cov0" title="0">
                                        if tt, ok := unmarshal(val.Content[i+1].Alias).(map[string]interface{}); ok </span><span class="cov0" title="0">{
                                                tt["_kics_lines"] = getLines(val.Content[i+1], val.Content[i].Line)
                                                utils.MergeMaps(tmp, tt)
                                        }</span>
                                        <span class="cov0" title="0">if v, ok := unmarshal(val.Content[i+1].Alias).(string); ok </span><span class="cov0" title="0">{
                                                tmp[val.Content[i].Value] = v
                                        }</span>
                                }
                        }
                }
        }
        <span class="cov8" title="20">return tmp</span>
}

// getLines creates the map containing the line information for the yaml Node
// def is the line to be used as "_kics__default"
func getLines(val *yaml.Node, def int) map[string]*LineObject <span class="cov7" title="18">{
        lineMap := make(map[string]*LineObject)

        // line information map
        lineMap["_kics__default"] = &amp;LineObject{
                Line: def,
                Arr:  []map[string]*LineObject{},
        }

        // if yaml Node is an Array use func getSeqLines
        if val.Kind == yaml.SequenceNode </span><span class="cov1" title="1">{
                return getSeqLines(val, def)
        }</span>

        // iterate two by two, since first iteration is the key and the second is the value
        <span class="cov7" title="17">for i := 0; i &lt; len(val.Content); i += 2 </span><span class="cov9" title="32">{
                lineArr := make([]map[string]*LineObject, 0)
                // in case the value iteration is an array call getLines for each iteration of the array
                if val.Content[i+1].Kind == yaml.SequenceNode </span><span class="cov2" title="2">{
                        for _, contentEntry := range val.Content[i+1].Content </span><span class="cov4" title="5">{
                                defaultLine := val.Content[i].Line
                                if contentEntry.Kind == yaml.ScalarNode </span><span class="cov3" title="3">{
                                        defaultLine = contentEntry.Line
                                }</span> else<span class="cov2" title="2"> if contentEntry.Kind == yaml.MappingNode &amp;&amp; len(contentEntry.Content) &gt; 0 </span><span class="cov2" title="2">{
                                        defaultLine = contentEntry.Content[0].Line
                                }</span>
                                <span class="cov4" title="5">lineArr = append(lineArr, getLines(contentEntry, defaultLine))</span>
                        }
                }

                // line information map of each key of the yaml Node
                <span class="cov9" title="32">lineMap["_kics_"+val.Content[i].Value] = &amp;LineObject{
                        Line: val.Content[i].Line,
                        Arr:  lineArr,
                }</span>
        }

        <span class="cov7" title="17">return lineMap</span>
}

// getSeqLines iterates through the elements of an Array
// creating a map with each iteration lines information
func getSeqLines(val *yaml.Node, def int) map[string]*LineObject <span class="cov1" title="1">{
        lineMap := make(map[string]*LineObject)
        lineArr := make([]map[string]*LineObject, 0)

        // get line information slice of every element in the array
        for _, cont := range val.Content </span><span class="cov2" title="2">{
                lineArr = append(lineArr, getLines(cont, cont.Line))
        }</span>

        // create line information of array with its line and elements line information
        <span class="cov1" title="1">lineMap["_kics__default"] = &amp;LineObject{
                Line: def,
                Arr:  lineArr,
        }
        return lineMap</span>
}

// scalarNodeResolver transforms a ScalarNode value in its correct type
func scalarNodeResolver(val *yaml.Node) interface{} <span class="cov9" title="36">{
        var transformed interface{} = val.Value
        switch val.Tag </span>{
        case "!!bool":<span class="cov1" title="1">
                transformed = transformBoolScalarNode(val.Value)</span>
        case "!!int":<span class="cov1" title="1">
                v, err := strconv.Atoi(val.Value)
                if err != nil </span><span class="cov0" title="0">{
                        log.Error().Msgf("failed to convert integer in yaml parser")
                        return val.Value
                }</span>
                <span class="cov1" title="1">transformed = v</span>
        case "!!null":<span class="cov1" title="1">
                transformed = nil</span>
        }

        <span class="cov9" title="36">return transformed</span>
}

// transformBoolScalarNode transforms a string value to its boolean representation
func transformBoolScalarNode(value string) bool <span class="cov1" title="1">{
        switch value </span>{
        case "true", "True":<span class="cov0" title="0">
                return true</span>
        default:<span class="cov1" title="1">
                return false</span>
        }
}
</pre>
		
		<pre class="file" id="file54" style="display: none">package model

import (
        "os"
        "path/filepath"
        "regexp"
        "sort"
        "strings"
        "time"

        "github.com/rs/zerolog/log"
)

// SeveritySummary contains scans' result numbers, how many vulnerabilities of each severity was detected
type SeveritySummary struct {
        ScanID            string           `json:"scan_id"`
        SeverityCounters  map[Severity]int `json:"severity_counters"`
        TotalCounter      int              `json:"total_counter"`
        TotalBOMResources int              `json:"total_bom_resources"`
}

// VulnerableFile contains information of a vulnerable file and where the vulnerability was found
type VulnerableFile struct {
        FileName         string      `json:"file_name"`
        SimilarityID     string      `json:"similarity_id"`
        Line             int         `json:"line"`
        VulnLines        *[]CodeLine `json:"-"`
        ResourceType     string      `json:"resource_type,omitempty"`
        ResourceName     string      `json:"resource_name,omitempty"`
        IssueType        IssueType   `json:"issue_type"`
        SearchKey        string      `json:"search_key"`
        SearchLine       int         `json:"search_line"`
        SearchValue      string      `json:"search_value"`
        KeyExpectedValue string      `json:"expected_value"`
        KeyActualValue   string      `json:"actual_value"`
        Value            *string     `json:"value,omitempty"`
        Remediation      string      `json:"remediation,omitempty"`
        RemediationType  string      `json:"remediation_type,omitempty"`
}

// QueryResult contains a query that tested positive ID, name, severity and a list of files that tested vulnerable
type QueryResult struct {
        QueryName                   string           `json:"query_name"`
        QueryID                     string           `json:"query_id"`
        QueryURI                    string           `json:"query_url"`
        Severity                    Severity         `json:"severity"`
        Platform                    string           `json:"platform"`
        CloudProvider               string           `json:"cloud_provider,omitempty"`
        Category                    string           `json:"category"`
        Description                 string           `json:"description"`
        DescriptionID               string           `json:"description_id"`
        CISDescriptionIDFormatted   string           `json:"cis_description_id,omitempty"`
        CISDescriptionTitle         string           `json:"cis_description_title,omitempty"`
        CISDescriptionTextFormatted string           `json:"cis_description_text,omitempty"`
        CISDescriptionID            string           `json:"cis_description_id_raw,omitempty"`
        CISDescriptionText          string           `json:"cis_description_text_raw,omitempty"`
        CISRationaleText            string           `json:"cis_description_rationale,omitempty"`
        CISBenchmarkName            string           `json:"cis_benchmark_name,omitempty"`
        CISBenchmarkVersion         string           `json:"cis_benchmark_version,omitempty"`
        Files                       []VulnerableFile `json:"files"`
}

// QueryResultSlice is a slice of QueryResult
type QueryResultSlice []QueryResult

// Counters hold information about how many files were scanned, parsed, failed to be scaned, the total of queries
// and how many queries failed to execute
type Counters struct {
        ScannedFiles           int `json:"files_scanned"`
        ScannedFilesLines      int `json:"lines_scanned"`
        ParsedFiles            int `json:"files_parsed"`
        ParsedFilesLines       int `json:"lines_parsed"`
        FailedToScanFiles      int `json:"files_failed_to_scan"`
        TotalQueries           int `json:"queries_total"`
        FailedToExecuteQueries int `json:"queries_failed_to_execute"`
        FailedSimilarityID     int `json:"queries_failed_to_compute_similarity_id"`
}

// Times represents an object that contains the start and end time of the scan
type Times struct {
        Start time.Time `json:"start"`
        End   time.Time `json:"end"`
}

// VersionResponse - is the model for the version response
type VersionResponse struct {
        Latest           bool   `json:"is_latest"`
        LatestVersionTag string `json:"latest_version"`
}

// Summary is a report of a single scan
type Summary struct {
        Version       string  `json:"kics_version,omitempty"`
        LatestVersion Version `json:"-"`
        Counters
        SeveritySummary
        Times
        ScannedPaths []string          `json:"paths"`
        Queries      QueryResultSlice  `json:"queries"`
        Bom          QueryResultSlice  `json:"bill_of_materials,omitempty"`
        FilePaths    map[string]string `json:"-"`
}

// PathParameters - structure wraps the required fields for temporary path translation
type PathParameters struct {
        ScannedPaths      []string
        PathExtractionMap map[string]ExtractedPathObject
}

var (
        queryRegex   = regexp.MustCompile(`\?([\w-]+(=[\w-]*)?(&amp;[\w-]+(=[\w-]*)?)*)?`)
        urlAuthRegex = regexp.MustCompile(`((ssh|https?)://)(\S+(:\S*)?@).*`)
)

const authGroupPosition = 3

func getRelativePath(basePath, filePath string) string <span class="cov7" title="4">{
        var returnPath string
        relativePath, err := filepath.Rel(basePath, filePath)
        if err != nil </span><span class="cov5" title="3">{
                returnPath = filePath
        }</span> else<span class="cov1" title="1"> {
                returnPath = relativePath
        }</span>
        <span class="cov7" title="4">return returnPath</span>
}

func replaceIfTemporaryPath(filePath string, pathExtractionMap map[string]ExtractedPathObject) string <span class="cov7" title="4">{
        prettyPath := filePath
        for key, val := range pathExtractionMap </span><span class="cov5" title="3">{
                if strings.Contains(filePath, key) </span><span class="cov4" title="2">{
                        splittedPath := strings.Split(filePath, key)
                        if !val.LocalPath </span><span class="cov4" title="2">{
                                // remove authentication information from the URL
                                sanitizedURL := removeURLCredentials(val.Path)
                                // remove query parameters '?key=value&amp;key2=value'
                                return filepath.FromSlash(queryRegex.ReplaceAllString(sanitizedURL, "") + splittedPath[1])
                        }</span>
                        <span class="cov0" title="0">prettyPath = filepath.FromSlash(filepath.Base(val.Path) + splittedPath[1])</span>
                } else<span class="cov1" title="1"> {
                        prettyPath = filePath
                }</span>
        }
        <span class="cov4" title="2">return prettyPath</span>
}

func removeAllURLCredentials(pathExtractionMap map[string]ExtractedPathObject) []string <span class="cov7" title="4">{
        sanitizedScannedPaths := make([]string, 0)
        for _, val := range pathExtractionMap </span><span class="cov5" title="3">{
                if !val.LocalPath </span><span class="cov4" title="2">{
                        sanitizedURL := removeURLCredentials(val.Path)
                        sanitizedScannedPaths = append(sanitizedScannedPaths, sanitizedURL)
                }</span> else<span class="cov1" title="1"> {
                        sanitizedScannedPaths = append(sanitizedScannedPaths, val.Path)
                }</span>
        }
        <span class="cov7" title="4">return sanitizedScannedPaths</span>
}

func removeURLCredentials(url string) string <span class="cov10" title="8">{
        authGroup := ""
        groups := urlAuthRegex.FindStringSubmatch(url)
        // credentials are present in the URL
        if len(groups) &gt; authGroupPosition </span><span class="cov7" title="5">{
                authGroup = groups[authGroupPosition]
        }</span>
        <span class="cov10" title="8">return strings.Replace(url, authGroup, "", 1)</span>
}

func resolvePath(filePath string, pathExtractionMap map[string]ExtractedPathObject) string <span class="cov7" title="4">{
        var returnPath string
        returnPath = replaceIfTemporaryPath(filepath.FromSlash(filePath), pathExtractionMap)
        pwd, err := os.Getwd()
        if err != nil </span><span class="cov0" title="0">{
                log.Error().Msgf("Unable to get current working dir %s", err)
                return returnPath
        }</span>
        <span class="cov7" title="4">returnPath = getRelativePath(pwd, returnPath)
        return returnPath</span>
}

// CreateSummary creates a report for a single scan, based on its scanID
func CreateSummary(counters Counters, vulnerabilities []Vulnerability,
        scanID string, pathExtractionMap map[string]ExtractedPathObject, version Version) Summary <span class="cov4" title="2">{
        log.Debug().Msg("model.CreateSummary()")
        q := make(map[string]QueryResult, len(vulnerabilities))
        severitySummary := SeveritySummary{
                ScanID: scanID,
        }
        filePaths := make(map[string]string)

        for i := range vulnerabilities </span><span class="cov1" title="1">{
                item := vulnerabilities[i]
                if _, ok := q[item.QueryID]; !ok </span><span class="cov1" title="1">{
                        q[item.QueryID] = QueryResult{
                                QueryName:     item.QueryName,
                                QueryID:       item.QueryID,
                                Severity:      item.Severity,
                                QueryURI:      item.QueryURI,
                                Platform:      item.Platform,
                                CloudProvider: strings.ToUpper(item.CloudProvider),
                                Category:      item.Category,
                                Description:   item.Description,
                                DescriptionID: item.DescriptionID,
                        }
                }</span>

                <span class="cov1" title="1">resolvedPath := resolvePath(item.FileName, pathExtractionMap)

                qItem := q[item.QueryID]
                qItem.Files = append(qItem.Files, VulnerableFile{
                        FileName:         resolvedPath,
                        SimilarityID:     item.SimilarityID,
                        Line:             item.Line,
                        VulnLines:        item.VulnLines,
                        ResourceType:     item.ResourceType,
                        ResourceName:     item.ResourceName,
                        IssueType:        item.IssueType,
                        SearchKey:        item.SearchKey,
                        SearchValue:      item.SearchValue,
                        KeyExpectedValue: item.KeyExpectedValue,
                        KeyActualValue:   item.KeyActualValue,
                        Value:            item.Value,
                        Remediation:      item.Remediation,
                        RemediationType:  item.RemediationType,
                })

                filePaths[resolvedPath] = item.FileName

                q[item.QueryID] = qItem</span>
        }

        <span class="cov4" title="2">queries := make([]QueryResult, 0, len(q))
        sevs := map[Severity]int{SeverityTrace: 0, SeverityInfo: 0, SeverityLow: 0, SeverityMedium: 0, SeverityHigh: 0}
        for idx := range q </span><span class="cov1" title="1">{
                sevs[q[idx].Severity] += len(q[idx].Files)

                if q[idx].Severity == SeverityTrace </span><span class="cov0" title="0">{
                        continue</span>
                }
                <span class="cov1" title="1">queries = append(queries, q[idx])

                severitySummary.TotalCounter += len(q[idx].Files)</span>
        }

        <span class="cov4" title="2">severityOrder := map[Severity]int{SeverityTrace: 4, SeverityInfo: 3, SeverityLow: 2, SeverityMedium: 1, SeverityHigh: 0}
        sort.Slice(queries, func(i, j int) bool </span><span class="cov0" title="0">{
                if severityOrder[queries[i].Severity] == severityOrder[queries[j].Severity] </span><span class="cov0" title="0">{
                        return queries[i].QueryName &lt; queries[j].QueryName
                }</span>
                <span class="cov0" title="0">return severityOrder[queries[i].Severity] &lt; severityOrder[queries[j].Severity]</span>
        })

        <span class="cov4" title="2">materials := make([]QueryResult, 0, len(q))
        for idx := range q </span><span class="cov1" title="1">{
                if q[idx].Severity == SeverityTrace </span><span class="cov0" title="0">{
                        materials = append(materials, q[idx])
                        severitySummary.TotalBOMResources += len(q[idx].Files)
                }</span>
        }

        <span class="cov4" title="2">severitySummary.SeverityCounters = sevs

        return Summary{
                Bom:             materials,
                Counters:        counters,
                Queries:         queries,
                SeveritySummary: severitySummary,
                ScannedPaths:    removeAllURLCredentials(pathExtractionMap),
                LatestVersion:   version,
                FilePaths:       filePaths,
        }</span>
}
</pre>
		
		<pre class="file" id="file55" style="display: none">package buildah

import (
        "strings"

        "github.com/Checkmarx/kics/pkg/model"
        "mvdan.cc/sh/v3/syntax"
)

func getKicsIgnore(comment string) string <span class="cov6" title="5">{
        commentLower := model.KICSCommentRgxp.ReplaceAllString(strings.ToLower(comment), "")
        commentLower = strings.Trim(commentLower, "\r")
        commentLower = strings.Trim(commentLower, "\n")

        return commentLower
}</span>

func (i *Info) getIgnoreLines(comment *syntax.Comment) <span class="cov9" title="10">{
        // get normal comments
        i.IgnoreLines = append(i.IgnoreLines, int(comment.Hash.Line()))

        if model.KICSCommentRgxp.MatchString(comment.Text) </span><span class="cov4" title="3">{
                kicsIgnore := getKicsIgnore(comment.Text)

                switch model.CommentCommand(kicsIgnore) </span>{
                case model.IgnoreLine:<span class="cov1" title="1">
                        // get kics-scan ignore-line
                        i.IgnoreLines = append(i.IgnoreLines, int(comment.Hash.Line())+1)</span>
                case model.IgnoreBlock:<span class="cov3" title="2">
                        // get kics-scan ignore-block for ignoreFromBlock
                        i.IgnoreBlockLines = append(i.IgnoreBlockLines, int(comment.Pos().Line()))</span>
                }
        }
}

func (i *Info) getIgnoreBlockLines(comments []syntax.Comment, start, end int) <span class="cov10" title="13">{
        for c := range comments </span><span class="cov4" title="3">{
                comment := comments[c]

                // get kics-scan ignore-block related to command
                if model.KICSCommentRgxp.MatchString(comment.Text) </span><span class="cov3" title="2">{
                        kicsIgnore := getKicsIgnore(comment.Text)

                        if model.CommentCommand(kicsIgnore) == model.IgnoreBlock </span><span class="cov1" title="1">{
                                if int(comment.Hash.Line()) == start-1 </span><span class="cov1" title="1">{
                                        i.IgnoreLines = append(i.IgnoreLines, model.Range(start, end)...)
                                        i.IgnoreBlockLines = append(i.IgnoreBlockLines, model.Range(start, end)...)
                                }</span>
                        }
                }
        }
}

func (i *Info) ignoreFromBlock() <span class="cov6" title="5">{
        for j := range i.IgnoreBlockLines </span><span class="cov5" title="4">{
                for z := range i.FromValues </span><span class="cov6" title="5">{
                        i.getIgnoreLinesFromBlock(i.IgnoreBlockLines[j], i.FromValues[z])
                }</span>
        }
}

func (i *Info) getIgnoreLinesFromBlock(ignoreBlockLine int, fromValue FromValue) <span class="cov6" title="5">{
        start := fromValue.Line
        value := fromValue.Value
        if start == ignoreBlockLine+1 </span><span class="cov1" title="1">{
                targetFrom := i.From[value]
                end := targetFrom[len(targetFrom)-1].EndLine
                i.IgnoreLines = append(i.IgnoreLines, model.Range(start, end)...)
        }</span>
}
</pre>
		
		<pre class="file" id="file56" style="display: none">package buildah

import (
        "bytes"
        "sort"
        "strings"

        "github.com/rs/zerolog/log"

        "encoding/json"

        "github.com/Checkmarx/kics/pkg/model"
        "github.com/pkg/errors"
        "mvdan.cc/sh/v3/syntax"
)

// Parser is a Buildah parser
type Parser struct {
}

// Resource separates the list of commands by file
type Resource struct {
        CommandList map[string][]Command `json:"command"`
}

// Command is the struct for each Buildah command
type Command struct {
        Cmd       string
        Original  string
        Value     string
        StartLine int `json:"_kics_line"`
        EndLine   int
}

// FromValue is the struct for each from
type FromValue struct {
        Value string
        Line  int
}

// Info has the relevant information to Buildah parser
type Info struct {
        IgnoreLines      []int
        From             map[string][]Command
        FromValues       []FromValue
        IgnoreBlockLines []int
}

const (
        buildah = "buildah"
)

// Resolve - replace or modifies in-memory content before parsing
func (p *Parser) Resolve(fileContent []byte, _ string) ([]byte, error) <span class="cov1" title="1">{
        return fileContent, nil
}</span>

// Parse - parses Buildah file to Json
func (p *Parser) Parse(_ string, fileContent []byte) ([]model.Document, []int, error) <span class="cov3" title="5">{
        var info Info
        info.From = map[string][]Command{}

        reader := bytes.NewReader(fileContent)
        f, err := syntax.NewParser(syntax.KeepComments(true)).Parse(reader, "")

        if err != nil </span><span class="cov0" title="0">{
                return nil, []int{}, err
        }</span>

        <span class="cov3" title="5">syntax.Walk(f, func(node syntax.Node) bool </span><span class="cov10" title="384">{
                switch x := node.(type) </span>{
                case *syntax.Stmt:<span class="cov5" title="19">
                        info.getStmt(x)</span>
                case *syntax.Comment:<span class="cov4" title="10">
                        info.getIgnoreLines(x)</span>
                }
                <span class="cov10" title="384">return true</span>
        })

        // get kics-scan ignore-block related to from
        <span class="cov3" title="5">info.ignoreFromBlock()

        var documents []model.Document
        var resource Resource
        resource.CommandList = info.From
        doc := &amp;model.Document{}
        j, err := json.Marshal(resource)
        if err != nil </span><span class="cov0" title="0">{
                return nil, []int{}, errors.Wrap(err, "failed to Marshal Buildah")
        }</span>

        <span class="cov3" title="5">err = json.Unmarshal(j, &amp;doc)
        if err != nil </span><span class="cov0" title="0">{
                return nil, []int{}, errors.Wrap(err, "failed to Unmarshal Buildah")
        }</span>

        <span class="cov3" title="5">documents = append(documents, *doc)

        sort.Ints(info.IgnoreLines)

        return documents, info.IgnoreLines, nil</span>
}

func (i *Info) getStmt(stmt *syntax.Stmt) <span class="cov5" title="19">{
        if cmd, ok := stmt.Cmd.(*syntax.CallExpr); ok </span><span class="cov5" title="19">{
                args := cmd.Args

                // get kics-scan ignore-block related to command + get command
                stCommand := i.getStmtInfo(stmt, args)

                if stCommand.Cmd == "buildah from" </span><span class="cov3" title="6">{
                        fromValue := FromValue{
                                Value: stCommand.Value,
                                Line:  stCommand.StartLine,
                        }
                        i.FromValues = append(i.FromValues, fromValue)
                }</span>

                <span class="cov5" title="19">if stCommand.Cmd != "" </span><span class="cov4" title="13">{
                        if len(i.FromValues) != 0 </span><span class="cov4" title="13">{
                                v := i.FromValues[len(i.FromValues)-1].Value
                                i.From[v] = append(i.From[v], stCommand)
                        }</span>
                }
        }
}

func (i *Info) getStmtInfo(stmt *syntax.Stmt, args []*syntax.Word) Command <span class="cov5" title="19">{
        var command Command
        minimumArgs := 2

        if len(args) &gt; minimumArgs </span><span class="cov4" title="13">{
                if getWordValue(args[0]) == buildah </span><span class="cov4" title="13">{
                        cmd := "buildah " + strings.TrimSpace(getWordValue(args[1]))
                        fullCmd := strings.TrimSpace(getFullCommand(args))
                        value := strings.TrimPrefix(fullCmd, cmd)
                        start := int(args[0].Pos().Line())
                        end := int(args[len(args)-1].End().Line())

                        command = Command{
                                Cmd:       cmd,
                                Original:  fullCmd,
                                StartLine: start,
                                EndLine:   end,
                                Value:     strings.TrimSpace(value),
                        }

                        // get kics-scan ignore-block comments
                        i.getIgnoreBlockLines(stmt.Comments, start, end)

                        return command
                }</span>
        }
        <span class="cov3" title="6">return command</span>
}

func getWordValue(wd *syntax.Word) string <span class="cov5" title="26">{
        printer := syntax.NewPrinter()
        var buf bytes.Buffer

        err := printer.Print(&amp;buf, wd)

        if err != nil </span><span class="cov0" title="0">{
                log.Debug().Msgf("failed to get word value: %s", err)
        }</span>

        <span class="cov5" title="26">value := buf.String()
        buf.Reset()

        return value</span>
}

func getFullCommand(args []*syntax.Word) string <span class="cov4" title="13">{
        var buf bytes.Buffer
        printer := syntax.NewPrinter()

        call := &amp;syntax.CallExpr{Args: args}

        err := printer.Print(&amp;buf, call)

        if err != nil </span><span class="cov0" title="0">{
                log.Debug().Msgf("failed to get full command: %s", err)
        }</span>

        <span class="cov4" title="13">command := buf.String()
        buf.Reset()

        command = strings.Replace(command, "\n", "", -1)
        command = strings.Replace(command, "\r", "", -1)
        command = strings.Replace(command, "\t", "", -1)
        command = strings.Replace(command, "\\", "", -1)

        return command</span>
}

// GetKind returns the kind of the parser
func (p *Parser) GetKind() model.FileKind <span class="cov0" title="0">{
        return model.KindBUILDAH
}</span>

// SupportedExtensions returns Buildah extensions
func (p *Parser) SupportedExtensions() []string <span class="cov1" title="1">{
        return []string{".sh"}
}</span>

// SupportedTypes returns types supported by this parser, which are Buildah
func (p *Parser) SupportedTypes() map[string]bool <span class="cov1" title="1">{
        return map[string]bool{"buildah": true}
}</span>

// GetCommentToken return the comment token of Buildah - #
func (p *Parser) GetCommentToken() string <span class="cov0" title="0">{
        return "#"
}</span>

// StringifyContent converts original content into string formated version
func (p *Parser) StringifyContent(content []byte) (string, error) <span class="cov0" title="0">{
        return string(content), nil
}</span>

// GetResolvedFiles returns the resolved files
func (p *Parser) GetResolvedFiles() map[string]model.ResolvedFile <span class="cov1" title="1">{
        return make(map[string]model.ResolvedFile)
}</span>
</pre>
		
		<pre class="file" id="file57" style="display: none">package docker

import (
        "strings"

        "github.com/Checkmarx/kics/pkg/model"
        "github.com/moby/buildkit/frontend/dockerfile/parser"
)

// ignore is a structure that contains information about the lines that are being ignored.
type ignore struct {
        from  map[string]bool
        lines []int
}

// newIgnore returns a new ignore struct.
func newIgnore() *ignore <span class="cov5" title="6">{
        return &amp;ignore{
                from:  make(map[string]bool),
                lines: make([]int, 0),
        }
}</span>

// setIgnore adds a new entry to the ignore struct for the 'FROM' block to be ignored
func (i *ignore) setIgnore(from string) <span class="cov2" title="2">{
        i.from[from] = true
}</span>

// ignoreBlock adds block lines to be ignored to the ignore struct.
func (i *ignore) ignoreBlock(node *parser.Node, from string) <span class="cov9" title="29">{
        if _, ok := i.from[from]; ok </span><span class="cov5" title="6">{
                i.lines = append(i.lines, model.Range(node.StartLine, node.EndLine)...)
        }</span>
}

// getIgnoreLines returns the lines that are being ignored.
func (i *ignore) getIgnoreLines() []int <span class="cov7" title="14">{
        return model.RemoveDuplicates(i.lines)
}</span>

// getIgnoreComments returns lines to be ignored for each node of the dockerfile
func (i *ignore) getIgnoreComments(node *parser.Node) (ignore bool) <span class="cov10" title="32">{
        if len(node.PrevComment) == 0 </span><span class="cov9" title="25">{
                return false
        }</span>

        <span class="cov6" title="7">for idx, comment := range node.PrevComment </span><span class="cov6" title="8">{
                switch processComment(comment) </span>{
                case model.IgnoreLine:<span class="cov4" title="4">
                        i.lines = append(i.lines, model.Range(node.StartLine-(idx+1), node.EndLine)...)</span>
                case model.IgnoreBlock:<span class="cov2" title="2">
                        i.lines = append(i.lines, node.StartLine-(idx+1))
                        ignore = true</span>
                default:<span class="cov2" title="2">
                        i.lines = append(i.lines, node.StartLine-(idx+1))</span>
                }
        }

        <span class="cov6" title="7">return</span>
}

// processComment returns the type of comment given.
func processComment(comment string) (value model.CommentCommand) <span class="cov6" title="8">{
        commentLower := strings.ToLower(comment)

        if model.KICSCommentRgxp.MatchString(commentLower) </span><span class="cov6" title="7">{
                commentLower = model.KICSCommentRgxp.ReplaceAllString(commentLower, "")
                commands := strings.Split(strings.Trim(commentLower, "\n"), " ")
                value = model.ProcessCommands(commands)
                return
        }</span>
        <span class="cov1" title="1">return model.CommentCommand(comment)</span>
}
</pre>
		
		<pre class="file" id="file58" style="display: none">package docker

import (
        "bytes"
        "encoding/json"
        "fmt"
        "strings"

        "github.com/Checkmarx/kics/pkg/model"
        "github.com/moby/buildkit/frontend/dockerfile/parser"
        "github.com/pkg/errors"
)

// Parser is a Dockerfile parser
type Parser struct {
}

// Resource Separates the list of commands by file
type Resource struct {
        CommandList map[string][]Command `json:"command"`
        Arguments   []Command            `json:"args"`
}

// Command is the struct for each dockerfile command
type Command struct {
        Cmd       string
        SubCmd    string
        Flags     []string
        Value     []string
        Original  string
        StartLine int `json:"_kics_line"`
        EndLine   int
        JSON      bool
}

// Resolve - replace or modifies in-memory content before parsing
func (p *Parser) Resolve(fileContent []byte, _ string) ([]byte, error) <span class="cov1" title="1">{
        return fileContent, nil
}</span>

// Parse - parses dockerfile to Json
func (p *Parser) Parse(_ string, fileContent []byte) ([]model.Document, []int, error) <span class="cov4" title="5">{
        var documents []model.Document
        reader := bytes.NewReader(fileContent)

        parsed, err := parser.Parse(reader)
        if err != nil </span><span class="cov0" title="0">{
                return nil, []int{}, errors.Wrap(err, "failed to parse Dockerfile")
        }</span>

        <span class="cov4" title="5">fromValue := ""
        from := make(map[string][]Command)
        arguments := make([]Command, 0)
        ignoreStruct := newIgnore()

        args := make(map[string]string, 0)

        for _, child := range parsed.AST.Children </span><span class="cov8" title="27">{
                child.Value = strings.ToLower(child.Value)
                if child.Value == "from" </span><span class="cov5" title="6">{
                        fromValue = strings.TrimPrefix(child.Original, "FROM ")
                }</span>

                <span class="cov8" title="27">if ignoreStruct.getIgnoreComments(child) </span><span class="cov1" title="1">{
                        ignoreStruct.setIgnore(fromValue)
                }</span>

                <span class="cov8" title="27">ignoreStruct.ignoreBlock(child, fromValue)

                cmd := Command{
                        Cmd:       child.Value,
                        Original:  child.Original,
                        Flags:     child.Flags,
                        StartLine: child.StartLine,
                        EndLine:   child.EndLine,
                }

                if child.Next != nil &amp;&amp; len(child.Next.Children) &gt; 0 </span><span class="cov2" title="2">{
                        cmd.SubCmd = strings.ToLower(child.Next.Children[0].Value)
                        child = child.Next.Children[0]
                }</span>

                <span class="cov8" title="27">cmd.JSON = child.Attributes["json"]
                for n := child.Next; n != nil; n = n.Next </span><span class="cov10" title="41">{
                        cmd.Value = append(cmd.Value, n.Value)
                }</span>

                <span class="cov8" title="27">if child.Value != "arg" </span><span class="cov8" title="22">{
                        cmd.Value = resolveArgs(cmd.Value, args)
                }</span> else<span class="cov4" title="5"> {
                        args = saveArgs(args, cmd.Value[0])
                }</span>

                <span class="cov8" title="27">if fromValue == "" </span><span class="cov4" title="4">{
                        arguments = append(arguments, cmd)
                }</span> else<span class="cov8" title="23"> {
                        from[fromValue] = append(from[fromValue], cmd)
                }</span>
        }

        <span class="cov4" title="5">doc := &amp;model.Document{}
        var resource Resource
        resource.CommandList = from
        resource.Arguments = arguments

        j, err := json.Marshal(resource)
        if err != nil </span><span class="cov0" title="0">{
                return nil, []int{}, errors.Wrap(err, "failed to Marshal Dockerfile")
        }</span>

        <span class="cov4" title="5">if err := json.Unmarshal(j, &amp;doc); err != nil </span><span class="cov0" title="0">{
                return nil, []int{}, errors.Wrap(err, "failed to Unmarshal Dockerfile")
        }</span>

        <span class="cov4" title="5">documents = append(documents, *doc)

        ignoreLines := ignoreStruct.getIgnoreLines()

        return documents, ignoreLines, nil</span>
}

// GetKind returns the kind of the parser
func (p *Parser) GetKind() model.FileKind <span class="cov1" title="1">{
        return model.KindDOCKER
}</span>

// SupportedExtensions returns Dockerfile extensions
func (p *Parser) SupportedExtensions() []string <span class="cov1" title="1">{
        return []string{"Dockerfile", ".dockerfile", ".ubi8", ".debian", "possibleDockerfile"}
}</span>

// SupportedTypes returns types supported by this parser, which are dockerfile
func (p *Parser) SupportedTypes() map[string]bool <span class="cov1" title="1">{
        return map[string]bool{"dockerfile": true}
}</span>

// GetCommentToken return the comment token of Docker - #
func (p *Parser) GetCommentToken() string <span class="cov1" title="1">{
        return "#"
}</span>

// StringifyContent converts original content into string formated version
func (p *Parser) StringifyContent(content []byte) (string, error) <span class="cov1" title="1">{
        return string(content), nil
}</span>

// GetResolvedFiles returns the list of files that are resolved
func (p *Parser) GetResolvedFiles() map[string]model.ResolvedFile <span class="cov1" title="1">{
        return make(map[string]model.ResolvedFile)
}</span>

func resolveArgs(values []string, args map[string]string) []string <span class="cov8" title="22">{
        for i := range values </span><span class="cov9" title="36">{
                for arg := range args </span><span class="cov7" title="12">{
                        ref := fmt.Sprintf("${%s}", arg)
                        values[i] = strings.Replace(values[i], ref, args[arg], 1)
                }</span>
        }

        <span class="cov8" title="22">return values</span>
}

func saveArgs(args map[string]string, argValue string) map[string]string <span class="cov4" title="5">{
        value := strings.Split(argValue, "=")
        if len(value) == 2 </span><span class="cov3" title="3">{
                args[value[0]] = value[1]
        }</span>
        <span class="cov4" title="5">if len(value) &gt; 2 </span><span class="cov1" title="1">{
                // to handle cases like ARG VAR=erereR=E
                args[value[0]] = strings.Join(value[1:], "=")
        }</span>

        <span class="cov4" title="5">return args</span>
}
</pre>
		
		<pre class="file" id="file59" style="display: none">package converter

import (
        "strings"

        "github.com/Checkmarx/kics/pkg/model"
        "github.com/emicklei/proto"
)

// JSONProto is a JSON representation of a proto file
type JSONProto struct {
        Syntax           string                      `json:"syntax"`
        PackageName      string                      `json:"package"`
        Messages         map[string]interface{}      `json:"messages"`
        Enum             map[string]interface{}      `json:"enum"`
        Services         map[string]interface{}      `json:"services"`
        Imports          map[string]interface{}      `json:"imports"`
        Options          []Option                    `json:"options"`
        Lines            map[string]model.LineObject `json:"_kics_lines"`
        linesToIgnore    []int                       `json:"-"`
        linesNotToIgnore []int                       `json:"-"`
}

// Service is a JSON representation of a proto service
type Service struct {
        RPC     map[string]RPC              `json:"rpc,omitempty"`
        Options map[string]Option           `json:"options,omitempty"`
        Lines   map[string]model.LineObject `json:"_kics_lines,omitempty"`
}

// Message is a JSON representation of a proto message
type Message struct {
        Field        map[string]*Field           `json:"field,omitempty"`
        Reserved     []*Reserved                 `json:"reserved,omitempty"`
        OneOf        map[string]OneOf            `json:"oneof,omitempty"`
        Enum         map[string]Enum             `json:"enum,omitempty"`
        Map          map[string]*Map             `json:"map,omitempty"`
        InnerMessage map[string]Message          `json:"inner_message,omitempty"`
        Options      map[string]Option           `json:"options,omitempty"`
        Lines        map[string]model.LineObject `json:"_kics_lines,omitempty"`
}

// Map is a JSON representation of a proto map
type Map struct {
        *Field  `json:"field,omitempty"`
        KeyType string                      `json:"key_type,omitempty"`
        Lines   map[string]model.LineObject `json:"_kics_lines,omitempty"`
}

// OneOf is a JSON representation of a proto oneof
type OneOf struct {
        Field   map[string]*Field           `json:"fields,omitempty"`
        Options map[string]Option           `json:"options,omitempty"`
        Lines   map[string]model.LineObject `json:"_kics_lines,omitempty"`
}

// Enum is a JSON representation of a proto enum
type Enum struct {
        Reserved  []*Reserved                 `json:"reserved,omitempty"`
        EnumField map[string]EnumValue        `json:"field,omitempty"`
        Options   map[string]Option           `json:"options,omitempty"`
        Lines     map[string]model.LineObject `json:"_kics_lines,omitempty"`
}

// EnumValue is a JSON representation of a proto enum value
type EnumValue struct {
        Value   int                         `json:"value,omitempty"`
        Options Option                      `json:"options,omitempty"`
        Lines   map[string]model.LineObject `json:"_kics_lines,omitempty"`
}

// Import is a JSON representation of a proto import
type Import struct {
        Kind  string                      `json:"kind,omitempty"`
        Lines map[string]model.LineObject `json:"_kics_lines,omitempty"`
}

// Reserved is a JSON representation of a proto reserved
type Reserved struct {
        Ranges     []proto.Range               `json:"ranges,omitempty"`
        FieldNames []string                    `json:"fieldNames,omitempty"`
        Lines      map[string]model.LineObject `json:"_kics_lines,omitempty"`
}

// Field is a JSON representation of a proto field
type Field struct {
        Type     string                      `json:"type,omitempty"`
        Sequence int                         `json:"sequence,omitempty"`
        Repeated bool                        `json:"repeated,omitempty"`
        Required bool                        `json:"required,omitempty"`
        Optional bool                        `json:"optional,omitempty"`
        Options  []Option                    `json:"options,omitempty"`
        Lines    map[string]model.LineObject `json:"_kics_lines,omitempty"`
}

// RPC is a JSON representation of a proto service RPC
type RPC struct {
        RequestType    string                      `json:"requestType,omitempty"`
        StreamsRequest bool                        `json:"streamsRequest,omitempty"`
        ReturnsType    string                      `json:"returnsType,omitempty"`
        StreamsReturns bool                        `json:"streamsReturns,omitempty"`
        Options        []Option                    `json:"options,omitempty"`
        Lines          map[string]model.LineObject `json:"_kics_lines,omitempty"`
}

// Option is a JSON representation of a proto option
type Option struct {
        Name                string                      `json:"name,omitempty"`
        Constant            OptionLiteral               `json:"constant,omitempty"`
        IsEmbedded          bool                        `json:"isEmbedded,omitempty"`
        AggregatedConstants []*OptionLiteral            `json:"aggregatedConstants,omitempty"`
        Lines               map[string]model.LineObject `json:"_kics_lines,omitempty"`
}

// OptionLiteral is a JSON representation of a proto option literal
type OptionLiteral struct {
        Name       string                      `json:"name,omitempty"`
        Source     string                      `json:"source,omitempty"`
        IsString   bool                        `json:"isString,omitempty"`
        QuoteRune  rune                        `json:"quoteRune,omitempty"`
        Array      []OptionLiteral             `json:"array,omitempty"`
        Map        map[string]OptionLiteral    `json:"map,omitempty"`
        OrderedMap []OptionLiteral             `json:"orderedMap,omitempty"`
        Lines      map[string]model.LineObject `json:"_kics_lines,omitempty"`
}

// newJSONProto creates a new JSONProto struct with default values for all fields
func newJSONProto() *JSONProto <span class="cov5" title="6">{
        return &amp;JSONProto{
                Messages:      make(map[string]interface{}),
                Services:      make(map[string]interface{}),
                Imports:       make(map[string]interface{}),
                Options:       make([]Option, 0),
                Enum:          make(map[string]interface{}),
                Syntax:        "",
                PackageName:   "",
                Lines:         make(map[string]model.LineObject),
                linesToIgnore: make([]int, 0),
        }
}</span>

// Convert converts a proto file to a JSONProto struct
func Convert(nodes *proto.Proto) (file *JSONProto, linesIgnore []int) <span class="cov4" title="5">{
        jproto := newJSONProto()

        messageLines := make(map[string]model.LineObject)
        enumLines := make(map[string]model.LineObject)
        serviceLines := make(map[string]model.LineObject)
        importLines := make(map[string]model.LineObject)

        defaultArr := make([]map[string]*model.LineObject, 0)

        for _, elem := range nodes.Elements </span><span class="cov8" title="19">{
                switch element := elem.(type) </span>{
                case *proto.Message:<span class="cov4" title="5">
                        jproto.processCommentProto(element.Comment, element.Position.Line, element)
                        jproto.Messages[element.Name] = jproto.convertMessage(element)
                        messageLines["_kics_"+element.Name] = model.LineObject{
                                Line: element.Position.Line,
                                Arr:  make([]map[string]*model.LineObject, 0),
                        }</span>
                case *proto.Service:<span class="cov1" title="1">
                        jproto.processCommentProto(element.Comment, element.Position.Line, element)
                        jproto.convertService(element)
                        serviceLines["_kics_"+element.Name] = model.LineObject{
                                Line: element.Position.Line,
                                Arr:  make([]map[string]*model.LineObject, 0),
                        }</span>
                case *proto.Package:<span class="cov3" title="3">
                        jproto.processCommentProto(element.Comment, element.Position.Line, element)
                        jproto.PackageName = element.Name
                        jproto.Lines["_kics_package"] = model.LineObject{
                                Line: element.Position.Line,
                        }</span>
                case *proto.Import:<span class="cov3" title="3">
                        jproto.processCommentProto(element.Comment, element.Position.Line, element)
                        jproto.Imports[element.Filename] = Import{
                                Kind: element.Kind,
                        }
                        importLines["_kics_"+element.Filename] = model.LineObject{
                                Line: element.Position.Line,
                                Arr:  make([]map[string]*model.LineObject, 0),
                        }</span>
                case *proto.Option:<span class="cov1" title="1">
                        jproto.processCommentProto(element.Comment, element.Position.Line, element)
                        jproto.Options = append(jproto.Options, jproto.convertSingleOption(element))
                        defaultArr = append(defaultArr, map[string]*model.LineObject{
                                element.Name: {
                                        Line: element.Position.Line,
                                },
                        })</span>
                case *proto.Enum:<span class="cov1" title="1">
                        jproto.processCommentProto(element.Comment, element.Position.Line, element)
                        jproto.Enum[element.Name] = jproto.convertEnum(element)
                        enumLines["_kics_"+element.Name] = model.LineObject{
                                Line: element.Position.Line,
                                Arr:  make([]map[string]*model.LineObject, 0),
                        }</span>
                case *proto.Syntax:<span class="cov4" title="5">
                        jproto.processCommentProto(element.Comment, element.Position.Line, element)
                        jproto.Syntax = element.Value
                        jproto.Lines["_kics_syntax"] = model.LineObject{
                                Line: element.Position.Line,
                        }</span>
                }
        }

        // set line information
        <span class="cov4" title="5">jproto.Messages["_kics_lines"] = messageLines
        jproto.Enum["_kics_lines"] = enumLines
        jproto.Services["_kics_lines"] = serviceLines
        jproto.Imports["_kics_lines"] = importLines

        jproto.Lines["kics__default"] = model.LineObject{
                Line: 0,
                Arr:  defaultArr,
        }

        return jproto, model.RemoveDuplicates(jproto.linesToIgnore)</span>
}

// convertMessage converts a proto message to a JSON message
func (j *JSONProto) convertMessage(n *proto.Message) Message <span class="cov5" title="6">{
        message := Message{
                Field:        make(map[string]*Field),
                Reserved:     make([]*Reserved, 0),
                OneOf:        make(map[string]OneOf),
                Enum:         make(map[string]Enum),
                Map:          make(map[string]*Map),
                InnerMessage: make(map[string]Message),
                Options:      make(map[string]Option),
                Lines:        make(map[string]model.LineObject),
        }

        defaultArr := make([]map[string]*model.LineObject, 0)

        for _, field := range n.Elements </span><span class="cov7" title="12">{
                switch field := field.(type) </span>{
                case *proto.NormalField:<span class="cov5" title="6">
                        j.processCommentProto(field.Comment, field.Position.Line, field)
                        message.Lines["_kics_"+field.Name] = model.LineObject{
                                Line: field.Position.Line,
                        }
                        message.Field[field.Name] = &amp;Field{
                                Type:     field.Type,
                                Sequence: field.Sequence,
                                Repeated: field.Repeated,
                                Required: field.Required,
                                Options:  j.convertOption(field.Options),
                                Lines: map[string]model.LineObject{
                                        "_kics__default": {Line: field.Position.Line},
                                },
                        }</span>
                case *proto.Reserved:<span class="cov1" title="1">
                        j.processCommentProto(field.Comment, field.Position.Line, field)
                        message.Reserved = append(message.Reserved, j.convertReserved(field))
                        defaultArr = append(defaultArr, map[string]*model.LineObject{
                                "Reserved": {
                                        Line: field.Position.Line,
                                },
                        })</span>
                case *proto.Oneof:<span class="cov1" title="1">
                        j.processCommentProto(field.Comment, field.Position.Line, field)
                        message.OneOf[field.Name] = j.convertOneOf(field)
                        message.Lines["_kics_"+field.Name] = model.LineObject{
                                Line: field.Position.Line,
                        }</span>
                case *proto.Enum:<span class="cov1" title="1">
                        j.processCommentProto(field.Comment, field.Position.Line, field)
                        message.Enum[field.Name] = j.convertEnum(field)
                        message.Lines["_kics_"+field.Name] = model.LineObject{
                                Line: field.Position.Line,
                        }</span>
                case *proto.MapField:<span class="cov1" title="1">
                        j.processCommentProto(field.Comment, field.Position.Line, field)
                        message.Map[field.Name] = &amp;Map{
                                Field: &amp;Field{
                                        Type:     field.Type,
                                        Sequence: field.Sequence,
                                        Lines: map[string]model.LineObject{
                                                "_kics__default": {Line: field.Position.Line},
                                        },
                                },
                                KeyType: field.KeyType,
                        }
                        message.Lines["_kics_"+field.Name] = model.LineObject{
                                Line: field.Position.Line,
                        }</span>
                case *proto.Message:<span class="cov1" title="1">
                        j.processCommentProto(field.Comment, field.Position.Line, field)
                        message.InnerMessage[field.Name] = j.convertMessage(field)
                        message.Lines["_kics_"+field.Name] = model.LineObject{
                                Line: field.Position.Line,
                        }</span>
                case *proto.Option:<span class="cov1" title="1">
                        j.processCommentProto(field.Comment, field.Position.Line, field)
                        message.Options[field.Name] = j.convertSingleOption(field)
                        message.Lines["_kics_"+field.Name] = model.LineObject{
                                Line: field.Position.Line,
                        }</span>
                }
                <span class="cov7" title="12">continue</span>
        }

        <span class="cov5" title="6">message.Lines["_kics__default"] = model.LineObject{
                Line: n.Position.Line,
                Arr:  defaultArr,
        }

        return message</span>
}

// convertEnum converts a proto enum to a JSON enum
func (j *JSONProto) convertEnum(n *proto.Enum) Enum <span class="cov2" title="2">{
        enum := Enum{
                Reserved:  make([]*Reserved, 0),
                EnumField: make(map[string]EnumValue),
                Options:   make(map[string]Option),
                Lines:     make(map[string]model.LineObject),
        }

        defaultArr := make([]map[string]*model.LineObject, 0)

        for _, elem := range n.Elements </span><span class="cov4" title="5">{
                switch elem := elem.(type) </span>{
                case *proto.EnumField:<span class="cov3" title="3">
                        j.processCommentProto(elem.Comment, elem.Position.Line, elem)
                        enum.EnumField[elem.Name] = EnumValue{
                                Value:   elem.Integer,
                                Options: j.convertSingleOption(elem.ValueOption),
                                Lines: map[string]model.LineObject{
                                        "_kics__default": {Line: elem.Position.Line},
                                },
                        }
                        enum.Lines["_kics_"+elem.Name] = model.LineObject{
                                Line: elem.Position.Line,
                        }</span>
                case *proto.Reserved:<span class="cov1" title="1">
                        j.processCommentProto(elem.Comment, elem.Position.Line, elem)
                        enum.Reserved = append(enum.Reserved, j.convertReserved(elem))
                        defaultArr = append(defaultArr, map[string]*model.LineObject{
                                "Reserved": {
                                        Line: elem.Position.Line,
                                },
                        })</span>
                case *proto.Option:<span class="cov1" title="1">
                        j.processCommentProto(elem.Comment, elem.Position.Line, elem)
                        enum.Options[elem.Name] = j.convertSingleOption(elem)
                        enum.Lines["_kics_"+elem.Name] = model.LineObject{
                                Line: elem.Position.Line,
                        }</span>
                }
                <span class="cov4" title="5">continue</span>
        }

        <span class="cov2" title="2">enum.Lines["_kics__default"] = model.LineObject{
                Line: n.Position.Line,
                Arr:  defaultArr,
        }

        return enum</span>
}

// convertOneOf converts a proto oneof to a JSON oneof
func (j *JSONProto) convertOneOf(n *proto.Oneof) OneOf <span class="cov1" title="1">{
        oneof := OneOf{
                Field:   make(map[string]*Field),
                Options: make(map[string]Option),
                Lines:   make(map[string]model.LineObject),
        }
        oneof.Lines["_kics__default"] = model.LineObject{
                Line: n.Position.Line,
                Arr:  make([]map[string]*model.LineObject, 0),
        }
        for _, elem := range n.Elements </span><span class="cov2" title="2">{
                switch elem := elem.(type) </span>{
                case *proto.OneOfField:<span class="cov2" title="2">
                        j.processCommentProto(elem.Comment, elem.Position.Line, elem)
                        oneof.Field[elem.Name] = &amp;Field{
                                Type:     elem.Type,
                                Sequence: elem.Sequence,
                                Options:  j.convertOption(elem.Options),
                                Lines: map[string]model.LineObject{
                                        "_kics__default": {Line: elem.Position.Line},
                                },
                        }
                        oneof.Lines["_kics_"+elem.Name] = model.LineObject{
                                Line: elem.Position.Line,
                        }</span>
                case *proto.Option:<span class="cov0" title="0">
                        j.processCommentProto(elem.Comment, elem.Position.Line, elem)
                        oneof.Options[elem.Name] = j.convertSingleOption(elem)
                        oneof.Lines["_kics_"+elem.Name] = model.LineObject{
                                Line: elem.Position.Line,
                        }</span>
                }
                <span class="cov2" title="2">continue</span>
        }
        <span class="cov1" title="1">return oneof</span>
}

// convertReserved converts a proto reserved to a JSON reserved
func (j *JSONProto) convertReserved(n *proto.Reserved) *Reserved <span class="cov2" title="2">{
        return &amp;Reserved{
                Ranges:     n.Ranges,
                FieldNames: n.FieldNames,
                Lines: map[string]model.LineObject{
                        "_kics__default": {Line: n.Position.Line},
                },
        }
}</span>

// convertService converts a proto service to a JSON service
func (j *JSONProto) convertService(n *proto.Service) <span class="cov1" title="1">{
        service := Service{
                RPC:     make(map[string]RPC),
                Options: make(map[string]Option),
                Lines:   make(map[string]model.LineObject),
        }

        service.Lines["_kics__default"] = model.LineObject{
                Line: n.Position.Line,
                Arr:  make([]map[string]*model.LineObject, 0),
        }

        for _, rpc := range n.Elements </span><span class="cov1" title="1">{
                switch rpc := rpc.(type) </span>{
                case *proto.RPC:<span class="cov1" title="1">
                        j.processCommentProto(rpc.Comment, rpc.Position.Line, rpc)
                        service.RPC[rpc.Name] = j.convertRPC(rpc)
                        service.Lines["_kics_"+rpc.Name] = model.LineObject{
                                Line: rpc.Position.Line,
                        }</span>
                case *proto.Option:<span class="cov0" title="0">
                        j.processCommentProto(rpc.Comment, rpc.Position.Line, rpc)
                        service.Options[rpc.Name] = j.convertSingleOption(rpc)
                        service.Lines["_kics_"+rpc.Name] = model.LineObject{
                                Line: rpc.Position.Line,
                        }</span>
                }
        }

        <span class="cov1" title="1">j.Services[n.Name] = service</span>
}

// convertOption converts a proto option to a JSON option
func (j *JSONProto) convertOption(n []*proto.Option) []Option <span class="cov6" title="9">{
        if n == nil </span><span class="cov5" title="7">{
                return []Option{}
        }</span>

        <span class="cov2" title="2">options := make([]Option, 0)
        for _, option := range n </span><span class="cov2" title="2">{
                j.processCommentProto(option.Comment, option.Position.Line, option)
                options = append(options, Option{
                        Name:       option.Name,
                        Constant:   j.convertOptionLiteral(&amp;option.Constant),
                        IsEmbedded: option.IsEmbedded,
                        Lines: map[string]model.LineObject{
                                "_kics__default": {Line: option.Position.Line},
                        },
                })
        }</span>
        <span class="cov2" title="2">return options</span>
}

// convertRPC converts a proto rpc to a JSON rpc
func (j *JSONProto) convertRPC(n *proto.RPC) RPC <span class="cov1" title="1">{
        return RPC{
                RequestType:    n.RequestType,
                StreamsRequest: n.StreamsRequest,
                ReturnsType:    n.ReturnsType,
                StreamsReturns: n.StreamsReturns,
                Options:        j.convertOption(n.Options),
                Lines: map[string]model.LineObject{
                        "_kics__default": {Line: n.Position.Line},
                },
        }
}</span>

// convertOptionLiteral converts a proto option literal to a JSON option literal
func (j *JSONProto) convertOptionLiteral(n *proto.Literal) OptionLiteral <span class="cov6" title="8">{
        return OptionLiteral{
                IsString:   n.IsString,
                Source:     n.Source,
                Name:       "",
                QuoteRune:  n.QuoteRune,
                Array:      j.getArrayLiteral(n.Array),
                Map:        j.getMapLiteral(n.Map),
                OrderedMap: j.getLiteralMap(n.OrderedMap),
                Lines: map[string]model.LineObject{
                        "_kics__default": {Line: n.Position.Line},
                },
        }
}</span>

// convertOptionNamedLiteral converts a proto option named literal to a JSON option named literal
func (j *JSONProto) convertOptionNamedLiteral(n *proto.NamedLiteral) OptionLiteral <span class="cov2" title="2">{
        return OptionLiteral{
                IsString:   n.IsString,
                Source:     n.Source,
                Name:       n.Name,
                QuoteRune:  n.QuoteRune,
                Array:      j.getArrayLiteral(n.Array),
                Map:        j.getMapLiteral(n.Map),
                OrderedMap: j.getLiteralMap(n.OrderedMap),
                Lines: map[string]model.LineObject{
                        "_kics__default": {Line: n.Position.Line},
                },
        }
}</span>

// convertSingleOption converts a proto option to a JSON option
func (j *JSONProto) convertSingleOption(n *proto.Option) Option <span class="cov5" title="6">{
        if n == nil </span><span class="cov2" title="2">{
                return Option{}
        }</span>
        <span class="cov4" title="4">return Option{
                Name:       n.Name,
                Constant:   j.convertOptionLiteral(&amp;n.Constant),
                IsEmbedded: n.IsEmbedded,
                Lines: map[string]model.LineObject{
                        "_kics__default": {Line: n.Position.Line},
                },
        }</span>
}

// getArrayLiteral converts a proto array literal to a JSON array literal
func (j *JSONProto) getArrayLiteral(n []*proto.Literal) []OptionLiteral <span class="cov6" title="10">{
        array := make([]OptionLiteral, 0)
        for _, elem := range n </span><span class="cov0" title="0">{
                array = append(array, j.convertOptionLiteral(elem))
        }</span>
        <span class="cov6" title="10">return array</span>
}

// getMapLiteral converts a proto map literal to a JSON map literal
func (j *JSONProto) getMapLiteral(n map[string]*proto.Literal) map[string]OptionLiteral <span class="cov6" title="10">{
        returnMap := make(map[string]OptionLiteral)
        for key, value := range n </span><span class="cov2" title="2">{
                returnMap[key] = j.convertOptionLiteral(value)
        }</span>
        <span class="cov6" title="10">return returnMap</span>
}

// getLiteralMap converts a proto literal map to a JSON literal map
func (j *JSONProto) getLiteralMap(n proto.LiteralMap) []OptionLiteral <span class="cov6" title="10">{
        array := make([]OptionLiteral, 0)
        for _, elem := range n </span><span class="cov2" title="2">{
                array = append(array, j.convertOptionNamedLiteral(elem))
        }</span>
        <span class="cov6" title="10">return array</span>
}

// processCommentProto gathers lines to ignore based on comment commands
func (j *JSONProto) processCommentProto(comment *proto.Comment, lineStart int, element interface{}) <span class="cov10" title="41">{
        // if comment is nil, return
        if comment == nil </span><span class="cov9" title="37">{
                j.linesNotToIgnore = append(j.linesNotToIgnore, lineStart)
                return
        }</span>

        <span class="cov4" title="4">rangeToIgnore := model.Range(comment.Position.Line, comment.Position.Line+(len(comment.Lines)-1))

        // ignore lines that are comments
        linesToIgnore := j.ignoreComment(rangeToIgnore)
        j.linesToIgnore = append(j.linesToIgnore, linesToIgnore...)

        var value model.CommentCommand
        for _, line := range comment.Lines </span><span class="cov4" title="4">{
                comment := strings.ToLower(line)
                if model.KICSCommentRgxp.MatchString(comment) </span><span class="cov3" title="3">{
                        comment = model.KICSCommentRgxp.ReplaceAllString(comment, "")
                        comment = strings.Trim(comment, "\n")
                        commands := strings.Split(strings.Trim(comment, "\r"), " ")
                        value = model.ProcessCommands(commands)
                }</span>
                <span class="cov4" title="4">continue</span>
        }

        <span class="cov4" title="4">lineEnd := getLastElementLine(element, lineStart)
        switch value </span>{
        case model.IgnoreLine:<span class="cov2" title="2">
                j.linesToIgnore = append(j.linesToIgnore, lineStart)</span>
        case model.IgnoreBlock:<span class="cov1" title="1">
                j.linesToIgnore = append(j.linesToIgnore, model.Range(lineStart, lineEnd)...)</span>
        default:<span class="cov1" title="1">
                break</span>
        }
}

// ignoreComment returns a slice of lines to ignore with inline comments removed
func (j *JSONProto) ignoreComment(values []int) []int <span class="cov4" title="4">{
        linesToIgnore := make([]int, 0)
        for _, value := range values </span><span class="cov4" title="4">{
                if isInSlice(value, j.linesNotToIgnore) </span><span class="cov1" title="1">{
                        continue</span>
                }
                <span class="cov3" title="3">linesToIgnore = append(linesToIgnore, value)</span>
        }
        <span class="cov4" title="4">return linesToIgnore</span>
}

// isInSlice checks if a value is in a slice
func isInSlice(value int, slice []int) bool <span class="cov4" title="4">{
        for _, v := range slice </span><span class="cov7" title="17">{
                if v == value </span><span class="cov1" title="1">{
                        return true
                }</span>
        }
        <span class="cov3" title="3">return false</span>
}

// getLastElementLine returns the last line of an element block
func getLastElementLine(v interface{}, parentLine int) int <span class="cov5" title="7">{
        position := 0
        switch t := v.(type) </span>{
        // case proto.Proto:
        //         position = getLastElement(t.Elements[len(t.Elements)-1], t.Position.Line)
        case *proto.Message:<span class="cov1" title="1">
                if len(t.Elements) &gt; 0 </span><span class="cov1" title="1">{
                        position = getLastElementLine(t.Elements[len(t.Elements)-1], t.Position.Line)
                }</span>
        case *proto.Service:<span class="cov0" title="0">
                if len(t.Elements) &gt; 0 </span><span class="cov0" title="0">{
                        position = getLastElementLine(t.Elements[len(t.Elements)-1], t.Position.Line)
                }</span>
        case *proto.EnumField:<span class="cov0" title="0">
                if len(t.Elements) &gt; 0 </span><span class="cov0" title="0">{
                        position = getLastElementLine(t.Elements[len(t.Elements)-1], t.Position.Line)
                }</span>
        case *proto.Enum:<span class="cov0" title="0">
                if len(t.Elements) &gt; 0 </span><span class="cov0" title="0">{
                        position = getLastElementLine(t.Elements[len(t.Elements)-1], t.Position.Line)
                }</span>
        case *proto.Oneof:<span class="cov2" title="2">
                if len(t.Elements) &gt; 0 </span><span class="cov2" title="2">{
                        position = getLastElementLine(t.Elements[len(t.Elements)-1], t.Position.Line)
                }</span>
        case *proto.RPC:<span class="cov0" title="0">
                if len(t.Elements) &gt; 0 </span><span class="cov0" title="0">{
                        position = getLastElementLine(t.Elements[len(t.Elements)-1], t.Position.Line)
                }</span>
        case *proto.Group:<span class="cov0" title="0">
                if len(t.Elements) &gt; 0 </span><span class="cov0" title="0">{
                        position = getLastElementLine(t.Elements[len(t.Elements)-1], t.Position.Line)
                }</span>
        default:<span class="cov4" title="4">
                position = setElementLine(v, parentLine)</span>
        }
        <span class="cov5" title="7">return position</span>
}

// setElementLine sets the last line of an element block
func setElementLine(v interface{}, parentLine int) int <span class="cov4" title="4">{
        position := 0
        switch t := v.(type) </span>{
        case *proto.Syntax:<span class="cov0" title="0">
                position = t.Position.Line</span>
        case *proto.Package:<span class="cov0" title="0">
                position = t.Position.Line</span>
        case *proto.Import:<span class="cov0" title="0">
                position = t.Position.Line</span>
        case *proto.NormalField:<span class="cov1" title="1">
                position = t.Position.Line</span>
        case *proto.Comment:<span class="cov0" title="0">
                position = t.Position.Line</span>
        case *proto.OneOfField:<span class="cov2" title="2">
                position = t.Position.Line</span>
        case *proto.Reserved:<span class="cov1" title="1">
                position = t.Position.Line</span>
        case *proto.MapField:<span class="cov0" title="0">
                position = t.Position.Line</span>
        case *proto.Extensions:<span class="cov0" title="0">
                position = t.Position.Line</span>
        default:<span class="cov0" title="0">
                position = parentLine</span>
        }
        <span class="cov4" title="4">return position</span>
}
</pre>
		
		<pre class="file" id="file60" style="display: none">package grpc

import (
        "bytes"
        "encoding/json"

        "github.com/Checkmarx/kics/pkg/model"
        "github.com/Checkmarx/kics/pkg/parser/grpc/converter"
        "github.com/emicklei/proto"
)

// Parser - parser for Proto files
type Parser struct {
}

// Parse - parses dockerfile to Json
func (p *Parser) Parse(_ string, fileContent []byte) ([]model.Document, []int, error) <span class="cov10" title="2">{
        reader := bytes.NewReader(fileContent)
        parserProto := proto.NewParser(reader)
        nodes, err := parserProto.Parse()
        if err != nil </span><span class="cov0" title="0">{
                return nil, nil, err
        }</span>

        <span class="cov10" title="2">var doc model.Document

        jproto, linesIgnore := converter.Convert(nodes)

        protoBytes, err := json.Marshal(jproto)
        if err != nil </span><span class="cov0" title="0">{
                return nil, nil, err
        }</span>

        <span class="cov10" title="2">err = json.Unmarshal(protoBytes, &amp;doc)
        if err != nil </span><span class="cov0" title="0">{
                return nil, nil, err
        }</span>

        <span class="cov10" title="2">return []model.Document{doc}, linesIgnore, nil</span>
}

// GetKind returns the kind of the parser
func (p *Parser) GetKind() model.FileKind <span class="cov1" title="1">{
        return model.KindPROTO
}</span>

// SupportedExtensions returns Dockerfile extensions
func (p *Parser) SupportedExtensions() []string <span class="cov1" title="1">{
        return []string{".proto"}
}</span>

// SupportedTypes returns types supported by this parser, which are dockerfile
func (p *Parser) SupportedTypes() map[string]bool <span class="cov1" title="1">{
        return map[string]bool{"grpc": true}
}</span>

// GetCommentToken return the comment token of Docker - #
func (p *Parser) GetCommentToken() string <span class="cov1" title="1">{
        return "//"
}</span>

// StringifyContent converts original content into string formatted version
func (p *Parser) StringifyContent(content []byte) (string, error) <span class="cov1" title="1">{
        return string(content), nil
}</span>

// Resolve resolves proto files variables
func (p *Parser) Resolve(fileContent []byte, _ string) ([]byte, error) <span class="cov1" title="1">{
        return fileContent, nil
}</span>

// GetResolvedFiles returns the list of files that are resolved
func (p *Parser) GetResolvedFiles() map[string]model.ResolvedFile <span class="cov1" title="1">{
        return make(map[string]model.ResolvedFile)
}</span>
</pre>
		
		<pre class="file" id="file61" style="display: none">package json

import (
        "bytes"
        "encoding/json"
        "fmt"
        "sort"
        "strings"

        "github.com/Checkmarx/kics/pkg/model"
)

type jsonLine struct {
        LineInfo map[string]model.Document
}

// jsonLineStruct is the struct that keeps important information for the creation of line Information Map
// tmpParent is the parent key of the value we are currently on
// pathArr is an array containing the path elements of the value we are currently on
// noremoveidx keeps information of which elements should not be removed from pathArr on closing delimeters
// lastWasRune keeps information if last Token was a delimeter
// parent is the string path of the element we are currently on
type jsonLineStruct struct {
        tmpParent   string
        pathArr     []string
        lastWasRune bool
        noremoveidx map[int]string
        parent      string
}

type fifo struct {
        name  string // for debugging purposes
        Value []int
}

// initiateJSONLine will create a map, containing line information for every key present in the JSON
func initializeJSONLine(doc []byte) *jsonLine <span class="cov4" title="17">{
        newMap := make(map[string]model.Document)
        dec := json.NewDecoder(bytes.NewReader(doc))

        jstruct := jsonLineStruct{
                tmpParent:   "",
                pathArr:     make([]string, 0),
                lastWasRune: false,
                noremoveidx: make(map[int]string),
                parent:      "",
        }

        // for each token inside JSON
        for </span><span class="cov6" title="158">{
                tok, err := dec.Token()
                if err != nil </span><span class="cov4" title="17">{
                        break</span>
                }

                <span class="cov6" title="141">if v, ok := tok.(json.Delim); ok </span><span class="cov6" title="80">{
                        // token is a delimeter
                        jstruct.delimSetup(v)
                }</span> else<span class="cov5" title="61"> {
                        jstruct.lastWasRune = false
                }</span>

                <span class="cov6" title="141">tokStringRepresentation := ""

                // if token is a string than update temporary father key
                switch t := tok.(type) </span>{
                case string:<span class="cov5" title="53">
                        jstruct.tmpParent = t
                        tokStringRepresentation = t</span>
                case float64:<span class="cov3" title="8">
                        tokStringRepresentation = fmt.Sprint(int(t))
                        jstruct.tmpParent = tokStringRepresentation</span>
                case bool:<span class="cov0" title="0">
                        tokStringRepresentation = fmt.Sprint(t)
                        jstruct.tmpParent = tokStringRepresentation</span>
                case nil:<span class="cov0" title="0">
                        tokStringRepresentation = fmt.Sprint(t)
                        jstruct.tmpParent = tokStringRepresentation</span>
                default:<span class="cov6" title="80">
                        continue</span>
                }

                <span class="cov5" title="61">line := 1
                // get the correct line based on byte offset
                for i, val := range doc </span><span class="cov10" title="2246">{
                        if i == int(dec.InputOffset()) </span><span class="cov5" title="61">{
                                break</span>
                        } else<span class="cov9" title="2185"> if val == byte('\n') </span><span class="cov6" title="144">{
                                line++
                        }</span>
                }

                // insert into line information map
                <span class="cov5" title="61">if _, ok := newMap[tokStringRepresentation]; !ok </span><span class="cov5" title="55">{
                        // key info is not in map yet
                        newLineSlice := &amp;fifo{name: tokStringRepresentation}
                        parentMap := make(map[string]interface{})
                        newLineSlice.add(line)
                        parentMap[jstruct.parent] = newLineSlice
                        newMap[tokStringRepresentation] = parentMap
                }</span> else<span class="cov3" title="6"> if v, ok := newMap[tokStringRepresentation][jstruct.parent]; ok </span><span class="cov1" title="2">{
                        // key info is in map with the same path so append is made
                        newLineSlice := &amp;fifo{name: tokStringRepresentation}
                        newLineSlice.add(v.(*fifo).Value...)
                        newLineSlice.add(line)
                        newMap[tokStringRepresentation][jstruct.parent] = newLineSlice
                }</span> else<span class="cov2" title="4"> {
                        // key info is in map with different path
                        newLineSlice := &amp;fifo{name: tokStringRepresentation}
                        newLineSlice.add(line)
                        newMap[tokStringRepresentation][jstruct.parent] = newLineSlice
                }</span>
        }
        <span class="cov4" title="17">return &amp;jsonLine{
                LineInfo: newMap,
        }</span>
}

// delimSetup updates the jsonLineStruct when a json delimeter (ex: { [ ...) is found
func (j *jsonLineStruct) delimSetup(v json.Delim) <span class="cov6" title="80">{
        lenPathArr := len(j.pathArr) - 1
        switch rune(v) </span>{
        case '{', '[':<span class="cov5" title="40">
                // check if last element was a json delimeter
                if !j.lastWasRune </span><span class="cov5" title="38">{
                        j.pathArr = append(j.pathArr, j.tmpParent)
                }</span> else<span class="cov1" title="2"> {
                        // check if temporary parent is in path array, if not last element must be the tempParent
                        // and added to noremoveidx
                        // the next close delimeter should not remove the last element from the pathArr
                        if j.tmpParent != j.pathArr[lenPathArr] </span><span class="cov0" title="0">{
                                j.tmpParent = j.pathArr[lenPathArr]
                                j.noremoveidx[lenPathArr] = j.tmpParent
                        }</span> else<span class="cov1" title="2"> {
                                // the next close delimeter should not remove the last element from the pathArr
                                j.noremoveidx[lenPathArr] = j.tmpParent
                        }</span>
                }
                // update parent path string
                <span class="cov5" title="40">j.parent = strings.Join(j.pathArr, ".")</span>
        case '}', ']':<span class="cov5" title="40">
                j.closeBrackets(lenPathArr)</span>
        }
        <span class="cov6" title="80">j.lastWasRune = true</span>
}

// closeBrackets is what based on the jsonLineStruct information
// will update the parent path and make necessary updates on its structure
func (j *jsonLineStruct) closeBrackets(lenPathArr int) <span class="cov5" title="40">{
        // check if there are elements in the pathArr
        if lenPathArr &gt; 0 </span><span class="cov4" title="23">{
                // check if there are elements in the no noremoveidx
                if v, ok := j.noremoveidx[lenPathArr]; ok </span><span class="cov1" title="2">{
                        // if the last elements in pathArr and noremoveidx differ,
                        // than the last element on pathArr was already closed and can
                        // be removed
                        if j.pathArr[lenPathArr] != v </span><span class="cov0" title="0">{
                                j.pathArr = j.pathArr[:lenPathArr]
                        }</span> else<span class="cov1" title="2"> {
                                // the last element was not closed but should be closed
                                // on the next closing delim
                                // remove from noremoveidx
                                delete(j.noremoveidx, lenPathArr)
                        }</span>
                } else<span class="cov4" title="21"> {
                        // this last element in the pathArr was closed
                        // it can now be removed from the pathArr
                        j.pathArr = j.pathArr[:lenPathArr]
                }</span>
        }
        // update parent string path
        <span class="cov5" title="40">j.parent = strings.Join(j.pathArr, ".")</span>
}

// setLineInfo will set the line information of keys in json based on the line Information map
func (j *jsonLine) setLineInfo(doc map[string]interface{}) map[string]interface{} <span class="cov3" title="9">{
        // set the line info for keys in root level
        doc["_kics_lines"] = j.setLine(doc, 0, "", false)
        return doc
}</span>

// setLine returns the line information for the key containing values
// def is the line of the key
// index is used in case of an array, otherwhise should be 0
// father is the path to the key
func (j *jsonLine) setLine(val map[string]interface{}, def int, father string, pop bool) map[string]*model.LineObject <span class="cov4" title="16">{
        lineMap := make(map[string]*model.LineObject)
        // set the line information of val
        lineMap["_kics__default"] = &amp;model.LineObject{
                Line: def,
                Arr:  []map[string]*model.LineObject{},
        }

        // iterate through the values of the object
        for key, val := range val </span><span class="cov4" title="17">{
                // if the key with father path was not found ignore
                if _, ok2 := j.LineInfo[key][father]; !ok2 </span><span class="cov0" title="0">{
                        continue</span>
                }

                <span class="cov4" title="17">line := j.LineInfo[key][father]

                if len(line.(*fifo).Value) == 0 </span><span class="cov0" title="0">{
                        continue</span>
                }

                <span class="cov4" title="17">lineArr := make([]map[string]*model.LineObject, 0)
                lineNr := line.(*fifo).head()
                if pop </span><span class="cov1" title="1">{
                        lineNr = line.(*fifo).pop()
                }</span>

                <span class="cov4" title="17">switch v := val.(type) </span>{
                // value is an array and must call func setSeqLines to set element lines
                case []interface{}:<span class="cov2" title="5">
                        lineArr = j.setSeqLines(v, lineNr, father, key, lineArr)</span>
                // value is an object and must setLines for each element of the object
                case map[string]interface{}:<span class="cov3" title="6">
                        v["_kics_lines"] = j.setLine(v, lineNr, fmt.Sprintf("%s.%s", father, key), false)</span>
                default:<span class="cov3" title="6">
                        // value as no childs
                        lineMap[fmt.Sprintf("_kics_%s", key)] = &amp;model.LineObject{
                                Line: lineNr,
                                Arr:  lineArr,
                        }
                        continue</span>
                }

                // set line information of value with its default line and
                // if present array elements line informations
                <span class="cov3" title="11">lineMap[fmt.Sprintf("_kics_%s", key)] = &amp;model.LineObject{
                        Line: lineNr,
                        Arr:  lineArr,
                }</span>
        }
        <span class="cov4" title="16">return lineMap</span>
}

// setSeqLines sets the elements lines information for value of type array
func (j *jsonLine) setSeqLines(v []interface{}, def int, father, key string,
        lineArr []map[string]*model.LineObject) []map[string]*model.LineObject <span class="cov2" title="5">{
        // update father path with key
        fatherKey := father + "." + key

        defaultLineArr := j.getMapDefaultLine(v, fatherKey)
        if defaultLineArr == -1 </span><span class="cov2" title="4">{
                defaultLineArr = def
        }</span>
        // iterate over each element of the array
        <span class="cov2" title="5">for _, contentEntry := range v </span><span class="cov3" title="10">{
                switch con := contentEntry.(type) </span>{
                // case element is a map/object call func setLine
                case map[string]interface{}:<span class="cov1" title="1">
                        lineArr = append(lineArr, j.setLine(con, defaultLineArr, fatherKey, true))</span>
                // case element is a string
                default:<span class="cov3" title="9">
                        stringedCon := fmt.Sprint(con)
                        // check if element is present in line info map
                        if lineStr, ok2 := j.LineInfo[stringedCon][fmt.Sprintf("%s.%s", father, key)]; ok2 </span><span class="cov3" title="9">{
                                if len(lineStr.(*fifo).Value) == 0 </span><span class="cov0" title="0">{
                                        continue</span>
                                }
                                <span class="cov3" title="9">lineArr = append(lineArr, map[string]*model.LineObject{
                                        "_kics__default": {
                                                Line: lineStr.(*fifo).pop(),
                                        },
                                })</span>
                        }
                }
        }
        <span class="cov2" title="5">return lineArr</span>
}

// must get all and choose the smallest one
func (j *jsonLine) getMapDefaultLine(v []interface{}, father string) int <span class="cov2" title="5">{
        returnNumber := -1
        for _, contentEntry := range v </span><span class="cov3" title="10">{
                linesNumbers := make([]int, 0)
                if c, ok := contentEntry.(map[string]interface{}); ok </span><span class="cov1" title="1">{
                        for key := range c </span><span class="cov1" title="1">{
                                if _, ok2 := j.LineInfo[key][father]; !ok2 </span><span class="cov0" title="0">{
                                        continue</span>
                                }
                                <span class="cov1" title="1">line := j.LineInfo[key][father]
                                if len(line.(*fifo).Value) == 0 </span><span class="cov0" title="0">{
                                        continue</span>
                                }
                                <span class="cov1" title="1">linesNumbers = append(linesNumbers, line.(*fifo).head())</span>
                        }
                        <span class="cov1" title="1">if len(linesNumbers) &gt; 0 </span><span class="cov1" title="1">{
                                sort.Ints(linesNumbers)
                                returnNumber = linesNumbers[0]
                        }</span>
                }
        }
        <span class="cov2" title="5">return returnNumber</span>
}

// SET OF TOOLS TO ASSIST WITH JSON LINE

func (f *fifo) add(elements ...int) <span class="cov5" title="64">{
        f.Value = append(f.Value, elements...)
}</span>

func (f *fifo) pop() int <span class="cov3" title="11">{
        firstElement := f.Value[0]
        f.Value = f.Value[1:]
        return firstElement
}</span>

func (f *fifo) head() int <span class="cov4" title="19">{
        return f.Value[0]
}</span>
</pre>
		
		<pre class="file" id="file62" style="display: none">package json

import (
        "bytes"
        "encoding/json"

        "github.com/Checkmarx/kics/pkg/model"
        "github.com/Checkmarx/kics/pkg/resolver/file"
        "github.com/mailru/easyjson"
)

// Parser defines a parser type
type Parser struct {
        shouldIdent   bool
        resolvedFiles map[string]model.ResolvedFile
}

// Resolve - replace or modifies in-memory content before parsing
func (p *Parser) Resolve(fileContent []byte, filename string) ([]byte, error) <span class="cov1" title="1">{
        // Resolve files passed as arguments with file resolver (e.g. file://)
        res := file.NewResolver(json.Unmarshal, json.Marshal, p.SupportedExtensions())
        resolved := res.Resolve(fileContent, filename, 0)
        p.resolvedFiles = res.ResolvedFiles
        if len(res.ResolvedFiles) == 0 </span><span class="cov1" title="1">{
                return fileContent, nil
        }</span>
        <span class="cov0" title="0">return resolved, nil</span>
}

// Parse parses json file and returns it as a Document
func (p *Parser) Parse(_ string, fileContent []byte) ([]model.Document, []int, error) <span class="cov1" title="1">{
        r := model.Document{}
        err := easyjson.Unmarshal(fileContent, &amp;r)
        if err != nil </span><span class="cov0" title="0">{
                var r []model.Document
                err = json.Unmarshal(fileContent, &amp;r)
                return r, []int{}, err
        }</span>

        <span class="cov1" title="1">jLine := initializeJSONLine(fileContent)
        kicsJSON := jLine.setLineInfo(r)

        // Try to parse JSON as Terraform plan
        kicsPlan, err := parseTFPlan(kicsJSON)
        if err != nil </span><span class="cov1" title="1">{
                // JSON is not a tf plan
                return []model.Document{kicsJSON}, []int{}, nil
        }</span>

        <span class="cov0" title="0">p.shouldIdent = true

        return []model.Document{kicsPlan}, []int{}, nil</span>
}

// SupportedExtensions returns extensions supported by this parser, which is json extension
func (p *Parser) SupportedExtensions() []string <span class="cov10" title="2">{
        return []string{".json"}
}</span>

// GetKind returns JSON constant kind
func (p *Parser) GetKind() model.FileKind <span class="cov1" title="1">{
        return model.KindJSON
}</span>

// SupportedTypes returns types supported by this parser, which are cloudFormation
func (p *Parser) SupportedTypes() map[string]bool <span class="cov1" title="1">{
        return map[string]bool{"cloudformation": true, "openapi": true, "azureresourcemanager": true, "terraform": true, "kubernetes": true}
}</span>

// GetCommentToken return an empty string, since JSON does not have comment token
func (p *Parser) GetCommentToken() string <span class="cov1" title="1">{
        return ""
}</span>

// StringifyContent converts original content into string formated version
func (p *Parser) StringifyContent(content []byte) (string, error) <span class="cov10" title="2">{
        if p.shouldIdent </span><span class="cov1" title="1">{
                var out bytes.Buffer
                err := json.Indent(&amp;out, content, "", "  ")
                if err != nil </span><span class="cov0" title="0">{
                        return "", err
                }</span>
                <span class="cov1" title="1">return out.String(), nil</span>
        }
        <span class="cov1" title="1">return string(content), nil</span>
}

// GetResolvedFiles returns resolved files
func (p *Parser) GetResolvedFiles() map[string]model.ResolvedFile <span class="cov1" title="1">{
        return p.resolvedFiles
}</span>
</pre>
		
		<pre class="file" id="file63" style="display: none">package json

import (
        "encoding/json"

        "github.com/Checkmarx/kics/pkg/model"
        hcl_plan "github.com/hashicorp/terraform-json"
)

// KicsPlan is an auxiliary structure for parsing tfplans as a KICS Document
type KicsPlan struct {
        Resource map[string]KicsPlanResource `json:"resource"`
}

// KicsPlanResource is an auxiliary structure for parsing tfplans as a KICS Document
type KicsPlanResource map[string]KicsPlanNamedResource

// KicsPlanNamedResource is an auxiliary structure for parsing tfplans as a KICS Document
type KicsPlanNamedResource map[string]interface{}

// parseTFPlan unmarshals Document as a plan so it can be rebuilt with only
// the required information
func parseTFPlan(doc model.Document) (model.Document, error) <span class="cov10" title="3">{
        var plan *hcl_plan.Plan
        b, err := json.Marshal(doc)
        if err != nil </span><span class="cov0" title="0">{
                return model.Document{}, err
        }</span>
        // Unmarshal our Document as a plan so we are able retrieve planned_values
        // in a easier way
        <span class="cov10" title="3">err = json.Unmarshal(b, &amp;plan)
        if err != nil </span><span class="cov6" title="2">{
                // Consider as regular JSON and not tfplan
                return model.Document{}, err
        }</span>

        <span class="cov1" title="1">parsedPlan := readPlan(plan)
        return parsedPlan, nil</span>
}

// readPlan will get the information needed and parse it in a way KICS understands it
func readPlan(plan *hcl_plan.Plan) model.Document <span class="cov1" title="1">{
        kp := KicsPlan{
                Resource: make(map[string]KicsPlanResource),
        }

        kp.readModule(plan.PlannedValues.RootModule)

        doc := model.Document{}

        tmpDocBytes, err := json.Marshal(kp)
        if err != nil </span><span class="cov0" title="0">{
                return model.Document{}
        }</span>
        <span class="cov1" title="1">err = json.Unmarshal(tmpDocBytes, &amp;doc)
        if err != nil </span><span class="cov0" title="0">{
                return model.Document{}
        }</span>

        <span class="cov1" title="1">return doc</span>
}

// readModule will iterate over all planned_value getting the information required
func (kp *KicsPlan) readModule(module *hcl_plan.StateModule) <span class="cov1" title="1">{
        // initialize all the types interfaces
        for _, resource := range module.Resources </span><span class="cov1" title="1">{
                convNamedRes := make(map[string]KicsPlanNamedResource)
                kp.Resource[resource.Type] = convNamedRes
        }</span>
        // fill in all the types interfaces
        <span class="cov1" title="1">for _, resource := range module.Resources </span><span class="cov1" title="1">{
                kp.Resource[resource.Type][resource.Name] = resource.AttributeValues
        }</span>

        <span class="cov1" title="1">for _, childModule := range module.ChildModules </span><span class="cov0" title="0">{
                kp.readModule(childModule)
        }</span>
}
</pre>
		
		<pre class="file" id="file64" style="display: none">package parser

import "github.com/antlr/antlr4/runtime/Go/antlr"

type CustomSyntaxError struct {
        line, column int
        msg          string
}

type CustomErrorListener struct {
        *antlr.DefaultErrorListener
        Errors []*CustomSyntaxError
}

func NewCustomErrorListener() *CustomErrorListener <span class="cov1" title="1">{
        return &amp;CustomErrorListener{
                DefaultErrorListener: antlr.NewDefaultErrorListener(),
                Errors:               make([]*CustomSyntaxError, 0),
        }
}</span>

func (c *CustomErrorListener) HasErrors() bool <span class="cov10" title="3">{
        return len(c.Errors) &gt; 0
}</span>

func (c *CustomErrorListener) SyntaxError(recognizer antlr.Recognizer,
        offendingSymbol interface{}, line, column int, msg string, e antlr.RecognitionException) <span class="cov1" title="1">{
        c.Errors = append(c.Errors, &amp;CustomSyntaxError{
                line:   line,
                column: column,
                msg:    msg,
        })
}</span>
</pre>
		
		<pre class="file" id="file65" style="display: none">// Code generated from JSONFilter.g4 by ANTLR 4.9.2. DO NOT EDIT.

package parser // JSONFilter

import "github.com/antlr/antlr4/runtime/Go/antlr"

type BaseJSONFilterVisitor struct {
        *antlr.BaseParseTreeVisitor
}

func (v *BaseJSONFilterVisitor) VisitAwsjsonfilter(ctx *AwsjsonfilterContext) interface{} <span class="cov0" title="0">{
        return v.VisitChildren(ctx)
}</span>

func (v *BaseJSONFilterVisitor) VisitDotnotation(ctx *DotnotationContext) interface{} <span class="cov0" title="0">{
        return v.VisitChildren(ctx)
}</span>

func (v *BaseJSONFilterVisitor) VisitFilter_expr_parenthesized(ctx *Filter_expr_parenthesizedContext) interface{} <span class="cov0" title="0">{
        return v.VisitChildren(ctx)
}</span>

func (v *BaseJSONFilterVisitor) VisitFilter_expr_and(ctx *Filter_expr_andContext) interface{} <span class="cov0" title="0">{
        return v.VisitChildren(ctx)
}</span>

func (v *BaseJSONFilterVisitor) VisitFilter_expr_exp(ctx *Filter_expr_expContext) interface{} <span class="cov0" title="0">{
        return v.VisitChildren(ctx)
}</span>

func (v *BaseJSONFilterVisitor) VisitFilter_expr_or(ctx *Filter_expr_orContext) interface{} <span class="cov0" title="0">{
        return v.VisitChildren(ctx)
}</span>

func (v *BaseJSONFilterVisitor) VisitExp(ctx *ExpContext) interface{} <span class="cov0" title="0">{
        return v.VisitChildren(ctx)
}</span>

func (v *BaseJSONFilterVisitor) VisitSelector(ctx *SelectorContext) interface{} <span class="cov0" title="0">{
        return v.VisitChildren(ctx)
}</span>

func (v *BaseJSONFilterVisitor) VisitQualifiedidentifier(ctx *QualifiedidentifierContext) interface{} <span class="cov0" title="0">{
        return v.VisitChildren(ctx)
}</span>

func (v *BaseJSONFilterVisitor) VisitMember(ctx *MemberContext) interface{} <span class="cov0" title="0">{
        return v.VisitChildren(ctx)
}</span>

func (v *BaseJSONFilterVisitor) VisitOperator(ctx *OperatorContext) interface{} <span class="cov0" title="0">{
        return v.VisitChildren(ctx)
}</span>

func (v *BaseJSONFilterVisitor) VisitLiteral(ctx *LiteralContext) interface{} <span class="cov0" title="0">{
        return v.VisitChildren(ctx)
}</span>
</pre>
		
		<pre class="file" id="file66" style="display: none">// Code generated from JSONFilter.g4 by ANTLR 4.9.2. DO NOT EDIT.

package parser

import (
        "fmt"
        "unicode"

        "github.com/antlr/antlr4/runtime/Go/antlr"
)

// Suppress unused import error
var _ = fmt.Printf
var _ = unicode.IsLetter

var serializedLexerAtn = []uint16{
        3, 24715, 42794, 33075, 47597, 16764, 15335, 30598, 22884, 2, 29, 209,
        8, 1, 4, 2, 9, 2, 4, 3, 9, 3, 4, 4, 9, 4, 4, 5, 9, 5, 4, 6, 9, 6, 4, 7,
        9, 7, 4, 8, 9, 8, 4, 9, 9, 9, 4, 10, 9, 10, 4, 11, 9, 11, 4, 12, 9, 12,
        4, 13, 9, 13, 4, 14, 9, 14, 4, 15, 9, 15, 4, 16, 9, 16, 4, 17, 9, 17, 4,
        18, 9, 18, 4, 19, 9, 19, 4, 20, 9, 20, 4, 21, 9, 21, 4, 22, 9, 22, 4, 23,
        9, 23, 4, 24, 9, 24, 4, 25, 9, 25, 4, 26, 9, 26, 4, 27, 9, 27, 4, 28, 9,
        28, 4, 29, 9, 29, 4, 30, 9, 30, 4, 31, 9, 31, 4, 32, 9, 32, 4, 33, 9, 33,
        4, 34, 9, 34, 3, 2, 3, 2, 3, 2, 3, 3, 3, 3, 3, 4, 3, 4, 3, 5, 3, 5, 3,
        6, 3, 6, 3, 7, 3, 7, 3, 8, 3, 8, 3, 9, 3, 9, 3, 10, 3, 10, 3, 11, 3, 11,
        3, 11, 3, 12, 3, 12, 3, 12, 3, 13, 3, 13, 3, 14, 3, 14, 3, 14, 3, 15, 3,
        15, 3, 16, 3, 16, 3, 17, 3, 17, 3, 17, 3, 18, 3, 18, 3, 18, 3, 19, 3, 19,
        3, 19, 3, 20, 3, 20, 3, 20, 3, 20, 3, 21, 3, 21, 3, 21, 3, 21, 3, 21, 3,
        22, 3, 22, 3, 22, 3, 22, 3, 22, 3, 22, 3, 22, 3, 23, 3, 23, 3, 23, 3, 23,
        3, 23, 3, 24, 3, 24, 3, 24, 3, 24, 3, 24, 3, 24, 3, 25, 3, 25, 7, 25, 142,
        10, 25, 12, 25, 14, 25, 145, 11, 25, 3, 26, 3, 26, 3, 26, 7, 26, 150, 10,
        26, 12, 26, 14, 26, 153, 11, 26, 3, 26, 3, 26, 3, 27, 3, 27, 3, 27, 5,
        27, 160, 10, 27, 3, 28, 3, 28, 3, 28, 3, 28, 3, 28, 3, 28, 3, 29, 3, 29,
        3, 30, 3, 30, 3, 31, 5, 31, 173, 10, 31, 3, 31, 3, 31, 3, 31, 6, 31, 178,
        10, 31, 13, 31, 14, 31, 179, 5, 31, 182, 10, 31, 3, 31, 5, 31, 185, 10,
        31, 3, 32, 3, 32, 3, 32, 7, 32, 190, 10, 32, 12, 32, 14, 32, 193, 11, 32,
        5, 32, 195, 10, 32, 3, 33, 3, 33, 5, 33, 199, 10, 33, 3, 33, 3, 33, 3,
        34, 6, 34, 204, 10, 34, 13, 34, 14, 34, 205, 3, 34, 3, 34, 2, 2, 35, 3,
        3, 5, 4, 7, 5, 9, 6, 11, 7, 13, 8, 15, 9, 17, 10, 19, 11, 21, 12, 23, 13,
        25, 14, 27, 15, 29, 16, 31, 17, 33, 18, 35, 19, 37, 20, 39, 21, 41, 22,
        43, 23, 45, 24, 47, 25, 49, 26, 51, 27, 53, 2, 55, 2, 57, 2, 59, 2, 61,
        28, 63, 2, 65, 2, 67, 29, 3, 2, 12, 4, 2, 67, 92, 99, 124, 5, 2, 50, 59,
        67, 92, 99, 124, 10, 2, 36, 36, 49, 49, 94, 94, 100, 100, 104, 104, 112,
        112, 116, 116, 118, 118, 5, 2, 50, 59, 67, 72, 99, 104, 5, 2, 2, 33, 36,
        36, 94, 94, 4, 2, 45, 45, 47, 47, 3, 2, 50, 59, 3, 2, 51, 59, 4, 2, 71,
        71, 103, 103, 5, 2, 11, 12, 15, 15, 34, 34, 2, 214, 2, 3, 3, 2, 2, 2, 2,
        5, 3, 2, 2, 2, 2, 7, 3, 2, 2, 2, 2, 9, 3, 2, 2, 2, 2, 11, 3, 2, 2, 2, 2,
        13, 3, 2, 2, 2, 2, 15, 3, 2, 2, 2, 2, 17, 3, 2, 2, 2, 2, 19, 3, 2, 2, 2,
        2, 21, 3, 2, 2, 2, 2, 23, 3, 2, 2, 2, 2, 25, 3, 2, 2, 2, 2, 27, 3, 2, 2,
        2, 2, 29, 3, 2, 2, 2, 2, 31, 3, 2, 2, 2, 2, 33, 3, 2, 2, 2, 2, 35, 3, 2,
        2, 2, 2, 37, 3, 2, 2, 2, 2, 39, 3, 2, 2, 2, 2, 41, 3, 2, 2, 2, 2, 43, 3,
        2, 2, 2, 2, 45, 3, 2, 2, 2, 2, 47, 3, 2, 2, 2, 2, 49, 3, 2, 2, 2, 2, 51,
        3, 2, 2, 2, 2, 61, 3, 2, 2, 2, 2, 67, 3, 2, 2, 2, 3, 69, 3, 2, 2, 2, 5,
        72, 3, 2, 2, 2, 7, 74, 3, 2, 2, 2, 9, 76, 3, 2, 2, 2, 11, 78, 3, 2, 2,
        2, 13, 80, 3, 2, 2, 2, 15, 82, 3, 2, 2, 2, 17, 84, 3, 2, 2, 2, 19, 86,
        3, 2, 2, 2, 21, 88, 3, 2, 2, 2, 23, 91, 3, 2, 2, 2, 25, 94, 3, 2, 2, 2,
        27, 96, 3, 2, 2, 2, 29, 99, 3, 2, 2, 2, 31, 101, 3, 2, 2, 2, 33, 103, 3,
        2, 2, 2, 35, 106, 3, 2, 2, 2, 37, 109, 3, 2, 2, 2, 39, 112, 3, 2, 2, 2,
        41, 116, 3, 2, 2, 2, 43, 121, 3, 2, 2, 2, 45, 128, 3, 2, 2, 2, 47, 133,
        3, 2, 2, 2, 49, 139, 3, 2, 2, 2, 51, 146, 3, 2, 2, 2, 53, 156, 3, 2, 2,
        2, 55, 161, 3, 2, 2, 2, 57, 167, 3, 2, 2, 2, 59, 169, 3, 2, 2, 2, 61, 172,
        3, 2, 2, 2, 63, 194, 3, 2, 2, 2, 65, 196, 3, 2, 2, 2, 67, 203, 3, 2, 2,
        2, 69, 70, 7, 38, 2, 2, 70, 71, 7, 48, 2, 2, 71, 4, 3, 2, 2, 2, 72, 73,
        7, 44, 2, 2, 73, 6, 3, 2, 2, 2, 74, 75, 7, 125, 2, 2, 75, 8, 3, 2, 2, 2,
        76, 77, 7, 127, 2, 2, 77, 10, 3, 2, 2, 2, 78, 79, 7, 42, 2, 2, 79, 12,
        3, 2, 2, 2, 80, 81, 7, 43, 2, 2, 81, 14, 3, 2, 2, 2, 82, 83, 7, 93, 2,
        2, 83, 16, 3, 2, 2, 2, 84, 85, 7, 95, 2, 2, 85, 18, 3, 2, 2, 2, 86, 87,
        7, 48, 2, 2, 87, 20, 3, 2, 2, 2, 88, 89, 7, 40, 2, 2, 89, 90, 7, 40, 2,
        2, 90, 22, 3, 2, 2, 2, 91, 92, 7, 126, 2, 2, 92, 93, 7, 126, 2, 2, 93,
        24, 3, 2, 2, 2, 94, 95, 7, 63, 2, 2, 95, 26, 3, 2, 2, 2, 96, 97, 7, 35,
        2, 2, 97, 98, 7, 63, 2, 2, 98, 28, 3, 2, 2, 2, 99, 100, 7, 64, 2, 2, 100,
        30, 3, 2, 2, 2, 101, 102, 7, 62, 2, 2, 102, 32, 3, 2, 2, 2, 103, 104, 7,
        64, 2, 2, 104, 105, 7, 63, 2, 2, 105, 34, 3, 2, 2, 2, 106, 107, 7, 62,
        2, 2, 107, 108, 7, 63, 2, 2, 108, 36, 3, 2, 2, 2, 109, 110, 7, 75, 2, 2,
        110, 111, 7, 85, 2, 2, 111, 38, 3, 2, 2, 2, 112, 113, 7, 80, 2, 2, 113,
        114, 7, 81, 2, 2, 114, 115, 7, 86, 2, 2, 115, 40, 3, 2, 2, 2, 116, 117,
        7, 80, 2, 2, 117, 118, 7, 87, 2, 2, 118, 119, 7, 78, 2, 2, 119, 120, 7,
        78, 2, 2, 120, 42, 3, 2, 2, 2, 121, 122, 7, 71, 2, 2, 122, 123, 7, 90,
        2, 2, 123, 124, 7, 75, 2, 2, 124, 125, 7, 85, 2, 2, 125, 126, 7, 86, 2,
        2, 126, 127, 7, 85, 2, 2, 127, 44, 3, 2, 2, 2, 128, 129, 7, 86, 2, 2, 129,
        130, 7, 84, 2, 2, 130, 131, 7, 87, 2, 2, 131, 132, 7, 71, 2, 2, 132, 46,
        3, 2, 2, 2, 133, 134, 7, 72, 2, 2, 134, 135, 7, 67, 2, 2, 135, 136, 7,
        78, 2, 2, 136, 137, 7, 85, 2, 2, 137, 138, 7, 71, 2, 2, 138, 48, 3, 2,
        2, 2, 139, 143, 9, 2, 2, 2, 140, 142, 9, 3, 2, 2, 141, 140, 3, 2, 2, 2,
        142, 145, 3, 2, 2, 2, 143, 141, 3, 2, 2, 2, 143, 144, 3, 2, 2, 2, 144,
        50, 3, 2, 2, 2, 145, 143, 3, 2, 2, 2, 146, 151, 7, 36, 2, 2, 147, 150,
        5, 53, 27, 2, 148, 150, 5, 59, 30, 2, 149, 147, 3, 2, 2, 2, 149, 148, 3,
        2, 2, 2, 150, 153, 3, 2, 2, 2, 151, 149, 3, 2, 2, 2, 151, 152, 3, 2, 2,
        2, 152, 154, 3, 2, 2, 2, 153, 151, 3, 2, 2, 2, 154, 155, 7, 36, 2, 2, 155,
        52, 3, 2, 2, 2, 156, 159, 7, 94, 2, 2, 157, 160, 9, 4, 2, 2, 158, 160,
        5, 55, 28, 2, 159, 157, 3, 2, 2, 2, 159, 158, 3, 2, 2, 2, 160, 54, 3, 2,
        2, 2, 161, 162, 7, 119, 2, 2, 162, 163, 5, 57, 29, 2, 163, 164, 5, 57,
        29, 2, 164, 165, 5, 57, 29, 2, 165, 166, 5, 57, 29, 2, 166, 56, 3, 2, 2,
        2, 167, 168, 9, 5, 2, 2, 168, 58, 3, 2, 2, 2, 169, 170, 10, 6, 2, 2, 170,
        60, 3, 2, 2, 2, 171, 173, 9, 7, 2, 2, 172, 171, 3, 2, 2, 2, 172, 173, 3,
        2, 2, 2, 173, 174, 3, 2, 2, 2, 174, 181, 5, 63, 32, 2, 175, 177, 7, 48,
        2, 2, 176, 178, 9, 8, 2, 2, 177, 176, 3, 2, 2, 2, 178, 179, 3, 2, 2, 2,
        179, 177, 3, 2, 2, 2, 179, 180, 3, 2, 2, 2, 180, 182, 3, 2, 2, 2, 181,
        175, 3, 2, 2, 2, 181, 182, 3, 2, 2, 2, 182, 184, 3, 2, 2, 2, 183, 185,
        5, 65, 33, 2, 184, 183, 3, 2, 2, 2, 184, 185, 3, 2, 2, 2, 185, 62, 3, 2,
        2, 2, 186, 195, 7, 50, 2, 2, 187, 191, 9, 9, 2, 2, 188, 190, 9, 8, 2, 2,
        189, 188, 3, 2, 2, 2, 190, 193, 3, 2, 2, 2, 191, 189, 3, 2, 2, 2, 191,
        192, 3, 2, 2, 2, 192, 195, 3, 2, 2, 2, 193, 191, 3, 2, 2, 2, 194, 186,
        3, 2, 2, 2, 194, 187, 3, 2, 2, 2, 195, 64, 3, 2, 2, 2, 196, 198, 9, 10,
        2, 2, 197, 199, 9, 7, 2, 2, 198, 197, 3, 2, 2, 2, 198, 199, 3, 2, 2, 2,
        199, 200, 3, 2, 2, 2, 200, 201, 5, 63, 32, 2, 201, 66, 3, 2, 2, 2, 202,
        204, 9, 11, 2, 2, 203, 202, 3, 2, 2, 2, 204, 205, 3, 2, 2, 2, 205, 203,
        3, 2, 2, 2, 205, 206, 3, 2, 2, 2, 206, 207, 3, 2, 2, 2, 207, 208, 8, 34,
        2, 2, 208, 68, 3, 2, 2, 2, 15, 2, 143, 149, 151, 159, 172, 179, 181, 184,
        191, 194, 198, 205, 3, 8, 2, 2,
}

var lexerChannelNames = []string{
        "DEFAULT_TOKEN_CHANNEL", "HIDDEN",
}

var lexerModeNames = []string{
        "DEFAULT_MODE",
}

var lexerLiteralNames = []string{
        "", "'$.'", "'*'", "'{'", "'}'", "'('", "')'", "'['", "']'", "'.'", "'&amp;&amp;'",
        "'||'", "'='", "'!='", "'&gt;'", "'&lt;'", "'&gt;='", "'&lt;='", "'IS'", "'NOT'", "'NULL'",
        "'EXISTS'", "'TRUE'", "'FALSE'",
}

var lexerSymbolicNames = []string{
        "", "SEL_START", "STAR", "LCURLY", "RCURLY", "LPAREN", "RPAREN", "LBRACKET",
        "RBRACKET", "DOT", "AND", "OR", "EQUALS", "NOT_EQUALS", "GT", "LT", "GE",
        "LE", "IS", "NOT", "NULL", "EXISTS", "TRUE", "FALSE", "INDENTIFIER", "STRING",
        "NUMBER", "WS",
}

var lexerRuleNames = []string{
        "SEL_START", "STAR", "LCURLY", "RCURLY", "LPAREN", "RPAREN", "LBRACKET",
        "RBRACKET", "DOT", "AND", "OR", "EQUALS", "NOT_EQUALS", "GT", "LT", "GE",
        "LE", "IS", "NOT", "NULL", "EXISTS", "TRUE", "FALSE", "INDENTIFIER", "STRING",
        "ESC", "UNICODE", "HEX", "SAFECODEPOINT", "NUMBER", "INT", "EXP", "WS",
}

type JSONFilterLexer struct {
        *antlr.BaseLexer
        channelNames []string
        modeNames    []string
        // TODO: EOF string
}

// NewJSONFilterLexer produces a new lexer instance for the optional input antlr.CharStream.
//
// The *JSONFilterLexer instance produced may be reused by calling the SetInputStream method.
// The initial lexer configuration is expensive to construct, and the object is not thread-safe;
// however, if used within a Golang sync.Pool, the construction cost amortizes well and the
// objects can be used in a thread-safe manner.
func NewJSONFilterLexer(input antlr.CharStream) *JSONFilterLexer <span class="cov0" title="0">{
        l := new(JSONFilterLexer)
        lexerDeserializer := antlr.NewATNDeserializer(nil)
        lexerAtn := lexerDeserializer.DeserializeFromUInt16(serializedLexerAtn)
        lexerDecisionToDFA := make([]*antlr.DFA, len(lexerAtn.DecisionToState))
        for index, ds := range lexerAtn.DecisionToState </span><span class="cov0" title="0">{
                lexerDecisionToDFA[index] = antlr.NewDFA(ds, index)
        }</span>
        <span class="cov0" title="0">l.BaseLexer = antlr.NewBaseLexer(input)
        l.Interpreter = antlr.NewLexerATNSimulator(l, lexerAtn, lexerDecisionToDFA, antlr.NewPredictionContextCache())

        l.channelNames = lexerChannelNames
        l.modeNames = lexerModeNames
        l.RuleNames = lexerRuleNames
        l.LiteralNames = lexerLiteralNames
        l.SymbolicNames = lexerSymbolicNames
        l.GrammarFileName = "JSONFilter.g4"
        // TODO: l.EOF = antlr.TokenEOF

        return l</span>
}

// JSONFilterLexer tokens.
const (
        JSONFilterLexerSEL_START   = 1
        JSONFilterLexerSTAR        = 2
        JSONFilterLexerLCURLY      = 3
        JSONFilterLexerRCURLY      = 4
        JSONFilterLexerLPAREN      = 5
        JSONFilterLexerRPAREN      = 6
        JSONFilterLexerLBRACKET    = 7
        JSONFilterLexerRBRACKET    = 8
        JSONFilterLexerDOT         = 9
        JSONFilterLexerAND         = 10
        JSONFilterLexerOR          = 11
        JSONFilterLexerEQUALS      = 12
        JSONFilterLexerNOT_EQUALS  = 13
        JSONFilterLexerGT          = 14
        JSONFilterLexerLT          = 15
        JSONFilterLexerGE          = 16
        JSONFilterLexerLE          = 17
        JSONFilterLexerIS          = 18
        JSONFilterLexerNOT         = 19
        JSONFilterLexerNULL        = 20
        JSONFilterLexerEXISTS      = 21
        JSONFilterLexerTRUE        = 22
        JSONFilterLexerFALSE       = 23
        JSONFilterLexerINDENTIFIER = 24
        JSONFilterLexerSTRING      = 25
        JSONFilterLexerNUMBER      = 26
        JSONFilterLexerWS          = 27
)
</pre>
		
		<pre class="file" id="file67" style="display: none">// Code generated from JSONFilter.g4 by ANTLR 4.9.2. DO NOT EDIT.

package parser // JSONFilter

import (
        "fmt"
        "reflect"
        "strconv"

        "github.com/antlr/antlr4/runtime/Go/antlr"
)

// Suppress unused import errors
var _ = fmt.Printf
var _ = reflect.Copy
var _ = strconv.Itoa

var parserATN = []uint16{
        3, 24715, 42794, 33075, 47597, 16764, 15335, 30598, 22884, 3, 29, 92, 4,
        2, 9, 2, 4, 3, 9, 3, 4, 4, 9, 4, 4, 5, 9, 5, 4, 6, 9, 6, 4, 7, 9, 7, 4,
        8, 9, 8, 4, 9, 9, 9, 4, 10, 9, 10, 3, 2, 3, 2, 3, 3, 3, 3, 3, 3, 3, 3,
        3, 4, 3, 4, 3, 4, 3, 4, 3, 4, 3, 4, 5, 4, 33, 10, 4, 3, 4, 3, 4, 3, 4,
        3, 4, 3, 4, 3, 4, 7, 4, 41, 10, 4, 12, 4, 14, 4, 44, 11, 4, 3, 5, 3, 5,
        3, 5, 3, 5, 5, 5, 50, 10, 5, 3, 6, 3, 6, 3, 6, 3, 7, 3, 7, 3, 7, 7, 7,
        58, 10, 7, 12, 7, 14, 7, 61, 11, 7, 3, 8, 3, 8, 3, 8, 3, 8, 3, 8, 6, 8,
        68, 10, 8, 13, 8, 14, 8, 69, 5, 8, 72, 10, 8, 3, 9, 3, 9, 3, 10, 3, 10,
        3, 10, 6, 10, 79, 10, 10, 13, 10, 14, 10, 80, 3, 10, 3, 10, 3, 10, 3, 10,
        3, 10, 3, 10, 3, 10, 5, 10, 90, 10, 10, 3, 10, 2, 3, 6, 11, 2, 4, 6, 8,
        10, 12, 14, 16, 18, 2, 4, 3, 2, 14, 21, 4, 2, 4, 4, 28, 28, 2, 97, 2, 20,
        3, 2, 2, 2, 4, 22, 3, 2, 2, 2, 6, 32, 3, 2, 2, 2, 8, 45, 3, 2, 2, 2, 10,
        51, 3, 2, 2, 2, 12, 54, 3, 2, 2, 2, 14, 71, 3, 2, 2, 2, 16, 73, 3, 2, 2,
        2, 18, 89, 3, 2, 2, 2, 20, 21, 5, 4, 3, 2, 21, 3, 3, 2, 2, 2, 22, 23, 7,
        5, 2, 2, 23, 24, 5, 6, 4, 2, 24, 25, 7, 6, 2, 2, 25, 5, 3, 2, 2, 2, 26,
        27, 8, 4, 1, 2, 27, 28, 7, 7, 2, 2, 28, 29, 5, 6, 4, 2, 29, 30, 7, 8, 2,
        2, 30, 33, 3, 2, 2, 2, 31, 33, 5, 8, 5, 2, 32, 26, 3, 2, 2, 2, 32, 31,
        3, 2, 2, 2, 33, 42, 3, 2, 2, 2, 34, 35, 12, 5, 2, 2, 35, 36, 7, 12, 2,
        2, 36, 41, 5, 6, 4, 6, 37, 38, 12, 4, 2, 2, 38, 39, 7, 13, 2, 2, 39, 41,
        5, 6, 4, 5, 40, 34, 3, 2, 2, 2, 40, 37, 3, 2, 2, 2, 41, 44, 3, 2, 2, 2,
        42, 40, 3, 2, 2, 2, 42, 43, 3, 2, 2, 2, 43, 7, 3, 2, 2, 2, 44, 42, 3, 2,
        2, 2, 45, 46, 5, 10, 6, 2, 46, 49, 5, 16, 9, 2, 47, 50, 5, 18, 10, 2, 48,
        50, 5, 12, 7, 2, 49, 47, 3, 2, 2, 2, 49, 48, 3, 2, 2, 2, 50, 9, 3, 2, 2,
        2, 51, 52, 7, 3, 2, 2, 52, 53, 5, 12, 7, 2, 53, 11, 3, 2, 2, 2, 54, 59,
        5, 14, 8, 2, 55, 56, 7, 11, 2, 2, 56, 58, 5, 14, 8, 2, 57, 55, 3, 2, 2,
        2, 58, 61, 3, 2, 2, 2, 59, 57, 3, 2, 2, 2, 59, 60, 3, 2, 2, 2, 60, 13,
        3, 2, 2, 2, 61, 59, 3, 2, 2, 2, 62, 72, 7, 26, 2, 2, 63, 67, 7, 26, 2,
        2, 64, 65, 7, 9, 2, 2, 65, 66, 7, 28, 2, 2, 66, 68, 7, 10, 2, 2, 67, 64,
        3, 2, 2, 2, 68, 69, 3, 2, 2, 2, 69, 67, 3, 2, 2, 2, 69, 70, 3, 2, 2, 2,
        70, 72, 3, 2, 2, 2, 71, 62, 3, 2, 2, 2, 71, 63, 3, 2, 2, 2, 72, 15, 3,
        2, 2, 2, 73, 74, 9, 2, 2, 2, 74, 17, 3, 2, 2, 2, 75, 78, 7, 28, 2, 2, 76,
        77, 7, 11, 2, 2, 77, 79, 9, 3, 2, 2, 78, 76, 3, 2, 2, 2, 79, 80, 3, 2,
        2, 2, 80, 78, 3, 2, 2, 2, 80, 81, 3, 2, 2, 2, 81, 90, 3, 2, 2, 2, 82, 90,
        7, 27, 2, 2, 83, 90, 7, 28, 2, 2, 84, 90, 7, 22, 2, 2, 85, 90, 7, 23, 2,
        2, 86, 90, 7, 24, 2, 2, 87, 90, 7, 25, 2, 2, 88, 90, 7, 26, 2, 2, 89, 75,
        3, 2, 2, 2, 89, 82, 3, 2, 2, 2, 89, 83, 3, 2, 2, 2, 89, 84, 3, 2, 2, 2,
        89, 85, 3, 2, 2, 2, 89, 86, 3, 2, 2, 2, 89, 87, 3, 2, 2, 2, 89, 88, 3,
        2, 2, 2, 90, 19, 3, 2, 2, 2, 11, 32, 40, 42, 49, 59, 69, 71, 80, 89,
}
var literalNames = []string{
        "", "'$.'", "'*'", "'{'", "'}'", "'('", "')'", "'['", "']'", "'.'", "'&amp;&amp;'",
        "'||'", "'='", "'!='", "'&gt;'", "'&lt;'", "'&gt;='", "'&lt;='", "'IS'", "'NOT'", "'NULL'",
        "'EXISTS'", "'TRUE'", "'FALSE'",
}
var symbolicNames = []string{
        "", "SEL_START", "STAR", "LCURLY", "RCURLY", "LPAREN", "RPAREN", "LBRACKET",
        "RBRACKET", "DOT", "AND", "OR", "EQUALS", "NOT_EQUALS", "GT", "LT", "GE",
        "LE", "IS", "NOT", "NULL", "EXISTS", "TRUE", "FALSE", "INDENTIFIER", "STRING",
        "NUMBER", "WS",
}

var ruleNames = []string{
        "awsjsonfilter", "dotnotation", "filter_expr", "exp", "selector", "qualifiedidentifier",
        "member", "operator", "literal",
}

type JSONFilterParser struct {
        *antlr.BaseParser
}

// NewJSONFilterParser produces a new parser instance for the optional input antlr.TokenStream.
//
// The *JSONFilterParser instance produced may be reused by calling the SetInputStream method.
// The initial parser configuration is expensive to construct, and the object is not thread-safe;
// however, if used within a Golang sync.Pool, the construction cost amortizes well and the
// objects can be used in a thread-safe manner.
func NewJSONFilterParser(input antlr.TokenStream) *JSONFilterParser <span class="cov0" title="0">{
        this := new(JSONFilterParser)
        deserializer := antlr.NewATNDeserializer(nil)
        deserializedATN := deserializer.DeserializeFromUInt16(parserATN)
        decisionToDFA := make([]*antlr.DFA, len(deserializedATN.DecisionToState))
        for index, ds := range deserializedATN.DecisionToState </span><span class="cov0" title="0">{
                decisionToDFA[index] = antlr.NewDFA(ds, index)
        }</span>
        <span class="cov0" title="0">this.BaseParser = antlr.NewBaseParser(input)

        this.Interpreter = antlr.NewParserATNSimulator(this, deserializedATN, decisionToDFA, antlr.NewPredictionContextCache())
        this.RuleNames = ruleNames
        this.LiteralNames = literalNames
        this.SymbolicNames = symbolicNames
        this.GrammarFileName = "JSONFilter.g4"

        return this</span>
}

// JSONFilterParser tokens.
const (
        JSONFilterParserEOF         = antlr.TokenEOF
        JSONFilterParserSEL_START   = 1
        JSONFilterParserSTAR        = 2
        JSONFilterParserLCURLY      = 3
        JSONFilterParserRCURLY      = 4
        JSONFilterParserLPAREN      = 5
        JSONFilterParserRPAREN      = 6
        JSONFilterParserLBRACKET    = 7
        JSONFilterParserRBRACKET    = 8
        JSONFilterParserDOT         = 9
        JSONFilterParserAND         = 10
        JSONFilterParserOR          = 11
        JSONFilterParserEQUALS      = 12
        JSONFilterParserNOT_EQUALS  = 13
        JSONFilterParserGT          = 14
        JSONFilterParserLT          = 15
        JSONFilterParserGE          = 16
        JSONFilterParserLE          = 17
        JSONFilterParserIS          = 18
        JSONFilterParserNOT         = 19
        JSONFilterParserNULL        = 20
        JSONFilterParserEXISTS      = 21
        JSONFilterParserTRUE        = 22
        JSONFilterParserFALSE       = 23
        JSONFilterParserINDENTIFIER = 24
        JSONFilterParserSTRING      = 25
        JSONFilterParserNUMBER      = 26
        JSONFilterParserWS          = 27
)

// JSONFilterParser rules.
const (
        JSONFilterParserRULE_awsjsonfilter       = 0
        JSONFilterParserRULE_dotnotation         = 1
        JSONFilterParserRULE_filter_expr         = 2
        JSONFilterParserRULE_exp                 = 3
        JSONFilterParserRULE_selector            = 4
        JSONFilterParserRULE_qualifiedidentifier = 5
        JSONFilterParserRULE_member              = 6
        JSONFilterParserRULE_operator            = 7
        JSONFilterParserRULE_literal             = 8
)

// IAwsjsonfilterContext is an interface to support dynamic dispatch.
type IAwsjsonfilterContext interface {
        antlr.ParserRuleContext

        // GetParser returns the parser.
        GetParser() antlr.Parser

        // IsAwsjsonfilterContext differentiates from other interfaces.
        IsAwsjsonfilterContext()
}

type AwsjsonfilterContext struct {
        *antlr.BaseParserRuleContext
        parser antlr.Parser
}

func NewEmptyAwsjsonfilterContext() *AwsjsonfilterContext <span class="cov0" title="0">{
        var p = new(AwsjsonfilterContext)
        p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
        p.RuleIndex = JSONFilterParserRULE_awsjsonfilter
        return p
}</span>

func (*AwsjsonfilterContext) IsAwsjsonfilterContext() {<span class="cov0" title="0">}</span>

func NewAwsjsonfilterContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *AwsjsonfilterContext <span class="cov0" title="0">{
        var p = new(AwsjsonfilterContext)

        p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

        p.parser = parser
        p.RuleIndex = JSONFilterParserRULE_awsjsonfilter

        return p
}</span>

func (s *AwsjsonfilterContext) GetParser() antlr.Parser <span class="cov0" title="0">{ return s.parser }</span>

func (s *AwsjsonfilterContext) Dotnotation() IDotnotationContext <span class="cov0" title="0">{
        var t = s.GetTypedRuleContext(reflect.TypeOf((*IDotnotationContext)(nil)).Elem(), 0)

        if t == nil </span><span class="cov0" title="0">{
                return nil
        }</span>

        <span class="cov0" title="0">return t.(IDotnotationContext)</span>
}

func (s *AwsjsonfilterContext) GetRuleContext() antlr.RuleContext <span class="cov0" title="0">{
        return s
}</span>

func (s *AwsjsonfilterContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string <span class="cov0" title="0">{
        return antlr.TreesStringTree(s, ruleNames, recog)
}</span>

func (s *AwsjsonfilterContext) Accept(visitor antlr.ParseTreeVisitor) interface{} <span class="cov0" title="0">{
        switch t := visitor.(type) </span>{
        case JSONFilterVisitor:<span class="cov0" title="0">
                return t.VisitAwsjsonfilter(s)</span>

        default:<span class="cov0" title="0">
                return t.VisitChildren(s)</span>
        }
}

func (p *JSONFilterParser) Awsjsonfilter() (localctx IAwsjsonfilterContext) <span class="cov0" title="0">{
        localctx = NewAwsjsonfilterContext(p, p.GetParserRuleContext(), p.GetState())
        p.EnterRule(localctx, 0, JSONFilterParserRULE_awsjsonfilter)

        defer func() </span><span class="cov0" title="0">{
                p.ExitRule()
        }</span>()

        <span class="cov0" title="0">defer func() </span><span class="cov0" title="0">{
                if err := recover(); err != nil </span><span class="cov0" title="0">{
                        if v, ok := err.(antlr.RecognitionException); ok </span><span class="cov0" title="0">{
                                localctx.SetException(v)
                                p.GetErrorHandler().ReportError(p, v)
                                p.GetErrorHandler().Recover(p, v)
                        }</span> else<span class="cov0" title="0"> {
                                panic(err)</span>
                        }
                }
        }()

        <span class="cov0" title="0">p.EnterOuterAlt(localctx, 1)
        </span><span class="cov0" title="0">{
                p.SetState(18)
                p.Dotnotation()
        }</span>

        <span class="cov0" title="0">return localctx</span>
}

// IDotnotationContext is an interface to support dynamic dispatch.
type IDotnotationContext interface {
        antlr.ParserRuleContext

        // GetParser returns the parser.
        GetParser() antlr.Parser

        // IsDotnotationContext differentiates from other interfaces.
        IsDotnotationContext()
}

type DotnotationContext struct {
        *antlr.BaseParserRuleContext
        parser antlr.Parser
}

func NewEmptyDotnotationContext() *DotnotationContext <span class="cov0" title="0">{
        var p = new(DotnotationContext)
        p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
        p.RuleIndex = JSONFilterParserRULE_dotnotation
        return p
}</span>

func (*DotnotationContext) IsDotnotationContext() {<span class="cov0" title="0">}</span>

func NewDotnotationContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *DotnotationContext <span class="cov0" title="0">{
        var p = new(DotnotationContext)

        p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

        p.parser = parser
        p.RuleIndex = JSONFilterParserRULE_dotnotation

        return p
}</span>

func (s *DotnotationContext) GetParser() antlr.Parser <span class="cov0" title="0">{ return s.parser }</span>

func (s *DotnotationContext) LCURLY() antlr.TerminalNode <span class="cov0" title="0">{
        return s.GetToken(JSONFilterParserLCURLY, 0)
}</span>

func (s *DotnotationContext) Filter_expr() IFilter_exprContext <span class="cov0" title="0">{
        var t = s.GetTypedRuleContext(reflect.TypeOf((*IFilter_exprContext)(nil)).Elem(), 0)

        if t == nil </span><span class="cov0" title="0">{
                return nil
        }</span>

        <span class="cov0" title="0">return t.(IFilter_exprContext)</span>
}

func (s *DotnotationContext) RCURLY() antlr.TerminalNode <span class="cov0" title="0">{
        return s.GetToken(JSONFilterParserRCURLY, 0)
}</span>

func (s *DotnotationContext) GetRuleContext() antlr.RuleContext <span class="cov0" title="0">{
        return s
}</span>

func (s *DotnotationContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string <span class="cov0" title="0">{
        return antlr.TreesStringTree(s, ruleNames, recog)
}</span>

func (s *DotnotationContext) Accept(visitor antlr.ParseTreeVisitor) interface{} <span class="cov0" title="0">{
        switch t := visitor.(type) </span>{
        case JSONFilterVisitor:<span class="cov0" title="0">
                return t.VisitDotnotation(s)</span>

        default:<span class="cov0" title="0">
                return t.VisitChildren(s)</span>
        }
}

func (p *JSONFilterParser) Dotnotation() (localctx IDotnotationContext) <span class="cov0" title="0">{
        localctx = NewDotnotationContext(p, p.GetParserRuleContext(), p.GetState())
        p.EnterRule(localctx, 2, JSONFilterParserRULE_dotnotation)

        defer func() </span><span class="cov0" title="0">{
                p.ExitRule()
        }</span>()

        <span class="cov0" title="0">defer func() </span><span class="cov0" title="0">{
                if err := recover(); err != nil </span><span class="cov0" title="0">{
                        if v, ok := err.(antlr.RecognitionException); ok </span><span class="cov0" title="0">{
                                localctx.SetException(v)
                                p.GetErrorHandler().ReportError(p, v)
                                p.GetErrorHandler().Recover(p, v)
                        }</span> else<span class="cov0" title="0"> {
                                panic(err)</span>
                        }
                }
        }()

        <span class="cov0" title="0">p.EnterOuterAlt(localctx, 1)
        </span><span class="cov0" title="0">{
                p.SetState(20)
                p.Match(JSONFilterParserLCURLY)
        }</span>
        <span class="cov0" title="0">{
                p.SetState(21)
                p.filter_expr(0)
        }</span>
        <span class="cov0" title="0">{
                p.SetState(22)
                p.Match(JSONFilterParserRCURLY)
        }</span>

        <span class="cov0" title="0">return localctx</span>
}

// IFilter_exprContext is an interface to support dynamic dispatch.
type IFilter_exprContext interface {
        antlr.ParserRuleContext

        // GetParser returns the parser.
        GetParser() antlr.Parser

        // IsFilter_exprContext differentiates from other interfaces.
        IsFilter_exprContext()
}

type Filter_exprContext struct {
        *antlr.BaseParserRuleContext
        parser antlr.Parser
}

func NewEmptyFilter_exprContext() *Filter_exprContext <span class="cov0" title="0">{
        var p = new(Filter_exprContext)
        p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
        p.RuleIndex = JSONFilterParserRULE_filter_expr
        return p
}</span>

func (*Filter_exprContext) IsFilter_exprContext() {<span class="cov0" title="0">}</span>

func NewFilter_exprContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Filter_exprContext <span class="cov0" title="0">{
        var p = new(Filter_exprContext)

        p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

        p.parser = parser
        p.RuleIndex = JSONFilterParserRULE_filter_expr

        return p
}</span>

func (s *Filter_exprContext) GetParser() antlr.Parser <span class="cov0" title="0">{ return s.parser }</span>

func (s *Filter_exprContext) CopyFrom(ctx *Filter_exprContext) <span class="cov0" title="0">{
        s.BaseParserRuleContext.CopyFrom(ctx.BaseParserRuleContext)
}</span>

func (s *Filter_exprContext) GetRuleContext() antlr.RuleContext <span class="cov0" title="0">{
        return s
}</span>

func (s *Filter_exprContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string <span class="cov0" title="0">{
        return antlr.TreesStringTree(s, ruleNames, recog)
}</span>

type Filter_expr_parenthesizedContext struct {
        *Filter_exprContext
}

func NewFilter_expr_parenthesizedContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *Filter_expr_parenthesizedContext <span class="cov0" title="0">{
        var p = new(Filter_expr_parenthesizedContext)

        p.Filter_exprContext = NewEmptyFilter_exprContext()
        p.parser = parser
        p.CopyFrom(ctx.(*Filter_exprContext))

        return p
}</span>

func (s *Filter_expr_parenthesizedContext) GetRuleContext() antlr.RuleContext <span class="cov0" title="0">{
        return s
}</span>

func (s *Filter_expr_parenthesizedContext) LPAREN() antlr.TerminalNode <span class="cov0" title="0">{
        return s.GetToken(JSONFilterParserLPAREN, 0)
}</span>

func (s *Filter_expr_parenthesizedContext) Filter_expr() IFilter_exprContext <span class="cov0" title="0">{
        var t = s.GetTypedRuleContext(reflect.TypeOf((*IFilter_exprContext)(nil)).Elem(), 0)

        if t == nil </span><span class="cov0" title="0">{
                return nil
        }</span>

        <span class="cov0" title="0">return t.(IFilter_exprContext)</span>
}

func (s *Filter_expr_parenthesizedContext) RPAREN() antlr.TerminalNode <span class="cov0" title="0">{
        return s.GetToken(JSONFilterParserRPAREN, 0)
}</span>

func (s *Filter_expr_parenthesizedContext) Accept(visitor antlr.ParseTreeVisitor) interface{} <span class="cov0" title="0">{
        switch t := visitor.(type) </span>{
        case JSONFilterVisitor:<span class="cov0" title="0">
                return t.VisitFilter_expr_parenthesized(s)</span>

        default:<span class="cov0" title="0">
                return t.VisitChildren(s)</span>
        }
}

type Filter_expr_andContext struct {
        *Filter_exprContext
        lhs IFilter_exprContext
        rhs IFilter_exprContext
}

func NewFilter_expr_andContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *Filter_expr_andContext <span class="cov0" title="0">{
        var p = new(Filter_expr_andContext)

        p.Filter_exprContext = NewEmptyFilter_exprContext()
        p.parser = parser
        p.CopyFrom(ctx.(*Filter_exprContext))

        return p
}</span>

func (s *Filter_expr_andContext) GetLhs() IFilter_exprContext <span class="cov0" title="0">{ return s.lhs }</span>

func (s *Filter_expr_andContext) GetRhs() IFilter_exprContext <span class="cov0" title="0">{ return s.rhs }</span>

func (s *Filter_expr_andContext) SetLhs(v IFilter_exprContext) <span class="cov0" title="0">{ s.lhs = v }</span>

func (s *Filter_expr_andContext) SetRhs(v IFilter_exprContext) <span class="cov0" title="0">{ s.rhs = v }</span>

func (s *Filter_expr_andContext) GetRuleContext() antlr.RuleContext <span class="cov0" title="0">{
        return s
}</span>

func (s *Filter_expr_andContext) AND() antlr.TerminalNode <span class="cov0" title="0">{
        return s.GetToken(JSONFilterParserAND, 0)
}</span>

func (s *Filter_expr_andContext) AllFilter_expr() []IFilter_exprContext <span class="cov0" title="0">{
        var ts = s.GetTypedRuleContexts(reflect.TypeOf((*IFilter_exprContext)(nil)).Elem())
        var tst = make([]IFilter_exprContext, len(ts))

        for i, t := range ts </span><span class="cov0" title="0">{
                if t != nil </span><span class="cov0" title="0">{
                        tst[i] = t.(IFilter_exprContext)
                }</span>
        }

        <span class="cov0" title="0">return tst</span>
}

func (s *Filter_expr_andContext) Filter_expr(i int) IFilter_exprContext <span class="cov0" title="0">{
        var t = s.GetTypedRuleContext(reflect.TypeOf((*IFilter_exprContext)(nil)).Elem(), i)

        if t == nil </span><span class="cov0" title="0">{
                return nil
        }</span>

        <span class="cov0" title="0">return t.(IFilter_exprContext)</span>
}

func (s *Filter_expr_andContext) Accept(visitor antlr.ParseTreeVisitor) interface{} <span class="cov0" title="0">{
        switch t := visitor.(type) </span>{
        case JSONFilterVisitor:<span class="cov0" title="0">
                return t.VisitFilter_expr_and(s)</span>

        default:<span class="cov0" title="0">
                return t.VisitChildren(s)</span>
        }
}

type Filter_expr_expContext struct {
        *Filter_exprContext
}

func NewFilter_expr_expContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *Filter_expr_expContext <span class="cov0" title="0">{
        var p = new(Filter_expr_expContext)

        p.Filter_exprContext = NewEmptyFilter_exprContext()
        p.parser = parser
        p.CopyFrom(ctx.(*Filter_exprContext))

        return p
}</span>

func (s *Filter_expr_expContext) GetRuleContext() antlr.RuleContext <span class="cov0" title="0">{
        return s
}</span>

func (s *Filter_expr_expContext) Exp() IExpContext <span class="cov0" title="0">{
        var t = s.GetTypedRuleContext(reflect.TypeOf((*IExpContext)(nil)).Elem(), 0)

        if t == nil </span><span class="cov0" title="0">{
                return nil
        }</span>

        <span class="cov0" title="0">return t.(IExpContext)</span>
}

func (s *Filter_expr_expContext) Accept(visitor antlr.ParseTreeVisitor) interface{} <span class="cov0" title="0">{
        switch t := visitor.(type) </span>{
        case JSONFilterVisitor:<span class="cov0" title="0">
                return t.VisitFilter_expr_exp(s)</span>

        default:<span class="cov0" title="0">
                return t.VisitChildren(s)</span>
        }
}

type Filter_expr_orContext struct {
        *Filter_exprContext
        lhs IFilter_exprContext
        rhs IFilter_exprContext
}

func NewFilter_expr_orContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *Filter_expr_orContext <span class="cov0" title="0">{
        var p = new(Filter_expr_orContext)

        p.Filter_exprContext = NewEmptyFilter_exprContext()
        p.parser = parser
        p.CopyFrom(ctx.(*Filter_exprContext))

        return p
}</span>

func (s *Filter_expr_orContext) GetLhs() IFilter_exprContext <span class="cov0" title="0">{ return s.lhs }</span>

func (s *Filter_expr_orContext) GetRhs() IFilter_exprContext <span class="cov0" title="0">{ return s.rhs }</span>

func (s *Filter_expr_orContext) SetLhs(v IFilter_exprContext) <span class="cov0" title="0">{ s.lhs = v }</span>

func (s *Filter_expr_orContext) SetRhs(v IFilter_exprContext) <span class="cov0" title="0">{ s.rhs = v }</span>

func (s *Filter_expr_orContext) GetRuleContext() antlr.RuleContext <span class="cov0" title="0">{
        return s
}</span>

func (s *Filter_expr_orContext) OR() antlr.TerminalNode <span class="cov0" title="0">{
        return s.GetToken(JSONFilterParserOR, 0)
}</span>

func (s *Filter_expr_orContext) AllFilter_expr() []IFilter_exprContext <span class="cov0" title="0">{
        var ts = s.GetTypedRuleContexts(reflect.TypeOf((*IFilter_exprContext)(nil)).Elem())
        var tst = make([]IFilter_exprContext, len(ts))

        for i, t := range ts </span><span class="cov0" title="0">{
                if t != nil </span><span class="cov0" title="0">{
                        tst[i] = t.(IFilter_exprContext)
                }</span>
        }

        <span class="cov0" title="0">return tst</span>
}

func (s *Filter_expr_orContext) Filter_expr(i int) IFilter_exprContext <span class="cov0" title="0">{
        var t = s.GetTypedRuleContext(reflect.TypeOf((*IFilter_exprContext)(nil)).Elem(), i)

        if t == nil </span><span class="cov0" title="0">{
                return nil
        }</span>

        <span class="cov0" title="0">return t.(IFilter_exprContext)</span>
}

func (s *Filter_expr_orContext) Accept(visitor antlr.ParseTreeVisitor) interface{} <span class="cov0" title="0">{
        switch t := visitor.(type) </span>{
        case JSONFilterVisitor:<span class="cov0" title="0">
                return t.VisitFilter_expr_or(s)</span>

        default:<span class="cov0" title="0">
                return t.VisitChildren(s)</span>
        }
}

func (p *JSONFilterParser) Filter_expr() (localctx IFilter_exprContext) <span class="cov0" title="0">{
        return p.filter_expr(0)
}</span>

func (p *JSONFilterParser) filter_expr(_p int) (localctx IFilter_exprContext) <span class="cov0" title="0">{
        var _parentctx antlr.ParserRuleContext = p.GetParserRuleContext()
        _parentState := p.GetState()
        localctx = NewFilter_exprContext(p, p.GetParserRuleContext(), _parentState)
        var _prevctx IFilter_exprContext = localctx
        var _ antlr.ParserRuleContext = _prevctx // TODO: To prevent unused variable warning.
        _startState := 4
        p.EnterRecursionRule(localctx, 4, JSONFilterParserRULE_filter_expr, _p)

        defer func() </span><span class="cov0" title="0">{
                p.UnrollRecursionContexts(_parentctx)
        }</span>()

        <span class="cov0" title="0">defer func() </span><span class="cov0" title="0">{
                if err := recover(); err != nil </span><span class="cov0" title="0">{
                        if v, ok := err.(antlr.RecognitionException); ok </span><span class="cov0" title="0">{
                                localctx.SetException(v)
                                p.GetErrorHandler().ReportError(p, v)
                                p.GetErrorHandler().Recover(p, v)
                        }</span> else<span class="cov0" title="0"> {
                                panic(err)</span>
                        }
                }
        }()

        <span class="cov0" title="0">var _alt int

        p.EnterOuterAlt(localctx, 1)
        p.SetState(30)
        p.GetErrorHandler().Sync(p)

        switch p.GetTokenStream().LA(1) </span>{
        case JSONFilterParserLPAREN:<span class="cov0" title="0">
                localctx = NewFilter_expr_parenthesizedContext(p, localctx)
                p.SetParserRuleContext(localctx)
                _prevctx = localctx

                </span><span class="cov0" title="0">{
                        p.SetState(25)
                        p.Match(JSONFilterParserLPAREN)
                }</span>
                <span class="cov0" title="0">{
                        p.SetState(26)
                        p.filter_expr(0)
                }</span>
                <span class="cov0" title="0">{
                        p.SetState(27)
                        p.Match(JSONFilterParserRPAREN)
                }</span>

        case JSONFilterParserSEL_START:<span class="cov0" title="0">
                localctx = NewFilter_expr_expContext(p, localctx)
                p.SetParserRuleContext(localctx)
                _prevctx = localctx
                </span><span class="cov0" title="0">{
                        p.SetState(29)
                        p.Exp()
                }</span>

        default:<span class="cov0" title="0">
                panic(antlr.NewNoViableAltException(p, nil, nil, nil, nil, nil))</span>
        }
        <span class="cov0" title="0">p.GetParserRuleContext().SetStop(p.GetTokenStream().LT(-1))
        p.SetState(40)
        p.GetErrorHandler().Sync(p)
        _alt = p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 2, p.GetParserRuleContext())

        for _alt != 2 &amp;&amp; _alt != antlr.ATNInvalidAltNumber </span><span class="cov0" title="0">{
                if _alt == 1 </span><span class="cov0" title="0">{
                        if p.GetParseListeners() != nil </span><span class="cov0" title="0">{
                                p.TriggerExitRuleEvent()
                        }</span>
                        <span class="cov0" title="0">_prevctx = localctx
                        p.SetState(38)
                        p.GetErrorHandler().Sync(p)
                        switch p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 1, p.GetParserRuleContext()) </span>{
                        case 1:<span class="cov0" title="0">
                                localctx = NewFilter_expr_andContext(p, NewFilter_exprContext(p, _parentctx, _parentState))
                                localctx.(*Filter_expr_andContext).lhs = _prevctx

                                p.PushNewRecursionContext(localctx, _startState, JSONFilterParserRULE_filter_expr)
                                p.SetState(32)

                                if !(p.Precpred(p.GetParserRuleContext(), 3)) </span><span class="cov0" title="0">{
                                        panic(antlr.NewFailedPredicateException(p, "p.Precpred(p.GetParserRuleContext(), 3)", ""))</span>
                                }
                                <span class="cov0" title="0">{
                                        p.SetState(33)
                                        p.Match(JSONFilterParserAND)
                                }</span>
                                <span class="cov0" title="0">{
                                        p.SetState(34)

                                        var _x = p.filter_expr(4)

                                        localctx.(*Filter_expr_andContext).rhs = _x
                                }</span>

                        case 2:<span class="cov0" title="0">
                                localctx = NewFilter_expr_orContext(p, NewFilter_exprContext(p, _parentctx, _parentState))
                                localctx.(*Filter_expr_orContext).lhs = _prevctx

                                p.PushNewRecursionContext(localctx, _startState, JSONFilterParserRULE_filter_expr)
                                p.SetState(35)

                                if !(p.Precpred(p.GetParserRuleContext(), 2)) </span><span class="cov0" title="0">{
                                        panic(antlr.NewFailedPredicateException(p, "p.Precpred(p.GetParserRuleContext(), 2)", ""))</span>
                                }
                                <span class="cov0" title="0">{
                                        p.SetState(36)
                                        p.Match(JSONFilterParserOR)
                                }</span>
                                <span class="cov0" title="0">{
                                        p.SetState(37)

                                        var _x = p.filter_expr(3)

                                        localctx.(*Filter_expr_orContext).rhs = _x
                                }</span>

                        }

                }
                <span class="cov0" title="0">p.SetState(42)
                p.GetErrorHandler().Sync(p)
                _alt = p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 2, p.GetParserRuleContext())</span>
        }

        <span class="cov0" title="0">return localctx</span>
}

// IExpContext is an interface to support dynamic dispatch.
type IExpContext interface {
        antlr.ParserRuleContext

        // GetParser returns the parser.
        GetParser() antlr.Parser

        // IsExpContext differentiates from other interfaces.
        IsExpContext()
}

type ExpContext struct {
        *antlr.BaseParserRuleContext
        parser antlr.Parser
}

func NewEmptyExpContext() *ExpContext <span class="cov0" title="0">{
        var p = new(ExpContext)
        p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
        p.RuleIndex = JSONFilterParserRULE_exp
        return p
}</span>

func (*ExpContext) IsExpContext() {<span class="cov0" title="0">}</span>

func NewExpContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *ExpContext <span class="cov0" title="0">{
        var p = new(ExpContext)

        p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

        p.parser = parser
        p.RuleIndex = JSONFilterParserRULE_exp

        return p
}</span>

func (s *ExpContext) GetParser() antlr.Parser <span class="cov0" title="0">{ return s.parser }</span>

func (s *ExpContext) Selector() ISelectorContext <span class="cov0" title="0">{
        var t = s.GetTypedRuleContext(reflect.TypeOf((*ISelectorContext)(nil)).Elem(), 0)

        if t == nil </span><span class="cov0" title="0">{
                return nil
        }</span>

        <span class="cov0" title="0">return t.(ISelectorContext)</span>
}

func (s *ExpContext) Operator() IOperatorContext <span class="cov0" title="0">{
        var t = s.GetTypedRuleContext(reflect.TypeOf((*IOperatorContext)(nil)).Elem(), 0)

        if t == nil </span><span class="cov0" title="0">{
                return nil
        }</span>

        <span class="cov0" title="0">return t.(IOperatorContext)</span>
}

func (s *ExpContext) Literal() ILiteralContext <span class="cov0" title="0">{
        var t = s.GetTypedRuleContext(reflect.TypeOf((*ILiteralContext)(nil)).Elem(), 0)

        if t == nil </span><span class="cov0" title="0">{
                return nil
        }</span>

        <span class="cov0" title="0">return t.(ILiteralContext)</span>
}

func (s *ExpContext) Qualifiedidentifier() IQualifiedidentifierContext <span class="cov0" title="0">{
        var t = s.GetTypedRuleContext(reflect.TypeOf((*IQualifiedidentifierContext)(nil)).Elem(), 0)

        if t == nil </span><span class="cov0" title="0">{
                return nil
        }</span>

        <span class="cov0" title="0">return t.(IQualifiedidentifierContext)</span>
}

func (s *ExpContext) GetRuleContext() antlr.RuleContext <span class="cov0" title="0">{
        return s
}</span>

func (s *ExpContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string <span class="cov0" title="0">{
        return antlr.TreesStringTree(s, ruleNames, recog)
}</span>

func (s *ExpContext) Accept(visitor antlr.ParseTreeVisitor) interface{} <span class="cov0" title="0">{
        switch t := visitor.(type) </span>{
        case JSONFilterVisitor:<span class="cov0" title="0">
                return t.VisitExp(s)</span>

        default:<span class="cov0" title="0">
                return t.VisitChildren(s)</span>
        }
}

func (p *JSONFilterParser) Exp() (localctx IExpContext) <span class="cov0" title="0">{
        localctx = NewExpContext(p, p.GetParserRuleContext(), p.GetState())
        p.EnterRule(localctx, 6, JSONFilterParserRULE_exp)

        defer func() </span><span class="cov0" title="0">{
                p.ExitRule()
        }</span>()

        <span class="cov0" title="0">defer func() </span><span class="cov0" title="0">{
                if err := recover(); err != nil </span><span class="cov0" title="0">{
                        if v, ok := err.(antlr.RecognitionException); ok </span><span class="cov0" title="0">{
                                localctx.SetException(v)
                                p.GetErrorHandler().ReportError(p, v)
                                p.GetErrorHandler().Recover(p, v)
                        }</span> else<span class="cov0" title="0"> {
                                panic(err)</span>
                        }
                }
        }()

        <span class="cov0" title="0">p.EnterOuterAlt(localctx, 1)
        </span><span class="cov0" title="0">{
                p.SetState(43)
                p.Selector()
        }</span>
        <span class="cov0" title="0">{
                p.SetState(44)
                p.Operator()
        }</span>
        <span class="cov0" title="0">p.SetState(47)
        p.GetErrorHandler().Sync(p)
        switch p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 3, p.GetParserRuleContext()) </span>{
        case 1:<span class="cov0" title="0">
                </span><span class="cov0" title="0">{
                        p.SetState(45)
                        p.Literal()
                }</span>

        case 2:<span class="cov0" title="0">
                </span><span class="cov0" title="0">{
                        p.SetState(46)
                        p.Qualifiedidentifier()
                }</span>

        }

        <span class="cov0" title="0">return localctx</span>
}

// ISelectorContext is an interface to support dynamic dispatch.
type ISelectorContext interface {
        antlr.ParserRuleContext

        // GetParser returns the parser.
        GetParser() antlr.Parser

        // IsSelectorContext differentiates from other interfaces.
        IsSelectorContext()
}

type SelectorContext struct {
        *antlr.BaseParserRuleContext
        parser antlr.Parser
}

func NewEmptySelectorContext() *SelectorContext <span class="cov0" title="0">{
        var p = new(SelectorContext)
        p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
        p.RuleIndex = JSONFilterParserRULE_selector
        return p
}</span>

func (*SelectorContext) IsSelectorContext() {<span class="cov0" title="0">}</span>

func NewSelectorContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *SelectorContext <span class="cov0" title="0">{
        var p = new(SelectorContext)

        p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

        p.parser = parser
        p.RuleIndex = JSONFilterParserRULE_selector

        return p
}</span>

func (s *SelectorContext) GetParser() antlr.Parser <span class="cov0" title="0">{ return s.parser }</span>

func (s *SelectorContext) SEL_START() antlr.TerminalNode <span class="cov0" title="0">{
        return s.GetToken(JSONFilterParserSEL_START, 0)
}</span>

func (s *SelectorContext) Qualifiedidentifier() IQualifiedidentifierContext <span class="cov0" title="0">{
        var t = s.GetTypedRuleContext(reflect.TypeOf((*IQualifiedidentifierContext)(nil)).Elem(), 0)

        if t == nil </span><span class="cov0" title="0">{
                return nil
        }</span>

        <span class="cov0" title="0">return t.(IQualifiedidentifierContext)</span>
}

func (s *SelectorContext) GetRuleContext() antlr.RuleContext <span class="cov0" title="0">{
        return s
}</span>

func (s *SelectorContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string <span class="cov0" title="0">{
        return antlr.TreesStringTree(s, ruleNames, recog)
}</span>

func (s *SelectorContext) Accept(visitor antlr.ParseTreeVisitor) interface{} <span class="cov0" title="0">{
        switch t := visitor.(type) </span>{
        case JSONFilterVisitor:<span class="cov0" title="0">
                return t.VisitSelector(s)</span>

        default:<span class="cov0" title="0">
                return t.VisitChildren(s)</span>
        }
}

func (p *JSONFilterParser) Selector() (localctx ISelectorContext) <span class="cov0" title="0">{
        localctx = NewSelectorContext(p, p.GetParserRuleContext(), p.GetState())
        p.EnterRule(localctx, 8, JSONFilterParserRULE_selector)

        defer func() </span><span class="cov0" title="0">{
                p.ExitRule()
        }</span>()

        <span class="cov0" title="0">defer func() </span><span class="cov0" title="0">{
                if err := recover(); err != nil </span><span class="cov0" title="0">{
                        if v, ok := err.(antlr.RecognitionException); ok </span><span class="cov0" title="0">{
                                localctx.SetException(v)
                                p.GetErrorHandler().ReportError(p, v)
                                p.GetErrorHandler().Recover(p, v)
                        }</span> else<span class="cov0" title="0"> {
                                panic(err)</span>
                        }
                }
        }()

        <span class="cov0" title="0">p.EnterOuterAlt(localctx, 1)
        </span><span class="cov0" title="0">{
                p.SetState(49)
                p.Match(JSONFilterParserSEL_START)
        }</span>
        <span class="cov0" title="0">{
                p.SetState(50)
                p.Qualifiedidentifier()
        }</span>

        <span class="cov0" title="0">return localctx</span>
}

// IQualifiedidentifierContext is an interface to support dynamic dispatch.
type IQualifiedidentifierContext interface {
        antlr.ParserRuleContext

        // GetParser returns the parser.
        GetParser() antlr.Parser

        // IsQualifiedidentifierContext differentiates from other interfaces.
        IsQualifiedidentifierContext()
}

type QualifiedidentifierContext struct {
        *antlr.BaseParserRuleContext
        parser antlr.Parser
}

func NewEmptyQualifiedidentifierContext() *QualifiedidentifierContext <span class="cov0" title="0">{
        var p = new(QualifiedidentifierContext)
        p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
        p.RuleIndex = JSONFilterParserRULE_qualifiedidentifier
        return p
}</span>

func (*QualifiedidentifierContext) IsQualifiedidentifierContext() {<span class="cov0" title="0">}</span>

func NewQualifiedidentifierContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *QualifiedidentifierContext <span class="cov0" title="0">{
        var p = new(QualifiedidentifierContext)

        p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

        p.parser = parser
        p.RuleIndex = JSONFilterParserRULE_qualifiedidentifier

        return p
}</span>

func (s *QualifiedidentifierContext) GetParser() antlr.Parser <span class="cov0" title="0">{ return s.parser }</span>

func (s *QualifiedidentifierContext) AllMember() []IMemberContext <span class="cov0" title="0">{
        var ts = s.GetTypedRuleContexts(reflect.TypeOf((*IMemberContext)(nil)).Elem())
        var tst = make([]IMemberContext, len(ts))

        for i, t := range ts </span><span class="cov0" title="0">{
                if t != nil </span><span class="cov0" title="0">{
                        tst[i] = t.(IMemberContext)
                }</span>
        }

        <span class="cov0" title="0">return tst</span>
}

func (s *QualifiedidentifierContext) Member(i int) IMemberContext <span class="cov0" title="0">{
        var t = s.GetTypedRuleContext(reflect.TypeOf((*IMemberContext)(nil)).Elem(), i)

        if t == nil </span><span class="cov0" title="0">{
                return nil
        }</span>

        <span class="cov0" title="0">return t.(IMemberContext)</span>
}

func (s *QualifiedidentifierContext) AllDOT() []antlr.TerminalNode <span class="cov0" title="0">{
        return s.GetTokens(JSONFilterParserDOT)
}</span>

func (s *QualifiedidentifierContext) DOT(i int) antlr.TerminalNode <span class="cov0" title="0">{
        return s.GetToken(JSONFilterParserDOT, i)
}</span>

func (s *QualifiedidentifierContext) GetRuleContext() antlr.RuleContext <span class="cov0" title="0">{
        return s
}</span>

func (s *QualifiedidentifierContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string <span class="cov0" title="0">{
        return antlr.TreesStringTree(s, ruleNames, recog)
}</span>

func (s *QualifiedidentifierContext) Accept(visitor antlr.ParseTreeVisitor) interface{} <span class="cov0" title="0">{
        switch t := visitor.(type) </span>{
        case JSONFilterVisitor:<span class="cov0" title="0">
                return t.VisitQualifiedidentifier(s)</span>

        default:<span class="cov0" title="0">
                return t.VisitChildren(s)</span>
        }
}

func (p *JSONFilterParser) Qualifiedidentifier() (localctx IQualifiedidentifierContext) <span class="cov0" title="0">{
        localctx = NewQualifiedidentifierContext(p, p.GetParserRuleContext(), p.GetState())
        p.EnterRule(localctx, 10, JSONFilterParserRULE_qualifiedidentifier)

        defer func() </span><span class="cov0" title="0">{
                p.ExitRule()
        }</span>()

        <span class="cov0" title="0">defer func() </span><span class="cov0" title="0">{
                if err := recover(); err != nil </span><span class="cov0" title="0">{
                        if v, ok := err.(antlr.RecognitionException); ok </span><span class="cov0" title="0">{
                                localctx.SetException(v)
                                p.GetErrorHandler().ReportError(p, v)
                                p.GetErrorHandler().Recover(p, v)
                        }</span> else<span class="cov0" title="0"> {
                                panic(err)</span>
                        }
                }
        }()

        <span class="cov0" title="0">var _alt int

        p.EnterOuterAlt(localctx, 1)
        </span><span class="cov0" title="0">{
                p.SetState(52)
                p.Member()
        }</span>
        <span class="cov0" title="0">p.SetState(57)
        p.GetErrorHandler().Sync(p)
        _alt = p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 4, p.GetParserRuleContext())

        for _alt != 2 &amp;&amp; _alt != antlr.ATNInvalidAltNumber </span><span class="cov0" title="0">{
                if _alt == 1 </span><span class="cov0" title="0">{
                        </span><span class="cov0" title="0">{
                                p.SetState(53)
                                p.Match(JSONFilterParserDOT)
                        }</span>
                        <span class="cov0" title="0">{
                                p.SetState(54)
                                p.Member()
                        }</span>

                }
                <span class="cov0" title="0">p.SetState(59)
                p.GetErrorHandler().Sync(p)
                _alt = p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 4, p.GetParserRuleContext())</span>
        }

        <span class="cov0" title="0">return localctx</span>
}

// IMemberContext is an interface to support dynamic dispatch.
type IMemberContext interface {
        antlr.ParserRuleContext

        // GetParser returns the parser.
        GetParser() antlr.Parser

        // IsMemberContext differentiates from other interfaces.
        IsMemberContext()
}

type MemberContext struct {
        *antlr.BaseParserRuleContext
        parser antlr.Parser
}

func NewEmptyMemberContext() *MemberContext <span class="cov0" title="0">{
        var p = new(MemberContext)
        p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
        p.RuleIndex = JSONFilterParserRULE_member
        return p
}</span>

func (*MemberContext) IsMemberContext() {<span class="cov0" title="0">}</span>

func NewMemberContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *MemberContext <span class="cov0" title="0">{
        var p = new(MemberContext)

        p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

        p.parser = parser
        p.RuleIndex = JSONFilterParserRULE_member

        return p
}</span>

func (s *MemberContext) GetParser() antlr.Parser <span class="cov0" title="0">{ return s.parser }</span>

func (s *MemberContext) INDENTIFIER() antlr.TerminalNode <span class="cov0" title="0">{
        return s.GetToken(JSONFilterParserINDENTIFIER, 0)
}</span>

func (s *MemberContext) AllLBRACKET() []antlr.TerminalNode <span class="cov0" title="0">{
        return s.GetTokens(JSONFilterParserLBRACKET)
}</span>

func (s *MemberContext) LBRACKET(i int) antlr.TerminalNode <span class="cov0" title="0">{
        return s.GetToken(JSONFilterParserLBRACKET, i)
}</span>

func (s *MemberContext) AllNUMBER() []antlr.TerminalNode <span class="cov0" title="0">{
        return s.GetTokens(JSONFilterParserNUMBER)
}</span>

func (s *MemberContext) NUMBER(i int) antlr.TerminalNode <span class="cov0" title="0">{
        return s.GetToken(JSONFilterParserNUMBER, i)
}</span>

func (s *MemberContext) AllRBRACKET() []antlr.TerminalNode <span class="cov0" title="0">{
        return s.GetTokens(JSONFilterParserRBRACKET)
}</span>

func (s *MemberContext) RBRACKET(i int) antlr.TerminalNode <span class="cov0" title="0">{
        return s.GetToken(JSONFilterParserRBRACKET, i)
}</span>

func (s *MemberContext) GetRuleContext() antlr.RuleContext <span class="cov0" title="0">{
        return s
}</span>

func (s *MemberContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string <span class="cov0" title="0">{
        return antlr.TreesStringTree(s, ruleNames, recog)
}</span>

func (s *MemberContext) Accept(visitor antlr.ParseTreeVisitor) interface{} <span class="cov0" title="0">{
        switch t := visitor.(type) </span>{
        case JSONFilterVisitor:<span class="cov0" title="0">
                return t.VisitMember(s)</span>

        default:<span class="cov0" title="0">
                return t.VisitChildren(s)</span>
        }
}

func (p *JSONFilterParser) Member() (localctx IMemberContext) <span class="cov0" title="0">{
        localctx = NewMemberContext(p, p.GetParserRuleContext(), p.GetState())
        p.EnterRule(localctx, 12, JSONFilterParserRULE_member)

        defer func() </span><span class="cov0" title="0">{
                p.ExitRule()
        }</span>()

        <span class="cov0" title="0">defer func() </span><span class="cov0" title="0">{
                if err := recover(); err != nil </span><span class="cov0" title="0">{
                        if v, ok := err.(antlr.RecognitionException); ok </span><span class="cov0" title="0">{
                                localctx.SetException(v)
                                p.GetErrorHandler().ReportError(p, v)
                                p.GetErrorHandler().Recover(p, v)
                        }</span> else<span class="cov0" title="0"> {
                                panic(err)</span>
                        }
                }
        }()

        <span class="cov0" title="0">var _alt int

        p.SetState(69)
        p.GetErrorHandler().Sync(p)
        switch p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 6, p.GetParserRuleContext()) </span>{
        case 1:<span class="cov0" title="0">
                p.EnterOuterAlt(localctx, 1)
                </span><span class="cov0" title="0">{
                        p.SetState(60)
                        p.Match(JSONFilterParserINDENTIFIER)
                }</span>

        case 2:<span class="cov0" title="0">
                p.EnterOuterAlt(localctx, 2)
                </span><span class="cov0" title="0">{
                        p.SetState(61)
                        p.Match(JSONFilterParserINDENTIFIER)
                }</span>
                <span class="cov0" title="0">p.SetState(65)
                p.GetErrorHandler().Sync(p)
                _alt = 1
                for ok := true; ok; ok = _alt != 2 &amp;&amp; _alt != antlr.ATNInvalidAltNumber </span><span class="cov0" title="0">{
                        switch _alt </span>{
                        case 1:<span class="cov0" title="0">
                                </span><span class="cov0" title="0">{
                                        p.SetState(62)
                                        p.Match(JSONFilterParserLBRACKET)
                                }</span>
                                <span class="cov0" title="0">{
                                        p.SetState(63)
                                        p.Match(JSONFilterParserNUMBER)
                                }</span>
                                <span class="cov0" title="0">{
                                        p.SetState(64)
                                        p.Match(JSONFilterParserRBRACKET)
                                }</span>

                        default:<span class="cov0" title="0">
                                panic(antlr.NewNoViableAltException(p, nil, nil, nil, nil, nil))</span>
                        }

                        <span class="cov0" title="0">p.SetState(67)
                        p.GetErrorHandler().Sync(p)
                        _alt = p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 5, p.GetParserRuleContext())</span>
                }

        }

        <span class="cov0" title="0">return localctx</span>
}

// IOperatorContext is an interface to support dynamic dispatch.
type IOperatorContext interface {
        antlr.ParserRuleContext

        // GetParser returns the parser.
        GetParser() antlr.Parser

        // IsOperatorContext differentiates from other interfaces.
        IsOperatorContext()
}

type OperatorContext struct {
        *antlr.BaseParserRuleContext
        parser antlr.Parser
}

func NewEmptyOperatorContext() *OperatorContext <span class="cov0" title="0">{
        var p = new(OperatorContext)
        p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
        p.RuleIndex = JSONFilterParserRULE_operator
        return p
}</span>

func (*OperatorContext) IsOperatorContext() {<span class="cov0" title="0">}</span>

func NewOperatorContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *OperatorContext <span class="cov0" title="0">{
        var p = new(OperatorContext)

        p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

        p.parser = parser
        p.RuleIndex = JSONFilterParserRULE_operator

        return p
}</span>

func (s *OperatorContext) GetParser() antlr.Parser <span class="cov0" title="0">{ return s.parser }</span>

func (s *OperatorContext) EQUALS() antlr.TerminalNode <span class="cov0" title="0">{
        return s.GetToken(JSONFilterParserEQUALS, 0)
}</span>

func (s *OperatorContext) NOT_EQUALS() antlr.TerminalNode <span class="cov0" title="0">{
        return s.GetToken(JSONFilterParserNOT_EQUALS, 0)
}</span>

func (s *OperatorContext) IS() antlr.TerminalNode <span class="cov0" title="0">{
        return s.GetToken(JSONFilterParserIS, 0)
}</span>

func (s *OperatorContext) NOT() antlr.TerminalNode <span class="cov0" title="0">{
        return s.GetToken(JSONFilterParserNOT, 0)
}</span>

func (s *OperatorContext) GT() antlr.TerminalNode <span class="cov0" title="0">{
        return s.GetToken(JSONFilterParserGT, 0)
}</span>

func (s *OperatorContext) LT() antlr.TerminalNode <span class="cov0" title="0">{
        return s.GetToken(JSONFilterParserLT, 0)
}</span>

func (s *OperatorContext) GE() antlr.TerminalNode <span class="cov0" title="0">{
        return s.GetToken(JSONFilterParserGE, 0)
}</span>

func (s *OperatorContext) LE() antlr.TerminalNode <span class="cov0" title="0">{
        return s.GetToken(JSONFilterParserLE, 0)
}</span>

func (s *OperatorContext) GetRuleContext() antlr.RuleContext <span class="cov0" title="0">{
        return s
}</span>

func (s *OperatorContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string <span class="cov0" title="0">{
        return antlr.TreesStringTree(s, ruleNames, recog)
}</span>

func (s *OperatorContext) Accept(visitor antlr.ParseTreeVisitor) interface{} <span class="cov0" title="0">{
        switch t := visitor.(type) </span>{
        case JSONFilterVisitor:<span class="cov0" title="0">
                return t.VisitOperator(s)</span>

        default:<span class="cov0" title="0">
                return t.VisitChildren(s)</span>
        }
}

func (p *JSONFilterParser) Operator() (localctx IOperatorContext) <span class="cov0" title="0">{
        localctx = NewOperatorContext(p, p.GetParserRuleContext(), p.GetState())
        p.EnterRule(localctx, 14, JSONFilterParserRULE_operator)
        var _la int

        defer func() </span><span class="cov0" title="0">{
                p.ExitRule()
        }</span>()

        <span class="cov0" title="0">defer func() </span><span class="cov0" title="0">{
                if err := recover(); err != nil </span><span class="cov0" title="0">{
                        if v, ok := err.(antlr.RecognitionException); ok </span><span class="cov0" title="0">{
                                localctx.SetException(v)
                                p.GetErrorHandler().ReportError(p, v)
                                p.GetErrorHandler().Recover(p, v)
                        }</span> else<span class="cov0" title="0"> {
                                panic(err)</span>
                        }
                }
        }()

        <span class="cov0" title="0">p.EnterOuterAlt(localctx, 1)
        </span><span class="cov0" title="0">{
                p.SetState(71)
                _la = p.GetTokenStream().LA(1)

                if !(((_la)&amp;-(0x1f+1)) == 0 &amp;&amp; ((1&lt;&lt;uint(_la))&amp;((1&lt;&lt;JSONFilterParserEQUALS)|(1&lt;&lt;JSONFilterParserNOT_EQUALS)|(1&lt;&lt;JSONFilterParserGT)|(1&lt;&lt;JSONFilterParserLT)|(1&lt;&lt;JSONFilterParserGE)|(1&lt;&lt;JSONFilterParserLE)|(1&lt;&lt;JSONFilterParserIS)|(1&lt;&lt;JSONFilterParserNOT))) != 0) </span><span class="cov0" title="0">{
                        p.GetErrorHandler().RecoverInline(p)
                }</span> else<span class="cov0" title="0"> {
                        p.GetErrorHandler().ReportMatch(p)
                        p.Consume()
                }</span>
        }

        <span class="cov0" title="0">return localctx</span>
}

// ILiteralContext is an interface to support dynamic dispatch.
type ILiteralContext interface {
        antlr.ParserRuleContext

        // GetParser returns the parser.
        GetParser() antlr.Parser

        // IsLiteralContext differentiates from other interfaces.
        IsLiteralContext()
}

type LiteralContext struct {
        *antlr.BaseParserRuleContext
        parser antlr.Parser
}

func NewEmptyLiteralContext() *LiteralContext <span class="cov0" title="0">{
        var p = new(LiteralContext)
        p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
        p.RuleIndex = JSONFilterParserRULE_literal
        return p
}</span>

func (*LiteralContext) IsLiteralContext() {<span class="cov0" title="0">}</span>

func NewLiteralContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *LiteralContext <span class="cov0" title="0">{
        var p = new(LiteralContext)

        p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

        p.parser = parser
        p.RuleIndex = JSONFilterParserRULE_literal

        return p
}</span>

func (s *LiteralContext) GetParser() antlr.Parser <span class="cov0" title="0">{ return s.parser }</span>

func (s *LiteralContext) AllNUMBER() []antlr.TerminalNode <span class="cov0" title="0">{
        return s.GetTokens(JSONFilterParserNUMBER)
}</span>

func (s *LiteralContext) NUMBER(i int) antlr.TerminalNode <span class="cov0" title="0">{
        return s.GetToken(JSONFilterParserNUMBER, i)
}</span>

func (s *LiteralContext) AllDOT() []antlr.TerminalNode <span class="cov0" title="0">{
        return s.GetTokens(JSONFilterParserDOT)
}</span>

func (s *LiteralContext) DOT(i int) antlr.TerminalNode <span class="cov0" title="0">{
        return s.GetToken(JSONFilterParserDOT, i)
}</span>

func (s *LiteralContext) AllSTAR() []antlr.TerminalNode <span class="cov0" title="0">{
        return s.GetTokens(JSONFilterParserSTAR)
}</span>

func (s *LiteralContext) STAR(i int) antlr.TerminalNode <span class="cov0" title="0">{
        return s.GetToken(JSONFilterParserSTAR, i)
}</span>

func (s *LiteralContext) STRING() antlr.TerminalNode <span class="cov0" title="0">{
        return s.GetToken(JSONFilterParserSTRING, 0)
}</span>

func (s *LiteralContext) NULL() antlr.TerminalNode <span class="cov0" title="0">{
        return s.GetToken(JSONFilterParserNULL, 0)
}</span>

func (s *LiteralContext) EXISTS() antlr.TerminalNode <span class="cov0" title="0">{
        return s.GetToken(JSONFilterParserEXISTS, 0)
}</span>

func (s *LiteralContext) TRUE() antlr.TerminalNode <span class="cov0" title="0">{
        return s.GetToken(JSONFilterParserTRUE, 0)
}</span>

func (s *LiteralContext) FALSE() antlr.TerminalNode <span class="cov0" title="0">{
        return s.GetToken(JSONFilterParserFALSE, 0)
}</span>

func (s *LiteralContext) INDENTIFIER() antlr.TerminalNode <span class="cov0" title="0">{
        return s.GetToken(JSONFilterParserINDENTIFIER, 0)
}</span>

func (s *LiteralContext) GetRuleContext() antlr.RuleContext <span class="cov0" title="0">{
        return s
}</span>

func (s *LiteralContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string <span class="cov0" title="0">{
        return antlr.TreesStringTree(s, ruleNames, recog)
}</span>

func (s *LiteralContext) Accept(visitor antlr.ParseTreeVisitor) interface{} <span class="cov0" title="0">{
        switch t := visitor.(type) </span>{
        case JSONFilterVisitor:<span class="cov0" title="0">
                return t.VisitLiteral(s)</span>

        default:<span class="cov0" title="0">
                return t.VisitChildren(s)</span>
        }
}

func (p *JSONFilterParser) Literal() (localctx ILiteralContext) <span class="cov0" title="0">{
        localctx = NewLiteralContext(p, p.GetParserRuleContext(), p.GetState())
        p.EnterRule(localctx, 16, JSONFilterParserRULE_literal)
        var _la int

        defer func() </span><span class="cov0" title="0">{
                p.ExitRule()
        }</span>()

        <span class="cov0" title="0">defer func() </span><span class="cov0" title="0">{
                if err := recover(); err != nil </span><span class="cov0" title="0">{
                        if v, ok := err.(antlr.RecognitionException); ok </span><span class="cov0" title="0">{
                                localctx.SetException(v)
                                p.GetErrorHandler().ReportError(p, v)
                                p.GetErrorHandler().Recover(p, v)
                        }</span> else<span class="cov0" title="0"> {
                                panic(err)</span>
                        }
                }
        }()

        <span class="cov0" title="0">var _alt int

        p.SetState(87)
        p.GetErrorHandler().Sync(p)
        switch p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 8, p.GetParserRuleContext()) </span>{
        case 1:<span class="cov0" title="0">
                p.EnterOuterAlt(localctx, 1)
                </span><span class="cov0" title="0">{
                        p.SetState(73)
                        p.Match(JSONFilterParserNUMBER)
                }</span>
                <span class="cov0" title="0">p.SetState(76)
                p.GetErrorHandler().Sync(p)
                _alt = 1
                for ok := true; ok; ok = _alt != 2 &amp;&amp; _alt != antlr.ATNInvalidAltNumber </span><span class="cov0" title="0">{
                        switch _alt </span>{
                        case 1:<span class="cov0" title="0">
                                </span><span class="cov0" title="0">{
                                        p.SetState(74)
                                        p.Match(JSONFilterParserDOT)
                                }</span>
                                <span class="cov0" title="0">{
                                        p.SetState(75)
                                        _la = p.GetTokenStream().LA(1)

                                        if !(_la == JSONFilterParserSTAR || _la == JSONFilterParserNUMBER) </span><span class="cov0" title="0">{
                                                p.GetErrorHandler().RecoverInline(p)
                                        }</span> else<span class="cov0" title="0"> {
                                                p.GetErrorHandler().ReportMatch(p)
                                                p.Consume()
                                        }</span>
                                }

                        default:<span class="cov0" title="0">
                                panic(antlr.NewNoViableAltException(p, nil, nil, nil, nil, nil))</span>
                        }

                        <span class="cov0" title="0">p.SetState(78)
                        p.GetErrorHandler().Sync(p)
                        _alt = p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 7, p.GetParserRuleContext())</span>
                }

        case 2:<span class="cov0" title="0">
                p.EnterOuterAlt(localctx, 2)
                </span><span class="cov0" title="0">{
                        p.SetState(80)
                        p.Match(JSONFilterParserSTRING)
                }</span>

        case 3:<span class="cov0" title="0">
                p.EnterOuterAlt(localctx, 3)
                </span><span class="cov0" title="0">{
                        p.SetState(81)
                        p.Match(JSONFilterParserNUMBER)
                }</span>

        case 4:<span class="cov0" title="0">
                p.EnterOuterAlt(localctx, 4)
                </span><span class="cov0" title="0">{
                        p.SetState(82)
                        p.Match(JSONFilterParserNULL)
                }</span>

        case 5:<span class="cov0" title="0">
                p.EnterOuterAlt(localctx, 5)
                </span><span class="cov0" title="0">{
                        p.SetState(83)
                        p.Match(JSONFilterParserEXISTS)
                }</span>

        case 6:<span class="cov0" title="0">
                p.EnterOuterAlt(localctx, 6)
                </span><span class="cov0" title="0">{
                        p.SetState(84)
                        p.Match(JSONFilterParserTRUE)
                }</span>

        case 7:<span class="cov0" title="0">
                p.EnterOuterAlt(localctx, 7)
                </span><span class="cov0" title="0">{
                        p.SetState(85)
                        p.Match(JSONFilterParserFALSE)
                }</span>

        case 8:<span class="cov0" title="0">
                p.EnterOuterAlt(localctx, 8)
                </span><span class="cov0" title="0">{
                        p.SetState(86)
                        p.Match(JSONFilterParserINDENTIFIER)
                }</span>

        }

        <span class="cov0" title="0">return localctx</span>
}

func (p *JSONFilterParser) Sempred(localctx antlr.RuleContext, ruleIndex, predIndex int) bool <span class="cov0" title="0">{
        switch ruleIndex </span>{
        case 2:<span class="cov0" title="0">
                var t *Filter_exprContext = nil
                if localctx != nil </span><span class="cov0" title="0">{
                        t = localctx.(*Filter_exprContext)
                }</span>
                <span class="cov0" title="0">return p.Filter_expr_Sempred(t, predIndex)</span>

        default:<span class="cov0" title="0">
                panic("No predicate with index: " + fmt.Sprint(ruleIndex))</span>
        }
}

func (p *JSONFilterParser) Filter_expr_Sempred(localctx antlr.RuleContext, predIndex int) bool <span class="cov0" title="0">{
        switch predIndex </span>{
        case 0:<span class="cov0" title="0">
                return p.Precpred(p.GetParserRuleContext(), 3)</span>

        case 1:<span class="cov0" title="0">
                return p.Precpred(p.GetParserRuleContext(), 2)</span>

        default:<span class="cov0" title="0">
                panic("No predicate with index: " + fmt.Sprint(predIndex))</span>
        }
}
</pre>
		
		<pre class="file" id="file68" style="display: none">package parser // JSONFilter

import (
        "github.com/antlr/antlr4/runtime/Go/antlr"
)

const (
        AND = "&amp;&amp;"
        OR  = "||"
)

type AWSJSONFilter struct {
        FilterExpression interface{} `json:"_kics_filter_expr"`
}

type FilterExp struct {
        Op    interface{} `json:"_op"`
        Left  interface{} `json:"_left"`
        Right interface{} `json:"_right"`
}

type FilterSelector struct {
        Selector interface{} `json:"_selector"`
        Op       interface{} `json:"_op"`
        Value    interface{} `json:"_value"`
}

type JSONFilterTreeVisitor struct {
        *antlr.BaseParseTreeVisitor
}

func NewJSONFilterPrinterVisitor() *JSONFilterTreeVisitor <span class="cov0" title="0">{
        return &amp;JSONFilterTreeVisitor{
                &amp;antlr.BaseParseTreeVisitor{},
        }
}</span>

func (v *JSONFilterTreeVisitor) VisitAll(tree antlr.ParseTree) AWSJSONFilter <span class="cov0" title="0">{
        return AWSJSONFilter{
                FilterExpression: v.Visit(tree),
        }
}</span>

func (v *JSONFilterTreeVisitor) Visit(tree antlr.ParseTree) interface{} <span class="cov0" title="0">{
        return tree.Accept(v)
}</span>

func (v *JSONFilterTreeVisitor) VisitChildren(node antlr.RuleNode) interface{} <span class="cov0" title="0">{
        children := node.GetChildren()
        for _, child := range children </span><span class="cov0" title="0">{
                child.(antlr.ParseTree).Accept(v)
        }</span>
        <span class="cov0" title="0">return nil</span>
}

func (v *JSONFilterTreeVisitor) VisitAwsjsonfilter(ctx *AwsjsonfilterContext) interface{} <span class="cov0" title="0">{
        return v.Visit(ctx.Dotnotation())
}</span>

func (v *JSONFilterTreeVisitor) VisitDotnotation(ctx *DotnotationContext) interface{} <span class="cov0" title="0">{
        return v.Visit(ctx.Filter_expr())
}</span>

func (v *JSONFilterTreeVisitor) VisitFilter_expr_parenthesized(ctx *Filter_expr_parenthesizedContext) interface{} <span class="cov0" title="0">{
        return v.Visit(ctx.Filter_expr())
}</span>

func (v *JSONFilterTreeVisitor) VisitFilter_expr_and(ctx *Filter_expr_andContext) interface{} <span class="cov0" title="0">{
        return FilterExp{
                Op:    AND,
                Left:  v.Visit(ctx.GetLhs()),
                Right: v.Visit(ctx.GetRhs()),
        }
}</span>

func (v *JSONFilterTreeVisitor) VisitFilter_expr_exp(ctx *Filter_expr_expContext) interface{} <span class="cov0" title="0">{
        return v.Visit(ctx.Exp())
}</span>

func (v *JSONFilterTreeVisitor) VisitFilter_expr_or(ctx *Filter_expr_orContext) interface{} <span class="cov0" title="0">{
        return FilterExp{
                Op:    OR,
                Left:  v.Visit(ctx.GetLhs()),
                Right: v.Visit(ctx.GetRhs()),
        }
}</span>

func (v *JSONFilterTreeVisitor) VisitQualifiedidentifier(ctx *QualifiedidentifierContext) interface{} <span class="cov0" title="0">{
        return v.VisitChildren(ctx)
}</span>

func (v *JSONFilterTreeVisitor) VisitExp(ctx *ExpContext) interface{} <span class="cov0" title="0">{
        var value interface{}
        if ctx.Literal() != nil </span><span class="cov0" title="0">{
                value = v.Visit(ctx.Literal())
        }</span> else<span class="cov0" title="0"> {
                value = v.Visit(ctx.Qualifiedidentifier())
        }</span>
        <span class="cov0" title="0">selector := FilterSelector{
                Selector: v.Visit(ctx.Selector()),
                Op:       v.Visit(ctx.Operator()),
                Value:    value,
        }

        return selector</span>
}

func (v *JSONFilterTreeVisitor) VisitSelector(ctx *SelectorContext) interface{} <span class="cov0" title="0">{
        return ctx.GetText()
}</span>

func (v *JSONFilterTreeVisitor) VisitMember(ctx *MemberContext) interface{} <span class="cov0" title="0">{
        return ctx.GetText()
}</span>

func (v *JSONFilterTreeVisitor) VisitOperator(ctx *OperatorContext) interface{} <span class="cov0" title="0">{
        return ctx.GetText()
}</span>

func (v *JSONFilterTreeVisitor) VisitLiteral(ctx *LiteralContext) interface{} <span class="cov0" title="0">{
        return ctx.GetText()
}</span>
</pre>
		
		<pre class="file" id="file69" style="display: none">package parser

import (
        "bytes"
        "errors"
        "os"
        "strings"

        "github.com/Checkmarx/kics/pkg/model"
        "github.com/Checkmarx/kics/pkg/utils"
        "github.com/rs/zerolog/log"
)

type kindParser interface {
        GetKind() model.FileKind
        GetCommentToken() string
        SupportedExtensions() []string
        SupportedTypes() map[string]bool
        Parse(filePath string, fileContent []byte) ([]model.Document, []int, error)
        Resolve(fileContent []byte, filename string) ([]byte, error)
        StringifyContent(content []byte) (string, error)
        GetResolvedFiles() map[string]model.ResolvedFile
}

// Builder is a representation of parsers that will be construct
type Builder struct {
        parsers []kindParser
}

// NewBuilder creates a new Builder's reference
func NewBuilder() *Builder <span class="cov4" title="5">{
        log.Debug().Msg("parser.NewBuilder()")
        return &amp;Builder{}
}</span>

// Add is a function that adds a new parser to the caller and returns it
func (b *Builder) Add(p kindParser) *Builder <span class="cov6" title="11">{
        b.parsers = append(b.parsers, p)
        return b
}</span>

// Build prepares parsers and associates a parser to its extension and returns it
func (b *Builder) Build(types, cloudProviders []string) ([]*Parser, error) <span class="cov4" title="5">{
        parserSlice := make([]*Parser, 0, len(b.parsers))
        for _, parser := range b.parsers </span><span class="cov6" title="11">{
                supportedTypes := parser.SupportedTypes()
                if contains(types, supportedTypes) </span><span class="cov6" title="11">{
                        extensions := make(model.Extensions, len(b.parsers))
                        var platforms []string
                        for _, ext := range parser.SupportedExtensions() </span><span class="cov9" title="31">{
                                extensions[ext] = struct{}{}
                        }</span>
                        <span class="cov6" title="11">for key := range supportedTypes </span><span class="cov10" title="41">{
                                platforms = append(platforms, key)
                        }</span>
                        <span class="cov6" title="11">parserSlice = append(parserSlice, &amp;Parser{
                                parsers:    parser,
                                extensions: extensions,
                                Platform:   platforms,
                        })</span>
                }
        }

        <span class="cov4" title="5">return parserSlice, nil</span>
}

// ErrNotSupportedFile represents an error when a file is not supported by KICS
var ErrNotSupportedFile = errors.New("unsupported file to parse")

// Parser is a struct that associates a parser to its supported extensions
type Parser struct {
        parsers    kindParser
        extensions model.Extensions
        Platform   []string
}

// ParsedDocument is a struct containing data retrieved from parsing
type ParsedDocument struct {
        Docs          []model.Document
        Kind          model.FileKind
        Content       string
        IgnoreLines   []int
        CountLines    int
        ResolvedFiles map[string]model.ResolvedFile
}

// CommentsCommands gets commands on comments in the file beginning, before the code starts
func (c *Parser) CommentsCommands(filePath string, fileContent []byte) model.CommentsCommands <span class="cov1" title="1">{
        if c.isValidExtension(filePath) </span><span class="cov1" title="1">{
                commentsCommands := make(model.CommentsCommands)
                commentToken := c.parsers.GetCommentToken()
                if commentToken != "" </span><span class="cov1" title="1">{
                        lines := strings.Split(string(fileContent), "\n")
                        for _, line := range lines </span><span class="cov4" title="4">{
                                line = strings.TrimSpace(line)
                                if line == "" </span><span class="cov1" title="1">{
                                        continue</span>
                                }
                                <span class="cov3" title="3">if !strings.HasPrefix(line, commentToken) </span><span class="cov1" title="1">{
                                        break</span>
                                }
                                <span class="cov2" title="2">fields := strings.Fields(strings.TrimSpace(strings.TrimPrefix(line, commentToken)))
                                if len(fields) &gt; 1 &amp;&amp; fields[0] == "kics-scan" &amp;&amp; fields[1] != "" </span><span class="cov2" title="2">{
                                        commandParameters := strings.SplitN(fields[1], "=", 2)
                                        if len(commandParameters) &gt; 1 </span><span class="cov1" title="1">{
                                                commentsCommands[commandParameters[0]] = commandParameters[1]
                                        }</span> else<span class="cov1" title="1"> {
                                                commentsCommands[commandParameters[0]] = ""
                                        }</span>
                                }
                        }
                }
                <span class="cov1" title="1">return commentsCommands</span>
        }
        <span class="cov0" title="0">return nil</span>
}

// Parse executes a parser on the fileContent and returns the file content as a Document, the file kind and
// an error, if an error has occurred
func (c *Parser) Parse(filePath string, fileContent []byte) (ParsedDocument, error) <span class="cov3" title="3">{
        fileContent = utils.DecryptAnsibleVault(fileContent, os.Getenv("ANSIBLE_VAULT_PASSWORD_FILE"))

        if c.isValidExtension(filePath) </span><span class="cov3" title="3">{
                resolved, err := c.parsers.Resolve(fileContent, filePath)
                if err != nil </span><span class="cov0" title="0">{
                        return ParsedDocument{}, err
                }</span>
                <span class="cov3" title="3">obj, igLines, err := c.parsers.Parse(filePath, resolved)
                if err != nil </span><span class="cov0" title="0">{
                        return ParsedDocument{}, err
                }</span>

                <span class="cov3" title="3">cont, err := c.parsers.StringifyContent(fileContent)
                if err != nil </span><span class="cov0" title="0">{
                        log.Error().Msgf("failed to stringify original content: %s", err)
                        cont = string(fileContent)
                }</span>

                <span class="cov3" title="3">return ParsedDocument{
                        Docs:          obj,
                        Kind:          c.parsers.GetKind(),
                        Content:       cont,
                        IgnoreLines:   igLines,
                        CountLines:    bytes.Count(resolved, []byte{'\n'}) + 1,
                        ResolvedFiles: c.parsers.GetResolvedFiles(),
                }, nil</span>
        }
        <span class="cov0" title="0">return ParsedDocument{
                Docs:        nil,
                Kind:        "break",
                Content:     "",
                IgnoreLines: []int{},
        }, ErrNotSupportedFile</span>
}

// SupportedExtensions returns extensions supported by KICS
func (c *Parser) SupportedExtensions() model.Extensions <span class="cov4" title="4">{
        return c.extensions
}</span>

func contains(types []string, supportedTypes map[string]bool) bool <span class="cov7" title="13">{
        if types[0] == "" </span><span class="cov6" title="11">{
                return true
        }</span>

        <span class="cov2" title="2">for _, t := range types </span><span class="cov2" title="2">{
                if _, ok := supportedTypes[strings.ToLower(t)]; ok </span><span class="cov1" title="1">{
                        return true
                }</span>
        }

        <span class="cov1" title="1">return false</span>
}

func (c *Parser) isValidExtension(filePath string) bool <span class="cov5" title="7">{
        ext := utils.GetExtension(filePath)
        _, ok := c.extensions[ext]
        return ok
}</span>
</pre>
		
		<pre class="file" id="file70" style="display: none">package comment

import (
        "strings"

        "github.com/Checkmarx/kics/pkg/model"
        "github.com/hashicorp/hcl/v2"
        "github.com/hashicorp/hcl/v2/hclsyntax"
)

// comment is a comment token
type comment hclsyntax.Token

// position returns the position of the comment
func (c *comment) position() hcl.Pos <span class="cov5" title="16">{
        return hcl.Pos{Line: c.Range.End.Line + 1, Column: c.Range.End.Column, Byte: c.Range.End.Byte}
}</span>

// value returns the value of a comment
func (c *comment) value() (value model.CommentCommand) <span class="cov4" title="10">{
        comment := strings.ToLower(string(c.Bytes))
        // check if we are working with kics command
        if model.KICSCommentRgxp.MatchString(comment) </span><span class="cov4" title="8">{
                comment = model.KICSCommentRgxp.ReplaceAllString(comment, "")
                comment = strings.Trim(comment, "\n")
                commands := strings.Split(strings.Trim(comment, "\r"), " ")
                value = model.ProcessCommands(commands)
                return
        }</span>
        <span class="cov2" title="2">return model.CommentCommand(comment)</span>
}

// Ignore is a map of commands to ignore
type Ignore map[model.CommentCommand][]hcl.Pos

// Build builds the Ignore map
func (i *Ignore) build(ignoreLine, ignoreBlock, ignoreComment []hcl.Pos) <span class="cov4" title="8">{
        ignoreStruct := map[model.CommentCommand][]hcl.Pos{
                model.IgnoreLine:    ignoreLine,
                model.IgnoreBlock:   ignoreBlock,
                model.IgnoreComment: ignoreComment,
        }

        *i = ignoreStruct
}</span>

// ///////////////////////////
//     LINES TO IGNORE      //
// ///////////////////////////

// GetIgnoreLines returns the lines to ignore from a comment
func GetIgnoreLines(ignore Ignore, body *hclsyntax.Body) (lines []int) <span class="cov3" title="4">{
        lines = make([]int, 0)
        for _, position := range ignore[model.IgnoreBlock] </span><span class="cov3" title="4">{
                lines = append(lines, checkBlock(body, position)...)
        }</span>
        <span class="cov3" title="4">lines = append(lines, getLinesFromPos(ignore[model.IgnoreLine])...)
        lines = append(lines, getLinesFromPos(ignore[model.IgnoreComment])...)
        return</span>
}

// getLinesFromPos will return a list of lines from a list of positions
func getLinesFromPos(positions []hcl.Pos) (lines []int) <span class="cov4" title="8">{
        lines = make([]int, 0)
        for _, position := range positions </span><span class="cov3" title="4">{
                lines = append(lines, position.Line)
        }</span>
        <span class="cov4" title="8">return</span>
}

// checkBlock checks if the position is inside a block and returns the lines to ignore
func checkBlock(body *hclsyntax.Body, position hcl.Pos) (lines []int) <span class="cov3" title="4">{
        lines = make([]int, 0)
        blocks := body.BlocksAtPos(position)

        for _, block := range blocks </span><span class="cov2" title="2">{
                lines = append(lines, getLinesFromBlock(block, position)...)
        }</span>
        <span class="cov3" title="4">return</span>
}

// getLinesFromBlock returns the lines to ignore from a block
func getLinesFromBlock(block *hcl.Block, position hcl.Pos) (lines []int) <span class="cov2" title="2">{
        lines = make([]int, 0)
        if checkBlockRange(block, position) </span><span class="cov1" title="1">{
                rangeBlock := block.Body.(*hclsyntax.Body).Range()
                lines = append(lines, model.Range(rangeBlock.Start.Line, rangeBlock.End.Line)...)
        }</span> else<span class="cov1" title="1"> {
                // check in attributes
                attribute := block.Body.(*hclsyntax.Body).AttributeAtPos(position)
                lines = append(lines, getLinesFromAttr(attribute)...)
        }</span>
        <span class="cov2" title="2">return</span>
}

// getLinesFromAttr returns the lines to ignore from an attribute
func getLinesFromAttr(atr *hcl.Attribute) (lines []int) <span class="cov1" title="1">{
        lines = make([]int, 0)
        if atr == nil </span><span class="cov0" title="0">{
                return
        }</span>

        <span class="cov1" title="1">lines = append(lines, model.Range(atr.Range.Start.Line, atr.Range.End.Line)...)
        return</span>
}

// checkBlockRange checks if the position is inside a block
func checkBlockRange(block *hcl.Block, position hcl.Pos) bool <span class="cov2" title="2">{
        return block.TypeRange.End == position
}</span>

// ///////////////////////////
//     COMMENT PARSER       //
// ///////////////////////////

// ParseComments parses the comments and returns the kics commands
func ParseComments(src []byte, filename string) (Ignore, error) <span class="cov4" title="8">{
        comments, diags := hclsyntax.LexConfig(src, filename, hcl.Pos{Line: 0, Column: 0})
        if diags != nil &amp;&amp; diags.HasErrors() </span><span class="cov0" title="0">{
                return Ignore{}, diags.Errs()[0]
        }</span>

        <span class="cov4" title="8">ig := processTokens(comments)

        return ig, nil</span>
}

// processTokens goes over the tokens and returns the kics commands
func processTokens(tokens hclsyntax.Tokens) (ig Ignore) <span class="cov4" title="8">{
        ignoreLines := make([]hcl.Pos, 0)
        ignoreBlocks := make([]hcl.Pos, 0)
        ignoreComments := make([]hcl.Pos, 0)
        for i := range tokens </span><span class="cov10" title="274">{
                // token is not a comment
                if tokens[i].Type != hclsyntax.TokenComment || i+1 &gt; len(tokens) </span><span class="cov9" title="264">{
                        continue</span>
                }
                <span class="cov4" title="10">ignoreLines, ignoreBlocks, ignoreComments = processComment((*comment)(&amp;tokens[i]),
                        (*comment)(&amp;tokens[i+1]), ignoreLines, ignoreBlocks, ignoreComments)</span>
        }
        <span class="cov4" title="8">ig = make(map[model.CommentCommand][]hcl.Pos)
        ig.build(ignoreLines, ignoreBlocks, ignoreComments)
        return ig</span>
}

// processComment analyzes the comment to determine which type of kics command the comment is
func processComment(comment *comment, tokenToIgnore *comment,
        ignoreLine, ignoreBlock, ignoreComments []hcl.Pos) (ignoreLineR, ignoreBlockR, ignoreCommentsR []hcl.Pos) <span class="cov4" title="10">{
        ignoreLineR = ignoreLine
        ignoreBlockR = ignoreBlock
        ignoreCommentsR = ignoreComments

        switch comment.value() </span>{
        case model.IgnoreLine:<span class="cov2" title="2">
                // comment is of type kics ignore-line
                ignoreLineR = append(ignoreLineR, tokenToIgnore.position(), hcl.Pos{Line: comment.position().Line - 1})</span>
        case model.IgnoreBlock:<span class="cov3" title="4">
                // comment is of type kics ignore-block
                ignoreBlockR = append(ignoreBlockR, tokenToIgnore.position(), hcl.Pos{Line: comment.position().Line - 1})</span>
        default:<span class="cov3" title="4">
                // comment is not of type kics ignore
                ignoreCommentsR = append(ignoreCommentsR, hcl.Pos{Line: comment.position().Line - 1})
                return</span>
        }

        <span class="cov3" title="6">return</span>
}
</pre>
		
		<pre class="file" id="file71" style="display: none">package converter

import (
        "fmt"
        "strconv"
        "strings"

        sentryReport "github.com/Checkmarx/kics/internal/sentry"
        "github.com/Checkmarx/kics/pkg/model"
        "github.com/Checkmarx/kics/pkg/parser/terraform/functions"
        "github.com/hashicorp/hcl/v2"
        "github.com/hashicorp/hcl/v2/hclsyntax"
        "github.com/rs/zerolog/log"
        "github.com/zclconf/go-cty/cty"
        ctyconvert "github.com/zclconf/go-cty/cty/convert"
        ctyjson "github.com/zclconf/go-cty/cty/json"
)

// VariableMap represents a set of terraform input variables
type VariableMap map[string]cty.Value

var inputVarMap = make(VariableMap)

// This file is attributed to https://github.com/tmccombs/hcl2json.
// convertBlock() is manipulated for combining the both blocks and labels for one given resource.

// DefaultConverted an hcl File to a toJson serializable object
// This assumes that the body is a hclsyntax.Body
var DefaultConverted = func(file *hcl.File, inputVariables VariableMap) (model.Document, error) <span class="cov4" title="6">{
        inputVarMap = inputVariables
        c := converter{bytes: file.Bytes}
        body, err := c.convertBody(file.Body.(*hclsyntax.Body), 0)

        if err != nil </span><span class="cov0" title="0">{
                sentryReport.ReportSentry(&amp;sentryReport.Report{
                        Location: "var DefaultConverted",
                        Err:      err,
                        Kind:     model.KindTerraform,
                        Message:  "Failed to convert body in terraform parser",
                }, false)
                if er, ok := err.(*hcl.Diagnostic); ok &amp;&amp; er.Subject != nil </span><span class="cov0" title="0">{
                        return nil, err
                }</span>

                <span class="cov0" title="0">return nil, err</span>
        }

        <span class="cov4" title="6">return body, nil</span>
}

type converter struct {
        bytes []byte
}

func (c *converter) rangeSource(r hcl.Range) string <span class="cov8" title="35">{
        return string(c.bytes[r.Start.Byte:r.End.Byte])
}</span>

func (c *converter) convertBody(body *hclsyntax.Body, defLine int) (model.Document, error) <span class="cov7" title="23">{
        var err error
        var v string
        countValue := body.Attributes["count"]
        count := -1

        if countValue != nil </span><span class="cov0" title="0">{
                value, err := countValue.Expr.Value(nil)
                if err == nil </span><span class="cov0" title="0">{
                        switch value.Type() </span>{
                        case cty.String:<span class="cov0" title="0">
                                v = value.AsString()</span>
                        case cty.Number:<span class="cov0" title="0">
                                v = value.AsBigFloat().String()</span>
                        }

                        <span class="cov0" title="0">intValue, err := strconv.Atoi(v)
                        if err == nil </span><span class="cov0" title="0">{
                                count = intValue
                        }</span>
                }
        }

        <span class="cov7" title="23">if count == 0 </span><span class="cov0" title="0">{
                return nil, nil
        }</span>

        <span class="cov7" title="23">out := make(model.Document)
        kicsS := make(map[string]model.LineObject)
        // set kics line for the body
        kicsS["_kics__default"] = model.LineObject{
                Line: defLine,
        }

        if body.Attributes != nil </span><span class="cov7" title="23">{
                for key, value := range body.Attributes </span><span class="cov8" title="33">{
                        out[key], err = c.convertExpression(value.Expr)
                        // set kics line for the body value
                        kicsS["_kics_"+key] = model.LineObject{
                                Line: value.SrcRange.Start.Line,
                                Arr:  c.getArrLines(value.Expr),
                        }
                        if err != nil </span><span class="cov0" title="0">{
                                sentryReport.ReportSentry(&amp;sentryReport.Report{
                                        Location: "func convertBody",
                                        Err:      err,
                                        Kind:     model.KindTerraform,
                                        Message:  "Failed to convert Expression in terraform parser",
                                }, false)
                                return nil, err
                        }</span>
                }
        }

        <span class="cov7" title="23">for _, block := range body.Blocks </span><span class="cov6" title="15">{
                // set kics line for block
                kicsS["_kics_"+block.Type] = model.LineObject{
                        Line: block.TypeRange.Start.Line,
                }
                err = c.convertBlock(block, out, block.TypeRange.Start.Line)
                if err != nil </span><span class="cov0" title="0">{
                        sentryReport.ReportSentry(&amp;sentryReport.Report{
                                Location: "func convertBody",
                                Err:      err,
                                Kind:     model.KindTerraform,
                                Message:  "Failed to convert block in terraform parser",
                        }, false)
                        return nil, err
                }</span>
        }

        <span class="cov7" title="23">out["_kics_lines"] = kicsS

        return out, nil</span>
}

// getArrLines will get line information for the array elements
func (c *converter) getArrLines(expr hclsyntax.Expression) []map[string]*model.LineObject <span class="cov8" title="33">{
        arr := make([]map[string]*model.LineObject, 0)
        if v, ok := expr.(*hclsyntax.TupleConsExpr); ok </span><span class="cov2" title="2">{
                for _, ex := range v.Exprs </span><span class="cov5" title="7">{
                        arrEx := make(map[string]*model.LineObject)
                        // set default line of array
                        arrEx["_kics__default"] = &amp;model.LineObject{
                                Line: ex.Range().Start.Line,
                        }
                        switch valType := ex.(type) </span>{
                        case *hclsyntax.ObjectConsExpr:<span class="cov3" title="3">
                                arrEx["_kics__default"] = &amp;model.LineObject{
                                        Line: ex.Range().Start.Line + 1,
                                }
                                // set lines for array elements
                                for _, item := range valType.Items </span><span class="cov4" title="6">{
                                        key, err := c.convertKey(item.KeyExpr)
                                        if err != nil </span><span class="cov0" title="0">{
                                                sentryReport.ReportSentry(&amp;sentryReport.Report{
                                                        Location: "func getArrLines",
                                                        Err:      err,
                                                        Kind:     model.KindTerraform,
                                                        Message:  "Failed to convert key in terraform parser",
                                                }, false)
                                                return nil
                                        }</span>
                                        <span class="cov4" title="6">arrEx["_kics_"+key] = &amp;model.LineObject{
                                                Line: item.KeyExpr.Range().Start.Line,
                                        }</span>
                                }
                        case *hclsyntax.TupleConsExpr:<span class="cov0" title="0">
                                // set lines for array elements if type is different than array, map/object
                                arrEx["_kics__default"] = &amp;model.LineObject{
                                        Arr: c.getArrLines(valType),
                                }</span>
                        }

                        <span class="cov5" title="7">arr = append(arr, arrEx)</span>
                }
        }
        <span class="cov8" title="33">return arr</span>
}

func (c *converter) convertBlock(block *hclsyntax.Block, out model.Document, defLine int) error <span class="cov6" title="15">{
        var key = block.Type
        value, err := c.convertBody(block.Body, defLine)

        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>

        <span class="cov6" title="15">if value == nil </span><span class="cov0" title="0">{
                return nil
        }</span>

        <span class="cov6" title="15">for _, label := range block.Labels </span><span class="cov6" title="14">{
                if inner, exists := out[key]; exists </span><span class="cov2" title="2">{
                        var ok bool
                        out, ok = inner.(model.Document)
                        if !ok </span><span class="cov0" title="0">{
                                return fmt.Errorf("unable to convert Block to JSON: %v.%v", block.Type, strings.Join(block.Labels, "."))
                        }</span>
                } else<span class="cov6" title="12"> {
                        obj := make(model.Document)
                        out[key] = obj
                        out = obj
                }</span>
                <span class="cov6" title="14">key = label</span>
        }

        <span class="cov6" title="15">if current, exists := out[key]; exists </span><span class="cov3" title="3">{
                if list, ok := current.([]interface{}); ok </span><span class="cov1" title="1">{
                        out[key] = append(list, value)
                }</span> else<span class="cov2" title="2"> {
                        out[key] = []interface{}{current, value}
                }</span>
        } else<span class="cov6" title="12"> {
                out[key] = value
        }</span>

        <span class="cov6" title="15">return nil</span>
}

func (c *converter) convertExpression(expr hclsyntax.Expression) (interface{}, error) <span class="cov10" title="60">{
        // assume it is hcl syntax (because, um, it is)
        switch value := expr.(type) </span>{
        case *hclsyntax.LiteralValueExpr:<span class="cov6" title="10">
                return ctyjson.SimpleJSONValue{Value: value.Val}, nil</span>
        case *hclsyntax.TemplateExpr:<span class="cov7" title="23">
                return c.convertTemplate(value)</span>
        case *hclsyntax.TemplateWrapExpr:<span class="cov2" title="2">
                return c.convertExpression(value.Wrapped)</span>
        case *hclsyntax.TupleConsExpr:<span class="cov2" title="2">
                list := make([]interface{}, 0)
                for _, ex := range value.Exprs </span><span class="cov5" title="7">{
                        elem, err := c.convertExpression(ex)
                        if err != nil </span><span class="cov0" title="0">{
                                sentryReport.ReportSentry(&amp;sentryReport.Report{
                                        Location: "func convertExpression",
                                        Err:      err,
                                        Kind:     model.KindTerraform,
                                        Message:  "Failed to convert expression in terraform parser",
                                }, false)
                                return nil, err
                        }</span>
                        <span class="cov5" title="7">list = append(list, elem)</span>
                }
                <span class="cov2" title="2">return list, nil</span>
        case *hclsyntax.ObjectConsExpr:<span class="cov4" title="5">
                return c.objectConsExpr(value)</span>
        case *hclsyntax.FunctionCallExpr:<span class="cov4" title="6">
                return c.evalFunction(expr)</span>
        case *hclsyntax.ConditionalExpr:<span class="cov1" title="1">
                expressionEvaluated, err := expr.Value(&amp;hcl.EvalContext{
                        Variables: inputVarMap,
                        Functions: functions.TerraformFuncs,
                })
                if err != nil </span><span class="cov1" title="1">{
                        sentryReport.ReportSentry(&amp;sentryReport.Report{
                                Location: "func convertExpression",
                                Err:      err,
                                Kind:     model.KindTerraform,
                                Message:  "Failed to get value in terraform parser",
                        }, false)
                        return c.wrapExpr(expr)
                }</span>
                <span class="cov0" title="0">return ctyjson.SimpleJSONValue{Value: expressionEvaluated}, nil</span>
        default:<span class="cov6" title="11">
                // try to evaluate with variables and functions
                valueConverted, _ := expr.Value(&amp;hcl.EvalContext{
                        Variables: inputVarMap,
                        Functions: functions.TerraformFuncs,
                })
                if !valueConverted.Type().HasDynamicTypes() &amp;&amp; valueConverted.IsKnown() </span><span class="cov4" title="6">{
                        return ctyjson.SimpleJSONValue{Value: valueConverted}, nil
                }</span>
                <span class="cov4" title="5">return c.wrapExpr(expr)</span>
        }
}

func (c *converter) objectConsExpr(value *hclsyntax.ObjectConsExpr) (model.Document, error) <span class="cov4" title="5">{
        m := make(model.Document)
        for _, item := range value.Items </span><span class="cov7" title="18">{
                key, err := c.convertKey(item.KeyExpr)
                if err != nil </span><span class="cov0" title="0">{
                        sentryReport.ReportSentry(&amp;sentryReport.Report{
                                Location: "func objectConsExpr",
                                Err:      err,
                                Kind:     model.KindTerraform,
                                Message:  "Failed to convert key in terraform parser",
                        }, false)
                        return nil, err
                }</span>
                <span class="cov7" title="18">m[key], err = c.convertExpression(item.ValueExpr)
                if err != nil </span><span class="cov0" title="0">{
                        sentryReport.ReportSentry(&amp;sentryReport.Report{
                                Location: "func objectConsExpr",
                                Err:      err,
                                Kind:     model.KindTerraform,
                                Message:  "Failed to convert expression in terraform parser",
                        }, false)
                        return nil, err
                }</span>
        }
        <span class="cov4" title="5">return m, nil</span>
}

func (c *converter) convertKey(keyExpr hclsyntax.Expression) (string, error) <span class="cov7" title="24">{
        // a key should never have dynamic input
        if k, isKeyExpr := keyExpr.(*hclsyntax.ObjectConsKeyExpr); isKeyExpr </span><span class="cov7" title="24">{
                keyExpr = k.Wrapped
                if _, isTraversal := keyExpr.(*hclsyntax.ScopeTraversalExpr); isTraversal </span><span class="cov7" title="20">{
                        return c.rangeSource(keyExpr.Range()), nil
                }</span>
        }
        <span class="cov4" title="4">return c.convertStringPart(keyExpr)</span>
}

func (c *converter) convertTemplate(t *hclsyntax.TemplateExpr) (string, error) <span class="cov8" title="31">{
        if t.IsStringLiteral() </span><span class="cov7" title="24">{
                // safe because the value is just the string
                v, err := t.Value(nil)
                if err != nil </span><span class="cov0" title="0">{
                        sentryReport.ReportSentry(&amp;sentryReport.Report{
                                Location: "func convertTemplate",
                                Err:      err,
                                Kind:     model.KindTerraform,
                                Message:  "Failed to get value in terraform parser",
                        }, false)
                        return "", err
                }</span>
                <span class="cov7" title="24">return v.AsString(), nil</span>
        }
        <span class="cov5" title="7">builder := &amp;strings.Builder{}
        for _, part := range t.Parts </span><span class="cov7" title="23">{
                s, err := c.convertStringPart(part)
                if err != nil </span><span class="cov0" title="0">{
                        sentryReport.ReportSentry(&amp;sentryReport.Report{
                                Location: "func convertTemplate",
                                Err:      err,
                                Kind:     model.KindTerraform,
                                Message:  "Failed to convert string part in terraform parser",
                        }, false)
                        return "", err
                }</span>
                <span class="cov7" title="23">builder.WriteString(s)</span>
        }

        <span class="cov5" title="7">s := builder.String()

        builder.Reset()
        builder = nil

        return s, nil</span>
}

func (c *converter) convertStringPart(expr hclsyntax.Expression) (string, error) <span class="cov8" title="33">{
        switch v := expr.(type) </span>{
        case *hclsyntax.LiteralValueExpr:<span class="cov6" title="15">
                s, err := ctyconvert.Convert(v.Val, cty.String)
                if err != nil </span><span class="cov0" title="0">{
                        sentryReport.ReportSentry(&amp;sentryReport.Report{
                                Location: "func convertStringPart",
                                Err:      err,
                                Kind:     model.KindTerraform,
                                Message:  "Failed to cty convert in terraform parser",
                        }, false)
                        return "", err
                }</span>
                <span class="cov6" title="15">return s.AsString(), nil</span>
        case *hclsyntax.TemplateExpr:<span class="cov5" title="8">
                return c.convertTemplate(v)</span>
        case *hclsyntax.TemplateWrapExpr:<span class="cov1" title="1">
                return c.convertStringPart(v.Wrapped)</span>
        case *hclsyntax.ConditionalExpr:<span class="cov2" title="2">
                return c.convertTemplateConditional(v)</span>
        case *hclsyntax.TemplateJoinExpr:<span class="cov1" title="1">
                return c.convertTemplateFor(v.Tuple.(*hclsyntax.ForExpr))</span>
        case *hclsyntax.ParenthesesExpr:<span class="cov0" title="0">
                return c.convertStringPart(v.Expression)</span>
        default:<span class="cov4" title="6">
                // try to evaluate with variables
                valueConverted, _ := expr.Value(&amp;hcl.EvalContext{
                        Variables: inputVarMap,
                })
                if valueConverted.Type().FriendlyName() == "string" </span><span class="cov1" title="1">{
                        return valueConverted.AsString(), nil
                }</span>
                // treating as an embedded expression
                <span class="cov4" title="5">return c.wrapExpr(expr)</span>
        }
}

func (c *converter) convertTemplateConditional(expr *hclsyntax.ConditionalExpr) (string, error) <span class="cov2" title="2">{
        builder := &amp;strings.Builder{}
        builder.WriteString("%{if ")
        builder.WriteString(c.rangeSource(expr.Condition.Range()))
        builder.WriteString("}")
        trueResult, err := c.convertStringPart(expr.TrueResult)
        if err != nil </span><span class="cov0" title="0">{
                sentryReport.ReportSentry(&amp;sentryReport.Report{
                        Location: "func convertTemplateConditional",
                        Err:      err,
                        Kind:     model.KindTerraform,
                        Message:  "Failed to convert string part terraform parser",
                }, false)
                return "", nil
        }</span>
        <span class="cov2" title="2">builder.WriteString(trueResult)
        falseResult, err := c.convertStringPart(expr.FalseResult)
        if err != nil </span><span class="cov0" title="0">{
                sentryReport.ReportSentry(&amp;sentryReport.Report{
                        Location: "func convertTemplateConditional",
                        Err:      err,
                        Kind:     model.KindTerraform,
                        Message:  "Failed to convert string part terraform parser",
                }, false)
                return "", nil
        }</span>
        <span class="cov2" title="2">if len(falseResult) &gt; 0 </span><span class="cov1" title="1">{
                builder.WriteString("%{else}")
                builder.WriteString(falseResult)
        }</span>
        <span class="cov2" title="2">builder.WriteString("%{endif}")

        s := builder.String()

        builder.Reset()
        builder = nil

        return s, nil</span>
}

func (c *converter) convertTemplateFor(expr *hclsyntax.ForExpr) (string, error) <span class="cov1" title="1">{
        builder := &amp;strings.Builder{}
        builder.WriteString("%{for ")
        if len(expr.KeyVar) &gt; 0 </span><span class="cov0" title="0">{
                builder.WriteString(expr.KeyVar)
                builder.WriteString(", ")
        }</span>
        <span class="cov1" title="1">builder.WriteString(expr.ValVar)
        builder.WriteString(" in ")
        builder.WriteString(c.rangeSource(expr.CollExpr.Range()))
        builder.WriteString("}")
        templ, err := c.convertStringPart(expr.ValExpr)
        if err != nil </span><span class="cov0" title="0">{
                sentryReport.ReportSentry(&amp;sentryReport.Report{
                        Location: "func convertTemplateFor",
                        Err:      err,
                        Kind:     model.KindTerraform,
                        Message:  "Failed to convert string part terraform parser",
                }, false)
                return "", err
        }</span>
        <span class="cov1" title="1">builder.WriteString(templ)
        builder.WriteString("%{endfor}")

        s := builder.String()

        builder.Reset()
        builder = nil
        return s, nil</span>
}

func (c *converter) wrapExpr(expr hclsyntax.Expression) (string, error) <span class="cov6" title="11">{
        expression := c.rangeSource(expr.Range())
        if strings.HasPrefix(expression, "var.") </span><span class="cov3" title="3">{
                log.Trace().Msgf("Variable ${%s} value not found", expression)
        }</span>
        <span class="cov6" title="11">return "${" + expression + "}", nil</span>
}

func (c *converter) evalFunction(expression hclsyntax.Expression) (interface{}, error) <span class="cov4" title="6">{
        expressionEvaluated, err := expression.Value(&amp;hcl.EvalContext{
                Variables: inputVarMap,
                Functions: functions.TerraformFuncs,
        })
        if err != nil </span><span class="cov1" title="1">{
                for _, expressionError := range err </span><span class="cov1" title="1">{
                        if expressionError.Summary == "Unknown variable" </span><span class="cov1" title="1">{
                                jsonPath := c.rangeSource(expressionError.Expression.Range())
                                rootKey := strings.Split(jsonPath, ".")[0]
                                if strings.Contains(jsonPath, ".") </span><span class="cov1" title="1">{
                                        jsonCtyValue, convertErr := createEntryInputVar(strings.Split(jsonPath, ".")[1:], jsonPath)
                                        if convertErr != nil </span><span class="cov0" title="0">{
                                                return c.wrapExpr(expression)
                                        }</span>
                                        <span class="cov1" title="1">inputVarMap[rootKey] = jsonCtyValue</span>
                                } else<span class="cov0" title="0"> {
                                        inputVarMap[rootKey] = cty.StringVal(jsonPath)
                                }</span>
                        }
                }
                <span class="cov1" title="1">expressionEvaluated, err = expression.Value(&amp;hcl.EvalContext{
                        Variables: inputVarMap,
                        Functions: functions.TerraformFuncs,
                })
                if err != nil </span><span class="cov0" title="0">{
                        return c.wrapExpr(expression)
                }</span>
        }
        <span class="cov4" title="6">return ctyjson.SimpleJSONValue{Value: expressionEvaluated}, nil</span>
}

func createEntryInputVar(path []string, defaultValue string) (cty.Value, error) <span class="cov1" title="1">{
        mapJSON := "{"
        closeMap := "}"
        for idx, key := range path </span><span class="cov1" title="1">{
                if idx+1 &lt; len(path) </span><span class="cov0" title="0">{
                        mapJSON += fmt.Sprintf("%q:{", key)
                        closeMap += "}"
                }</span> else<span class="cov1" title="1"> {
                        mapJSON += fmt.Sprintf("%q: %q", key, defaultValue)
                }</span>
        }
        <span class="cov1" title="1">mapJSON += closeMap
        jsonType, err := ctyjson.ImpliedType([]byte(mapJSON))
        if err != nil </span><span class="cov0" title="0">{
                return cty.NilVal, err
        }</span>
        <span class="cov1" title="1">value, err := ctyjson.Unmarshal([]byte(mapJSON), jsonType)
        if err != nil </span><span class="cov0" title="0">{
                return cty.NilVal, err
        }</span>
        <span class="cov1" title="1">return value, nil</span>
}
</pre>
		
		<pre class="file" id="file72" style="display: none">package terraform

import (
        "bytes"
        "encoding/json"
        "path/filepath"
        "sync"

        "github.com/Checkmarx/kics/pkg/builder/engine"
        "github.com/Checkmarx/kics/pkg/parser/terraform/functions"
        "github.com/hashicorp/hcl/v2"
        "github.com/hashicorp/hcl/v2/hcldec"
        "github.com/hashicorp/hcl/v2/hclsyntax"
        "github.com/rs/zerolog/log"
        "github.com/zclconf/go-cty/cty"
        "github.com/zclconf/go-cty/cty/gocty"
        ctyjson "github.com/zclconf/go-cty/cty/json"
)

type dataSourcePolicyCondition struct {
        Test     string   `json:"test,omitempty"`
        Variable string   `json:"variable,omitempty"`
        Values   []string `json:"values,omitempty"`
}

type dataSourcePolicyPrincipal struct {
        Type        string   `json:"type,omitempty"`
        Identifiers []string `json:"identifiers,omitempty"`
}

type dataSourcePolicyStatement struct {
        Actions       []string                  `json:"actions"`
        Condition     dataSourcePolicyCondition `json:"condition"`
        Effect        string                    `json:"effect"`
        NotActions    []string                  `json:"not_actions"`
        NotPrincipals dataSourcePolicyPrincipal `json:"not_principals"`
        NotResources  []string                  `json:"not_resources"`
        Principals    dataSourcePolicyPrincipal `json:"principals"`
        Resources     []string                  `json:"resources"`
        Sid           string                    `json:"sid"`
}

type dataSourcePolicy struct {
        ID        string                      `json:"id"`
        Statement []dataSourcePolicyStatement `json:"statement"`
        Version   string                      `json:"version"`
}

type dataSource struct {
        Value dataSourcePolicy `json:"value"`
}

type convertedPolicyCondition map[string]map[string][]string
type convertedPolicyPrincipal map[string][]string

type convertedPolicyStatement struct {
        Actions       []string                 `json:"Actions,omitempty"`
        Condition     convertedPolicyCondition `json:"Condition,omitempty"`
        Effect        string                   `json:"Effect,omitempty"`
        NotActions    []string                 `json:"Not_actions,omitempty"`
        NotPrincipals convertedPolicyPrincipal `json:"Not_principals,omitempty"`
        NotResources  []string                 `json:"Not_resources,omitempty"`
        Principals    convertedPolicyPrincipal `json:"Principals,omitempty"`
        Resources     []string                 `json:"Resources,omitempty"`
        Sid           string                   `json:"Sid,omitempty"`
}

type convertedPolicy struct {
        ID        string                     `json:"Id,omitempty"`
        Statement []convertedPolicyStatement `json:"Statement,omitempty"`
        Version   string                     `json:"Version,omitempty"`
}

var mutexData = &amp;sync.Mutex{}

func getDataSourcePolicy(currentPath string) <span class="cov5" title="3">{
        tfFiles, err := filepath.Glob(filepath.Join(currentPath, "*.tf"))
        if err != nil </span><span class="cov0" title="0">{
                log.Error().Msg("Error getting .tf files to parse data source")
                return
        }</span>
        <span class="cov5" title="3">if len(tfFiles) == 0 </span><span class="cov1" title="1">{
                return
        }</span>
        <span class="cov4" title="2">jsonMap := make(map[string]map[string]string)
        for _, tfFile := range tfFiles </span><span class="cov7" title="4">{
                parsedFile, parseErr := parseFile(tfFile, true)
                if parseErr != nil </span><span class="cov0" title="0">{
                        log.Debug().Msgf("Error trying to parse file %s for data source.", tfFile)
                        continue</span>
                }
                <span class="cov7" title="4">body, ok := parsedFile.Body.(*hclsyntax.Body)
                if !ok </span><span class="cov0" title="0">{
                        continue</span>
                }
                <span class="cov7" title="4">for _, block := range body.Blocks </span><span class="cov10" title="8">{
                        if block.Type == "data" &amp;&amp; block.Labels[0] == "aws_iam_policy_document" &amp;&amp; len(block.Labels) &gt; 1 </span><span class="cov7" title="4">{
                                policyJSON := parseDataSourceBody(block.Body)
                                jsonMap[block.Labels[1]] = map[string]string{
                                        "json": policyJSON,
                                }
                        }</span>
                }
        }
        <span class="cov4" title="2">policyResource := map[string]map[string]map[string]string{
                "aws_iam_policy_document": jsonMap,
        }
        data, err := gocty.ToCtyValue(policyResource, cty.Map(cty.Map(cty.Map(cty.String))))
        if err != nil </span><span class="cov0" title="0">{
                log.Error().Msgf("Error trying to convert policy to cty value: %s", err)
                return
        }</span>

        <span class="cov4" title="2">mutexData.Lock()
        inputVariableMap["data"] = data
        mutexData.Unlock()</span>
}

func decodeDataSourcePolicy(value cty.Value) dataSourcePolicy <span class="cov7" title="4">{
        jsonified, err := ctyjson.Marshal(value, cty.DynamicPseudoType)
        if err != nil </span><span class="cov0" title="0">{
                log.Error().Msgf("Error trying to decode data source block: %s", err)
                return dataSourcePolicy{}
        }</span>
        <span class="cov7" title="4">var data dataSource
        err = json.Unmarshal(jsonified, &amp;data)
        if err != nil </span><span class="cov0" title="0">{
                log.Error().Msgf("Error trying to encode data source json: %s", err)
                return dataSourcePolicy{}
        }</span>
        <span class="cov7" title="4">return data.Value</span>
}

func getPrincipalSpec() *hcldec.ObjectSpec <span class="cov10" title="8">{
        return &amp;hcldec.ObjectSpec{
                "type": &amp;hcldec.AttrSpec{
                        Name:     "type",
                        Type:     cty.String,
                        Required: false,
                },
                "identifiers": &amp;hcldec.AttrSpec{
                        Name:     "identifiers",
                        Type:     cty.List(cty.String),
                        Required: false,
                },
        }
}</span>

func getConditionalSpec() *hcldec.ObjectSpec <span class="cov7" title="4">{
        return &amp;hcldec.ObjectSpec{
                "test": &amp;hcldec.AttrSpec{
                        Name:     "test",
                        Type:     cty.String,
                        Required: false,
                },
                "variable": &amp;hcldec.AttrSpec{
                        Name:     "variable",
                        Type:     cty.String,
                        Required: false,
                },
                "values": &amp;hcldec.AttrSpec{
                        Name:     "values",
                        Type:     cty.List(cty.String),
                        Required: false,
                },
        }
}</span>

func getStatementSpec() *hcldec.BlockListSpec <span class="cov7" title="4">{
        return &amp;hcldec.BlockListSpec{
                TypeName: "statement",
                Nested: &amp;hcldec.ObjectSpec{
                        "sid": &amp;hcldec.AttrSpec{
                                Name:     "sid",
                                Type:     cty.String,
                                Required: false,
                        },
                        "effect": &amp;hcldec.AttrSpec{
                                Name:     "effect",
                                Type:     cty.String,
                                Required: false,
                        },
                        "actions": &amp;hcldec.AttrSpec{
                                Name:     "actions",
                                Type:     cty.List(cty.String),
                                Required: false,
                        },
                        "not_actions": &amp;hcldec.AttrSpec{
                                Name:     "not_actions",
                                Type:     cty.List(cty.String),
                                Required: false,
                        },
                        "resources": &amp;hcldec.AttrSpec{
                                Name:     "resources",
                                Type:     cty.List(cty.String),
                                Required: false,
                        },
                        "not_resources": &amp;hcldec.AttrSpec{
                                Name:     "not_resources",
                                Type:     cty.List(cty.String),
                                Required: false,
                        },
                        "principals": &amp;hcldec.BlockSpec{
                                TypeName: "principals",
                                Nested:   getPrincipalSpec(),
                        },
                        "not_principals": &amp;hcldec.BlockSpec{
                                TypeName: "not_principals",
                                Nested:   getPrincipalSpec(),
                        },
                        "condition": &amp;hcldec.BlockSpec{
                                TypeName: "condition",
                                Nested:   getConditionalSpec(),
                        },
                },
        }
}</span>

func parseDataSourceBody(body *hclsyntax.Body) string <span class="cov7" title="4">{
        dataSourceSpec := &amp;hcldec.ObjectSpec{
                "id": &amp;hcldec.AttrSpec{
                        Name:     "id",
                        Type:     cty.String,
                        Required: false,
                },
                "version": &amp;hcldec.AttrSpec{
                        Name:     "version",
                        Type:     cty.String,
                        Required: false,
                },
                "statement": getStatementSpec(),
        }

        resolveDataResources(body)

        target, decodeErrs := hcldec.Decode(body, dataSourceSpec, &amp;hcl.EvalContext{
                Variables: inputVariableMap,
                Functions: functions.TerraformFuncs,
        })

        // check decode errors
        for _, decErr := range decodeErrs </span><span class="cov0" title="0">{
                if decErr.Summary != "Unknown variable" </span><span class="cov0" title="0">{
                        log.Debug().Msgf("Error trying to eval data source block: %s", decErr.Summary)
                        return ""
                }</span>
                <span class="cov0" title="0">log.Debug().Msg("Dismissed Error when decoding policy: Found unknown variable")</span>
        }

        <span class="cov7" title="4">dataSourceJSON := decodeDataSourcePolicy(target)
        convertedDataSource := convertedPolicy{
                ID:      dataSourceJSON.ID,
                Version: dataSourceJSON.Version,
        }
        statements := make([]convertedPolicyStatement, len(dataSourceJSON.Statement))
        for idx := range dataSourceJSON.Statement </span><span class="cov10" title="8">{
                var convertedCondition convertedPolicyCondition
                if dataSourceJSON.Statement[idx].Condition.Variable != "" </span><span class="cov4" title="2">{
                        convertedCondition = convertedPolicyCondition{
                                dataSourceJSON.Statement[idx].Condition.Test: map[string][]string{
                                        dataSourceJSON.Statement[idx].Condition.Variable: dataSourceJSON.Statement[idx].Condition.Values,
                                },
                        }
                }</span>
                <span class="cov10" title="8">var convertedPrincipal convertedPolicyPrincipal
                if dataSourceJSON.Statement[idx].Principals.Type != "" </span><span class="cov4" title="2">{
                        convertedPrincipal = convertedPolicyPrincipal{
                                dataSourceJSON.Statement[idx].Principals.Type: dataSourceJSON.Statement[idx].Principals.Identifiers,
                        }
                }</span>
                <span class="cov10" title="8">var convertedNotPrincipal convertedPolicyPrincipal
                if dataSourceJSON.Statement[idx].NotPrincipals.Type != "" </span><span class="cov0" title="0">{
                        convertedNotPrincipal = convertedPolicyPrincipal{
                                dataSourceJSON.Statement[idx].NotPrincipals.Type: dataSourceJSON.Statement[idx].NotPrincipals.Identifiers,
                        }
                }</span>

                <span class="cov10" title="8">convertedStatement := convertedPolicyStatement{
                        Actions:       dataSourceJSON.Statement[idx].Actions,
                        Effect:        dataSourceJSON.Statement[idx].Effect,
                        NotActions:    dataSourceJSON.Statement[idx].NotActions,
                        NotResources:  dataSourceJSON.Statement[idx].NotResources,
                        Resources:     dataSourceJSON.Statement[idx].Resources,
                        Sid:           dataSourceJSON.Statement[idx].Sid,
                        Condition:     convertedCondition,
                        NotPrincipals: convertedNotPrincipal,
                        Principals:    convertedPrincipal,
                }
                statements[idx] = convertedStatement</span>
        }
        <span class="cov7" title="4">convertedDataSource.Statement = statements
        buffer := &amp;bytes.Buffer{}
        encoder := json.NewEncoder(buffer)
        encoder.SetEscapeHTML(false)
        err := encoder.Encode(convertedDataSource)
        if err != nil </span><span class="cov0" title="0">{
                log.Error().Msgf("Error trying to encoding data source json: %s", err)
                return ""
        }</span>
        <span class="cov7" title="4">return buffer.String()</span>
}

// resolveDataResources resolves the data resources expressions into LiteralValueExpr
func resolveDataResources(body *hclsyntax.Body) <span class="cov7" title="4">{
        for _, block := range body.Blocks </span><span class="cov10" title="8">{
                if resources, ok := block.Body.Attributes["resources"]; ok &amp;&amp;
                        block.Type == "statement" </span><span class="cov8" title="6">{
                        resolveTuple(resources.Expr)
                }</span>
        }
}

func resolveTuple(expr hclsyntax.Expression) <span class="cov8" title="6">{
        e := engine.Engine{}
        if v, ok := expr.(*hclsyntax.TupleConsExpr); ok </span><span class="cov8" title="6">{
                for i, ex := range v.Exprs </span><span class="cov10" title="8">{
                        striExpr, err := e.ExpToString(ex)

                        if err != nil </span><span class="cov0" title="0">{
                                log.Error().Msgf("Error trying to ExpToString: %s", err)
                        }</span>

                        <span class="cov10" title="8">v.Exprs[i] = &amp;hclsyntax.LiteralValueExpr{
                                Val:      cty.StringVal(striExpr),
                                SrcRange: v.Exprs[i].Range(),
                        }</span>
                }
        }
}
</pre>
		
		<pre class="file" id="file73" style="display: none">package terraform

import (
        "os"
        "path/filepath"
        "regexp"

        "github.com/Checkmarx/kics/pkg/model"
        "github.com/Checkmarx/kics/pkg/parser/terraform/comment"
        "github.com/Checkmarx/kics/pkg/parser/terraform/converter"
        "github.com/Checkmarx/kics/pkg/parser/utils"
        "github.com/hashicorp/hcl/v2"
        "github.com/hashicorp/hcl/v2/hclsyntax"
        "github.com/pkg/errors"
        "github.com/rs/zerolog/log"
        ctyjson "github.com/zclconf/go-cty/cty/json"
)

// RetriesDefaultValue is default number of times a parser will retry to execute
const RetriesDefaultValue = 50

// Converter returns content json, error line, error
type Converter func(file *hcl.File, inputVariables converter.VariableMap) (model.Document, error)

// Parser struct that contains the function to parse file and the number of retries if something goes wrong
type Parser struct {
        convertFunc  Converter
        numOfRetries int
}

// NewDefault initializes a parser with Parser default values
func NewDefault() *Parser <span class="cov4" title="4">{
        return &amp;Parser{
                numOfRetries: RetriesDefaultValue,
                convertFunc:  converter.DefaultConverted,
        }
}</span>

// Resolve - replace or modifies in-memory content before parsing
func (p *Parser) Resolve(fileContent []byte, filename string) ([]byte, error) <span class="cov1" title="1">{
        getInputVariables(filepath.Dir(filename))
        getDataSourcePolicy(filepath.Dir(filename))
        return fileContent, nil
}</span>

func processContent(elements model.Document, content, path string) <span class="cov1" title="1">{
        var certInfo map[string]interface{}
        if content != "" </span><span class="cov1" title="1">{
                certInfo = utils.AddCertificateInfo(path, content)
                if certInfo != nil </span><span class="cov1" title="1">{
                        elements["certificate_body"] = certInfo
                }</span>
        }
}

func processElements(elements model.Document, path string) <span class="cov2" title="2">{
        for k, v3 := range elements </span><span class="cov7" title="9">{ // resource elements
                if k != "certificate_body" </span><span class="cov7" title="9">{
                        continue</span>
                }
                <span class="cov0" title="0">switch value := v3.(type) </span>{
                case string:<span class="cov0" title="0">
                        content := utils.CheckCertificate(value)
                        processContent(elements, content, path)</span>
                case ctyjson.SimpleJSONValue:<span class="cov0" title="0">
                        content := utils.CheckCertificate(value.Value.AsString())
                        processContent(elements, content, path)</span>
                }
        }
}

func processResources(doc model.Document, path string) error <span class="cov2" title="2">{
        var resourcesElements model.Document
        for _, resources := range doc </span><span class="cov2" title="2">{ // iterate over resources
                resourcesElements = resources.(model.Document)
                for _, v2 := range resourcesElements </span><span class="cov2" title="2">{ // resource name
                        switch t := v2.(type) </span>{
                        case []interface{}:<span class="cov0" title="0">
                                return errors.New("failed to process resources")</span>
                        case interface{}:<span class="cov2" title="2">
                                if elements, ok := t.(model.Document); ok </span><span class="cov2" title="2">{
                                        processElements(elements, path)
                                }</span>
                        }
                }
        }
        <span class="cov2" title="2">return nil</span>
}

func addExtraInfo(json []model.Document, path string) ([]model.Document, error) <span class="cov4" title="3">{
        for _, documents := range json </span><span class="cov4" title="3">{ // iterate over documents
                if resources, ok := documents["resource"].(model.Document); ok </span><span class="cov2" title="2">{
                        err := processResources(resources, path)
                        if err != nil </span><span class="cov0" title="0">{
                                return []model.Document{}, err
                        }</span>
                }
        }

        <span class="cov4" title="3">return json, nil</span>
}

func parseFile(filename string, shouldReplaceDataSource bool) (*hcl.File, error) <span class="cov10" title="23">{
        file, err := os.ReadFile(filename)
        if err != nil </span><span class="cov4" title="3">{
                return nil, err
        }</span>
        <span class="cov9" title="20">if shouldReplaceDataSource </span><span class="cov5" title="5">{
                replaceDataIdentifiers := regexp.MustCompile(`(data\.[A-Za-z0-9._-]+)`)
                file = []byte(replaceDataIdentifiers.ReplaceAllString(string(file), "\"$1\""))
        }</span>
        <span class="cov9" title="20">parsedFile, _ := hclsyntax.ParseConfig(file, filename, hcl.Pos{Line: 1, Column: 1})

        return parsedFile, nil</span>
}

// Parse execute parser for the content in a file
func (p *Parser) Parse(path string, content []byte) ([]model.Document, []int, error) <span class="cov4" title="3">{
        file, diagnostics := hclsyntax.ParseConfig(content, filepath.Base(path), hcl.Pos{Byte: 0, Line: 1, Column: 1})
        if diagnostics != nil &amp;&amp; diagnostics.HasErrors() &amp;&amp; len(diagnostics.Errs()) &gt; 0 </span><span class="cov0" title="0">{
                err := diagnostics.Errs()[0]
                return nil, []int{}, err
        }</span>

        <span class="cov4" title="3">ignore, err := comment.ParseComments(content, path)
        if err != nil </span><span class="cov0" title="0">{
                log.Err(err).Msg("failed to parse comments")
        }</span>

        <span class="cov4" title="3">linesToIgnore := comment.GetIgnoreLines(ignore, file.Body.(*hclsyntax.Body))

        fc, parseErr := p.convertFunc(file, inputVariableMap)
        json, err := addExtraInfo([]model.Document{fc}, path)
        if err != nil </span><span class="cov0" title="0">{
                return json, []int{}, errors.Wrap(err, "failed terraform parse")
        }</span>

        <span class="cov4" title="3">return json, linesToIgnore, errors.Wrap(parseErr, "failed terraform parse")</span>
}

// SupportedExtensions returns Terraform extensions
func (p *Parser) SupportedExtensions() []string <span class="cov1" title="1">{
        return []string{".tf", ".tfvars"}
}</span>

// SupportedTypes returns types supported by this parser, which are terraform
func (p *Parser) SupportedTypes() map[string]bool <span class="cov1" title="1">{
        return map[string]bool{"terraform": true}
}</span>

// GetKind returns Terraform kind parser
func (p *Parser) GetKind() model.FileKind <span class="cov1" title="1">{
        return model.KindTerraform
}</span>

// GetCommentToken return the comment token of Terraform - #
func (p *Parser) GetCommentToken() string <span class="cov1" title="1">{
        return "#"
}</span>

// StringifyContent converts original content into string formated version
func (p *Parser) StringifyContent(content []byte) (string, error) <span class="cov1" title="1">{
        return string(content), nil
}</span>

// GetResolvedFiles returns the files that are resolved
func (p *Parser) GetResolvedFiles() map[string]model.ResolvedFile <span class="cov1" title="1">{
        return make(map[string]model.ResolvedFile)
}</span>
</pre>
		
		<pre class="file" id="file74" style="display: none">package terraform

import (
        "fmt"
        "os"
        "path/filepath"

        "github.com/Checkmarx/kics/pkg/parser/terraform/converter"
        "github.com/hashicorp/hcl/v2"
        "github.com/hashicorp/hcl/v2/hclsyntax"
        "github.com/rs/zerolog/log"
        "github.com/zclconf/go-cty/cty"
)

var inputVariableMap = make(converter.VariableMap)

func mergeMaps(baseMap, newItems converter.VariableMap) <span class="cov9" title="8">{
        for key, value := range newItems </span><span class="cov10" title="9">{
                baseMap[key] = value
        }</span>
}

func setInputVariablesDefaultValues(filename string) (converter.VariableMap, error) <span class="cov10" title="9">{
        parsedFile, err := parseFile(filename, false)
        if err != nil || parsedFile == nil </span><span class="cov1" title="1">{
                return nil, err
        }</span>
        <span class="cov9" title="8">content, _, _ := parsedFile.Body.PartialContent(&amp;hcl.BodySchema{
                Blocks: []hcl.BlockHeaderSchema{
                        {
                                Type:       "variable",
                                LabelNames: []string{"name"},
                        },
                },
        })

        defaultValuesMap := make(converter.VariableMap)
        for _, block := range content.Blocks </span><span class="cov10" title="9">{
                if len(block.Labels) == 0 || block.Labels[0] == "" </span><span class="cov3" title="2">{
                        continue</span>
                }
                <span class="cov8" title="7">attr, _ := block.Body.JustAttributes()
                if len(attr) == 0 </span><span class="cov3" title="2">{
                        continue</span>
                }
                <span class="cov7" title="5">if defaultValue, exists := attr["default"]; exists </span><span class="cov7" title="5">{
                        defaultVar, _ := defaultValue.Expr.Value(nil)
                        defaultValuesMap[block.Labels[0]] = defaultVar
                }</span>
        }
        <span class="cov9" title="8">return defaultValuesMap, nil</span>
}

func checkTfvarsValid(f *hcl.File, filename string) error <span class="cov7" title="5">{
        content, _, _ := f.Body.PartialContent(&amp;hcl.BodySchema{
                Blocks: []hcl.BlockHeaderSchema{
                        {
                                Type:       "variable",
                                LabelNames: []string{"name"},
                        },
                },
        })
        if len(content.Blocks) &gt; 0 </span><span class="cov3" title="2">{
                return fmt.Errorf("failed to get variables from %s, .tfvars file is used to assing values not to declare new variables", filename)
        }</span>
        <span class="cov5" title="3">return nil</span>
}

func getInputVariablesFromFile(filename string) (converter.VariableMap, error) <span class="cov8" title="6">{
        parsedFile, err := parseFile(filename, false)
        if err != nil || parsedFile == nil </span><span class="cov1" title="1">{
                return nil, err
        }</span>
        <span class="cov7" title="5">err = checkTfvarsValid(parsedFile, filename)
        if err != nil </span><span class="cov3" title="2">{
                return nil, err
        }</span>

        <span class="cov5" title="3">attrs := parsedFile.Body.(*hclsyntax.Body).Attributes
        variables := make(converter.VariableMap)
        for name, attr := range attrs </span><span class="cov10" title="9">{
                value, _ := attr.Expr.Value(&amp;hcl.EvalContext{})
                variables[name] = value
        }</span>
        <span class="cov5" title="3">return variables, nil</span>
}

func getInputVariables(currentPath string) <span class="cov5" title="3">{
        variablesMap := make(converter.VariableMap)
        tfFiles, err := filepath.Glob(filepath.Join(currentPath, "*.tf"))
        if err != nil </span><span class="cov0" title="0">{
                log.Error().Msg("Error getting .tf files")
        }</span>
        <span class="cov5" title="3">for _, tfFile := range tfFiles </span><span class="cov7" title="5">{
                variables, errDefaultValues := setInputVariablesDefaultValues(tfFile)
                if errDefaultValues != nil </span><span class="cov0" title="0">{
                        log.Error().Msgf("Error getting default values from %s", tfFile)
                        log.Err(errDefaultValues)
                        continue</span>
                }
                <span class="cov7" title="5">mergeMaps(variablesMap, variables)</span>
        }
        <span class="cov5" title="3">tfVarsFiles, err := filepath.Glob(filepath.Join(currentPath, "*.auto.tfvars"))
        if err != nil </span><span class="cov0" title="0">{
                log.Error().Msg("Error getting .auto.tfvars files")
        }</span>

        <span class="cov5" title="3">_, err = os.Stat(filepath.Join(currentPath, "terraform.tfvars"))
        if err != nil </span><span class="cov3" title="2">{
                log.Trace().Msgf("terraform.tfvars not found on %s", currentPath)
        }</span> else<span class="cov1" title="1"> {
                tfVarsFiles = append(tfVarsFiles, filepath.Join(currentPath, "terraform.tfvars"))
        }</span>

        <span class="cov5" title="3">for _, tfVarsFile := range tfVarsFiles </span><span class="cov5" title="3">{
                variables, errInputVariables := getInputVariablesFromFile(tfVarsFile)
                if errInputVariables != nil </span><span class="cov1" title="1">{
                        log.Error().Msgf("Error getting values from %s", tfVarsFiles)
                        log.Err(errInputVariables)
                        continue</span>
                }
                <span class="cov3" title="2">mergeMaps(variablesMap, variables)</span>
        }

        <span class="cov5" title="3">inputVariableMap["var"] = cty.ObjectVal(variablesMap)</span>
}
</pre>
		
		<pre class="file" id="file75" style="display: none">package utils

import (
        "crypto/rsa"
        "crypto/x509"
        "encoding/pem"
        "errors"
        "os"
        "path/filepath"
        "regexp"

        "github.com/rs/zerolog/log"
)

type certInfo struct {
        date        [3]int
        rsaKeyBytes int
}

// CheckCertificate verifies if the attribute 'certificate_body' refers a file
func CheckCertificate(content string) string <span class="cov1" title="1">{
        var re = regexp.MustCompile(`[0-9a-zA-Z-/\\_.]+\.pem`)

        match := re.FindString(content)

        return match
}</span>

func getCertificateInfo(filePath string) (certInfo, error) <span class="cov10" title="2">{
        certPEM, err := os.ReadFile(filePath)

        if err != nil </span><span class="cov0" title="0">{
                return certInfo{}, err
        }</span>

        <span class="cov10" title="2">block, _ := pem.Decode(certPEM)
        if block == nil </span><span class="cov0" title="0">{
                return certInfo{}, errors.New("failed to parse the certificate PEM")
        }</span>
        <span class="cov10" title="2">cert, err := x509.ParseCertificate(block.Bytes)
        if err != nil </span><span class="cov0" title="0">{
                return certInfo{}, err
        }</span>

        <span class="cov10" title="2">var certDate [3]int
        certDate[0] = cert.NotAfter.Year()
        certDate[1] = int(cert.NotAfter.Month())
        certDate[2] = cert.NotAfter.Day()

        var rsaBytes int

        switch t := cert.PublicKey.(type) </span>{
        case *rsa.PublicKey:<span class="cov10" title="2">
                _ = t
                rsaBytes = cert.PublicKey.(*rsa.PublicKey).Size()</span>
        default:<span class="cov0" title="0">
                rsaBytes = -1</span>
        }

        <span class="cov10" title="2">return certInfo{date: certDate, rsaKeyBytes: rsaBytes}, nil</span>
}

// AddCertificateInfo gets and adds certificate information of a certificate file
func AddCertificateInfo(path, content string) map[string]interface{} <span class="cov1" title="1">{
        var filePath string

        _, err := os.Stat(content)

        if err != nil </span><span class="cov1" title="1">{ // content is not a full valid path or is an incomplete path
                log.Trace().Msgf("path to the certificate content is not a valid: %s", content)
                filePath = filepath.Join(filepath.Dir(path), content)
        }</span> else<span class="cov0" title="0"> { // content is a full valid path
                filePath = content
        }</span>

        <span class="cov1" title="1">date, err := getCertificateInfo(filePath)

        if err == nil </span><span class="cov1" title="1">{
                attributes := make(map[string]interface{})
                attributes["file"] = filePath
                attributes["expiration_date"] = date.date

                if date.rsaKeyBytes != -1 </span><span class="cov1" title="1">{
                        attributes["rsa_key_bytes"] = date.rsaKeyBytes
                }</span>

                <span class="cov1" title="1">return attributes</span>
        }

        <span class="cov0" title="0">log.Error().Msgf("Failed to get certificate path %s: %s", filePath, err)

        return nil</span>
}
</pre>
		
		<pre class="file" id="file76" style="display: none">package json

import (
        "bytes"

        "github.com/Checkmarx/kics/pkg/parser/utils"

        "github.com/Checkmarx/kics/pkg/model"
        "github.com/Checkmarx/kics/pkg/resolver/file"
        "github.com/pkg/errors"
        "github.com/rs/zerolog/log"
        "gopkg.in/yaml.v3"
)

// Parser defines a parser type
type Parser struct {
        resolvedFiles map[string]model.ResolvedFile
}

// Resolve - replace or modifies in-memory content before parsing
func (p *Parser) Resolve(fileContent []byte, filename string) ([]byte, error) <span class="cov1" title="1">{
        // Resolve files passed as arguments with file resolver (e.g. file://)
        res := file.NewResolver(yaml.Unmarshal, yaml.Marshal, p.SupportedExtensions())
        resolved := res.Resolve(fileContent, filename, 0)
        p.resolvedFiles = res.ResolvedFiles
        if len(res.ResolvedFiles) == 0 </span><span class="cov1" title="1">{
                return fileContent, nil
        }</span>

        <span class="cov0" title="0">return resolved, nil</span>
}

// Parse parses yaml/yml file and returns it as a Document
func (p *Parser) Parse(filePath string, fileContent []byte) ([]model.Document, []int, error) <span class="cov6" title="6">{
        model.NewIgnore.Reset()
        var documents []model.Document
        dec := yaml.NewDecoder(bytes.NewReader(fileContent))

        doc := emptyDocument()
        for dec.Decode(doc) == nil </span><span class="cov6" title="5">{
                if len(*doc) &gt; 0 </span><span class="cov6" title="5">{
                        documents = append(documents, *doc)
                }</span>

                <span class="cov6" title="5">doc = emptyDocument()</span>
        }

        <span class="cov6" title="6">if len(documents) == 0 </span><span class="cov3" title="2">{
                return nil, []int{}, errors.Wrap(errors.New("invalid yaml"), "failed to parse yaml")
        }</span>

        <span class="cov5" title="4">linesToIgnore := model.NewIgnore.GetLines()

        return convertKeysToString(addExtraInfo(documents, filePath)), linesToIgnore, nil</span>
}

// convertKeysToString goes through every document to convert map[interface{}]interface{}
// to map[string]interface{}
func convertKeysToString(docs []model.Document) []model.Document <span class="cov5" title="4">{
        documents := make([]model.Document, 0, len(docs))
        for _, doc := range docs </span><span class="cov6" title="5">{
                for key, value := range doc </span><span class="cov8" title="11">{
                        doc[key] = convert(value)
                }</span>
                <span class="cov6" title="5">documents = append(documents, doc)</span>
        }
        <span class="cov5" title="4">return documents</span>
}

// convert goes recursively through the keys in the given value and converts nested maps type of map[interface{}]interface{}
// to map[string]interface{}
func convert(value interface{}) interface{} <span class="cov10" title="15">{
        switch t := value.(type) </span>{
        case map[interface{}]interface{}:<span class="cov0" title="0">
                mapStr := map[string]interface{}{}
                for key, val := range t </span><span class="cov0" title="0">{
                        if t, ok := key.(string); ok </span><span class="cov0" title="0">{
                                mapStr[t] = convert(val)
                        }</span>
                }
                <span class="cov0" title="0">return mapStr</span>
        case []interface{}:<span class="cov4" title="3">
                for key, val := range t </span><span class="cov5" title="4">{
                        t[key] = convert(val)
                }</span>
        case model.Document:<span class="cov0" title="0">
                for key, val := range t </span><span class="cov0" title="0">{
                        t[key] = convert(val)
                }</span>
        }
        <span class="cov10" title="15">return value</span>
}

// SupportedExtensions returns extensions supported by this parser, which are yaml and yml extension
func (p *Parser) SupportedExtensions() []string <span class="cov3" title="2">{
        return []string{".yaml", ".yml"}
}</span>

// SupportedTypes returns types supported by this parser, which are ansible, cloudFormation, k8s
func (p *Parser) SupportedTypes() map[string]bool <span class="cov1" title="1">{
        return map[string]bool{
                "ansible":                 true,
                "cloudformation":          true,
                "kubernetes":              true,
                "crossplane":              true,
                "knative":                 true,
                "openapi":                 true,
                "googledeploymentmanager": true,
                "dockercompose":           true,
                "pulumi":                  true,
                "serverlessfw":            true,
        }
}</span>

// GetKind returns YAML constant kind
func (p *Parser) GetKind() model.FileKind <span class="cov1" title="1">{
        return model.KindYAML
}</span>

func processCertContent(elements map[string]interface{}, content, filePath string) <span class="cov1" title="1">{
        var certInfo map[string]interface{}
        if content != "" </span><span class="cov1" title="1">{
                certInfo = utils.AddCertificateInfo(filePath, content)
                if certInfo != nil </span><span class="cov1" title="1">{
                        elements["certificate"] = certInfo
                }</span>
        }
}

func processElements(elements map[string]interface{}, filePath string) <span class="cov3" title="2">{
        if elements["certificate"] != nil </span><span class="cov1" title="1">{
                processCertContent(elements, utils.CheckCertificate(elements["certificate"].(string)), filePath)
        }</span>
}

func addExtraInfo(documents []model.Document, filePath string) []model.Document <span class="cov5" title="4">{
        for _, documentPlaybooks := range documents </span><span class="cov6" title="5">{ // iterate over documents
                if playbooks, ok := documentPlaybooks["playbooks"]; ok </span><span class="cov1" title="1">{
                        processPlaybooks(playbooks, filePath)
                }</span>
        }

        <span class="cov5" title="4">return documents</span>
}

func processPlaybooks(playbooks interface{}, filePath string) <span class="cov1" title="1">{
        sliceResources, ok := playbooks.([]interface{})
        if !ok </span><span class="cov0" title="0">{ // prevent panic if playbooks is not a slice
                log.Warn().Msgf("Failed to parse playbooks: %s", filePath)
                return
        }</span>
        <span class="cov1" title="1">for _, resources := range sliceResources </span><span class="cov1" title="1">{ // iterate over playbooks
                processPlaybooksElements(resources, filePath)
        }</span>
}

func processPlaybooksElements(resources interface{}, filePath string) <span class="cov1" title="1">{
        mapResources, ok := resources.(map[string]interface{})
        if !ok </span><span class="cov0" title="0">{
                log.Warn().Msgf("Failed to parse playbooks elements: %s", filePath)
                return
        }</span>
        <span class="cov1" title="1">for _, value := range mapResources </span><span class="cov3" title="2">{
                mapValue, ok := value.(map[string]interface{})
                if !ok </span><span class="cov1" title="1">{
                        continue</span>
                }
                <span class="cov1" title="1">processElements(mapValue, filePath)</span>
        }
}

// GetCommentToken return the comment token of YAML - #
func (p *Parser) GetCommentToken() string <span class="cov1" title="1">{
        return "#"
}</span>

// StringifyContent converts original content into string formated version
func (p *Parser) StringifyContent(content []byte) (string, error) <span class="cov1" title="1">{
        return string(content), nil
}</span>

func emptyDocument() *model.Document <span class="cov8" title="11">{
        return &amp;model.Document{}
}</span>

// GetResolvedFiles returns resolved files
func (p *Parser) GetResolvedFiles() map[string]model.ResolvedFile <span class="cov1" title="1">{
        return p.resolvedFiles
}</span>
</pre>
		
		<pre class="file" id="file77" style="display: none">package printer

import (
        "io"
        "os"
        "path/filepath"
        "strings"

        consoleHelpers "github.com/Checkmarx/kics/internal/console/helpers"
        "github.com/Checkmarx/kics/internal/constants"
        "github.com/gookit/color"
        "github.com/pkg/errors"
        "github.com/rs/zerolog"
        "github.com/rs/zerolog/log"
)

// NoColor - disables ASCII color codes
func NoColor(opt interface{}, changed bool) error <span class="cov4" title="2">{
        noColor := opt.(bool)
        if noColor </span><span class="cov1" title="1">{
                color.Disable()
                consoleLogger.NoColor = true
        }</span>
        <span class="cov4" title="2">return nil</span>
}

// Verbose - redirects log entries to stdout
func Verbose(opt interface{}, changed bool) error <span class="cov4" title="2">{
        verbose := opt.(bool)
        if verbose </span><span class="cov1" title="1">{
                consoleLogger = zerolog.ConsoleWriter{Out: os.Stdout}
                outConsoleLogger = os.Stdout
        }</span>
        <span class="cov4" title="2">return nil</span>
}

// Silent - disables stdout output
func Silent(opt interface{}) error <span class="cov4" title="2">{
        silent := opt.(bool)
        if silent </span><span class="cov1" title="1">{
                color.SetOutput(io.Discard)
                os.Stdout = nil
                log.Logger = log.Output(zerolog.MultiLevelWriter(io.Discard, outFileLogger.(io.Writer)))
        }</span>
        <span class="cov4" title="2">return nil</span>
}

// CI - enable only log messages to CLI output
func CI(opt interface{}) error <span class="cov4" title="2">{
        ci := opt.(bool)
        if ci </span><span class="cov1" title="1">{
                color.SetOutput(io.Discard)
                log.Logger = log.Output(zerolog.MultiLevelWriter(outConsoleLogger, outFileLogger.(io.Writer)))
                os.Stdout = nil
        }</span>
        <span class="cov4" title="2">return nil</span>
}

// LogFormat - configures the logs format (JSON,pretty).
func LogFormat(logFormat string) error <span class="cov7" title="4">{
        if logFormat == constants.LogFormatJSON </span><span class="cov1" title="1">{
                log.Logger = log.Output(zerolog.MultiLevelWriter(outConsoleLogger, loggerFile.(io.Writer)))
                outFileLogger = loggerFile
                outConsoleLogger = os.Stdout
        }</span> else<span class="cov6" title="3"> if logFormat == constants.LogFormatPretty </span><span class="cov4" title="2">{
                fileLogger = consoleHelpers.CustomConsoleWriter(&amp;zerolog.ConsoleWriter{Out: loggerFile.(io.Writer), NoColor: true})
                log.Logger = log.Output(zerolog.MultiLevelWriter(consoleLogger, fileLogger))
                outFileLogger = fileLogger
                outConsoleLogger = zerolog.ConsoleWriter{Out: os.Stdout, NoColor: true}
        }</span> else<span class="cov1" title="1"> {
                return errors.New("invalid log format")
        }</span>
        <span class="cov6" title="3">return nil</span>
}

// LogPath - sets the log files location
func LogPath(opt interface{}, changed bool) error <span class="cov6" title="3">{
        logPath := opt.(string)
        var err error
        if !changed </span><span class="cov1" title="1">{
                if loggerFile == nil </span><span class="cov0" title="0">{
                        loggerFile = io.Discard
                        return nil
                }</span>
                <span class="cov1" title="1">return nil</span>
        }
        <span class="cov4" title="2">if logPath == "" </span><span class="cov1" title="1">{
                logPath, err = constants.GetDefaultLogPath()
                if err != nil </span><span class="cov0" title="0">{
                        return err
                }</span>
        } else<span class="cov1" title="1"> if filepath.Dir(logPath) != "." </span><span class="cov1" title="1">{
                if createErr := os.MkdirAll(filepath.Dir(logPath), os.ModePerm); createErr != nil </span><span class="cov0" title="0">{
                        return createErr
                }</span>
        }

        <span class="cov4" title="2">loggerFile, err = os.OpenFile(logPath, os.O_CREATE|os.O_WRONLY, os.ModePerm)
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>
        <span class="cov4" title="2">return nil</span>
}

// LogFile - enables write to log file
func LogFile(opt interface{}, changed bool) error <span class="cov4" title="2">{
        logFile := opt.(bool)
        if logFile </span><span class="cov1" title="1">{
                logPath, err := constants.GetDefaultLogPath()
                if err != nil </span><span class="cov0" title="0">{
                        return err
                }</span>
                <span class="cov1" title="1">loggerFile, err = os.OpenFile(filepath.Clean(logPath), os.O_CREATE|os.O_WRONLY, os.ModePerm)
                if err != nil </span><span class="cov0" title="0">{
                        return err
                }</span>
                <span class="cov1" title="1">fileLogger = consoleHelpers.CustomConsoleWriter(&amp;zerolog.ConsoleWriter{Out: loggerFile.(io.Writer), NoColor: true})</span>
        }
        <span class="cov4" title="2">return nil</span>
}

// LogLevel - sets log level
func LogLevel(opt interface{}, changed bool) error <span class="cov10" title="7">{
        logLevel := opt.(string)
        switch strings.ToUpper(logLevel) </span>{
        case "TRACE":<span class="cov1" title="1">
                zerolog.SetGlobalLevel(zerolog.TraceLevel)</span>
        case "DEBUG":<span class="cov1" title="1">
                zerolog.SetGlobalLevel(zerolog.DebugLevel)</span>
        case "INFO":<span class="cov4" title="2">
                zerolog.SetGlobalLevel(zerolog.InfoLevel)</span>
        case "WARN":<span class="cov1" title="1">
                zerolog.SetGlobalLevel(zerolog.WarnLevel)</span>
        case "ERROR":<span class="cov1" title="1">
                zerolog.SetGlobalLevel(zerolog.ErrorLevel)</span>
        case "FATAL":<span class="cov1" title="1">
                zerolog.SetGlobalLevel(zerolog.FatalLevel)</span>
        }
        <span class="cov10" title="7">return nil</span>
}
</pre>
		
		<pre class="file" id="file78" style="display: none">package printer

import (
        "fmt"
        "io"
        "sort"
        "strconv"
        "strings"

        consoleFlags "github.com/Checkmarx/kics/internal/console/flags"
        "github.com/Checkmarx/kics/pkg/model"
        "github.com/gookit/color"
        "github.com/rs/zerolog"
        "github.com/rs/zerolog/log"
        "github.com/spf13/pflag"
)

const (
        wordWrapCount     = 5
        charsLimitPerLine = 255
)

var (
        optionsMap = map[string]func(opt interface{}, changed bool) error{
                consoleFlags.CIFlag: func(opt interface{}, changed bool) error <span class="cov1" title="1">{
                        return nil
                }</span>,
                consoleFlags.LogFileFlag:  LogFile,
                consoleFlags.LogLevelFlag: LogLevel,
                consoleFlags.LogPathFlag:  LogPath,
                consoleFlags.SilentFlag: func(opt interface{}, changed bool) error <span class="cov1" title="1">{
                        return nil
                }</span>,
                consoleFlags.VerboseFlag: Verbose,
                consoleFlags.LogFormatFlag: func(opt interface{}, changed bool) error <span class="cov1" title="1">{
                        return nil
                }</span>,
                consoleFlags.NoColorFlag: NoColor,
        }

        optionsOrderMap = map[int]string{
                1: consoleFlags.CIFlag,
                2: consoleFlags.LogFileFlag,
                3: consoleFlags.LogLevelFlag,
                4: consoleFlags.LogPathFlag,
                5: consoleFlags.SilentFlag,
                6: consoleFlags.VerboseFlag,
                7: consoleFlags.LogFormatFlag,
                8: consoleFlags.NoColorFlag,
        }

        consoleLogger = zerolog.ConsoleWriter{Out: io.Discard}
        fileLogger    = zerolog.ConsoleWriter{Out: io.Discard}

        outFileLogger    interface{}
        outConsoleLogger = io.Discard

        loggerFile  interface{}
        initialized bool
)

// Printer wil print console output with colors
// Medium is for medium sevevity results
// High is for high sevevity results
// Low is for low sevevity results
// Info is for info sevevity results
// Success is for successful prints
// Line is the color to print the line with the vulnerability
// minVersion is a bool that if true will print the results output in a minimum version
type Printer struct {
        Medium              color.RGBColor
        High                color.RGBColor
        Low                 color.RGBColor
        Info                color.RGBColor
        Success             color.RGBColor
        Line                color.RGBColor
        VersionMessage      color.RGBColor
        ContributionMessage color.RGBColor
        minimal             bool
}

// WordWrap Wraps text at the specified number of words
func WordWrap(s, identation string, limit int) string <span class="cov4" title="3">{
        if strings.TrimSpace(s) == "" </span><span class="cov1" title="1">{
                return s
        }</span>

        <span class="cov3" title="2">wordSlice := strings.Fields(s)
        var result string

        for len(wordSlice) &gt;= 1 </span><span class="cov4" title="3">{
                result = result + identation + strings.Join(wordSlice[:limit], " ") + "\r\n"

                wordSlice = wordSlice[limit:]
                if len(wordSlice) &lt; limit </span><span class="cov3" title="2">{
                        limit = len(wordSlice)
                }</span>
        }
        <span class="cov3" title="2">return result</span>
}

// PrintResult prints on output the summary results
func PrintResult(summary *model.Summary, failedQueries map[string]error, printer *Printer) error <span class="cov3" title="2">{
        log.Debug().Msg("helpers.PrintResult()")
        fmt.Printf("Files scanned: %d\n", summary.ScannedFiles)
        fmt.Printf("Parsed files: %d\n", summary.ParsedFiles)
        fmt.Printf("Queries loaded: %d\n", summary.TotalQueries)

        fmt.Printf("Queries failed to execute: %d\n\n", summary.FailedToExecuteQueries)
        for queryName, err := range failedQueries </span><span class="cov0" title="0">{
                fmt.Printf("\t- %s:\n", queryName)
                fmt.Printf("%s", WordWrap(err.Error(), "\t\t", wordWrapCount))
        }</span>
        <span class="cov3" title="2">fmt.Printf("------------------------------------\n\n")
        for index := range summary.Queries </span><span class="cov5" title="4">{
                idx := len(summary.Queries) - index - 1
                if summary.Queries[idx].Severity == model.SeverityTrace </span><span class="cov0" title="0">{
                        continue</span>
                }

                <span class="cov5" title="4">fmt.Printf(
                        "%s, Severity: %s, Results: %d\n",
                        printer.PrintBySev(summary.Queries[idx].QueryName, string(summary.Queries[idx].Severity)),
                        printer.PrintBySev(string(summary.Queries[idx].Severity), string(summary.Queries[idx].Severity)),
                        len(summary.Queries[idx].Files),
                )
                if !printer.minimal </span><span class="cov3" title="2">{
                        if summary.Queries[idx].CISDescriptionID != "" </span><span class="cov0" title="0">{
                                fmt.Printf("%s %s\n", printer.Bold("CIS ID:"), summary.Queries[idx].CISDescriptionIDFormatted)
                                fmt.Printf("%s %s\n", printer.Bold("Title:"), summary.Queries[idx].CISDescriptionTitle)
                                fmt.Printf("%s %s\n", printer.Bold("Description:"), summary.Queries[idx].CISDescriptionTextFormatted)
                        }</span> else<span class="cov3" title="2"> {
                                fmt.Printf("%s %s\n", printer.Bold("Description:"), summary.Queries[idx].Description)
                        }</span>
                        <span class="cov3" title="2">fmt.Printf("%s %s\n\n", printer.Bold("Platform:"), summary.Queries[idx].Platform)</span>
                }
                <span class="cov5" title="4">printFiles(&amp;summary.Queries[idx], printer)</span>
        }
        <span class="cov3" title="2">fmt.Printf("\nResults Summary:\n")
        printSeverityCounter(model.SeverityHigh, summary.SeveritySummary.SeverityCounters[model.SeverityHigh], printer.High)
        printSeverityCounter(model.SeverityMedium, summary.SeveritySummary.SeverityCounters[model.SeverityMedium], printer.Medium)
        printSeverityCounter(model.SeverityLow, summary.SeveritySummary.SeverityCounters[model.SeverityLow], printer.Low)
        printSeverityCounter(model.SeverityInfo, summary.SeveritySummary.SeverityCounters[model.SeverityInfo], printer.Info)
        fmt.Printf("TOTAL: %d\n\n", summary.SeveritySummary.TotalCounter)

        log.Info().Msgf("Files scanned: %d", summary.ScannedFiles)
        log.Info().Msgf("Lines scanned: %d", summary.ScannedFilesLines)
        log.Info().Msgf("Parsed files: %d", summary.ParsedFiles)
        log.Info().Msgf("Lines parsed: %d", summary.ParsedFilesLines)
        log.Info().Msgf("Queries loaded: %d", summary.TotalQueries)
        log.Info().Msgf("Queries failed to execute: %d", summary.FailedToExecuteQueries)
        log.Info().Msg("Inspector stopped")

        return nil</span>
}

func printSeverityCounter(severity string, counter int, printColor color.RGBColor) <span class="cov7" title="8">{
        fmt.Printf("%s: %d\n", printColor.Sprint(severity), counter)
}</span>

func printFiles(query *model.QueryResult, printer *Printer) <span class="cov5" title="4">{
        for fileIdx := range query.Files </span><span class="cov6" title="6">{
                fmt.Printf("\t%s %s:%s\n", printer.PrintBySev(fmt.Sprintf("[%d]:", fileIdx+1), string(query.Severity)),
                        query.Files[fileIdx].FileName, printer.Success.Sprint(query.Files[fileIdx].Line))
                if !printer.minimal </span><span class="cov4" title="3">{
                        fmt.Println()
                        for _, line := range *query.Files[fileIdx].VulnLines </span><span class="cov0" title="0">{
                                if len(line.Line) &gt; charsLimitPerLine </span><span class="cov0" title="0">{
                                        line.Line = line.Line[:charsLimitPerLine]
                                }</span>
                                <span class="cov0" title="0">if line.Position == query.Files[fileIdx].Line </span><span class="cov0" title="0">{
                                        printer.Line.Printf("\t\t%03d: %s\n", line.Position, line.Line)
                                }</span> else<span class="cov0" title="0"> {
                                        fmt.Printf("\t\t%03d: %s\n", line.Position, line.Line)
                                }</span>
                        }
                        <span class="cov4" title="3">fmt.Print("\n\n")</span>
                }
        }
}

// SetupPrinter - configures stdout and log options with given FlagSet
func SetupPrinter(flags *pflag.FlagSet) error <span class="cov1" title="1">{
        err := validateFlags()
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>

        <span class="cov1" title="1">keys := make([]int, 0, len(optionsOrderMap))
        for k := range optionsOrderMap </span><span class="cov7" title="8">{
                keys = append(keys, k)
        }</span>

        <span class="cov1" title="1">sort.Ints(keys)

        for _, key := range keys </span><span class="cov7" title="8">{
                f := flags.Lookup(optionsOrderMap[key])
                switch f.Value.Type() </span>{
                case "string":<span class="cov4" title="3">
                        value := f.Value.String()
                        err = optionsMap[optionsOrderMap[key]](value, f.Changed)
                        if err != nil </span><span class="cov0" title="0">{
                                return err
                        }</span>
                case "bool":<span class="cov5" title="5">
                        value, errBool := strconv.ParseBool(f.Value.String())
                        if errBool != nil </span><span class="cov0" title="0">{
                                return err
                        }</span>
                        <span class="cov5" title="5">err = optionsMap[optionsOrderMap[key]](value, f.Changed)
                        if err != nil </span><span class="cov0" title="0">{
                                return err
                        }</span>
                }
        }

        // LogFormat needs to be the last option
        <span class="cov1" title="1">logFormat := strings.ToLower(consoleFlags.GetStrFlag(consoleFlags.LogFormatFlag))
        err = LogFormat(logFormat)
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>

        <span class="cov1" title="1">err = Silent(consoleFlags.GetBoolFlag(consoleFlags.SilentFlag))
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>

        <span class="cov1" title="1">err = CI(consoleFlags.GetBoolFlag(consoleFlags.CIFlag))
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>
        <span class="cov1" title="1">initialized = true
        return nil</span>
}

// IsInitialized returns true if printer is ready, false otherwise
func IsInitialized() bool <span class="cov1" title="1">{
        return initialized
}</span>

// NewPrinter initializes a new Printer
func NewPrinter(minimal bool) *Printer <span class="cov4" title="3">{
        return &amp;Printer{
                Medium:              color.HEX("#ff7213"),
                High:                color.HEX("#bb2124"),
                Low:                 color.HEX("#edd57e"),
                Success:             color.HEX("#22bb33"),
                Info:                color.HEX("#5bc0de"),
                Line:                color.HEX("#f0ad4e"),
                VersionMessage:      color.HEX("#ff9913"),
                ContributionMessage: color.HEX("ffe313"),
                minimal:             minimal,
        }
}</span>

// PrintBySev will print the output with the specific severity color given the severity of the result
func (p *Printer) PrintBySev(content, sev string) string <span class="cov10" title="19">{
        switch strings.ToUpper(sev) </span>{
        case model.SeverityHigh:<span class="cov7" title="9">
                return p.High.Sprintf(content)</span>
        case model.SeverityMedium:<span class="cov6" title="7">
                return p.Medium.Sprintf(content)</span>
        case model.SeverityLow:<span class="cov1" title="1">
                return p.Low.Sprintf(content)</span>
        case model.SeverityInfo:<span class="cov1" title="1">
                return p.Info.Sprintf(content)</span>
        }
        <span class="cov1" title="1">return content</span>
}

// Bold returns the output in a bold format
func (p *Printer) Bold(content string) string <span class="cov5" title="4">{
        return color.Bold.Sprintf(content)
}</span>
</pre>
		
		<pre class="file" id="file79" style="display: none">package printer

import (
        "fmt"
        "time"

        consoleFlags "github.com/Checkmarx/kics/internal/console/flags"
        "github.com/rs/zerolog/log"
)

func validateFlags() error <span class="cov1" title="1">{
        verboseFlag := consoleFlags.GetBoolFlag(consoleFlags.VerboseFlag)
        silentFlag := consoleFlags.GetBoolFlag(consoleFlags.SilentFlag)
        ciFlag := consoleFlags.GetBoolFlag(consoleFlags.CIFlag)

        if silentFlag &amp;&amp; verboseFlag </span><span class="cov0" title="0">{
                return consoleFlags.FormatNewError(consoleFlags.SilentFlag, consoleFlags.VerboseFlag)
        }</span>

        <span class="cov1" title="1">if verboseFlag &amp;&amp; ciFlag </span><span class="cov0" title="0">{
                return consoleFlags.FormatNewError(consoleFlags.VerboseFlag, consoleFlags.CIFlag)
        }</span>

        <span class="cov1" title="1">if silentFlag &amp;&amp; ciFlag </span><span class="cov0" title="0">{
                return consoleFlags.FormatNewError(consoleFlags.SilentFlag, consoleFlags.CIFlag)
        }</span>
        <span class="cov1" title="1">return nil</span>
}

// PrintScanDuration prints the scan duration
func PrintScanDuration(elapsed time.Duration) <span class="cov10" title="2">{
        if consoleFlags.GetBoolFlag(consoleFlags.CIFlag) </span><span class="cov1" title="1">{
                elapsedStrFormat := "Scan duration: %vms\n"
                fmt.Printf(elapsedStrFormat, elapsed.Milliseconds())
                log.Info().Msgf(elapsedStrFormat, elapsed.Milliseconds())
        }</span> else<span class="cov1" title="1"> {
                elapsedStrFormat := "Scan duration: %v\n"
                fmt.Printf(elapsedStrFormat, elapsed)
                log.Info().Msgf(elapsedStrFormat, elapsed)
        }</span>
}
</pre>
		
		<pre class="file" id="file80" style="display: none">package circle

import (
        "fmt"
        "io"
        "time"

        "github.com/Checkmarx/kics/internal/constants"
        "github.com/cheggaaa/pb/v3"
)

const (
        barWidth     = 0
        sleepTimeout = 100
)

// ProgressBar is a struct that holds the required feilds for
// a Circle Progress Bar
type ProgressBar struct {
        label string
        pBar  *pb.ProgressBar
        close func() error
}

// NewProgressBar creates a new instance of a Circle Progress Bar
func NewProgressBar(label string, silent bool) ProgressBar <span class="cov10" title="3">{
        newPb := pb.New64(constants.MaxInteger)
        tmp := fmt.Sprintf(`{{ %q }} {{(cycle . "\\" "-" "|" "/" "-" "|" )}}`, label)
        newPb.SetWidth(barWidth)
        newPb.SetTemplateString(tmp)
        if silent </span><span class="cov1" title="1">{
                newPb.SetWriter(io.Discard)
        }</span>
        <span class="cov10" title="3">newPb.Start()

        return ProgressBar{
                label: label,
                pBar:  newPb,
                close: func() error </span><span class="cov1" title="1">{
                        newPb.Finish()
                        return nil
                }</span>,
        }
}

// Start initializes the Circle Progress Bar
func (p ProgressBar) Start() <span class="cov0" title="0">{
        for </span><span class="cov0" title="0">{ // increment until the Close func is called
                p.pBar.Increment()
                // lower cpu usage from infinite loop
                time.Sleep(time.Millisecond * sleepTimeout)
        }</span>
}

// Close stops the Circle Progress Bar and
// changes the template to done
func (p ProgressBar) Close() error <span class="cov1" title="1">{
        p.pBar.SetTemplateString(fmt.Sprintf("%sDone", p.label))
        return p.close()
}</span>
</pre>
		
		<pre class="file" id="file81" style="display: none">package counter

import (
        "io"
        "sync"

        "github.com/cheggaaa/pb/v3"
        "github.com/rs/zerolog/log"
)

// ProgressBar is a struct that holds the required feilds for
// a Counter Progress Bar
type ProgressBar struct {
        label           string
        total           int64
        currentProgress int64
        progress        chan int64
        pBar            *pb.ProgressBar
        close           func() error
        wg              *sync.WaitGroup
}

const (
        barWidth = 80
)

// NewProgressBar creates a new instance of a Counter Progress Bar
func NewProgressBar(label string, total int64, progress chan int64, wg *sync.WaitGroup, silent bool) ProgressBar <span class="cov3" title="2">{
        newPb := pb.New64(total)
        newPb.SetMaxWidth(barWidth)
        newPb.Set("prefix", label)
        newPb.SetTemplateString(`{{string . "prefix"}}{{bar . }} {{percent . }}`)
        if silent </span><span class="cov1" title="1">{
                newPb.SetWriter(io.Discard)
        }</span>
        <span class="cov3" title="2">newPb.Start()

        return ProgressBar{
                label:    label,
                total:    total,
                progress: progress,
                pBar:     newPb,
                wg:       wg,
                close: func() error </span><span class="cov0" title="0">{
                        newPb.Finish()
                        return nil
                }</span>,
        }
}

// Start initializes the Counter Progress Bar
func (p ProgressBar) Start() <span class="cov3" title="2">{
        defer func() </span><span class="cov0" title="0">{
                err := p.Close()
                if err != nil </span><span class="cov0" title="0">{
                        log.Error().Msgf("failed to stop progress bar %v", err)
                }</span>
                <span class="cov0" title="0">p.wg.Done()</span>
        }()

        <span class="cov3" title="2">for </span><span class="cov10" title="20">{
                newProgress, ok := &lt;-p.progress
                p.currentProgress += newProgress
                p.pBar.Increment()
                if !ok || p.currentProgress &gt;= p.pBar.Total() </span><span class="cov0" title="0">{
                        break</span>
                }
        }
}

// Close stops the Counter Progress Bar
func (p ProgressBar) Close() error <span class="cov0" title="0">{ return p.close() }</span>
</pre>
		
		<pre class="file" id="file82" style="display: none">package progress

import (
        "sync"

        "github.com/Checkmarx/kics/pkg/progress/circle"
        "github.com/Checkmarx/kics/pkg/progress/counter"
)

// PBar is the interface for the types of available progress bars (Circle ,Counter)
// Start initializes the Progress Bar execution
// Close stops the Progress Bar execution
type PBar interface {
        Start()
        Close() error
}

// PbBuilder is the struct that contains the progress bar Builders
// Silent is set to true when all progress bars should be silent
type PbBuilder struct {
        Silent bool
}

// InitializePbBuilder creates an instace of a PbBuilder
func InitializePbBuilder(noProgress, ci, silentFlag bool) *PbBuilder <span class="cov10" title="2">{
        pbbuilder := PbBuilder{
                Silent: false,
        }
        if noProgress || ci || silentFlag </span><span class="cov1" title="1">{
                pbbuilder = PbBuilder{
                        Silent: true,
                }
        }</span>
        <span class="cov10" title="2">return &amp;pbbuilder</span>
}

// BuildCounter builds and returns a Counter Progress Bar
func (i *PbBuilder) BuildCounter(label string, total int, wg *sync.WaitGroup, progressChannel chan int64) PBar <span class="cov1" title="1">{
        return counter.NewProgressBar(label, int64(total), progressChannel, wg, i.Silent)
}</span>

// BuildCircle builds and returns a Circle Progress Bar
func (i *PbBuilder) BuildCircle(label string) PBar <span class="cov1" title="1">{
        return circle.NewProgressBar(label, i.Silent)
}</span>
</pre>
		
		<pre class="file" id="file83" style="display: none">package remediation

import (
        "encoding/json"
        "os"
        "path/filepath"
        "sort"
        "strings"

        "github.com/rs/zerolog/log"
)

// Report includes all query results
type Report struct {
        Queries []Query `json:"queries"`
}

// Query includes all the files that presents a result related to the queryID
type Query struct {
        Files   []File `json:"files"`
        QueryID string `json:"query_id"`
}

// File presents the result information related to the file
type File struct {
        FilePath        string `json:"file_name"`
        Line            int    `json:"line"`
        Remediation     string `json:"remediation"`
        RemediationType string `json:"remediation_type"`
        SimilarityID    string `json:"similarity_id"`
        SearchKey       string `json:"search_key"`
        ExpectedValue   string `json:"expected_value"`
        ActualValue     string `json:"actual_value"`
}

// Remediation presents all the relevant information for the fix
type Remediation struct {
        Line          int
        Remediation   string
        SimilarityID  string
        QueryID       string
        SearchKey     string
        ExpectedValue string
        ActualValue   string
}

// Set includes all the replacements and additions related to a file
type Set struct {
        Replacement []Remediation
        Addition    []Remediation
}

// RemediateFile remediationSets the replacements first and secondly, the additions sorted down
func (s *Summary) RemediateFile(filePath string, remediationSet Set) error <span class="cov10" title="4">{
        filepath.Clean(filePath)
        content, err := os.ReadFile(filePath)

        if err != nil </span><span class="cov0" title="0">{
                log.Error().Msgf("failed to read file: %s", err)
                return err
        }</span>

        <span class="cov10" title="4">lines := strings.Split(string(content), "\n")

        // do replacements first
        if len(remediationSet.Replacement) &gt; 0 </span><span class="cov8" title="3">{
                for i := range remediationSet.Replacement </span><span class="cov8" title="3">{
                        r := remediationSet.Replacement[i]
                        remediatedLines := replacement(&amp;r, lines)
                        if len(remediatedLines) &gt; 0 &amp;&amp; willRemediate(remediatedLines, filePath, &amp;r) </span><span class="cov5" title="2">{
                                lines = s.writeRemediation(remediatedLines, lines, filePath, r.SimilarityID)
                        }</span>
                }
        }

        // do additions after
        <span class="cov10" title="4">if len(remediationSet.Addition) &gt; 0 </span><span class="cov1" title="1">{
                // descending order
                sort.Slice(remediationSet.Addition, func(i, j int) bool </span><span class="cov0" title="0">{
                        return remediationSet.Addition[i].Line &gt; remediationSet.Addition[j].Line
                }</span>)

                <span class="cov1" title="1">for i := range remediationSet.Addition </span><span class="cov1" title="1">{
                        a := remediationSet.Addition[i]
                        remediatedLines := addition(&amp;a, &amp;lines)
                        if len(remediatedLines) &gt; 0 &amp;&amp; willRemediate(remediatedLines, filePath, &amp;a) </span><span class="cov1" title="1">{
                                lines = s.writeRemediation(remediatedLines, lines, filePath, a.SimilarityID)
                        }</span>
                }
        }

        <span class="cov10" title="4">return nil</span>
}

// ReplacementInfo presents the relevant information to do the replacement
type ReplacementInfo struct {
        Before string `json:"before"`
        After  string `json:"after"`
}

func replacement(r *Remediation, lines []string) []string <span class="cov8" title="3">{
        originalLine := lines[r.Line-1]

        var replacement ReplacementInfo
        err := json.Unmarshal([]byte(r.Remediation), &amp;replacement)

        if err != nil || replacement == (ReplacementInfo{}) </span><span class="cov0" title="0">{
                return []string{}
        }</span>

        <span class="cov8" title="3">remediated := strings.Replace(lines[r.Line-1], replacement.Before, replacement.After, 1)

        if originalLine == remediated </span><span class="cov1" title="1">{
                log.Info().Msgf("remediation '%s' is already done", r.SimilarityID)
                return []string{}
        }</span>

        // replace the original line with remediation
        <span class="cov5" title="2">lines[r.Line-1] = remediated

        return lines</span>
}

func addition(r *Remediation, lines *[]string) []string <span class="cov1" title="1">{
        fatherNumberLine := r.Line - 1

        if len(*lines) &lt;= fatherNumberLine+1 </span><span class="cov0" title="0">{
                return []string{}
        }</span>

        <span class="cov1" title="1">firstLine := strings.Split(r.Remediation, "\n")[0]

        if strings.TrimSpace((*lines)[fatherNumberLine+1]) == strings.TrimSpace(firstLine) </span><span class="cov0" title="0">{
                log.Info().Msgf("remediation '%s' is already done", r.SimilarityID)
                return []string{}
        }</span>

        <span class="cov1" title="1">begin := make([]string, len(*lines))
        end := make([]string, len(*lines))

        copy(begin, *lines)
        copy(end, *lines)

        begin = begin[:fatherNumberLine+1]
        end = end[fatherNumberLine+1:]

        before := getBefore((*lines)[fatherNumberLine+1])

        remediation := begin
        remediation = append(remediation, before+r.Remediation)
        remediation = append(remediation, end...)

        return remediation</span>
}

func (s *Summary) writeRemediation(remediatedLines, lines []string, filePath, similarityID string) []string <span class="cov8" title="3">{
        remediated := []byte(strings.Join(remediatedLines, "\n"))

        if err := os.WriteFile(filePath, remediated, os.ModePerm); err != nil </span><span class="cov0" title="0">{
                log.Error().Msgf("failed to write file: %s", err)
                return lines
        }</span>

        <span class="cov8" title="3">log.Info().Msgf("file '%s' was remediated with '%s'", filePath, similarityID)
        s.ActualRemediationDoneNumber++

        return remediatedLines</span>
}
</pre>
		
		<pre class="file" id="file84" style="display: none">package remediation

import (
        "context"
        "encoding/json"
        "errors"
        "time"

        "github.com/Checkmarx/kics/pkg/engine"
        "github.com/Checkmarx/kics/pkg/kics"
        "github.com/Checkmarx/kics/pkg/model"
        "github.com/Checkmarx/kics/pkg/scan"
        "github.com/open-policy-agent/opa/topdown"

        "github.com/Checkmarx/kics/internal/console/flags"
        "github.com/Checkmarx/kics/internal/tracker"
        "github.com/Checkmarx/kics/pkg/engine/source"
        "github.com/Checkmarx/kics/pkg/parser"
        buildahParser "github.com/Checkmarx/kics/pkg/parser/buildah"
        dockerParser "github.com/Checkmarx/kics/pkg/parser/docker"
        protoParser "github.com/Checkmarx/kics/pkg/parser/grpc"
        jsonParser "github.com/Checkmarx/kics/pkg/parser/json"
        terraformParser "github.com/Checkmarx/kics/pkg/parser/terraform"
        yamlParser "github.com/Checkmarx/kics/pkg/parser/yaml"
        "github.com/Checkmarx/kics/pkg/utils"
        "github.com/open-policy-agent/opa/rego"
        "github.com/rs/zerolog/log"
)

type runQueryInfo struct {
        payload   model.Documents
        query     *engine.PreparedQuery
        inspector *engine.Inspector
        tmpFile   string
        files     model.FileMetadatas
}

// scanTmpFile scans a temporary file against a specific query
func scanTmpFile(tmpFile, queryID string, remediated []byte) ([]model.Vulnerability, error) <span class="cov10" title="3">{
        // get payload
        files, err := getPayload(tmpFile, remediated)

        if err != nil </span><span class="cov0" title="0">{
                log.Err(err)
                return []model.Vulnerability{}, err
        }</span>

        <span class="cov10" title="3">if len(files) == 0 </span><span class="cov0" title="0">{
                log.Error().Msg("failed to get payload")
                return []model.Vulnerability{}, errors.New("failed to get payload")
        }</span>

        <span class="cov10" title="3">payload := files.Combine(false)

        // init scan
        inspector, err := initScan(queryID)

        if err != nil </span><span class="cov0" title="0">{
                log.Err(err)
                return []model.Vulnerability{}, err
        }</span>

        // load query
        <span class="cov10" title="3">query, err := loadQuery(inspector, queryID)

        if err != nil </span><span class="cov0" title="0">{
                log.Err(err)
                return []model.Vulnerability{}, err
        }</span>

        // run query
        <span class="cov10" title="3">info := &amp;runQueryInfo{
                payload:   payload,
                query:     query,
                inspector: inspector,
                tmpFile:   tmpFile,
                files:     files,
        }

        return runQuery(info), nil</span>
}

// getPayload gets the payload of a file
func getPayload(filePath string, content []byte) (model.FileMetadatas, error) <span class="cov10" title="3">{
        ext := utils.GetExtension(filePath)
        var p []*parser.Parser
        var err error

        switch ext </span>{
        case ".dockerfile", "Dockerfile", "possibleDockerfile", ".ubi8", ".debian":<span class="cov0" title="0">
                p, err = parser.NewBuilder().Add(&amp;dockerParser.Parser{}).Build([]string{""}, []string{""})</span>

        case ".tf":<span class="cov10" title="3">
                p, err = parser.NewBuilder().Add(terraformParser.NewDefault()).Build([]string{""}, []string{""})</span>

        case ".proto":<span class="cov0" title="0">
                p, err = parser.NewBuilder().Add(&amp;protoParser.Parser{}).Build([]string{""}, []string{""})</span>

        case ".yaml", ".yml":<span class="cov0" title="0">
                p, err = parser.NewBuilder().Add(&amp;yamlParser.Parser{}).Build([]string{""}, []string{""})</span>

        case ".json":<span class="cov0" title="0">
                p, err = parser.NewBuilder().Add(&amp;jsonParser.Parser{}).Build([]string{""}, []string{""})</span>

        case ".sh":<span class="cov0" title="0">
                p, err = parser.NewBuilder().Add(&amp;buildahParser.Parser{}).Build([]string{""}, []string{""})</span>
        }

        <span class="cov10" title="3">if err != nil </span><span class="cov0" title="0">{
                log.Error().Msgf("failed to get parser: %s", err)
                return model.FileMetadatas{}, err
        }</span>

        <span class="cov10" title="3">if len(p) == 0 </span><span class="cov0" title="0">{
                log.Info().Msg("failed to get parser")
                return model.FileMetadatas{}, errors.New("failed to get parser")
        }</span>

        <span class="cov10" title="3">documents, er := p[0].Parse(filePath, content)

        if er != nil </span><span class="cov0" title="0">{
                log.Error().Msgf("failed to parse file '%s': %s", filePath, er)
                return model.FileMetadatas{}, er
        }</span>

        <span class="cov10" title="3">var files model.FileMetadatas

        for _, document := range documents.Docs </span><span class="cov10" title="3">{
                _, err = json.Marshal(document)
                if err != nil </span><span class="cov0" title="0">{
                        continue</span>
                }

                <span class="cov10" title="3">file := model.FileMetadata{
                        FilePath:          filePath,
                        Document:          kics.PrepareScanDocument(document, documents.Kind),
                        LineInfoDocument:  document,
                        Commands:          p[0].CommentsCommands(filePath, content),
                        OriginalData:      string(content),
                        LinesOriginalData: utils.SplitLines(string(content)),
                }

                files = append(files, file)</span>
        }

        <span class="cov10" title="3">return files, nil</span>
}

// runQuery runs a query and returns its results
func runQuery(r *runQueryInfo) []model.Vulnerability <span class="cov10" title="3">{
        queryExecTimeout := time.Duration(flags.GetIntFlag(flags.QueryExecTimeoutFlag)) * time.Second

        timeoutCtx, cancel := context.WithTimeout(context.Background(), queryExecTimeout)
        defer cancel()

        options := []rego.EvalOption{rego.EvalInput(r.payload)}

        results, err := r.query.OpaQuery.Eval(timeoutCtx, options...)

        if err != nil </span><span class="cov0" title="0">{
                if topdown.IsCancel(err) </span><span class="cov0" title="0">{
                        log.Err(err)
                }</span>

                <span class="cov0" title="0">log.Err(err)</span>
        }

        <span class="cov10" title="3">ctx := context.Background()

        queryCtx := &amp;engine.QueryContext{
                Ctx:           ctx,
                Query:         r.query,
                BaseScanPaths: []string{r.tmpFile},
                Files:         r.files.ToMap(),
        }

        decoded, err := r.inspector.DecodeQueryResults(queryCtx, results)

        if err != nil </span><span class="cov0" title="0">{
                log.Err(err)
        }</span>

        <span class="cov10" title="3">return decoded</span>
}

func initScan(queryID string) (*engine.Inspector, error) <span class="cov10" title="3">{
        scanParams := &amp;scan.Parameters{
                QueriesPath:      flags.GetMultiStrFlag(flags.QueriesPath),
                Platform:         flags.GetMultiStrFlag(flags.TypeFlag),
                CloudProvider:    flags.GetMultiStrFlag(flags.CloudProviderFlag),
                LibrariesPath:    flags.GetStrFlag(flags.LibrariesPath),
                PreviewLines:     flags.GetIntFlag(flags.PreviewLinesFlag),
                QueryExecTimeout: flags.GetIntFlag(flags.QueryExecTimeoutFlag),
        }

        c := &amp;scan.Client{
                ScanParams: scanParams,
        }

        err := c.GetQueryPath()

        if err != nil </span><span class="cov0" title="0">{
                log.Err(err)
                return &amp;engine.Inspector{}, err
        }</span>

        <span class="cov10" title="3">queriesSource := source.NewFilesystemSource(
                c.ScanParams.QueriesPath,
                c.ScanParams.Platform,
                c.ScanParams.CloudProvider,
                c.ScanParams.LibrariesPath)

        includeQueries := source.IncludeQueries{
                ByIDs: []string{queryID},
        }

        queryFilter := source.QueryInspectorParameters{
                IncludeQueries: includeQueries,
        }

        t, err := tracker.NewTracker(c.ScanParams.PreviewLines)
        if err != nil </span><span class="cov0" title="0">{
                log.Err(err)
                return &amp;engine.Inspector{}, err
        }</span>

        <span class="cov10" title="3">ctx := context.Background()

        inspector, err := engine.NewInspector(ctx,
                queriesSource,
                engine.DefaultVulnerabilityBuilder,
                t,
                &amp;queryFilter,
                make(map[string]bool),
                c.ScanParams.QueryExecTimeout,
                false,
        )

        return inspector, err</span>
}

func loadQuery(inspector *engine.Inspector, queryID string) (*engine.PreparedQuery, error) <span class="cov10" title="3">{
        if len(inspector.QueryLoader.QueriesMetadata) == 1 </span><span class="cov10" title="3">{
                queryOpa, err := inspector.QueryLoader.LoadQuery(context.Background(), &amp;inspector.QueryLoader.QueriesMetadata[0])

                if err != nil </span><span class="cov0" title="0">{
                        log.Err(err)
                        return &amp;engine.PreparedQuery{}, err
                }</span>

                <span class="cov10" title="3">query := &amp;engine.PreparedQuery{
                        OpaQuery: *queryOpa,
                        Metadata: inspector.QueryLoader.QueriesMetadata[0],
                }

                return query, nil</span>
        }

        <span class="cov0" title="0">return &amp;engine.PreparedQuery{}, errors.New("unable to load query" + queryID)</span>
}
</pre>
		
		<pre class="file" id="file85" style="display: none">package remediation

import (
        "os"
        "path/filepath"
        "regexp"
        "strings"

        "github.com/Checkmarx/kics/pkg/model"
        "github.com/Checkmarx/kics/pkg/utils"
        "github.com/rs/zerolog/log"
)

// Summary represents the information about the number of selected remediation and remediation done
type Summary struct {
        SelectedRemediationNumber   int
        ActualRemediationDoneNumber int
}

// GetRemediationSets collects all the replacements and additions per file
func (s *Summary) GetRemediationSets(results Report, include []string) map[string]interface{} <span class="cov4" title="2">{
        remediationSets := make(map[string]interface{})

        vulns := getVulns(results)

        if len(vulns) &gt; 0 </span><span class="cov4" title="2">{
                remediationSets = s.GetRemediationSetsFromVulns(vulns, include)
        }</span>

        <span class="cov4" title="2">return remediationSets</span>
}

func shouldRemediate(file *File, include []string) bool <span class="cov8" title="4">{
        if len(file.Remediation) &gt; 0 &amp;&amp;
                len(file.RemediationType) &gt; 0 &amp;&amp;
                (include[0] == "all" || utils.Contains(file.SimilarityID, include)) &amp;&amp;
                filepath.Ext(file.FilePath) == ".tf" </span><span class="cov7" title="3">{ // temporary
                return true
        }</span>

        <span class="cov1" title="1">return false</span>
}

func getBefore(line string) string <span class="cov1" title="1">{
        re := regexp.MustCompile(`^[\s-]*`)
        before := re.FindAll([]byte(line), -1)

        return string(before[0])
}</span>

// willRemediate verifies if the remediation actually removes the result
func willRemediate(remediated []string, originalFileName string, remediation *Remediation) bool <span class="cov7" title="3">{
        filepath.Clean(originalFileName)
        // create temporary file
        tmpFile := filepath.Join(os.TempDir(), "temporary-remediation-"+utils.NextRandom()+"-"+filepath.Base(originalFileName))
        f, err := os.OpenFile(tmpFile, os.O_WRONLY|os.O_CREATE|os.O_TRUNC, os.ModePerm)

        if err != nil </span><span class="cov0" title="0">{
                log.Error().Msgf("failed to open temporary file for remediation '%s': %s", remediation.SimilarityID, err)
                return false
        }</span>

        <span class="cov7" title="3">content := []byte(strings.Join(remediated, "\n"))

        defer func(f *os.File) </span><span class="cov7" title="3">{
                err = f.Close()
                if err != nil </span><span class="cov0" title="0">{
                        log.Err(err).Msgf("failed to close file: %s", tmpFile)
                }</span>
        }(f)

        <span class="cov7" title="3">if _, err = f.Write(content); err != nil </span><span class="cov0" title="0">{
                log.Error().Msgf("failed to write temporary file for remediation '%s': %s", remediation.SimilarityID, err)
                return false
        }</span>

        // scan the temporary file to verify if the remediation removed the result
        <span class="cov7" title="3">results, err := scanTmpFile(tmpFile, remediation.QueryID, content)

        if err != nil </span><span class="cov0" title="0">{
                log.Error().Msgf("failed to get results of query %s: %s", remediation.QueryID, err)
                return false
        }</span>

        <span class="cov7" title="3">err = os.Remove(tmpFile)

        if err != nil </span><span class="cov0" title="0">{
                log.Err(err)
        }</span>

        <span class="cov7" title="3">return removedResult(results, remediation)</span>
}

func removedResult(results []model.Vulnerability, remediation *Remediation) bool <span class="cov7" title="3">{
        for i := range results </span><span class="cov4" title="2">{
                result := results[i]

                if result.SearchKey == remediation.SearchKey &amp;&amp;
                        result.KeyActualValue == remediation.ActualValue &amp;&amp;
                        result.KeyExpectedValue == remediation.ExpectedValue </span><span class="cov0" title="0">{
                        log.Info().Msgf("failed to remediate '%s'", remediation.SimilarityID)
                        return false
                }</span>
        }
        <span class="cov7" title="3">return true</span>
}

// CreateTempFile creates a temporary file with the content as the file pointed in the filePathCopyFrom
func CreateTempFile(filePathCopyFrom, tmpFilePath string) string <span class="cov10" title="5">{
        filepath.Clean(filePathCopyFrom)
        filepath.Clean(tmpFilePath)
        f, err := os.OpenFile(tmpFilePath, os.O_WRONLY|os.O_CREATE|os.O_TRUNC, os.ModePerm)

        if err != nil </span><span class="cov0" title="0">{
                log.Error().Msgf("failed to open file '%s': %s", tmpFilePath, err)
                return ""
        }</span>

        <span class="cov10" title="5">content, err := os.ReadFile(filePathCopyFrom)

        defer func(f *os.File) </span><span class="cov10" title="5">{
                err = f.Close()
                if err != nil </span><span class="cov0" title="0">{
                        log.Err(err).Msgf("failed to close file: %s", tmpFilePath)
                }</span>
        }(f)

        <span class="cov10" title="5">if err != nil </span><span class="cov0" title="0">{
                log.Error().Msgf("failed to read file '%s': %s", filePathCopyFrom, err)
                return ""
        }</span>

        <span class="cov10" title="5">if _, err = f.Write(content); err != nil </span><span class="cov0" title="0">{
                log.Error().Msgf("failed to write file '%s': %s", tmpFilePath, err)
                return ""
        }</span>

        <span class="cov10" title="5">return tmpFilePath</span>
}

// GetRemediationSetsFromVulns collects all the replacements and additions per file from []model.Vulnerability
func (s *Summary) GetRemediationSetsFromVulns(vulnerabilities []model.Vulnerability, include []string) map[string]interface{} <span class="cov4" title="2">{
        remediationSets := make(map[string]interface{})

        for i := range vulnerabilities </span><span class="cov8" title="4">{
                vuln := vulnerabilities[i]

                file := File{
                        FilePath:        vuln.FileName,
                        Line:            vuln.Line,
                        Remediation:     vuln.Remediation,
                        RemediationType: vuln.RemediationType,
                        SimilarityID:    vuln.SimilarityID,
                }

                var remediationSet Set

                if shouldRemediate(&amp;file, include) </span><span class="cov7" title="3">{
                        s.SelectedRemediationNumber++
                        r := &amp;Remediation{
                                Line:          file.Line,
                                Remediation:   file.Remediation,
                                SimilarityID:  file.SimilarityID,
                                QueryID:       vuln.QueryID,
                                SearchKey:     vuln.SearchKey,
                                ExpectedValue: vuln.KeyExpectedValue,
                                ActualValue:   vuln.KeyActualValue,
                        }

                        if file.RemediationType == "replacement" </span><span class="cov4" title="2">{
                                remediationSet.Replacement = append(remediationSet.Replacement, *r)
                        }</span>

                        <span class="cov7" title="3">if file.RemediationType == "addition" </span><span class="cov1" title="1">{
                                remediationSet.Addition = append(remediationSet.Addition, *r)
                        }</span>

                        <span class="cov7" title="3">if _, ok := remediationSets[file.FilePath]; !ok </span><span class="cov4" title="2">{
                                remediationSets[file.FilePath] = remediationSet
                                continue</span>
                        }

                        <span class="cov1" title="1">updatedRemediationSet := remediationSets[file.FilePath].(Set)

                        updatedRemediationSet.Addition = append(updatedRemediationSet.Addition, remediationSet.Addition...)
                        updatedRemediationSet.Replacement = append(updatedRemediationSet.Replacement, remediationSet.Replacement...)

                        remediationSets[file.FilePath] = updatedRemediationSet</span>
                }
        }
        <span class="cov4" title="2">return remediationSets</span>
}

func getVulns(results Report) []model.Vulnerability <span class="cov4" title="2">{
        vulns := []model.Vulnerability{}
        for i := range results.Queries </span><span class="cov8" title="4">{
                query := results.Queries[i]

                for j := range query.Files </span><span class="cov8" title="4">{
                        file := query.Files[j]
                        vuln := &amp;model.Vulnerability{
                                FileName:         file.FilePath,
                                Line:             file.Line,
                                Remediation:      file.Remediation,
                                RemediationType:  file.RemediationType,
                                SimilarityID:     file.SimilarityID,
                                QueryID:          query.QueryID,
                                SearchKey:        file.SearchKey,
                                KeyExpectedValue: file.ExpectedValue,
                                KeyActualValue:   file.ActualValue,
                        }

                        vulns = append(vulns, *vuln)
                }</span>
        }
        <span class="cov4" title="2">return vulns</span>
}
</pre>
		
		<pre class="file" id="file86" style="display: none">package report

import (
        "strings"

        reportModel "github.com/Checkmarx/kics/pkg/report/model"
)

// PrintASFFReport prints the ASFF report in the given path and filename with the given body
func PrintASFFReport(path, filename string, body interface{}) error <span class="cov8" title="1">{
        if !strings.HasPrefix(filename, "asff-") </span><span class="cov8" title="1">{
                filename = "asff-" + filename
        }</span>
        <span class="cov8" title="1">if body != "" </span><span class="cov8" title="1">{
                summary, err := getSummary(body)
                if err != nil </span><span class="cov0" title="0">{
                        return err
                }</span>

                <span class="cov8" title="1">body = reportModel.BuildASFF(&amp;summary)</span>
        }

        <span class="cov8" title="1">return ExportJSONReport(path, filename, body)</span>
}
</pre>
		
		<pre class="file" id="file87" style="display: none">package report

import (
        "strings"

        reportModel "github.com/Checkmarx/kics/pkg/report/model"
)

// PrintCodeClimateReport prints the code climate report in the given path and filename with the given body
func PrintCodeClimateReport(path, filename string, body interface{}) error <span class="cov8" title="1">{
        if !strings.HasPrefix(filename, "codeclimate") </span><span class="cov8" title="1">{
                filename = "codeclimate-" + filename
        }</span>

        <span class="cov8" title="1">if body != "" </span><span class="cov8" title="1">{
                summary, err := getSummary(body)
                if err != nil </span><span class="cov0" title="0">{
                        return err
                }</span>

                <span class="cov8" title="1">body = reportModel.BuildCodeClimateReport(&amp;summary)</span>
        }

        <span class="cov8" title="1">return ExportJSONReport(path, filename, body)</span>
}
</pre>
		
		<pre class="file" id="file88" style="display: none">package report

import (
        "encoding/json"
        "encoding/xml"
        "fmt"
        "html/template"
        "os"
        "path/filepath"
        "strconv"
        "strings"
        "time"

        "github.com/Checkmarx/kics/pkg/model"
        reportModel "github.com/Checkmarx/kics/pkg/report/model"
        "github.com/gocarina/gocsv"
        "github.com/rs/zerolog/log"
)

var (
        stringsSeverity = map[string]model.Severity{
                "high":   model.AllSeverities[0],
                "medium": model.AllSeverities[1],
                "low":    model.AllSeverities[2],
                "info":   model.AllSeverities[3],
        }

        templateFuncs = template.FuncMap{
                "lower":          strings.ToLower,
                "sprintf":        fmt.Sprintf,
                "severity":       getSeverities,
                "getCurrentTime": getCurrentTime,
                "trimSpaces":     trimSpaces,
                "toString":       toString,
        }
)

func toString(value interface{}) string <span class="cov1" title="1">{
        switch v := value.(type) </span>{
        case string:<span class="cov0" title="0">
                return v</span>
        case int:<span class="cov0" title="0">
                return strconv.Itoa(v)</span>
        default:<span class="cov1" title="1">
                return fmt.Sprintf("%v", v)</span>
        }
}

func trimSpaces(value string) string <span class="cov0" title="0">{
        return strings.TrimPrefix(value, " ")
}</span>

func getSeverities(severity string) model.Severity <span class="cov5" title="4">{
        return stringsSeverity[severity]
}</span>

func getCurrentTime() string <span class="cov1" title="1">{
        dt := time.Now()
        return dt.Format("01/02/2006 15:04")
}</span>

func fileCreationReport(path, filename string) <span class="cov10" title="13">{
        log.Info().Str("fileName", filename).Msgf("Results saved to file %s", path)
        fmt.Printf("Results saved to file %s\n", path)
}</span>

func closeFile(path, filename string, file *os.File) <span class="cov9" title="11">{
        err := file.Close()
        if err != nil </span><span class="cov0" title="0">{
                log.Err(err).Msgf("Failed to close file %s", path)
        }</span>

        <span class="cov9" title="11">fileCreationReport(path, filename)</span>
}

func getPlatforms(queries model.QueryResultSlice) string <span class="cov4" title="3">{
        platforms := make([]string, 0)
        alreadyAdded := make(map[string]string)
        for idx := range queries </span><span class="cov4" title="3">{
                if _, ok := alreadyAdded[queries[idx].Platform]; !ok </span><span class="cov4" title="3">{
                        alreadyAdded[queries[idx].Platform] = ""
                        platforms = append(platforms, queries[idx].Platform)
                }</span>
        }
        <span class="cov4" title="3">return strings.Join(platforms, ", ")</span>
}

// ExportJSONReport - encodes a given body to a JSON file in a given filepath
func ExportJSONReport(path, filename string, body interface{}) error <span class="cov7" title="6">{
        if !strings.Contains(filename, ".") </span><span class="cov4" title="3">{
                filename += jsonExtension
        }</span>
        <span class="cov7" title="6">fullPath := filepath.Join(path, filename)

        f, err := os.OpenFile(filepath.Clean(fullPath), os.O_WRONLY|os.O_CREATE|os.O_TRUNC, os.ModePerm)
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>

        <span class="cov7" title="6">defer closeFile(fullPath, filename, f)

        encoder := json.NewEncoder(f)
        encoder.SetIndent("", "\t")

        return encoder.Encode(body)</span>
}

func getSummary(body interface{}) (sum model.Summary, err error) <span class="cov9" title="10">{
        var summary model.Summary
        result, err := json.Marshal(body)
        if err != nil </span><span class="cov0" title="0">{
                return model.Summary{}, err
        }</span>
        <span class="cov9" title="10">if err := json.Unmarshal(result, &amp;summary); err != nil </span><span class="cov0" title="0">{
                return model.Summary{}, err
        }</span>

        <span class="cov9" title="10">return summary, nil</span>
}

func exportXMLReport(path, filename string, body interface{}) error <span class="cov4" title="3">{
        if !strings.HasSuffix(filename, ".xml") </span><span class="cov4" title="3">{
                filename += ".xml"
        }</span>

        <span class="cov4" title="3">fullPath := filepath.Join(path, filename)
        f, err := os.OpenFile(filepath.Clean(fullPath), os.O_WRONLY|os.O_CREATE|os.O_TRUNC, os.ModePerm)
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>
        <span class="cov4" title="3">defer closeFile(fullPath, filename, f)
        if _, err = f.WriteString(xml.Header); err != nil </span><span class="cov0" title="0">{
                log.Debug().Err(err).Msg("Failed to write XML header")
        }</span>
        <span class="cov4" title="3">encoder := xml.NewEncoder(f)
        encoder.Indent("", "\t")

        return encoder.Encode(body)</span>
}

func exportCSVReport(path, filename string, body []reportModel.CSVReport) error <span class="cov1" title="1">{
        fullPath := filepath.Join(path, filename)
        f, err := os.OpenFile(filepath.Clean(fullPath), os.O_WRONLY|os.O_CREATE|os.O_TRUNC, os.ModePerm)
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>

        <span class="cov1" title="1">defer closeFile(fullPath, filename, f)

        return gocsv.MarshalFile(&amp;body, f)</span>
}
</pre>
		
		<pre class="file" id="file89" style="display: none">package report

import (
        "strings"

        reportModel "github.com/Checkmarx/kics/pkg/report/model"
)

// PrintCSVReport prints the CSV report in the given path and filename with the given body
func PrintCSVReport(path, filename string, body interface{}) error <span class="cov8" title="1">{
        if !strings.HasSuffix(filename, ".csv") </span><span class="cov8" title="1">{
                filename += ".csv"
        }</span>

        <span class="cov8" title="1">var report []reportModel.CSVReport
        if body != "" </span><span class="cov8" title="1">{
                summary, err := getSummary(body)
                if err != nil </span><span class="cov0" title="0">{
                        return err
                }</span>

                <span class="cov8" title="1">report = reportModel.BuildCSVReport(&amp;summary)</span>
        }

        <span class="cov8" title="1">return exportCSVReport(path, filename, report)</span>
}
</pre>
		
		<pre class="file" id="file90" style="display: none">package report

import (
        "strings"

        "github.com/Checkmarx/kics/pkg/model"
        reportModel "github.com/Checkmarx/kics/pkg/report/model"
)

// PrintCycloneDxReport prints the CycloneDX report in the given path and filename with the given body
func PrintCycloneDxReport(path, filename string, body interface{}) error <span class="cov10" title="2">{
        filePaths := make(map[string]string)

        if !strings.HasPrefix(filename, "cyclonedx-") </span><span class="cov10" title="2">{
                filename = "cyclonedx-" + filename
        }</span>

        <span class="cov10" title="2">if body != "" </span><span class="cov10" title="2">{
                if s, ok := body.(*model.Summary); ok </span><span class="cov0" title="0">{
                        filePaths = s.FilePaths
                }</span>
                <span class="cov10" title="2">summary, err := getSummary(body)
                if err != nil </span><span class="cov0" title="0">{
                        return err
                }</span>

                <span class="cov10" title="2">body = reportModel.BuildCycloneDxReport(&amp;summary, filePaths)</span>
        }

        <span class="cov10" title="2">return exportXMLReport(path, filename, body)</span>
}
</pre>
		
		<pre class="file" id="file91" style="display: none">package report

import (
        "strings"

        reportModel "github.com/Checkmarx/kics/pkg/report/model"
)

// PrintGitlabSASTReport creates a report file on sarif format
func PrintGitlabSASTReport(path, filename string, body interface{}) error <span class="cov1" title="1">{
        filename = strings.ReplaceAll(filename, ".glsast", "")
        if !strings.HasSuffix(filename, jsonExtension) </span><span class="cov1" title="1">{
                filename += jsonExtension
        }</span>
        <span class="cov1" title="1">if !strings.HasPrefix(filename, "gl-sast-") </span><span class="cov1" title="1">{
                filename = "gl-sast-" + filename
        }</span>
        <span class="cov1" title="1">if body != "" </span><span class="cov1" title="1">{
                summary, err := getSummary(body)
                if err != nil </span><span class="cov0" title="0">{
                        return err
                }</span>

                <span class="cov1" title="1">gitlabSASTReport := reportModel.NewGitlabSASTReport(summary.Times.Start, summary.Times.End)

                for idxQuery := range summary.Queries </span><span class="cov1" title="1">{
                        for idxFile := range summary.Queries[idxQuery].Files </span><span class="cov10" title="2">{
                                gitlabSASTReport.BuildGitlabSASTVulnerability(&amp;summary.Queries[idxQuery], &amp;summary.Queries[idxQuery].Files[idxFile])
                        }</span>
                }
                <span class="cov1" title="1">body = gitlabSASTReport</span>
        }

        <span class="cov1" title="1">return ExportJSONReport(path, filename, body)</span>
}
</pre>
		
		<pre class="file" id="file92" style="display: none">package report

import (
        "bytes"
        _ "embed" // used for embedding report static files
        "html/template"
        "os"
        "path/filepath"
        "strings"

        "github.com/Checkmarx/kics/internal/constants"
        "github.com/tdewolff/minify/v2"
        minifyCSS "github.com/tdewolff/minify/v2/css"
        minifyHtml "github.com/tdewolff/minify/v2/html"
        minifyJS "github.com/tdewolff/minify/v2/js"
)

var (
        //go:embed template/html/report.tmpl
        htmlTemplate string
        //go:embed template/html/report.css
        cssTemplate string
        //go:embed template/html/report.js
        jsTemplate string
        //go:embed template/html/github.svg
        githubSVG string
        //go:embed template/html/info.svg
        infoSVG string
        //go:embed template/html/vulnerability_fill.svg
        vulnerabilityFillSVG string
        //go:embed template/html/vulnerability_out.svg
        vulnerabilityOutSVG string
)

const (
        textHTML = "text/html"
)

var svgMap = map[string]string{
        "github.svg":             githubSVG,
        "info.svg":               infoSVG,
        "vulnerability_fill.svg": vulnerabilityFillSVG,
        "vulnerability_out.svg":  vulnerabilityOutSVG,
}

func includeSVG(name string) template.HTML <span class="cov10" title="7">{
        return template.HTML(svgMap[name]) //nolint
}</span>

func includeCSS(name string) template.HTML <span class="cov1" title="1">{
        minifier := minify.New()
        minifier.AddFunc("text/css", minifyCSS.Minify)
        cssMinified, err := minifier.String("text/css", cssTemplate)
        if err != nil </span><span class="cov0" title="0">{
                return ""
        }</span>
        <span class="cov1" title="1">return template.HTML("&lt;style&gt;" + cssMinified + "&lt;/style&gt;")</span> //nolint
}

func includeJS(name string) template.HTML <span class="cov1" title="1">{
        minifier := minify.New()
        minifier.AddFunc("text/javascript", minifyJS.Minify)
        jsMinified, err := minifier.String("text/javascript", jsTemplate)
        if err != nil </span><span class="cov0" title="0">{
                return ""
        }</span>
        <span class="cov1" title="1">return template.HTML("&lt;script&gt;" + jsMinified + "&lt;/script&gt;")</span> //nolint
}

func getPaths(paths []string) string <span class="cov1" title="1">{
        return strings.Join(paths, ", ")
}</span>

func getVersion() string <span class="cov1" title="1">{
        return constants.Version
}</span>

// PrintHTMLReport creates a report file on HTML format
func PrintHTMLReport(path, filename string, body interface{}) error <span class="cov1" title="1">{
        if !strings.HasSuffix(filename, ".html") </span><span class="cov1" title="1">{
                filename += ".html"
        }</span>

        <span class="cov1" title="1">templateFuncs["includeSVG"] = includeSVG
        templateFuncs["includeCSS"] = includeCSS
        templateFuncs["includeJS"] = includeJS
        templateFuncs["getPaths"] = getPaths
        templateFuncs["getPlatforms"] = getPlatforms
        templateFuncs["getVersion"] = getVersion

        fullPath := filepath.Join(path, filename)
        t := template.Must(template.New("report.tmpl").Funcs(templateFuncs).Parse(htmlTemplate))

        f, err := os.OpenFile(filepath.Clean(fullPath), os.O_WRONLY|os.O_CREATE|os.O_TRUNC, os.ModePerm)
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>
        <span class="cov1" title="1">defer closeFile(fullPath, filename, f)
        var buffer bytes.Buffer

        err = t.Execute(&amp;buffer, body)
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>
        <span class="cov1" title="1">minifier := minify.New()
        minifier.AddFunc(textHTML, minifyHtml.Minify)
        minifier.Add(textHTML, &amp;minifyHtml.Minifier{
                KeepDocumentTags: true,
                KeepEndTags:      true,
                KeepQuotes:       true,
        })

        minifierWriter := minifier.Writer(textHTML, f)
        defer minifierWriter.Close()

        _, err = minifierWriter.Write(buffer.Bytes())
        return err</span>
}
</pre>
		
		<pre class="file" id="file93" style="display: none">package report

import "github.com/Checkmarx/kics/internal/constants"

const jsonExtension = ".json"

// PrintJSONReport prints on JSON file the summary results
func PrintJSONReport(path, filename string, body interface{}) error <span class="cov8" title="1">{
        if body != "" </span><span class="cov8" title="1">{
                summary, err := getSummary(body)
                if err != nil </span><span class="cov0" title="0">{
                        return err
                }</span>
                <span class="cov8" title="1">for idx := range summary.Queries </span><span class="cov8" title="1">{
                        summary.Queries[idx].CISBenchmarkName = ""
                        summary.Queries[idx].CISBenchmarkVersion = ""
                        summary.Queries[idx].CISDescriptionID = ""
                        summary.Queries[idx].CISDescriptionText = ""
                        summary.Queries[idx].CISRationaleText = ""
                }</span>
                <span class="cov8" title="1">summary.Version = constants.Version
                body = summary</span>
        }

        <span class="cov8" title="1">return ExportJSONReport(path, filename, body)</span>
}
</pre>
		
		<pre class="file" id="file94" style="display: none">package report

import (
        "strings"

        "github.com/Checkmarx/kics/pkg/model"
        reportModel "github.com/Checkmarx/kics/pkg/report/model"
)

// PrintJUnitReport prints the JUnit report in the given path and filename with the given body
func PrintJUnitReport(path, filename string, body interface{}) error <span class="cov8" title="1">{
        if !strings.HasPrefix(filename, "junit-") </span><span class="cov8" title="1">{
                filename = "junit-" + filename
        }</span>

        <span class="cov8" title="1">summary := model.Summary{}

        if body != "" </span><span class="cov8" title="1">{
                var err error
                summary, err = getSummary(body)
                if err != nil </span><span class="cov0" title="0">{
                        return err
                }</span>
        }

        <span class="cov8" title="1">jUnitReport := reportModel.NewJUnitReport(summary.Times.End.Sub(summary.Times.Start).String())
        for idx := range summary.Queries </span><span class="cov8" title="1">{
                jUnitReport.GenerateTestEntry(&amp;summary.Queries[idx])
        }</span>

        <span class="cov8" title="1">jUnitReport.FinishReport()

        return exportXMLReport(path, filename, jUnitReport)</span>
}
</pre>
		
		<pre class="file" id="file95" style="display: none">package model

import (
        "fmt"
        "os"
        "strings"
        "time"

        "github.com/Checkmarx/kics/pkg/model"
        "github.com/aws/aws-sdk-go/aws"
        "github.com/rs/zerolog/log"
)

// AwsAccountInfo contains all the relevant information of the user AWS account
type AwsAccountInfo struct {
        AwsAccountID string
        AwsRegion    string
}

// AwsSecurityFinding contains all the relevant information to build a finding
type AwsSecurityFinding struct {
        AwsAccountID  string `json:"AwsAccountId"`
        Compliance    Compliance
        CreatedAt     string
        Description   string
        GeneratorID   string `json:"GeneratorId"`
        ID            string `json:"Id"`
        ProductArn    string
        Remediation   Remediation
        Resources     []Resource
        SchemaVersion string
        Severity      Severity
        Title         string
        Types         []string
        UpdatedAt     string
}

// AsffRecommendation includes the recommendation to avoid the finding
type AsffRecommendation struct {
        Text string
}

// Remediation contains the recommendation
type Remediation struct {
        Recommendation AsffRecommendation
}

// Resource contains the ID and the type of the target resource
type Resource struct {
        ID   string `json:"Id"`
        Type string
}

// Severity contains the original severity (KICS severity) and the label severity (ASFF severity)
type Severity struct {
        Original string
        Label    string
}

// Compliance contains the status of the finding
type Compliance struct {
        Status string
}

// BuildASFF builds the ASFF report
func BuildASFF(summary *model.Summary) []AwsSecurityFinding <span class="cov1" title="1">{
        findings := []AwsSecurityFinding{}

        awsAccountInfo := getAwsAccountInfo()

        if awsAccountInfo.incompleteAwsAccountInfo() </span><span class="cov0" title="0">{
                variables := "AWS_ACCOUNT_ID, AWS_REGION"
                log.Debug().Msg(fmt.Sprintf("failed to get AWS account information: check your environment variables (%s)", variables))
        }</span>

        <span class="cov1" title="1">for idx := range summary.Queries </span><span class="cov1" title="1">{
                query := summary.Queries[idx]

                findingPerQuery := awsAccountInfo.getFindingsPerQuery(&amp;query)
                findings = append(findings, findingPerQuery...)
        }</span>

        <span class="cov1" title="1">return findings</span>
}

func (a *AwsAccountInfo) getFindingsPerQuery(query *model.QueryResult) []AwsSecurityFinding <span class="cov1" title="1">{
        var findings []AwsSecurityFinding
        if query.CloudProvider == "AWS" </span><span class="cov1" title="1">{
                for i := range query.Files </span><span class="cov1" title="1">{
                        finding := a.getFinding(query, &amp;query.Files[i])
                        findings = append(findings, finding)
                }</span>
        }

        <span class="cov1" title="1">return findings</span>
}

func (a *AwsAccountInfo) getFinding(query *model.QueryResult, file *model.VulnerableFile) AwsSecurityFinding <span class="cov1" title="1">{
        awsAccountID := a.AwsAccountID
        awsRegion := a.AwsRegion

        timeFormatted := time.Now().Format(time.RFC3339)

        arn := "arn:aws:securityhub:%s:%s:product/%s/default"
        arn = fmt.Sprintf(arn, awsRegion, awsAccountID, awsAccountID)

        severity := string(query.Severity)
        if severity == "INFO" </span><span class="cov0" title="0">{
                severity = "INFORMATIONAL"
        }</span>

        <span class="cov1" title="1">finding := AwsSecurityFinding{
                AwsAccountID: *aws.String(awsAccountID),
                CreatedAt:    *aws.String(timeFormatted),
                Description:  *aws.String(getDescription(query, "asff")),
                GeneratorID:  *aws.String(query.QueryID),
                ID:           *aws.String(fmt.Sprintf("%s/%s/%s", awsRegion, awsAccountID, file.SimilarityID)),
                ProductArn:   *aws.String(arn),
                Resources: []Resource{
                        {
                                ID:   *aws.String(query.QueryID),
                                Type: *aws.String("Other"),
                        },
                },
                SchemaVersion: *aws.String("2018-10-08"),
                Severity: Severity{
                        Original: *aws.String(string(query.Severity)),
                        Label:    *aws.String(severity),
                },
                Title:     *aws.String(query.QueryName),
                Types:     []string{*aws.String("Software and Configuration Checks/Vulnerabilities/KICS")},
                UpdatedAt: *aws.String(timeFormatted),

                Remediation: Remediation{
                        Recommendation: AsffRecommendation{
                                Text: *aws.String(fmt.Sprintf(
                                        "Problem found on '%s' file in line %d. Expected value: %s. Actual value: %s.",
                                        file.FileName,
                                        file.Line,
                                        strings.TrimRight(file.KeyExpectedValue, "."),
                                        strings.TrimRight(file.KeyActualValue, "."),
                                )),
                        },
                },
                Compliance: Compliance{Status: *aws.String("FAILED")},
        }

        return finding</span>
}

func getEnv(env string) string <span class="cov10" title="2">{
        if len(os.Getenv(env)) &gt; 0 </span><span class="cov0" title="0">{
                return os.Getenv(env)
        }</span>

        <span class="cov10" title="2">return env</span>
}

func getAwsAccountInfo() *AwsAccountInfo <span class="cov1" title="1">{
        awsAccountInfo := AwsAccountInfo{
                AwsAccountID: getEnv("AWS_ACCOUNT_ID"),
                AwsRegion:    getEnv("AWS_REGION"),
        }

        return &amp;awsAccountInfo
}</span>

func (a *AwsAccountInfo) incompleteAwsAccountInfo() bool <span class="cov1" title="1">{
        if a.AwsAccountID == "" || a.AwsRegion == "" </span><span class="cov0" title="0">{
                return true
        }</span>

        <span class="cov1" title="1">return false</span>
}
</pre>
		
		<pre class="file" id="file96" style="display: none">package model

import "github.com/Checkmarx/kics/pkg/model"

type lines struct {
        Begin int `json:"begin"`
}

type location struct {
        Path  string `json:"path"`
        Lines lines  `json:"lines"`
}

// CodeClimateReport struct contains all the info to create the code climate report
type CodeClimateReport struct {
        Type        string   `json:"type"`
        CheckName   string   `json:"check_name"`
        Description string   `json:"description"`
        Categories  []string `json:"categories"`
        Location    location `json:"location"`
        Severity    string   `json:"severity"`
        Fingerprint string   `json:"fingerprint"`
}

var severityMap = map[string]string{
        model.SeverityTrace:  "info",
        model.SeverityInfo:   "info",
        model.SeverityLow:    "minor",
        model.SeverityMedium: "major",
        model.SeverityHigh:   "critical",
}

// BuildCodeClimateReport builds the code climate report
func BuildCodeClimateReport(summary *model.Summary) []CodeClimateReport <span class="cov1" title="1">{
        var codeClimateReport []CodeClimateReport

        for i := range summary.Queries </span><span class="cov1" title="1">{
                for j := range summary.Queries[i].Files </span><span class="cov10" title="2">{
                        codeClimateReport = append(codeClimateReport, CodeClimateReport{
                                Type:        "issue",
                                CheckName:   summary.Queries[i].QueryName,
                                Description: summary.Queries[i].Description,
                                Categories:  []string{"Security"},
                                Location: location{
                                        Path:  summary.Queries[i].Files[j].FileName,
                                        Lines: lines{Begin: summary.Queries[i].Files[j].Line},
                                },
                                Severity:    severityMap[string(summary.Queries[i].Severity)],
                                Fingerprint: summary.Queries[i].Files[j].SimilarityID,
                        })
                }</span>
        }

        <span class="cov1" title="1">return codeClimateReport</span>
}
</pre>
		
		<pre class="file" id="file97" style="display: none">package model

import "github.com/Checkmarx/kics/pkg/model"

// CSVReport struct contains all the info to create the csv report
type CSVReport struct {
        QueryName                   string `csv:"query_name"`
        QueryID                     string `csv:"query_id"`
        QueryURI                    string `csv:"query_uri"`
        Severity                    string `csv:"severity"`
        Platform                    string `csv:"platform"`
        CloudProvider               string `csv:"cloud_provider"`
        Category                    string `csv:"category"`
        DescriptionID               string `csv:"description_id"`
        Description                 string `csv:"description"`
        CISDescriptionIDFormatted   string `csv:"cis_description_id"`
        CISDescriptionTitle         string `csv:"cis_description_title"`
        CISDescriptionTextFormatted string `csv:"cis_description_text"`
        FileName                    string `csv:"file_name"`
        SimilarityID                string `csv:"similarity_id"`
        Line                        int    `csv:"line"`
        IssueType                   string `csv:"issue_type"`
        SearchKey                   string `csv:"search_key"`
        SearchLine                  int    `csv:"search_line"`
        SearchValue                 string `csv:"search_value"`
        ExpectedValue               string `csv:"expected_value"`
        ActualValue                 string `csv:"actual_value"`
}

// BuildCSVReport builds the CSV report
func BuildCSVReport(summary *model.Summary) []CSVReport <span class="cov1" title="1">{
        csvReport := []CSVReport{}

        for i := range summary.Queries </span><span class="cov1" title="1">{
                for j := range summary.Queries[i].Files </span><span class="cov10" title="2">{
                        csvReport = append(csvReport, CSVReport{
                                QueryName:                   summary.Queries[i].QueryName,
                                QueryID:                     summary.Queries[i].QueryID,
                                QueryURI:                    summary.Queries[i].QueryURI,
                                Severity:                    string(summary.Queries[i].Severity),
                                Platform:                    summary.Queries[i].Platform,
                                CloudProvider:               summary.Queries[i].CloudProvider,
                                Category:                    summary.Queries[i].Category,
                                DescriptionID:               summary.Queries[i].DescriptionID,
                                Description:                 summary.Queries[i].Description,
                                CISDescriptionIDFormatted:   summary.Queries[i].CISDescriptionIDFormatted,
                                CISDescriptionTitle:         summary.Queries[i].CISDescriptionTitle,
                                CISDescriptionTextFormatted: summary.Queries[i].CISDescriptionTextFormatted,
                                FileName:                    summary.Queries[i].Files[j].FileName,
                                SimilarityID:                summary.Queries[i].Files[j].SimilarityID,
                                Line:                        summary.Queries[i].Files[j].Line,
                                IssueType:                   string(summary.Queries[i].Files[j].IssueType),
                                SearchKey:                   summary.Queries[i].Files[j].SearchKey,
                                SearchLine:                  summary.Queries[i].Files[j].SearchLine,
                                SearchValue:                 summary.Queries[i].Files[j].SearchValue,
                                ExpectedValue:               summary.Queries[i].Files[j].KeyExpectedValue,
                                ActualValue:                 summary.Queries[i].Files[j].KeyActualValue,
                        })
                }</span>
        }

        <span class="cov1" title="1">return csvReport</span>
}
</pre>
		
		<pre class="file" id="file98" style="display: none">package model

import (
        "crypto/sha256"
        "encoding/hex"
        "encoding/xml"
        "fmt"
        "os"
        "path/filepath"
        "strings"
        "time"

        "github.com/Checkmarx/kics/internal/constants"
        "github.com/Checkmarx/kics/pkg/model"
        "github.com/google/uuid"
        "github.com/rs/zerolog/log"
)

var cycloneDxSeverityLevelEquivalence = map[model.Severity]string{
        "INFO":   "None",
        "LOW":    "Low",
        "MEDIUM": "Medium",
        "HIGH":   "High",
}

// CycloneDxReport includes all the properties considered relevant for the CycloneDX Report
type CycloneDxReport struct {
        XMLName xml.Name `xml:"bom"`

        // bom tag information
        XMLNS        string `xml:"xmlns,attr"`
        SerialNumber string `xml:"serialNumber,attr"`
        XMLNSV       string `xml:"xmlns:v,attr"`
        Version      int    `xml:"version,attr"`

        // bom body information
        Metadata   *Metadata  `xml:"metadata"`
        Components Components `xml:"components"`
}

// Metadata includes the relevant additional information about the CycloneDX report
type Metadata struct {
        Timestamp string  `xml:"timestamp"`  // the timestamp when the CycloneDX report is created
        Tools     *[]Tool `xml:"tools&gt;tool"` // array of tools used to create the CycloneDX report
}

// Tool includes the information about the tool used to create the CycloneDX report
type Tool struct {
        Vendor  string `xml:"vendor"`
        Name    string `xml:"name"`
        Version string `xml:"version"`
}

// Components is a list of components
type Components struct {
        Components []Component `xml:"component"`
}

// Component includes the CycloneDX component structure properties considered relevant
type Component struct {
        // component tag information
        Type   string `xml:"type,attr"`
        BomRef string `xml:"bom-ref,attr"`

        // component body information
        Name            string          `xml:"name"`
        Version         string          `xml:"version"`
        Hashes          []Hash          `xml:"hashes&gt;hash"`
        Purl            string          `xml:"purl"`
        Vulnerabilities []Vulnerability `xml:"v:vulnerabilities&gt;v:vulnerability"`
}

// Hash includes the algorithm used in the HASH function and the output of it (content)
type Hash struct {
        Alg     string `xml:"alg,attr"`
        Content string `xml:",chardata"`
}

// Vulnerability includes all the relevant information about the vulnerability
type Vulnerability struct {
        // vulnerability tag information
        Ref string `xml:"ref,attr"`

        // vulnerability body information
        ID              string           `xml:"v:id"`
        Source          Source           `xml:"v:source"`
        Ratings         []Rating         `xml:"v:ratings&gt;v:rating"`
        Description     string           `xml:"v:description"`
        Recommendations []Recommendation `xml:"v:recommendations&gt;v:recommendation"`
}

// Source includes information about the origin where the vulnerability was reported
type Source struct {
        Name string `xml:"name"`
        URL  string `xml:"url"`
}

// Rating includes the severity of the vulnerability and the method used to classify it
type Rating struct {
        Severity string `xml:"v:severity"`
        Method   string `xml:"v:method"`
}

// Recommendation describes how the vulnerability should be avoided
type Recommendation struct {
        Recommendation string `xml:""`
}

func match(fileNames []model.VulnerableFile, fileName string) bool <span class="cov6" title="3">{
        for i := range fileNames </span><span class="cov6" title="3">{
                if fileNames[i].FileName == fileName </span><span class="cov1" title="1">{
                        return true
                }</span>
        }
        <span class="cov4" title="2">return false</span>
}

func getAllFiles(summary *model.Summary) []model.VulnerableFile <span class="cov1" title="1">{
        var fileNames []model.VulnerableFile
        for i := range summary.Queries </span><span class="cov4" title="2">{
                files := summary.Queries[i].Files
                for idx := range files </span><span class="cov6" title="3">{
                        if !match(fileNames, files[idx].FileName) </span><span class="cov4" title="2">{
                                fileNames = append(fileNames, files[idx])
                        }</span>
                }
        }
        <span class="cov1" title="1">return fileNames</span>
}

func generateSha256(filePath string, filePaths map[string]string) string <span class="cov4" title="2">{
        file := filePaths[filePath]
        content, err := os.ReadFile(filepath.Clean(file))

        if err != nil </span><span class="cov0" title="0">{
                log.Trace().Msgf("failed to read %s", file)
                return ""
        }</span>

        <span class="cov4" title="2">hashSum := sha256.Sum256(content)
        return hex.EncodeToString(hashSum[:])</span>
}

func getPurl(filePath, version string) string <span class="cov4" title="2">{
        return fmt.Sprintf("pkg:generic/%s@%s", filePath, version)
}</span>

func getDescription(query *model.QueryResult, format string) string <span class="cov7" title="4">{
        queryDescription := query.Description

        if query.CISDescriptionTextFormatted != "" </span><span class="cov0" title="0">{
                queryDescription = query.CISDescriptionTextFormatted
        }</span>

        <span class="cov7" title="4">if format == "asff" </span><span class="cov1" title="1">{
                return queryDescription
        }</span>

        <span class="cov6" title="3">description := fmt.Sprintf("[%s].[%s]: %s", query.Platform, query.QueryName, queryDescription)

        return description</span>
}

func getVulnerabilitiesByFile(query *model.QueryResult, fileName, purl string) []Vulnerability <span class="cov7" title="4">{
        vulns := make([]Vulnerability, 0)
        for idx := range query.Files </span><span class="cov10" title="6">{
                file := query.Files[idx]
                if fileName == file.FileName </span><span class="cov6" title="3">{
                        vuln := Vulnerability{
                                Ref: purl + query.QueryID,
                                ID:  query.QueryID,
                                Source: Source{
                                        Name: "KICS",
                                        URL:  "https://kics.io/",
                                },
                                Ratings: []Rating{
                                        {
                                                Severity: cycloneDxSeverityLevelEquivalence[query.Severity],
                                                Method:   "Other",
                                        },
                                },
                                Description: getDescription(query, "cyclonedx"),
                                Recommendations: []Recommendation{
                                        {
                                                Recommendation: fmt.Sprintf(
                                                        "Problem found in line %d. Expected value: %s. Actual value: %s.",
                                                        file.Line,
                                                        strings.TrimRight(file.KeyExpectedValue, "."),
                                                        strings.TrimRight(file.KeyActualValue, "."),
                                                ),
                                        },
                                },
                        }
                        vulns = append(vulns, vuln)
                }</span>
        }
        <span class="cov7" title="4">return vulns</span>
}

func getVulnerabilities(fileName, purl string, summary *model.Summary) []Vulnerability <span class="cov4" title="2">{
        vulns := make([]Vulnerability, 0)
        for i := range summary.Queries </span><span class="cov7" title="4">{
                query := summary.Queries[i]
                vulns = append(vulns, getVulnerabilitiesByFile(&amp;query, fileName, purl)...)
        }</span>
        <span class="cov4" title="2">return vulns</span>
}

// InitCycloneDxReport inits the CycloneDx report with no components (consequently, no vulnerabilities)
func InitCycloneDxReport() *CycloneDxReport <span class="cov4" title="2">{
        metadata := Metadata{
                Timestamp: time.Now().Format(time.RFC3339),
                Tools: &amp;[]Tool{
                        {
                                Vendor:  "Checkmarx",
                                Name:    "KICS",
                                Version: constants.Version,
                        },
                },
        }

        return &amp;CycloneDxReport{
                XMLNS:        "http://cyclonedx.org/schema/bom/1.3",
                XMLNSV:       "http://cyclonedx.org/schema/ext/vulnerability/1.0",
                SerialNumber: "urn:uuid:" + uuid.New().String(),
                Version:      1,
                Metadata:     &amp;metadata,
        }
}</span>

// BuildCycloneDxReport builds the CycloneDX report
func BuildCycloneDxReport(summary *model.Summary, filePaths map[string]string) *CycloneDxReport <span class="cov1" title="1">{
        var component Component
        var vuln []Vulnerability
        var version, sha, purl, filePath string

        bom := InitCycloneDxReport()
        files := getAllFiles(summary)

        for i := range files </span><span class="cov4" title="2">{
                filePath = strings.Replace(files[i].FileName, "\\", "/", -1)
                sha = generateSha256(files[i].FileName, filePaths)

                index := 12
                if len(sha) &lt; index </span><span class="cov0" title="0">{
                        log.Trace().Msgf("failed to generate SHA-256 for %s", filePath)
                        continue</span>
                }

                <span class="cov4" title="2">version = fmt.Sprintf("0.0.0-%s", sha[0:12])
                purl = getPurl(filePath, version)
                vuln = getVulnerabilities(files[i].FileName, purl, summary)

                component = Component{
                        Type:    "file",
                        BomRef:  purl,
                        Name:    filePath,
                        Version: version,
                        Purl:    purl,
                        Hashes: []Hash{
                                {
                                        Alg:     "SHA-256",
                                        Content: sha,
                                },
                        },
                        Vulnerabilities: vuln,
                }

                bom.Components.Components = append(bom.Components.Components, component)</span>
        }
        <span class="cov1" title="1">return bom</span>
}
</pre>
		
		<pre class="file" id="file99" style="display: none">package model

import (
        "fmt"
        "strings"
        "time"

        "github.com/Checkmarx/kics/internal/constants"
        "github.com/Checkmarx/kics/pkg/model"
        "golang.org/x/text/cases"
        "golang.org/x/text/language"
)

const timeFormat = "2006-01-02T15:04:05" // YYYY-MM-DDTHH:MM:SS a.k.a ISO8601

type gitlabSASTReport struct {
        Schema          string                    `json:"schema"`
        SchemaVersion   string                    `json:"version"`
        Scan            gitlabSASTScan            `json:"scan"`
        Vulnerabilities []gitlabSASTVulnerability `json:"vulnerabilities"`
}

type gitlabSASTScan struct {
        StartTime string            `json:"start_time"`
        EndTime   string            `json:"end_time"`
        Status    string            `json:"status"`
        Scantype  string            `json:"type"`
        Scanner   gitlabSASTScanner `json:"scanner"`
}

type gitlabSASTScanner struct {
        ID      string                  `json:"id"`
        Name    string                  `json:"name"`
        URL     string                  `json:"url"`
        Version string                  `json:"version"`
        Vendor  gitlabSASTScannerVendor `json:"vendor"`
}

type gitlabSASTScannerVendor struct {
        Name string `json:"name"`
}

type gitlabSASTVulnerabilityDetails map[string]interface{}

type gitlabSASTVulnerability struct {
        ID          string                              `json:"id"`
        Category    string                              `json:"category"`
        Severity    string                              `json:"severity"`
        CVE         string                              `json:"cve"`
        Scanner     gitlabSASTVulnerabilityScanner      `json:"scanner"`
        Name        string                              `json:"name"`
        Message     string                              `json:"message"`
        Links       []gitlabSASTVulnerabilityLink       `json:"links"`
        Location    gitlabSASTVulnerabilityLocation     `json:"location"`
        Identifiers []gitlabSASTVulnerabilityIdentifier `json:"identifiers"`
        Details     gitlabSASTVulnerabilityDetails      `json:"details,omitempty"`
}

type gitlabSASTVulnerabilityScanner struct {
        ID   string `json:"id"`
        Name string `json:"name"`
}

type gitlabSASTVulnerabilityLink struct {
        URL string `json:"url"`
}

type gitlabSASTVulnerabilityLocation struct {
        File  string `json:"file"`
        Start int    `json:"start_line"`
        End   int    `json:"end_line"`
}

type gitlabSASTVulnerabilityIdentifier struct {
        IdentifierType string `json:"type"`
        Name           string `json:"name"`
        URL            string `json:"url"`
        Value          string `json:"value"`
}

// GitlabSASTReport represents a usable gitlab sast report reference
type GitlabSASTReport interface {
        BuildGitlabSASTVulnerability(issue *model.QueryResult, file *model.VulnerableFile)
}

// NewGitlabSASTReport initializes a new instance of GitlabSASTReport to be uses
func NewGitlabSASTReport(start, end time.Time) GitlabSASTReport <span class="cov10" title="3">{
        return &amp;gitlabSASTReport{
                Schema:          "https://gitlab.com/gitlab-org/security-products/security-report-schemas/-/raw/v14.1.0/dist/sast-report-format.json",
                SchemaVersion:   "14.0.1",
                Scan:            initGitlabSASTScan(start, end),
                Vulnerabilities: make([]gitlabSASTVulnerability, 0),
        }
}</span>

func initGitlabSASTScan(start, end time.Time) gitlabSASTScan <span class="cov10" title="3">{
        return gitlabSASTScan{
                Status:    "success",
                Scantype:  "sast",
                StartTime: start.Format(timeFormat),
                EndTime:   end.Format(timeFormat),
                Scanner: gitlabSASTScanner{
                        ID:   "keeping-infrastructure-as-code-secure",
                        Name: constants.Fullname,
                        URL:  constants.URL,
                        Vendor: gitlabSASTScannerVendor{
                                Name: "Checkmarx",
                        },
                        Version: constants.Version,
                },
        }
}</span>

// BuildGitlabSASTVulnerability adds a new vulnerability struct to vulnerability slice
func (glsr *gitlabSASTReport) BuildGitlabSASTVulnerability(issue *model.QueryResult, file *model.VulnerableFile) <span class="cov6" title="2">{
        if len(issue.Files) &gt; 0 </span><span class="cov1" title="1">{
                vulnerability := gitlabSASTVulnerability{
                        ID:       file.SimilarityID,
                        Category: "sast",
                        Severity: cases.Title(language.Und).String(strings.ToLower(string(issue.Severity))),
                        CVE:      file.SimilarityID,
                        Scanner: gitlabSASTVulnerabilityScanner{
                                ID:   "keeping_infrastructure_as_code_secure",
                                Name: constants.Fullname,
                        },
                        Name:    issue.QueryName,
                        Message: issue.Description,
                        Links: []gitlabSASTVulnerabilityLink{
                                {
                                        URL: issue.QueryURI,
                                },
                        },
                        Location: gitlabSASTVulnerabilityLocation{
                                File:  file.FileName,
                                Start: file.Line,
                                End:   file.Line,
                        },
                        Identifiers: []gitlabSASTVulnerabilityIdentifier{
                                {
                                        IdentifierType: "kics",
                                        Name:           constants.Fullname,
                                        URL:            fmt.Sprintf("https://docs.kics.io/latest/queries/%s-queries", strings.ToLower(issue.Platform)),
                                        Value:          issue.QueryID,
                                },
                        },
                }
                if issue.CISDescriptionID != "" </span><span class="cov0" title="0">{
                        vulnerability.Message = issue.CISDescriptionTextFormatted
                        vulnerability.Details = gitlabSASTVulnerabilityDetails{
                                "cisTitle": issue.CISDescriptionTitle,
                                "cisId":    issue.CISDescriptionIDFormatted,
                        }
                }</span>
                <span class="cov1" title="1">glsr.Vulnerabilities = append(glsr.Vulnerabilities, vulnerability)</span>
        }
}
</pre>
		
		<pre class="file" id="file100" style="display: none">package model

import (
        "encoding/xml"
        "fmt"
        "strings"

        "github.com/Checkmarx/kics/internal/constants"
        "github.com/Checkmarx/kics/pkg/model"
)

type junitTestSuites struct {
        XMLName    xml.Name         `xml:"testsuites"`
        Name       string           `xml:"name,attr"`
        Time       string           `xml:"time,attr"`
        Failures   string           `xml:"failures,attr"`
        TestSuites []junitTestSuite `xml:"testsuite"`
}

type junitTestSuite struct {
        XMLName   xml.Name        `xml:"testsuite"`
        Name      string          `xml:"name,attr"`
        Failures  string          `xml:"failures,attr"`
        Tests     string          `xml:"tests,attr"`
        TestCases []junitTestCase `xml:"testcase"`
        failCount int
}

type junitTestCase struct {
        XMLName   xml.Name       `xml:"testcase"`
        Name      string         `xml:"name,attr"`
        ClassName string         `xml:"classname,attr"`
        Failures  []junitFailure `xml:"failure"`
}

type junitFailure struct {
        XMLName xml.Name `xml:"failure"`
        Type    string   `xml:"type,attr"`    // Query name
        Message string   `xml:"message,attr"` // File name + line number
}

// JUnitReport is a JUnit report representation
type JUnitReport interface {
        GenerateTestEntry(query *model.QueryResult)
        FinishReport()
}

// NewJUnitReport creates a new JUnit report instance
func NewJUnitReport(time string) JUnitReport <span class="cov10" title="3">{
        return &amp;junitTestSuites{
                Name:       fmt.Sprintf("KICS %s", constants.Version),
                Time:       time,
                Failures:   "",
                TestSuites: []junitTestSuite{},
        }
}</span>

// GenerateTestEntry generates a new test entry for failed tests on KICS scan
func (jUnit *junitTestSuites) GenerateTestEntry(query *model.QueryResult) <span class="cov1" title="1">{
        queryDescription := query.Description
        if query.CISDescriptionTextFormatted != "" </span><span class="cov0" title="0">{
                queryDescription = query.CISDescriptionTextFormatted
        }</span>

        <span class="cov1" title="1">failedTestCases := []junitTestCase{}

        for idx := range query.Files </span><span class="cov1" title="1">{
                failedTestCase := junitTestCase{
                        Name:      fmt.Sprintf("%s: %s file in line %d", query.QueryName, query.Files[idx].FileName, query.Files[idx].Line),
                        ClassName: query.Platform,
                        Failures:  []junitFailure{},
                }

                failedTest := junitFailure{
                        Type: queryDescription,
                        Message: fmt.Sprintf(
                                "[Severity: %s, Query description: %s] Problem found on '%s' file in line %d. Expected value: %s. Actual value: %s.",
                                query.Severity,
                                queryDescription,
                                query.Files[idx].FileName,
                                query.Files[idx].Line,
                                strings.TrimRight(query.Files[idx].KeyExpectedValue, "."),
                                strings.TrimRight(query.Files[idx].KeyActualValue, "."),
                        ),
                }

                failedTestCase.Failures = append(failedTestCase.Failures, failedTest)
                failedTestCases = append(failedTestCases, failedTestCase)
        }</span>

        <span class="cov1" title="1">newTestSuite := junitTestSuite{
                Name:      query.Platform,
                Failures:  "",
                Tests:     "",
                failCount: len(query.Files),
                TestCases: failedTestCases,
        }

        jUnit.TestSuites = append(jUnit.TestSuites, newTestSuite)</span>
}

// FinishReport finishes the report, adding the total number of failed tests for each platform and the total number of failed tests
func (jUnit *junitTestSuites) FinishReport() <span class="cov6" title="2">{
        failsCount := 0
        for idx := range jUnit.TestSuites </span><span class="cov1" title="1">{
                failsCount += jUnit.TestSuites[idx].failCount
                jUnit.TestSuites[idx].Failures = fmt.Sprintf("%d", jUnit.TestSuites[idx].failCount)
                jUnit.TestSuites[idx].Tests = fmt.Sprintf("%d", jUnit.TestSuites[idx].failCount)
        }</span>
        <span class="cov6" title="2">jUnit.Failures = fmt.Sprintf("%d", failsCount)</span>
}
</pre>
		
		<pre class="file" id="file101" style="display: none">package model

import (
        "github.com/Checkmarx/kics/internal/constants"
        "github.com/Checkmarx/kics/pkg/model"
        "github.com/rs/zerolog/log"
)

var categoriesNotFound = make(map[string]bool)

var severityLevelEquivalence = map[model.Severity]string{
        "INFO":   "none",
        "LOW":    "note",
        "MEDIUM": "warning",
        "HIGH":   "error",
}

var targetTemplate = sarifDescriptorReference{
        ToolComponent: sarifComponentReference{
                ComponentReferenceGUID:  "58cdcc6f-fe41-4724-bfb3-131a93df4c3f",
                ComponentReferenceName:  "Categories",
                ComponentReferenceIndex: 0,
        },
}

type sarifProperties map[string]interface{}

type ruleMetadata struct {
        queryID          string
        queryName        string
        queryDescription string
        queryURI         string
        queryCategory    string
        severity         model.Severity
}

type ruleCISMetadata struct {
        descriptionText string
        id              string
        title           string
}

type sarifMessage struct {
        Text string `json:"text"`
}

type sarifComponentReference struct {
        ComponentReferenceName  string `json:"name"`
        ComponentReferenceGUID  string `json:"guid"`
        ComponentReferenceIndex int    `json:"index"`
}

type sarifDescriptorReference struct {
        ReferenceID    string                  `json:"id"`
        ReferenceIndex int                     `json:"index"`
        ToolComponent  sarifComponentReference `json:"toolComponent"`
}

type sarifDescriptorRelationship struct {
        Target sarifDescriptorReference `json:"target"`
}

type sarifConfiguration struct {
        Level string `json:"level"`
}

type sarifRule struct {
        RuleID               string                        `json:"id"`
        RuleName             string                        `json:"name"`
        RuleShortDescription sarifMessage                  `json:"shortDescription"`
        RuleFullDescription  sarifMessage                  `json:"fullDescription"`
        DefaultConfiguration sarifConfiguration            `json:"defaultConfiguration"`
        HelpURI              string                        `json:"helpUri"`
        RuleRelationships    []sarifDescriptorRelationship `json:"relationships"`
        RuleProperties       sarifProperties               `json:"properties,omitempty"`
}

type sarifDriver struct {
        ToolName     string      `json:"name"`
        ToolVersion  string      `json:"version"`
        ToolFullName string      `json:"fullName"`
        ToolURI      string      `json:"informationUri"`
        Rules        []sarifRule `json:"rules"`
}

type sarifTool struct {
        Driver sarifDriver `json:"driver"`
}

type sarifRegion struct {
        StartLine int `json:"startLine"`
}

type sarifArtifactLocation struct {
        ArtifactURI string `json:"uri"`
}

type sarifPhysicalLocation struct {
        ArtifactLocation sarifArtifactLocation `json:"artifactLocation"`
        Region           sarifRegion           `json:"region"`
}

type sarifLocation struct {
        PhysicalLocation sarifPhysicalLocation `json:"physicalLocation"`
}

type sarifResult struct {
        ResultRuleID    string          `json:"ruleId"`
        ResultRuleIndex int             `json:"ruleIndex"`
        ResultKind      string          `json:"kind"`
        ResultMessage   sarifMessage    `json:"message"`
        ResultLocations []sarifLocation `json:"locations"`
}

type sarifTaxanomyDefinition struct {
        DefinitionID               string       `json:"id"`
        DefinitionName             string       `json:"name"`
        DefinitionShortDescription sarifMessage `json:"shortDescription"`
        DefinitionFullDescription  sarifMessage `json:"fullDescription"`
}

type sarifTaxonomy struct {
        TaxonomyGUID             string                    `json:"guid"`
        TaxonomyName             string                    `json:"name"`
        TaxonomyFullDescription  sarifMessage              `json:"fullDescription"`
        TaxonomyShortDescription sarifMessage              `json:"shortDescription"`
        TaxonomyDefinitions      []sarifTaxanomyDefinition `json:"taxa"`
}

// SarifRun - sarifRun is a component of the SARIF report
type SarifRun struct {
        Tool       sarifTool       `json:"tool"`
        Results    []sarifResult   `json:"results"`
        Taxonomies []sarifTaxonomy `json:"taxonomies"`
}

// SarifReport represents a usable sarif report reference
type SarifReport interface {
        BuildSarifIssue(issue *model.QueryResult)
}

type sarifReport struct {
        Schema       string     `json:"$schema"`
        SarifVersion string     `json:"version"`
        Runs         []SarifRun `json:"runs"`
}

func initSarifTool() sarifTool <span class="cov4" title="5">{
        return sarifTool{
                Driver: sarifDriver{
                        ToolName:     "KICS",
                        ToolVersion:  constants.Version,
                        ToolFullName: constants.Fullname,
                        ToolURI:      constants.URL,
                        Rules:        make([]sarifRule, 0),
                },
        }
}</span>

func initSarifCategories() []sarifTaxanomyDefinition <span class="cov4" title="5">{
        allCategories := []sarifTaxanomyDefinition{noCategory}
        for _, category := range categories </span><span class="cov10" title="75">{
                allCategories = append(allCategories, category)
        }</span>
        <span class="cov4" title="5">return allCategories</span>
}

func initSarifTaxonomies() []sarifTaxonomy <span class="cov4" title="5">{
        return []sarifTaxonomy{
                {
                        TaxonomyGUID: targetTemplate.ToolComponent.ComponentReferenceGUID,
                        TaxonomyName: targetTemplate.ToolComponent.ComponentReferenceName,
                        TaxonomyShortDescription: sarifMessage{
                                Text: "Vulnerabilities categories",
                        },
                        TaxonomyFullDescription: sarifMessage{
                                Text: "This taxonomy contains the types an issue can assume",
                        },
                        TaxonomyDefinitions: initSarifCategories(),
                },
        }
}</span>

func initSarifRun() []SarifRun <span class="cov4" title="5">{
        return []SarifRun{
                {
                        Tool:       initSarifTool(),
                        Results:    make([]sarifResult, 0),
                        Taxonomies: initSarifTaxonomies(),
                },
        }
}</span>

// NewSarifReport creates and start a new sarif report with default values respecting SARIF schema 2.1.0
func NewSarifReport() SarifReport <span class="cov3" title="4">{
        return &amp;sarifReport{
                Schema:       "https://raw.githubusercontent.com/oasis-tcs/sarif-spec/master/Schemata/sarif-schema-2.1.0.json",
                SarifVersion: "2.1.0",
                Runs:         initSarifRun(),
        }
}</span>

func (sr *sarifReport) findSarifCategory(category string) int <span class="cov3" title="3">{
        for idx, taxonomy := range sr.Runs[0].Taxonomies[0].TaxonomyDefinitions </span><span class="cov9" title="48">{
                if taxonomy.DefinitionName == category </span><span class="cov0" title="0">{
                        return idx
                }</span>
        }
        <span class="cov3" title="3">return 0</span>
}

func (sr *sarifReport) buildSarifCategory(category string) sarifDescriptorReference <span class="cov3" title="3">{
        target := targetTemplate
        categoryIndex := sr.findSarifCategory(category)
        target.ReferenceIndex = categoryIndex
        target.ReferenceID = sr.Runs[0].Taxonomies[0].TaxonomyDefinitions[categoryIndex].DefinitionID
        if categoryIndex == 0 </span><span class="cov3" title="3">{
                if _, exists := categoriesNotFound[category]; !exists </span><span class="cov2" title="2">{
                        log.Warn().Msgf("Category %s not found.", category)
                        categoriesNotFound[category] = true
                }</span>
        }
        <span class="cov3" title="3">return target</span>
}

func (sr *sarifReport) findSarifRuleIndex(ruleID string) int <span class="cov3" title="4">{
        for idx := range sr.Runs[0].Tool.Driver.Rules </span><span class="cov2" title="2">{
                if sr.Runs[0].Tool.Driver.Rules[idx].RuleID == ruleID </span><span class="cov1" title="1">{
                        return idx
                }</span>
        }
        <span class="cov3" title="3">return -1</span>
}

func (sr *sarifReport) buildSarifRule(queryMetadata *ruleMetadata, cisMetadata ruleCISMetadata) int <span class="cov3" title="4">{
        index := sr.findSarifRuleIndex(queryMetadata.queryID)
        if index &lt; 0 </span><span class="cov3" title="3">{
                helpURI := "https://docs.kics.io/"
                if queryMetadata.queryURI != "" </span><span class="cov3" title="3">{
                        helpURI = queryMetadata.queryURI
                }</span>
                <span class="cov3" title="3">rule := sarifRule{
                        RuleID:               queryMetadata.queryID,
                        RuleName:             queryMetadata.queryName,
                        RuleShortDescription: sarifMessage{Text: queryMetadata.queryName},
                        RuleFullDescription:  sarifMessage{Text: queryMetadata.queryDescription},
                        DefaultConfiguration: sarifConfiguration{Level: severityLevelEquivalence[queryMetadata.severity]},
                        RuleRelationships:    []sarifDescriptorRelationship{{Target: sr.buildSarifCategory(queryMetadata.queryCategory)}},
                        HelpURI:              helpURI,
                        RuleProperties:       nil,
                }
                if cisMetadata.id != "" </span><span class="cov0" title="0">{
                        rule.RuleFullDescription.Text = cisMetadata.descriptionText
                        rule.RuleProperties = sarifProperties{
                                "cisId":    cisMetadata.id,
                                "cisTitle": cisMetadata.title,
                        }
                }</span>

                <span class="cov3" title="3">sr.Runs[0].Tool.Driver.Rules = append(sr.Runs[0].Tool.Driver.Rules, rule)
                index = len(sr.Runs[0].Tool.Driver.Rules) - 1</span>
        }
        <span class="cov3" title="4">return index</span>
}

// BuildSarifIssue creates a new entries in Results (one for each file) and new entry in Rules and Taxonomy if necessary
func (sr *sarifReport) BuildSarifIssue(issue *model.QueryResult) <span class="cov4" title="5">{
        if len(issue.Files) &gt; 0 </span><span class="cov3" title="4">{
                metadata := ruleMetadata{
                        queryID:          issue.QueryID,
                        queryName:        issue.QueryName,
                        queryDescription: issue.Description,
                        queryURI:         issue.QueryURI,
                        queryCategory:    issue.Category,
                        severity:         issue.Severity,
                }
                cisDescriptions := ruleCISMetadata{
                        id:              issue.CISDescriptionIDFormatted,
                        title:           issue.CISDescriptionTitle,
                        descriptionText: issue.CISDescriptionTextFormatted,
                }
                ruleIndex := sr.buildSarifRule(&amp;metadata, cisDescriptions)

                kind := "fail"
                if severityLevelEquivalence[issue.Severity] == "none" </span><span class="cov1" title="1">{
                        kind = "informational"
                }</span>
                <span class="cov3" title="4">for idx := range issue.Files </span><span class="cov3" title="4">{
                        line := issue.Files[idx].Line
                        if line &lt; 1 </span><span class="cov1" title="1">{
                                line = 1
                        }</span>
                        <span class="cov3" title="4">result := sarifResult{
                                ResultRuleID:    issue.QueryID,
                                ResultRuleIndex: ruleIndex,
                                ResultKind:      kind,
                                ResultMessage:   sarifMessage{Text: issue.Files[idx].KeyActualValue},
                                ResultLocations: []sarifLocation{
                                        {
                                                PhysicalLocation: sarifPhysicalLocation{
                                                        ArtifactLocation: sarifArtifactLocation{ArtifactURI: issue.Files[idx].FileName},
                                                        Region:           sarifRegion{StartLine: line},
                                                },
                                        },
                                },
                        }
                        sr.Runs[0].Results = append(sr.Runs[0].Results, result)</span>
                }
        }
}
</pre>
		
		<pre class="file" id="file102" style="display: none">package model

const categoryIdentifier = "CAT"

var noCategory = sarifTaxanomyDefinition{
        DefinitionID:               categoryIdentifier + "000",
        DefinitionName:             "Undefined Category",
        DefinitionShortDescription: sarifMessage{Text: "Category is not defined"},
        DefinitionFullDescription:  sarifMessage{Text: "Category is not defined"},
}

func createSarifCategory(identifier, name, description string) sarifTaxanomyDefinition <span class="cov10" title="15">{
        return sarifTaxanomyDefinition{
                DefinitionID:   identifier,
                DefinitionName: name,
                DefinitionShortDescription: sarifMessage{
                        Text: description,
                },
                DefinitionFullDescription: sarifMessage{
                        Text: description,
                },
        }
}</span>

var categories = map[string]sarifTaxanomyDefinition{
        "Access Control": createSarifCategory(categoryIdentifier+"001", "Access Control", "Service permission and identity management"),
        "Availability":   createSarifCategory(categoryIdentifier+"002", "Availability", "Reliability and Scalability"),
        "Backup":         createSarifCategory(categoryIdentifier+"003", "Backup", "Survivability and Recovery"),
        "Best Practices": createSarifCategory(categoryIdentifier+"004", "Best Practices", "Metadata management"),
        "Build Process": createSarifCategory(
                categoryIdentifier+"005",
                "Build Process",
                "Insecure configurations when building/deploying",
        ),
        "Encryption": createSarifCategory(categoryIdentifier+"006", "Encryption", "Data Security and Encryption configuration"),
        "Insecure Configurations": createSarifCategory(
                categoryIdentifier+"007",
                "Insecure Configurations",
                "Configurations which expose the application unnecessarily",
        ),
        "Insecure Defaults": createSarifCategory(
                categoryIdentifier+"008",
                "Insecure Defaults",
                "Configurations that are insecure by default",
        ),
        "Networking and Firewall": createSarifCategory(
                categoryIdentifier+"009",
                "Networking and Firewall",
                "Network port exposure and firewall configuration",
        ),
        "Observability": createSarifCategory(categoryIdentifier+"010", "Observability", "Logging and Monitoring"),
        "Resource Management": createSarifCategory(
                categoryIdentifier+"011",
                "Resource Management",
                "Resource and privilege limit configuration",
        ),
        "Secret Management": createSarifCategory(categoryIdentifier+"012", "Secret Management", "Secret and Key management"),
        "Supply-Chain":      createSarifCategory(categoryIdentifier+"013", "Supply-Chain", "Dependency version management"),
        "Structure and Semantics": createSarifCategory(
                categoryIdentifier+"014",
                "Structure and Semantics",
                "Malformed document structure or inadequate semantics",
        ),
        "Bill Of Materials": createSarifCategory(categoryIdentifier+"015", "Bill Of Materials", "List of resources provisioned"),
}
</pre>
		
		<pre class="file" id="file103" style="display: none">package model

import (
        "github.com/Checkmarx/kics/internal/constants"
        "github.com/Checkmarx/kics/pkg/model"
)

// severitySonarQubeEquivalence maps the severity of the KICS to the SonarQube equivalent
var severitySonarQubeEquivalence = map[model.Severity]string{
        "INFO":   "INFO",
        "LOW":    "MINOR",
        "MEDIUM": "MAJOR",
        "HIGH":   "CRITICAL",
}

// categorySonarQubeEquivalence maps the category to the SonarQube equivalent
var categorySonarQubeEquivalence = map[string]string{
        "Access Control":          "VULNERABILITY",
        "Availability":            "VULNERABILITY",
        "Backup":                  "VULNERABILITY",
        "Best Practices":          "CODE_SMELL",
        "Build Process":           "VULNERABILITY",
        "Encryption":              "VULNERABILITY",
        "Insecure Configurations": "CODE_SMELL",
        "Insecure Defaults":       "CODE_SMELL",
        "Networking and Firewall": "VULNERABILITY",
        "Observability":           "VULNERABILITY",
        "Resource Management":     "VULNERABILITY",
        "Secret Management":       "VULNERABILITY",
        "Supply-Chain":            "VULNERABILITY",
        "Structure and Semantics": "CODE_SMELL",
}

// SonarQubeReportBuilder is the builder for the SonarQubeReport struct
type SonarQubeReportBuilder struct {
        version string
        report  *SonarQubeReport
}

// SonarQubeReport is a list of issues for SonarQube Report
type SonarQubeReport struct {
        Issues []Issue `json:"issues"`
}

// Issue is a single issue for SonarQube Report
type Issue struct {
        EngineID           string      `json:"engineId"`
        RuleID             string      `json:"ruleId"`
        Severity           string      `json:"severity"`
        Type               string      `json:"type"`
        PrimaryLocation    *Location   `json:"primaryLocation"`
        SecondaryLocations []*Location `json:"secondaryLocations,omitempty"`
}

// Location is the location for the vulnerability in the SonarQube Report
type Location struct {
        Message   string `json:"message"`
        FilePath  string `json:"filePath"`
        TextRange *Range `json:"textRange"`
}

// Range is the range for the vulnerability in the SonarQube Report
type Range struct {
        StartLine int `json:"startLine"`
}

// NewSonarQubeRepory creates a new SonarQubeReportBuilder instance
func NewSonarQubeRepory() *SonarQubeReportBuilder <span class="cov1" title="1">{
        return &amp;SonarQubeReportBuilder{
                version: "KICS " + constants.Version,
                report: &amp;SonarQubeReport{
                        Issues: make([]Issue, 0),
                },
        }
}</span>

// BuildReport builds the SonarQubeReport from the given QueryResults
func (s *SonarQubeReportBuilder) BuildReport(summary *model.Summary) *SonarQubeReport <span class="cov1" title="1">{
        for i := range summary.Queries </span><span class="cov1" title="1">{
                s.buildIssue(&amp;summary.Queries[i])
        }</span>
        <span class="cov1" title="1">return s.report</span>
}

// buildIssue builds the issue from the given QueryResult and adds it to the SonarQubeReport
func (s *SonarQubeReportBuilder) buildIssue(query *model.QueryResult) <span class="cov1" title="1">{
        issue := Issue{
                EngineID:           s.version,
                RuleID:             query.QueryID,
                Severity:           severitySonarQubeEquivalence[query.Severity],
                Type:               categorySonarQubeEquivalence[query.Category],
                PrimaryLocation:    buildLocation(0, query),
                SecondaryLocations: buildSecondaryLocation(query),
        }
        s.report.Issues = append(s.report.Issues, issue)
}</span>

// buildSecondaryLocation builds the secondary location for the SonarQube Report
func buildSecondaryLocation(query *model.QueryResult) []*Location <span class="cov1" title="1">{
        locations := make([]*Location, 0)
        for i := range query.Files[1:] </span><span class="cov1" title="1">{
                locations = append(locations, buildLocation(i+1, query))
        }</span>
        <span class="cov1" title="1">return locations</span>
}

// buildLocation builds the location for the SonarQube Report
func buildLocation(index int, query *model.QueryResult) *Location <span class="cov10" title="2">{
        message := query.Description
        if query.CISDescriptionID != "" </span><span class="cov0" title="0">{
                message = query.CISDescriptionID
        }</span>
        <span class="cov10" title="2">return &amp;Location{
                Message:  message,
                FilePath: query.Files[index].FileName,
                TextRange: &amp;Range{
                        StartLine: query.Files[index].Line,
                },
        }</span>
}
</pre>
		
		<pre class="file" id="file104" style="display: none">package report

import (
        _ "embed" // used for embedding report static files
        "fmt"
        "path/filepath"
        "time"

        "github.com/Checkmarx/kics/internal/constants"
        "github.com/Checkmarx/kics/pkg/model"
        "github.com/johnfercher/maroto/pkg/color"
        "github.com/johnfercher/maroto/pkg/consts"
        "github.com/johnfercher/maroto/pkg/pdf"
        "github.com/johnfercher/maroto/pkg/props"
        "github.com/rs/zerolog/log"
)

const (
        defaultTextSize = 8
        smallTextSize   = 6
        pgMarginLeft    = 10
        pgMarginTop     = 15
        pgMarginRight   = 10
        rowXSmall       = 3
        rowSmall        = 4
        rowMedium       = 5
        rowLarge        = 8
        rowXLarge       = 15
        colOne          = 1
        colTwo          = 2
        colThree        = 3
        colFour         = 4
        colFive         = 5
        colSix          = 6
        colEight        = 8
        colNine         = 9
        colTen          = 10
        colFullPage     = 12
        colRuneSlitter  = 20
        textSize        = 10
)

var (
        grayColor = getGrayColor()
        //go:embed assets/vuln
        vulnImageBase64 string
        //go:embed assets/checkmarx-logo
        checkmarxLogo string
)

func createQueryEntryMetadataField(m pdf.Maroto, label, value string, textSize int) <span class="cov8" title="6">{
        m.Col(colTwo, func() </span><span class="cov8" title="6">{
                m.Text(label, props.Text{
                        Size:        float64(textSize),
                        Align:       consts.Left,
                        Extrapolate: false,
                })
        }</span>)
        <span class="cov8" title="6">m.Col(colTwo, func() </span><span class="cov8" title="6">{
                m.Text(value, props.Text{
                        Size:        float64(textSize),
                        Align:       consts.Left,
                        Extrapolate: false,
                })
        }</span>)
}

func createQueriesTable(m pdf.Maroto, queries []model.QueryResult) error <span class="cov4" title="2">{
        for i := range queries </span><span class="cov4" title="2">{
                m.SetBackgroundColor(color.NewWhite())
                queryName := queries[i].QueryName
                resultsCount := fmt.Sprint(len(queries[i].Files))
                severity := string(queries[i].Severity)
                platform := queries[i].Platform
                category := queries[i].Category
                description := queries[i].Description
                var err error
                m.Row(rowLarge, func() </span><span class="cov4" title="2">{
                        m.Col(colOne, func() </span><span class="cov4" title="2">{
                                err = m.Base64Image(vulnImageBase64, consts.Png, props.Rect{
                                        Center:  false,
                                        Percent: 50,
                                        Left:    2,
                                })
                        }</span>)
                        <span class="cov4" title="2">m.Col(colNine, func() </span><span class="cov4" title="2">{
                                m.Text(queryName, props.Text{
                                        Size:        11,
                                        Style:       consts.Bold,
                                        Align:       consts.Left,
                                        Extrapolate: false,
                                })
                        }</span>)
                        <span class="cov4" title="2">m.Col(colOne, func() </span><span class="cov4" title="2">{
                                m.Text("Results", props.Text{
                                        Size:        8,
                                        Style:       consts.Bold,
                                        Align:       consts.Right,
                                        Extrapolate: false,
                                })
                        }</span>)
                        <span class="cov4" title="2">m.Col(colOne, func() </span><span class="cov4" title="2">{
                                m.Text(resultsCount, props.Text{
                                        Size:        8,
                                        Style:       consts.Bold,
                                        Align:       consts.Right,
                                        Extrapolate: false,
                                })
                        }</span>)
                })
                <span class="cov4" title="2">if err != nil </span><span class="cov0" title="0">{
                        return err
                }</span>
                <span class="cov4" title="2">m.Row(colFour, func() </span><span class="cov4" title="2">{
                        createQueryEntryMetadataField(m, "Severity", severity, textSize)
                }</span>)
                <span class="cov4" title="2">m.Row(colThree, func() </span><span class="cov4" title="2">{
                        createQueryEntryMetadataField(m, "Platform", platform, defaultTextSize)
                }</span>)
                <span class="cov4" title="2">m.Row(colFive, func() </span><span class="cov4" title="2">{
                        createQueryEntryMetadataField(m, "Category", category, defaultTextSize)
                }</span>)
                <span class="cov4" title="2">if queries[i].CISDescriptionID != "" </span><span class="cov0" title="0">{
                        createCISRows(m, &amp;queries[i])
                }</span> else<span class="cov4" title="2"> {
                        createDescription(m, description)
                }</span>
                <span class="cov4" title="2">createResultsTable(m, &amp;queries[i])</span>
        }
        <span class="cov4" title="2">return nil</span>
}

func createDescription(m pdf.Maroto, description string) <span class="cov4" title="2">{
        m.Row(colFive, func() </span><span class="cov4" title="2">{
                m.Col(colTwo, func() </span><span class="cov4" title="2">{
                        m.Text("Description", props.Text{
                                Size:        float64(textSize),
                                Align:       consts.Left,
                                Style:       consts.Bold,
                                Extrapolate: false,
                        })
                }</span>)
        })
        <span class="cov4" title="2">m.Row(getRowLength(description), func() </span><span class="cov4" title="2">{
                m.Col(colFullPage, func() </span><span class="cov4" title="2">{
                        m.Text(description, props.Text{
                                Size:        float64(defaultTextSize),
                                Align:       consts.Left,
                                Extrapolate: false,
                        })
                }</span>)
        })
        <span class="cov4" title="2">m.Row(colFive, func() </span><span class="cov4" title="2">{
                m.ColSpace(0)
        }</span>)
}

func createCISRows(m pdf.Maroto, query *model.QueryResult) <span class="cov0" title="0">{
        cisID := query.CISDescriptionIDFormatted
        description := query.CISDescriptionTextFormatted
        title := query.CISDescriptionTitle

        m.Row(colFive, func() </span><span class="cov0" title="0">{
                m.Col(colTwo, func() </span><span class="cov0" title="0">{
                        m.Text("CIS ID", props.Text{
                                Size:        float64(defaultTextSize),
                                Align:       consts.Left,
                                Style:       consts.Bold,
                                Extrapolate: false,
                        })
                }</span>)
                <span class="cov0" title="0">m.Col(colEight, func() </span><span class="cov0" title="0">{
                        m.Text(cisID, props.Text{
                                Size:        float64(defaultTextSize),
                                Align:       consts.Left,
                                Extrapolate: false,
                        })
                }</span>)
        })
        <span class="cov0" title="0">m.Row(colFive, func() </span><span class="cov0" title="0">{
                m.Col(colTwo, func() </span><span class="cov0" title="0">{
                        m.Text("Title", props.Text{
                                Size:        float64(defaultTextSize),
                                Align:       consts.Left,
                                Style:       consts.Bold,
                                Extrapolate: false,
                        })
                }</span>)
                <span class="cov0" title="0">m.Col(colEight, func() </span><span class="cov0" title="0">{
                        m.Text(title, props.Text{
                                Size:        float64(defaultTextSize),
                                Align:       consts.Left,
                                Extrapolate: false,
                        })
                }</span>)
        })
        <span class="cov0" title="0">createDescription(m, description)</span>
}

func getRowLength(value string) float64 <span class="cov4" title="2">{
        length := float64(len(value))
        x := 2.5
        result := ((length / x) / colRuneSlitter) + 1
        return result
}</span>

func createResultsTable(m pdf.Maroto, query *model.QueryResult) <span class="cov4" title="2">{
        for idx := range query.Files </span><span class="cov7" title="4">{
                if idx%2 == 0 </span><span class="cov4" title="2">{
                        m.SetBackgroundColor(grayColor)
                }</span> else<span class="cov4" title="2"> {
                        m.SetBackgroundColor(color.NewWhite())
                }</span>

                <span class="cov7" title="4">filePath := query.Files[idx].FileName
                fileLine := fmt.Sprintf("%s:%s", filePath, fmt.Sprint(query.Files[idx].Line))
                m.Row(colFive, func() </span><span class="cov7" title="4">{
                        m.Col(colFullPage, func() </span><span class="cov7" title="4">{
                                m.Text(fileLine, props.Text{
                                        Size:        defaultTextSize,
                                        Align:       consts.Left,
                                        Extrapolate: false,
                                })
                        }</span>)
                })
                <span class="cov7" title="4">expectedValue := fmt.Sprintf("Expected: %s", query.Files[idx].KeyExpectedValue)
                m.Row(colFive, func() </span><span class="cov7" title="4">{
                        m.Col(colFullPage, func() </span><span class="cov7" title="4">{
                                m.Text(expectedValue, props.Text{
                                        Size:        smallTextSize,
                                        Align:       consts.Left,
                                        Extrapolate: false,
                                })
                        }</span>)
                })
        }
        <span class="cov4" title="2">m.SetBackgroundColor(color.NewWhite())
        m.Line(1.0)</span>
}

func createHeaderArea(m pdf.Maroto) <span class="cov4" title="2">{
        m.Row(rowLarge, func() </span><span class="cov4" title="2">{
                m.Col(colSix, func() </span><span class="cov4" title="2">{
                        _ = m.Base64Image(checkmarxLogo, consts.Png, props.Rect{})
                }</span>)
        })
        <span class="cov4" title="2">m.Row(colFive, func() </span><span class="cov4" title="2">{
                m.ColSpace(0)
        }</span>)
        <span class="cov4" title="2">m.SetBackgroundColor(getPurpleColor())
        m.Row(rowXLarge, func() </span><span class="cov4" title="2">{
                m.Col(colSix, func() </span><span class="cov4" title="2">{
                        m.Text(" KICS REPORT", props.Text{
                                Size:        25,
                                Style:       consts.Bold,
                                Align:       consts.Left,
                                Extrapolate: false,
                                Color:       color.NewWhite(),
                        })
                }</span>)
                <span class="cov4" title="2">m.Col(colSix, func() </span><span class="cov4" title="2">{
                        m.Text(fmt.Sprintf("%s ", constants.Version), props.Text{
                                Size:        25,
                                Style:       consts.Bold,
                                Align:       consts.Right,
                                Extrapolate: false,
                                Color:       color.NewWhite(),
                        })
                }</span>)
        })
        <span class="cov4" title="2">m.SetBackgroundColor(color.NewWhite())
        m.Row(rowXSmall, func() </span><span class="cov4" title="2">{
                m.ColSpace(colFullPage)
        }</span>)
}

func createFooterArea(m pdf.Maroto) <span class="cov7" title="4">{
        m.Row(rowMedium, func() </span><span class="cov4" title="2">{
                m.Col(colOne, func() </span><span class="cov4" title="2">{
                        m.Text("https://kics.io")
                }</span>)
        })
}

// PrintPdfReport creates a report file on the PDF format
func PrintPdfReport(path, filename string, body interface{}) error <span class="cov4" title="2">{
        startTime := time.Now()
        log.Info().Msg("Started generating pdf report")

        summary := body.(*model.Summary)

        m := pdf.NewMaroto(consts.Portrait, consts.A4)
        m.SetPageMargins(pgMarginLeft, pgMarginTop, pgMarginRight)

        m.SetFirstPageNb(1)
        m.SetAliasNbPages("{total}")

        m.RegisterHeader(func() </span><span class="cov4" title="2">{
                createHeaderArea(m)
        }</span>)
        <span class="cov4" title="2">m.RegisterFooter(func() </span><span class="cov7" title="4">{
                createFooterArea(m)
        }</span>)

        <span class="cov4" title="2">m.SetBackgroundColor(color.NewWhite())

        createFirstPageHeader(m, summary)

        m.Line(1.0)

        err := createQueriesTable(m, summary.Queries)
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>

        <span class="cov4" title="2">err = m.OutputFileAndClose(filepath.Join(path, fmt.Sprintf("%s.pdf", filename)))
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>

        <span class="cov4" title="2">log.Info().Msgf("Generate report duration: %v", time.Since(startTime))

        fileCreationReport(filepath.Join(path, filename+".pdf"), filename)

        return err</span>
}

func createDateField(m pdf.Maroto, label string, scanTime time.Time) <span class="cov7" title="4">{
        m.Row(colFour, func() </span><span class="cov7" title="4">{
                m.Col(colTwo, func() </span><span class="cov7" title="4">{
                        m.Text(label, props.Text{
                                Size:        defaultTextSize,
                                Align:       consts.Left,
                                Extrapolate: false,
                        })
                }</span>)
                <span class="cov7" title="4">m.Col(colTwo, func() </span><span class="cov7" title="4">{
                        m.Text(scanTime.Format("15:04:05, Jan 02 2006"), props.Text{
                                Size:        defaultTextSize,
                                Align:       consts.Left,
                                Extrapolate: false,
                        })
                }</span>)
        })
}

func createDateArea(m pdf.Maroto, summary *model.Summary) <span class="cov4" title="2">{
        createDateField(m, "START TIME", summary.Start)
        createDateField(m, "END TIME", summary.End)
}</span>

func createPlatformsArea(m pdf.Maroto, summary *model.Summary) <span class="cov4" title="2">{
        m.Row(rowSmall, func() </span><span class="cov4" title="2">{
                m.Col(colTwo, func() </span><span class="cov4" title="2">{
                        m.Text("PLATFORMS", props.Text{
                                Size:        defaultTextSize,
                                Align:       consts.Left,
                                Extrapolate: false,
                        })
                }</span>)
                <span class="cov4" title="2">m.Col(colTen, func() </span><span class="cov4" title="2">{
                        m.Text(getPlatforms(summary.Queries), props.Text{
                                Size:        defaultTextSize,
                                Align:       consts.Left,
                                Extrapolate: false,
                        })
                }</span>)
        })
}

func createSummaryResultsField(m pdf.Maroto, label, value string, mColor color.Color) <span class="cov10" title="8">{
        m.Col(colOne, func() </span><span class="cov10" title="8">{
                m.Text(label, props.Text{
                        Size:        defaultTextSize,
                        Align:       consts.Left,
                        Style:       consts.Bold,
                        Extrapolate: false,
                        Color:       mColor,
                })
        }</span>)
        <span class="cov10" title="8">m.Col(colOne, func() </span><span class="cov10" title="8">{
                m.Text(value, props.Text{
                        Size:        defaultTextSize,
                        Align:       consts.Left,
                        Style:       consts.Bold,
                        Extrapolate: false,
                        Color:       mColor,
                })
        }</span>)
}

func createSummaryArea(m pdf.Maroto, summary *model.Summary) <span class="cov4" title="2">{
        highSeverityCount := fmt.Sprint(summary.SeverityCounters["HIGH"])
        mediumSeverityCount := fmt.Sprint(summary.SeverityCounters["MEDIUM"])
        lowSeverityCount := fmt.Sprint(summary.SeverityCounters["LOW"])
        infoSeverityCount := fmt.Sprint(summary.SeverityCounters["INFO"])
        totalCount := fmt.Sprint(summary.TotalCounter)

        m.Row(rowMedium, func() </span><span class="cov4" title="2">{
                createSummaryResultsField(m, "HIGH", highSeverityCount, getRedColor())
                createSummaryResultsField(m, "MEDIUM", mediumSeverityCount, getOrangeColor())
                createSummaryResultsField(m, "LOW", lowSeverityCount, getYellowColor())
                createSummaryResultsField(m, "INFO", infoSeverityCount, getBlueColor())

                m.ColSpace(colTwo)

                m.Col(colOne, func() </span><span class="cov4" title="2">{
                        m.Text("TOTAL", props.Text{
                                Size:        defaultTextSize,
                                Align:       consts.Right,
                                Style:       consts.Bold,
                                Extrapolate: false,
                        })
                }</span>)
                <span class="cov4" title="2">m.Col(colOne, func() </span><span class="cov4" title="2">{
                        m.Text(totalCount, props.Text{
                                Size:        defaultTextSize,
                                Align:       consts.Right,
                                Style:       consts.Bold,
                                Extrapolate: false,
                        })
                }</span>)
        })
}

func createFirstPageHeader(m pdf.Maroto, summary *model.Summary) <span class="cov4" title="2">{
        createSummaryArea(m, summary)
        createPlatformsArea(m, summary)
        createDateArea(m, summary)
        m.Row(rowSmall, func() </span><span class="cov4" title="2">{
                m.Col(colTwo, func() </span><span class="cov4" title="2">{
                        m.Text("SCANNED PATHS:", props.Text{
                                Size:        defaultTextSize,
                                Align:       consts.Left,
                                Extrapolate: false,
                        })
                }</span>)
        })
        <span class="cov4" title="2">for i := range summary.ScannedPaths </span><span class="cov4" title="2">{
                scannedPaths := summary.ScannedPaths[i]
                m.Row(rowSmall, func() </span><span class="cov4" title="2">{
                        m.Col(colFullPage, func() </span><span class="cov4" title="2">{
                                m.Text(fmt.Sprintf("- %s", scannedPaths), props.Text{
                                        Size:        defaultTextSize,
                                        Align:       consts.Left,
                                        Extrapolate: true,
                                })
                        }</span>)
                })
        }
        <span class="cov4" title="2">m.Row(rowXSmall, func() </span><span class="cov4" title="2">{
                m.ColSpace(colFullPage)
        }</span>)
}

func getGrayColor() color.Color <span class="cov1" title="1">{
        return color.Color{
                Red:   200,
                Green: 200,
                Blue:  200,
        }
}</span>

func getRedColor() color.Color <span class="cov4" title="2">{
        return color.Color{
                Red:   200,
                Green: 0,
                Blue:  0,
        }
}</span>

func getYellowColor() color.Color <span class="cov4" title="2">{
        return color.Color{
                Red:   206,
                Green: 182,
                Blue:  26,
        }
}</span>

func getOrangeColor() color.Color <span class="cov4" title="2">{
        return color.Color{
                Red:   255,
                Green: 165,
                Blue:  0,
        }
}</span>

func getBlueColor() color.Color <span class="cov4" title="2">{
        return color.Color{
                Red:   0,
                Green: 0,
                Blue:  200,
        }
}</span>

func getPurpleColor() color.Color <span class="cov4" title="2">{
        return color.Color{
                Red:   80,
                Green: 62,
                Blue:  158,
        }
}</span>
</pre>
		
		<pre class="file" id="file105" style="display: none">package report

import (
        "strings"

        reportModel "github.com/Checkmarx/kics/pkg/report/model"
)

// PrintSarifReport creates a report file on sarif format
func PrintSarifReport(path, filename string, body interface{}) error <span class="cov8" title="1">{
        if !strings.HasSuffix(filename, ".sarif") </span><span class="cov8" title="1">{
                filename += ".sarif"
        }</span>
        <span class="cov8" title="1">if body != "" </span><span class="cov8" title="1">{
                summary, err := getSummary(body)
                if err != nil </span><span class="cov0" title="0">{
                        return err
                }</span>

                <span class="cov8" title="1">sarifReport := reportModel.NewSarifReport()
                for idx := range summary.Queries </span><span class="cov8" title="1">{
                        sarifReport.BuildSarifIssue(&amp;summary.Queries[idx])
                }</span>
                <span class="cov8" title="1">body = sarifReport</span>
        }

        <span class="cov8" title="1">return ExportJSONReport(path, filename, body)</span>
}
</pre>
		
		<pre class="file" id="file106" style="display: none">package report

import (
        "strings"

        reportModel "github.com/Checkmarx/kics/pkg/report/model"
)

// PrintSonarQubeReport prints the SonarQube report in the given path and filename with the given body
func PrintSonarQubeReport(path, filename string, body interface{}) error <span class="cov8" title="1">{
        if !strings.HasSuffix(filename, ".json") </span><span class="cov8" title="1">{
                filename += ".json"
        }</span>

        <span class="cov8" title="1">if !strings.HasPrefix(filename, "sonarqube-") </span><span class="cov8" title="1">{
                filename = "sonarqube-" + filename
        }</span>

        <span class="cov8" title="1">if body != "" </span><span class="cov8" title="1">{
                summary, err := getSummary(body)
                if err != nil </span><span class="cov0" title="0">{
                        return err
                }</span>

                <span class="cov8" title="1">SonarQubeReport := reportModel.NewSonarQubeRepory()
                body = SonarQubeReport.BuildReport(&amp;summary)</span>
        }

        <span class="cov8" title="1">return ExportJSONReport(path, filename, body)</span>
}
</pre>
		
		<pre class="file" id="file107" style="display: none">package file

import (
        "io"
        "os"
        "path/filepath"
        "strings"

        "github.com/Checkmarx/kics/internal/constants"
        "gopkg.in/yaml.v3"

        "github.com/Checkmarx/kics/pkg/model"
        "github.com/Checkmarx/kics/pkg/utils"
        "github.com/rs/zerolog/log"
)

// Resolver - replace or modifies in-memory content before parsing
type Resolver struct {
        unmarshler    func(fileContent []byte, v any) error
        marshler      func(v any) ([]byte, error)
        ResolvedFiles map[string]model.ResolvedFile
        Extension     []string
}

// NewResolver returns a new Resolver
func NewResolver(
        unmarshler func(fileContent []byte, v any) error,
        marshler func(v any) ([]byte, error),
        ext []string) *Resolver <span class="cov2" title="2">{
        return &amp;Resolver{
                unmarshler:    unmarshler,
                marshler:      marshler,
                ResolvedFiles: make(map[string]model.ResolvedFile),
                Extension:     ext,
        }
}</span>

// Resolve - replace or modifies in-memory content before parsing
func (r *Resolver) Resolve(fileContent []byte, path string, resolveCount int) []byte <span class="cov5" title="7">{
        if utils.Contains(filepath.Ext(path), []string{".yml", ".yaml"}) </span><span class="cov4" title="4">{
                return r.yamlResolve(fileContent, path, resolveCount)
        }</span>
        <span class="cov3" title="3">var obj any
        err := r.unmarshler(fileContent, &amp;obj)
        if err != nil </span><span class="cov0" title="0">{
                return fileContent
        }</span>

        // resolve the paths
        <span class="cov3" title="3">obj, _ = r.walk(obj, path, resolveCount)

        b, err := r.marshler(obj)
        if err != nil </span><span class="cov0" title="0">{
                return fileContent
        }</span>

        <span class="cov3" title="3">return b</span>
}

func (r *Resolver) walk(value any, path string, resolveCount int) (any, bool) <span class="cov9" title="33">{
        // go over the value and replace paths with the real content
        switch typedValue := value.(type) </span>{
        case string:<span class="cov6" title="12">
                if filepath.Base(path) != typedValue </span><span class="cov6" title="12">{
                        return r.resolvePath(typedValue, path, resolveCount)
                }</span>
                <span class="cov0" title="0">return value, false</span>
        case []any:<span class="cov1" title="1">
                for i, v := range typedValue </span><span class="cov1" title="1">{
                        typedValue[i], _ = r.walk(v, path, resolveCount)
                }</span>
                <span class="cov1" title="1">return typedValue, false</span>
        case map[string]any:<span class="cov8" title="20">
                return r.handleMap(typedValue, path, resolveCount)</span>
        default:<span class="cov0" title="0">
                return value, false</span>
        }
}

func (r *Resolver) handleMap(value map[string]interface{}, path string, resolveCount int) (any, bool) <span class="cov8" title="20">{
        for k, v := range value </span><span class="cov8" title="29">{
                val, res := r.walk(v, path, resolveCount)
                // check if it is a ref than everything needs to be changed
                if res &amp;&amp; strings.Contains(strings.ToLower(k), "ref") </span><span class="cov2" title="2">{
                        return val, false
                }</span>
                <span class="cov8" title="27">value[k] = val</span>
        }
        <span class="cov7" title="18">return value, false</span>
}

func (r *Resolver) yamlResolve(fileContent []byte, path string, resolveCount int) []byte <span class="cov4" title="4">{
        var obj yaml.Node
        err := r.unmarshler(fileContent, &amp;obj)
        if err != nil </span><span class="cov0" title="0">{
                return fileContent
        }</span>

        // resolve the paths
        <span class="cov4" title="4">obj, _ = r.yamlWalk(&amp;obj, path, resolveCount)

        if obj.Kind == 1 &amp;&amp; len(obj.Content) == 1 </span><span class="cov4" title="4">{
                obj = *obj.Content[0]
        }</span>

        <span class="cov4" title="4">b, err := r.marshler(obj)
        if err != nil </span><span class="cov0" title="0">{
                return fileContent
        }</span>

        <span class="cov4" title="4">return b</span>
}

func (r *Resolver) yamlWalk(value *yaml.Node, path string, resolveCount int) (yaml.Node, bool) <span class="cov10" title="46">{
        // go over the value and replace paths with the real conten
        switch value.Kind </span>{
        case yaml.ScalarNode:<span class="cov8" title="29">
                if filepath.Base(path) != value.Value </span><span class="cov8" title="29">{
                        return r.resolveYamlPath(value, path, resolveCount)
                }</span>
                <span class="cov0" title="0">return *value, false</span>
        default:<span class="cov7" title="17">
                for i := range value.Content </span><span class="cov9" title="42">{
                        resolved, ok := r.yamlWalk(value.Content[i], path, resolveCount)
                        if ok &amp;&amp; i &gt;= 1 </span><span class="cov3" title="3">{
                                if strings.Contains(value.Content[i-1].Value, "ref") </span><span class="cov3" title="3">{ // openapi
                                        return resolved, false
                                }</span>
                        }
                        <span class="cov9" title="39">value.Content[i] = &amp;resolved</span>
                }
                <span class="cov7" title="14">return *value, false</span>
        }
}

// isPath returns true if the value is a valid path
func (r *Resolver) resolveYamlPath(v *yaml.Node, filePath string, resolveCount int) (yaml.Node, bool) <span class="cov8" title="29">{
        value := v.Value
        if resolveCount &gt; constants.MaxResolvedFiles </span><span class="cov0" title="0">{
                return *v, false
        }</span>
        <span class="cov8" title="29">path := filepath.Join(filepath.Dir(filePath), value)
        _, err := os.Stat(path)
        if err != nil </span><span class="cov8" title="26">{
                return *v, false
        }</span>

        <span class="cov3" title="3">if !contains(filepath.Ext(path), r.Extension) </span><span class="cov0" title="0">{
                return *v, false
        }</span>

        // open the file with the content to replace
        <span class="cov3" title="3">file, err := os.Open(filepath.Clean(path))
        if err != nil </span><span class="cov0" title="0">{
                return *v, false
        }</span>

        <span class="cov3" title="3">defer func(file *os.File) </span><span class="cov3" title="3">{
                err = file.Close()
                if err != nil </span><span class="cov0" title="0">{
                        log.Err(err).Msgf("failed to close resolved file: %s", path)
                }</span>
        }(file)

        // read the content
        <span class="cov3" title="3">fileContent, err := io.ReadAll(file)
        if err != nil </span><span class="cov0" title="0">{
                return *v, false
        }</span>

        <span class="cov3" title="3">resolvedFile := r.Resolve(fileContent, path, resolveCount+1)

        // parse the content
        var obj yaml.Node
        err = r.unmarshler(resolvedFile, &amp;obj)
        if err != nil </span><span class="cov0" title="0">{
                return *v, false
        }</span>

        <span class="cov3" title="3">if obj.Kind == 1 &amp;&amp; len(obj.Content) == 1 </span><span class="cov3" title="3">{
                obj = *obj.Content[0]
        }</span>

        <span class="cov3" title="3">r.ResolvedFiles[value] = model.ResolvedFile{
                Content:      fileContent,
                Path:         path,
                LinesContent: utils.SplitLines(string(fileContent)),
        }

        // Cloudformation !Ref check
        if strings.Contains(strings.ToLower(value), "!ref") </span><span class="cov0" title="0">{
                return obj, false
        }</span>

        <span class="cov3" title="3">return obj, true</span>
}

// isPath returns true if the value is a valid path
func (r *Resolver) resolvePath(value, filePath string, resolveCount int) (any, bool) <span class="cov6" title="12">{
        if resolveCount &gt; constants.MaxResolvedFiles </span><span class="cov0" title="0">{
                return value, false
        }</span>
        <span class="cov6" title="12">path := filepath.Join(filepath.Dir(filePath), value)
        _, err := os.Stat(path)
        if err != nil </span><span class="cov6" title="10">{
                return value, false
        }</span>

        <span class="cov2" title="2">if !contains(filepath.Ext(path), r.Extension) </span><span class="cov0" title="0">{
                return value, false
        }</span>

        // open the file with the content to replace
        <span class="cov2" title="2">file, err := os.Open(filepath.Clean(path))
        if err != nil </span><span class="cov0" title="0">{
                return value, false
        }</span>

        <span class="cov2" title="2">defer func(file *os.File) </span><span class="cov2" title="2">{
                err = file.Close()
                if err != nil </span><span class="cov0" title="0">{
                        log.Err(err).Msgf("failed to close resolved file: %s", path)
                }</span>
        }(file)
        // read the content
        <span class="cov2" title="2">fileContent, err := io.ReadAll(file)
        if err != nil </span><span class="cov0" title="0">{
                return value, false
        }</span>

        <span class="cov2" title="2">resolvedFile := r.Resolve(fileContent, path, resolveCount+1)

        // parse the content
        var obj any
        err = r.unmarshler(resolvedFile, &amp;obj)
        if err != nil </span><span class="cov0" title="0">{
                return value, false
        }</span>

        <span class="cov2" title="2">r.ResolvedFiles[value] = model.ResolvedFile{
                Content:      fileContent,
                Path:         path,
                LinesContent: utils.SplitLines(string(fileContent)),
        }
        // Cloudformation !Ref check
        if strings.Contains(strings.ToLower(value), "!ref") </span><span class="cov0" title="0">{
                return obj, false
        }</span>
        <span class="cov2" title="2">return obj, true</span>
}

func contains(elem string, list []string) bool <span class="cov4" title="5">{
        for _, e := range list </span><span class="cov5" title="8">{
                if elem == e </span><span class="cov4" title="5">{
                        return true
                }</span>
        }
        <span class="cov0" title="0">return false</span>
}
</pre>
		
		<pre class="file" id="file108" style="display: none">package helm

import (
        "fmt"
        "io"
        "log"
        "os"
        "path/filepath"
        "strings"

        "github.com/pkg/errors"
        "helm.sh/helm/v3/pkg/action"
        "helm.sh/helm/v3/pkg/chart"
        "helm.sh/helm/v3/pkg/chart/loader"
        "helm.sh/helm/v3/pkg/chartutil"
        "helm.sh/helm/v3/pkg/cli"
        "helm.sh/helm/v3/pkg/cli/values"
        "helm.sh/helm/v3/pkg/getter"
        "helm.sh/helm/v3/pkg/release"
)

// credit: https://github.com/helm/helm

var (
        settings = cli.New()
)

func runInstall(args []string, client *action.Install,
        valueOpts *values.Options) (*release.Release, []string, error) <span class="cov2" title="3">{
        log.SetOutput(io.Discard)
        defer log.SetOutput(os.Stderr)
        if client.Version == "" &amp;&amp; client.Devel </span><span class="cov0" title="0">{
                client.Version = "&gt;0.0.0-0"
        }</span>

        <span class="cov2" title="3">name, charts, err := client.NameAndChart(args)
        if err != nil </span><span class="cov0" title="0">{
                return nil, []string{}, err
        }</span>
        <span class="cov2" title="3">client.ReleaseName = name

        cp, err := client.ChartPathOptions.LocateChart(charts, settings)
        if err != nil </span><span class="cov0" title="0">{
                return nil, []string{}, err
        }</span>

        <span class="cov2" title="3">p := getter.All(settings)
        vals, err := valueOpts.MergeValues(p)
        if err != nil </span><span class="cov0" title="0">{
                return nil, []string{}, err
        }</span>

        // Check chart dependencies to make sure all are present in /charts
        <span class="cov2" title="3">chartRequested, err := loader.Load(cp)
        if err != nil </span><span class="cov1" title="1">{
                return nil, []string{}, err
        }</span>

        <span class="cov2" title="2">excluded := getExcluded(chartRequested, cp)

        chartRequested = setID(chartRequested)

        if instErr := checkIfInstallable(chartRequested); instErr != nil </span><span class="cov0" title="0">{
                return nil, []string{}, instErr
        }</span>

        <span class="cov2" title="2">client.Namespace = "kics-namespace"
        helmRelease, err := client.Run(chartRequested, vals)
        if err != nil </span><span class="cov0" title="0">{
                return nil, []string{}, err
        }</span>
        <span class="cov2" title="2">return helmRelease, excluded, nil</span>
}

// checkIfInstallable validates if a chart can be installed
//
// Application chart type is only installable
func checkIfInstallable(ch *chart.Chart) error <span class="cov2" title="2">{
        switch ch.Metadata.Type </span>{
        case "", "application":<span class="cov2" title="2">
                return nil</span>
        }
        <span class="cov0" title="0">return errors.Errorf("%s charts are not installable", ch.Metadata.Type)</span>
}

// newClient will create a new instance on helm client used to render the chart
func newClient() *action.Install <span class="cov2" title="3">{
        cfg := new(action.Configuration)
        client := action.NewInstall(cfg)
        client.DryRun = true
        client.ReleaseName = "kics-helm"
        client.Replace = true // Skip the name check
        client.ClientOnly = true
        client.APIVersions = chartutil.VersionSet([]string{})
        client.IncludeCRDs = false
        return client
}</span>

// setID will add auxiliary lines for each template as well as its dependencies
func setID(chartReq *chart.Chart) *chart.Chart <span class="cov2" title="3">{
        for _, temp := range chartReq.Templates </span><span class="cov4" title="9">{
                temp = addID(temp)
                if temp != nil </span><span class="cov4" title="9">{
                        continue</span>
                }
        }
        <span class="cov2" title="3">for _, dep := range chartReq.Dependencies() </span><span class="cov1" title="1">{
                dep = setID(dep)
                if dep != nil </span><span class="cov1" title="1">{
                        continue</span>
                }
        }
        <span class="cov2" title="3">return chartReq</span>
}

// addID will add auxiliary lines used to detect line
// one for each "apiVersion:" where the id will be the line
func addID(file *chart.File) *chart.File <span class="cov4" title="9">{
        split := strings.Split(string(file.Data), "\n")
        for i := 0; i &lt; len(split); i++ </span><span class="cov10" title="303">{
                if strings.Contains(split[i], "apiVersion:") </span><span class="cov2" title="3">{
                        split = append(split, "")
                        copy(split[i+1:], split[i:])
                        split[i] = fmt.Sprintf("# KICS_HELM_ID_%d:", i)
                        i++
                }</span>
        }
        <span class="cov4" title="9">file.Data = []byte(strings.Join(split, "\n"))
        return file</span>
}

// getExcluded will return all files rendered to be excluded from scan
func getExcluded(charterino *chart.Chart, chartpath string) []string <span class="cov2" title="2">{
        excluded := make([]string, 0)
        for _, file := range charterino.Raw </span><span class="cov5" title="18">{
                excluded = append(excluded, filepath.Join(chartpath, file.Name))
        }</span>

        <span class="cov2" title="2">return excluded</span>
}
</pre>
		
		<pre class="file" id="file109" style="display: none">package helm

import (
        "path/filepath"
        "regexp"
        "strconv"
        "strings"

        "github.com/Checkmarx/kics/pkg/model"
        "github.com/pkg/errors"
        "helm.sh/helm/v3/pkg/chart"
        "helm.sh/helm/v3/pkg/cli/values"
        "helm.sh/helm/v3/pkg/release"
)

// Resolver is an instance of the helm resolver
type Resolver struct {
}

// splitManifest keeps the information of the manifest splitted by source
type splitManifest struct {
        path       string
        content    []byte
        original   []byte
        splitID    string
        splitIDMap map[int]interface{}
}

const (
        kicsHelmID = "# KICS_HELM_ID_"
)

// Resolve will render the passed helm chart and return its content ready for parsing
func (r *Resolver) Resolve(filePath string) (model.ResolvedFiles, error) <span class="cov3" title="3">{
        splits, excluded, err := renderHelm(filePath)
        if err != nil </span><span class="cov1" title="1">{ // return error to be logged
                return model.ResolvedFiles{}, errors.New("failed to render helm chart")
        }</span>
        <span class="cov2" title="2">var rfiles = model.ResolvedFiles{
                Excluded: excluded,
        }
        for _, split := range *splits </span><span class="cov3" title="3">{
                subFolder := filepath.Base(filePath)

                splitPath := strings.Split(split.path, getPathSeparator(split.path))

                splited := filepath.Join(splitPath[1:]...)

                origpath := filepath.Join(filepath.Dir(filePath), subFolder, splited)
                rfiles.File = append(rfiles.File, model.ResolvedHelm{
                        FileName:     origpath,
                        Content:      split.content,
                        OriginalData: split.original,
                        SplitID:      split.splitID,
                        IDInfo:       split.splitIDMap,
                })
        }</span>
        <span class="cov2" title="2">return rfiles, nil</span>
}

// SupportedTypes returns the supported fileKinds for this resolver
func (r *Resolver) SupportedTypes() []model.FileKind <span class="cov1" title="1">{
        return []model.FileKind{model.KindHELM}
}</span>

// renderHelm will use helm library to render helm charts
func renderHelm(path string) (*[]splitManifest, []string, error) <span class="cov3" title="3">{
        client := newClient()
        manifest, excluded, err := runInstall([]string{path}, client, &amp;values.Options{})
        if err != nil </span><span class="cov1" title="1">{
                return nil, []string{}, err
        }</span>
        <span class="cov2" title="2">splitted, err := splitManifestYAML(manifest)
        if err != nil </span><span class="cov0" title="0">{
                return nil, []string{}, err
        }</span>
        <span class="cov2" title="2">return splitted, excluded, nil</span>
}

// splitManifestYAML will split the rendered file and return its content by template as well as the template path
func splitManifestYAML(template *release.Release) (*[]splitManifest, error) <span class="cov2" title="2">{
        sources := make([]*chart.File, 0)
        sources = updateName(sources, template.Chart, template.Chart.Name())
        var splitedManifest []splitManifest
        splitedSource := strings.Split(template.Manifest, "---") // split manifest by '---'
        origData := toMap(sources)
        for _, splited := range splitedSource </span><span class="cov4" title="5">{
                var lineID string
                for _, line := range strings.Split(splited, "\n") </span><span class="cov6" title="11">{
                        if strings.Contains(line, kicsHelmID) </span><span class="cov3" title="3">{
                                lineID = line // get auxiliary line id
                                break</span>
                        }
                }
                <span class="cov4" title="5">path := strings.Split(strings.TrimLeft(splited, "\n# Source:"), "\n") // get source of split yaml
                // ignore auxiliary files used to render chart
                if path[0] == "" </span><span class="cov2" title="2">{
                        continue</span>
                }
                <span class="cov3" title="3">if origData[filepath.FromSlash(path[0])] == nil </span><span class="cov0" title="0">{
                        continue</span>
                }
                <span class="cov3" title="3">idMap, err := getIDMap(origData[filepath.FromSlash(path[0])])
                if err != nil </span><span class="cov0" title="0">{
                        return nil, err
                }</span>
                <span class="cov3" title="3">splitedManifest = append(splitedManifest, splitManifest{
                        path:       path[0],
                        content:    []byte(strings.ReplaceAll(splited, "\r", "")),
                        original:   origData[filepath.FromSlash(path[0])], // get original data from template
                        splitID:    lineID,
                        splitIDMap: idMap,
                })</span>
        }
        <span class="cov2" title="2">return &amp;splitedManifest, nil</span>
}

// toMap will convert to map original data having the path as it's key
func toMap(files []*chart.File) map[string][]byte <span class="cov2" title="2">{
        mapFiles := make(map[string][]byte)
        for _, file := range files </span><span class="cov6" title="9">{
                mapFiles[file.Name] = []byte(strings.ReplaceAll(string(file.Data), "\r", ""))
        }</span>
        <span class="cov2" title="2">return mapFiles</span>
}

// updateName will update the templates name as well as its dependencies
func updateName(template []*chart.File, charts *chart.Chart, name string) []*chart.File <span class="cov3" title="3">{
        if name != charts.Name() </span><span class="cov1" title="1">{
                name = filepath.Join(name, charts.Name())
        }</span>
        <span class="cov3" title="3">for _, temp := range charts.Templates </span><span class="cov6" title="9">{
                temp.Name = filepath.Join(name, temp.Name)
        }</span>
        <span class="cov3" title="3">template = append(template, charts.Templates...)
        for _, dep := range charts.Dependencies() </span><span class="cov1" title="1">{
                template = updateName(template, dep, filepath.Join(name, "charts"))
        }</span>
        <span class="cov3" title="3">return template</span>
}

// getIdMap will construct a map with ids with the corresponding lines as keys
// for use in detector
func getIDMap(originalData []byte) (map[int]interface{}, error) <span class="cov3" title="3">{
        ids := make(map[int]interface{})
        mapLines := make(map[int]int)
        idHelm := -1
        for line, stringLine := range strings.Split(string(originalData), "\n") </span><span class="cov10" title="48">{
                if strings.Contains(stringLine, kicsHelmID) </span><span class="cov3" title="3">{
                        id, err := strconv.Atoi(strings.TrimSuffix(strings.TrimPrefix(stringLine, kicsHelmID), ":"))
                        if err != nil </span><span class="cov0" title="0">{
                                return nil, err
                        }</span>
                        <span class="cov3" title="3">if idHelm == -1 </span><span class="cov3" title="3">{
                                idHelm = id
                                mapLines[line] = line
                        }</span> else<span class="cov0" title="0"> {
                                ids[idHelm] = mapLines
                                mapLines = make(map[int]int)
                                idHelm = id
                                mapLines[line] = line
                        }</span>
                } else<span class="cov9" title="45"> if idHelm != -1 </span><span class="cov9" title="44">{
                        mapLines[line] = line
                }</span>
        }
        <span class="cov3" title="3">ids[idHelm] = mapLines

        return ids, nil</span>
}

func getPathSeparator(path string) string <span class="cov3" title="3">{
        if matched, err := regexp.MatchString(`[a-zA-Z0-9_\/-]+(\[a-zA-Z0-9_\/-]+)*`, path); matched &amp;&amp; err == nil </span><span class="cov3" title="3">{
                return "/"
        }</span> else<span class="cov0" title="0"> if matched, err := regexp.MatchString(`[a-z0-9_.$-]+(\\[a-z0-9_.$-]+)*`, path); matched &amp;&amp; err == nil </span><span class="cov0" title="0">{
                return "\\"
        }</span>
        <span class="cov0" title="0">return ""</span>
}
</pre>
		
		<pre class="file" id="file110" style="display: none">package resolver

import (
        "os"
        "path/filepath"

        "github.com/Checkmarx/kics/pkg/model"
        "github.com/rs/zerolog/log"
)

// kindResolver is a type of resolver interface (ex: helm resolver)
// Resolve will render file/template
// SupportedTypes will return the file kinds that the resolver supports
type kindResolver interface {
        Resolve(filePath string) (model.ResolvedFiles, error)
        SupportedTypes() []model.FileKind
}

// Resolver is a struct containing the resolvers by file kind
type Resolver struct {
        resolvers map[model.FileKind]kindResolver
}

// Builder is a struct used to create a new resolver
type Builder struct {
        resolvers []kindResolver
}

// NewBuilder creates a new Builder's reference
func NewBuilder() *Builder <span class="cov10" title="2">{
        return &amp;Builder{}
}</span>

// Add will add kindResolvers for building the resolver
func (b *Builder) Add(p kindResolver) *Builder <span class="cov10" title="2">{
        log.Debug().Msgf("resolver.Add()")
        b.resolvers = append(b.resolvers, p)
        return b
}</span>

// Build will create a new intance of a resolver
func (b *Builder) Build() (*Resolver, error) <span class="cov10" title="2">{
        log.Debug().Msg("resolver.Build()")

        resolvers := make(map[model.FileKind]kindResolver, len(b.resolvers))
        for _, resolver := range b.resolvers </span><span class="cov10" title="2">{
                for _, typeRes := range resolver.SupportedTypes() </span><span class="cov10" title="2">{
                        resolvers[typeRes] = resolver
                }</span>
        }

        <span class="cov10" title="2">return &amp;Resolver{
                resolvers: resolvers,
        }, nil</span>
}

// Resolve will resolve the files according to its type
func (r *Resolver) Resolve(filePath string, kind model.FileKind) (model.ResolvedFiles, error) <span class="cov1" title="1">{
        if r, ok := r.resolvers[kind]; ok </span><span class="cov1" title="1">{
                obj, err := r.Resolve(filePath)
                if err != nil </span><span class="cov0" title="0">{
                        return model.ResolvedFiles{}, nil
                }</span>
                <span class="cov1" title="1">log.Debug().Msgf("resolver.Resolve() rendered file: %s", filePath)
                return obj, nil</span>
        }
        // need to log here
        <span class="cov0" title="0">return model.ResolvedFiles{}, nil</span>
}

// GetType will analyze the filepath to determine which resolver to use
func (r *Resolver) GetType(filePath string) model.FileKind <span class="cov10" title="2">{
        _, err := os.Stat(filepath.Join(filePath, "Chart.yaml"))
        if err == nil </span><span class="cov1" title="1">{
                return model.KindHELM
        }</span>
        <span class="cov1" title="1">return model.KindCOMMON</span>
}
</pre>
		
		<pre class="file" id="file111" style="display: none">package scan

import (
        "context"
        "time"

        "github.com/Checkmarx/kics/internal/storage"
        "github.com/Checkmarx/kics/internal/tracker"
        "github.com/Checkmarx/kics/pkg/descriptions"
        consolePrinter "github.com/Checkmarx/kics/pkg/printer"
        "github.com/Checkmarx/kics/pkg/progress"
        "github.com/rs/zerolog/log"
)

// Parameters represents all available scan parameters
type Parameters struct {
        CloudProvider               []string
        DisableCISDesc              bool
        DisableFullDesc             bool
        ExcludeCategories           []string
        ExcludePaths                []string
        ExcludeQueries              []string
        ExcludeResults              []string
        ExcludeSeverities           []string
        IncludeQueries              []string
        InputData                   string
        OutputName                  string
        OutputPath                  string
        Path                        []string
        PayloadPath                 string
        PreviewLines                int
        QueriesPath                 []string
        LibrariesPath               string
        ReportFormats               []string
        Platform                    []string
        QueryExecTimeout            int
        LineInfoPayload             bool
        DisableSecrets              bool
        SecretsRegexesPath          string
        ChangedDefaultQueryPath     bool
        ChangedDefaultLibrariesPath bool
        ScanID                      string
        BillOfMaterials             bool
        ExcludeGitIgnore            bool
}

// Client represents a scan client
type Client struct {
        ScanParams        *Parameters
        ScanStartTime     time.Time
        Tracker           *tracker.CITracker
        Storage           *storage.MemoryStorage
        ExcludeResultsMap map[string]bool
        Printer           *consolePrinter.Printer
        ProBarBuilder     *progress.PbBuilder
}

// NewClient initializes the client with all the required parameters
func NewClient(params *Parameters, proBarBuilder *progress.PbBuilder, customPrint *consolePrinter.Printer) (*Client, error) <span class="cov10" title="2">{
        t, err := tracker.NewTracker(params.PreviewLines)
        if err != nil </span><span class="cov1" title="1">{
                log.Err(err)
                return nil, err
        }</span>

        <span class="cov1" title="1">descriptions.CheckVersion(t)

        store := storage.NewMemoryStorage()

        excludeResultsMap := getExcludeResultsMap(params.ExcludeResults)

        return &amp;Client{
                ScanParams:        params,
                Tracker:           t,
                ProBarBuilder:     proBarBuilder,
                Storage:           store,
                ExcludeResultsMap: excludeResultsMap,
                Printer:           customPrint,
        }, nil</span>
}

// PerformScan executes executeScan and postScan
func (c *Client) PerformScan(ctx context.Context) error <span class="cov0" title="0">{
        c.ScanStartTime = time.Now()

        scanResults, err := c.executeScan(ctx)

        if err != nil </span><span class="cov0" title="0">{
                log.Err(err)
                return err
        }</span>

        <span class="cov0" title="0">postScanError := c.postScan(scanResults)

        if postScanError != nil </span><span class="cov0" title="0">{
                log.Err(postScanError)
                return postScanError
        }</span>

        <span class="cov0" title="0">return nil</span>
}
</pre>
		
		<pre class="file" id="file112" style="display: none">package scan

import (
        _ "embed" // Embed kics CLI img and scan-flags
        "os"
        "path/filepath"
        "strings"
        "time"

        consoleHelpers "github.com/Checkmarx/kics/internal/console/helpers"
        "github.com/Checkmarx/kics/pkg/descriptions"
        "github.com/Checkmarx/kics/pkg/engine/provider"
        "github.com/Checkmarx/kics/pkg/model"
        consolePrinter "github.com/Checkmarx/kics/pkg/printer"
        "github.com/Checkmarx/kics/pkg/progress"
        "github.com/Checkmarx/kics/pkg/report"
        "github.com/rs/zerolog/log"
)

func (c *Client) getSummary(results []model.Vulnerability, end time.Time, pathParameters model.PathParameters) model.Summary <span class="cov5" title="2">{
        counters := model.Counters{
                ScannedFiles:           c.Tracker.FoundFiles,
                ScannedFilesLines:      c.Tracker.FoundCountLines,
                ParsedFilesLines:       c.Tracker.ParsedCountLines,
                ParsedFiles:            c.Tracker.ParsedFiles,
                TotalQueries:           c.Tracker.LoadedQueries,
                FailedToExecuteQueries: c.Tracker.ExecutingQueries - c.Tracker.ExecutedQueries,
                FailedSimilarityID:     c.Tracker.FailedSimilarityID,
        }

        summary := model.CreateSummary(counters, results, c.ScanParams.ScanID, pathParameters.PathExtractionMap, c.Tracker.Version)
        summary.Times = model.Times{
                Start: c.ScanStartTime,
                End:   end,
        }

        if c.ScanParams.DisableCISDesc || c.ScanParams.DisableFullDesc </span><span class="cov0" title="0">{
                log.Warn().Msg("Skipping CIS descriptions because provided disable flag is set")
        }</span> else<span class="cov5" title="2"> {
                err := descriptions.RequestAndOverrideDescriptions(&amp;summary)
                if err != nil </span><span class="cov5" title="2">{
                        log.Warn().Msgf("Unable to get descriptions: %s", err)
                        log.Warn().Msgf("Using default descriptions")
                }</span>
        }

        <span class="cov5" title="2">return summary</span>
}

func (c *Client) resolveOutputs(
        summary *model.Summary,
        documents model.Documents,
        failedQueries map[string]error,
        printer *consolePrinter.Printer,
        proBarBuilder progress.PbBuilder,
) error <span class="cov1" title="1">{
        log.Debug().Msg("console.resolveOutputs()")

        if err := consolePrinter.PrintResult(summary, failedQueries, printer); err != nil </span><span class="cov0" title="0">{
                return err
        }</span>
        <span class="cov1" title="1">if c.ScanParams.PayloadPath != "" </span><span class="cov0" title="0">{
                if err := report.ExportJSONReport(
                        filepath.Dir(c.ScanParams.PayloadPath),
                        filepath.Base(c.ScanParams.PayloadPath),
                        documents,
                ); err != nil </span><span class="cov0" title="0">{
                        return err
                }</span>
        }

        <span class="cov1" title="1">return printOutput(
                c.ScanParams.OutputPath,
                c.ScanParams.OutputName,
                summary, c.ScanParams.ReportFormats,
                proBarBuilder,
        )</span>
}

func printOutput(outputPath, filename string, body interface{}, formats []string, proBarBuilder progress.PbBuilder) error <span class="cov10" title="4">{
        log.Debug().Msg("console.printOutput()")
        if outputPath == "" </span><span class="cov5" title="2">{
                return nil
        }</span>
        <span class="cov5" title="2">if len(formats) == 0 </span><span class="cov1" title="1">{
                formats = []string{"json"}
        }</span>

        <span class="cov5" title="2">log.Debug().Msgf("Output formats provided [%v]", strings.Join(formats, ","))
        err := consoleHelpers.GenerateReport(outputPath, filename, body, formats, proBarBuilder)

        return err</span>
}

// postScan is responsible for the output results
func (c *Client) postScan(scanResults *Results) error <span class="cov1" title="1">{
        if scanResults == nil </span><span class="cov1" title="1">{
                log.Info().Msg("No files were scanned")
                scanResults = &amp;Results{
                        Results:        []model.Vulnerability{},
                        ExtractedPaths: provider.ExtractedPath{},
                        Files:          model.FileMetadatas{},
                        FailedQueries:  map[string]error{},
                }
        }</span>

        <span class="cov1" title="1">summary := c.getSummary(scanResults.Results, time.Now(), model.PathParameters{
                ScannedPaths:      c.ScanParams.Path,
                PathExtractionMap: scanResults.ExtractedPaths.ExtractionMap,
        })

        if err := c.resolveOutputs(
                &amp;summary,
                scanResults.Files.Combine(c.ScanParams.LineInfoPayload),
                scanResults.FailedQueries,
                c.Printer,
                *c.ProBarBuilder); err != nil </span><span class="cov0" title="0">{
                log.Err(err)
                return err
        }</span>

        <span class="cov1" title="1">deleteExtractionFolder(scanResults.ExtractedPaths.ExtractionMap)

        consolePrinter.PrintScanDuration(time.Since(c.ScanStartTime))

        printVersionCheck(c.Printer, &amp;summary)

        contributionAppeal(c.Printer, c.ScanParams.QueriesPath)

        exitCode := consoleHelpers.ResultsExitCode(&amp;summary)
        if consoleHelpers.ShowError("results") &amp;&amp; exitCode != 0 </span><span class="cov0" title="0">{
                os.Exit(exitCode)
        }</span>

        <span class="cov1" title="1">return nil</span>
}
</pre>
		
		<pre class="file" id="file113" style="display: none">// Package scan implements functions and helpers to ensure the proper scan of the specified files
package scan

import (
        "context"
        "os"

        "github.com/Checkmarx/kics/assets"
        "github.com/Checkmarx/kics/pkg/engine"
        "github.com/Checkmarx/kics/pkg/engine/provider"
        "github.com/Checkmarx/kics/pkg/engine/secrets"
        "github.com/Checkmarx/kics/pkg/engine/source"
        "github.com/Checkmarx/kics/pkg/kics"
        "github.com/Checkmarx/kics/pkg/model"
        "github.com/Checkmarx/kics/pkg/parser"
        buildahParser "github.com/Checkmarx/kics/pkg/parser/buildah"
        dockerParser "github.com/Checkmarx/kics/pkg/parser/docker"
        protoParser "github.com/Checkmarx/kics/pkg/parser/grpc"
        jsonParser "github.com/Checkmarx/kics/pkg/parser/json"
        terraformParser "github.com/Checkmarx/kics/pkg/parser/terraform"
        yamlParser "github.com/Checkmarx/kics/pkg/parser/yaml"
        "github.com/Checkmarx/kics/pkg/resolver"
        "github.com/Checkmarx/kics/pkg/resolver/helm"
        "github.com/Checkmarx/kics/pkg/scanner"

        "github.com/rs/zerolog/log"
)

// Results represents a result generated by a single scan
type Results struct {
        Results        []model.Vulnerability
        ExtractedPaths provider.ExtractedPath
        Files          model.FileMetadatas
        FailedQueries  map[string]error
}

type executeScanParameters struct {
        services       []*kics.Service
        inspector      *engine.Inspector
        extractedPaths provider.ExtractedPath
}

func (c *Client) initScan(ctx context.Context) (*executeScanParameters, error) <span class="cov0" title="0">{
        progressBar := c.ProBarBuilder.BuildCircle("Preparing Scan Assets: ")
        go progressBar.Start()

        extractedPaths, err := c.prepareAndAnalyzePaths(ctx)
        if err != nil </span><span class="cov0" title="0">{
                log.Err(err)
                return nil, err
        }</span>

        <span class="cov0" title="0">if len(extractedPaths.Path) == 0 </span><span class="cov0" title="0">{
                return nil, nil
        }</span>

        <span class="cov0" title="0">querySource := source.NewFilesystemSource(
                c.ScanParams.QueriesPath,
                c.ScanParams.Platform,
                c.ScanParams.CloudProvider,
                c.ScanParams.LibrariesPath)

        queryFilter := c.createQueryFilter()

        inspector, err := engine.NewInspector(ctx,
                querySource,
                engine.DefaultVulnerabilityBuilder,
                c.Tracker,
                queryFilter,
                c.ExcludeResultsMap,
                c.ScanParams.QueryExecTimeout,
                true,
        )
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>

        <span class="cov0" title="0">secretsRegexRulesContent, err := getSecretsRegexRules(c.ScanParams.SecretsRegexesPath)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>

        <span class="cov0" title="0">isCustomSecretsRegexes := len(c.ScanParams.SecretsRegexesPath) &gt; 0

        secretsInspector, err := secrets.NewInspector(
                ctx,
                c.ExcludeResultsMap,
                c.Tracker,
                queryFilter,
                c.ScanParams.DisableSecrets,
                c.ScanParams.QueryExecTimeout,
                secretsRegexRulesContent,
                isCustomSecretsRegexes,
        )
        if err != nil </span><span class="cov0" title="0">{
                log.Err(err)
                return nil, err
        }</span>

        <span class="cov0" title="0">services, err := c.createService(
                inspector,
                secretsInspector,
                extractedPaths.Path,
                c.Tracker,
                c.Storage,
                querySource,
        )
        if err != nil </span><span class="cov0" title="0">{
                log.Err(err)
                return nil, err
        }</span>

        <span class="cov0" title="0">if err := progressBar.Close(); err != nil </span><span class="cov0" title="0">{
                log.Debug().Msgf("Failed to close progress bar: %s", err.Error())
        }</span>

        <span class="cov0" title="0">return &amp;executeScanParameters{
                services:       services,
                inspector:      inspector,
                extractedPaths: extractedPaths,
        }, nil</span>
}

func (c *Client) executeScan(ctx context.Context) (*Results, error) <span class="cov0" title="0">{
        executeScanParameters, err := c.initScan(ctx)

        if err != nil </span><span class="cov0" title="0">{
                log.Err(err)
                return nil, err
        }</span>

        <span class="cov0" title="0">if executeScanParameters == nil </span><span class="cov0" title="0">{
                return nil, nil
        }</span>

        <span class="cov0" title="0">if err = scanner.PrepareAndScan(ctx, c.ScanParams.ScanID, *c.ProBarBuilder, executeScanParameters.services); err != nil </span><span class="cov0" title="0">{
                log.Err(err)
                return nil, err
        }</span>

        <span class="cov0" title="0">failedQueries := executeScanParameters.inspector.GetFailedQueries()

        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>

        <span class="cov0" title="0">results, err := c.Storage.GetVulnerabilities(ctx, c.ScanParams.ScanID)
        if err != nil </span><span class="cov0" title="0">{
                log.Err(err)
                return nil, err
        }</span>

        <span class="cov0" title="0">files, err := c.Storage.GetFiles(ctx, c.ScanParams.ScanID)
        if err != nil </span><span class="cov0" title="0">{
                log.Err(err)
                return nil, err
        }</span>

        <span class="cov0" title="0">return &amp;Results{
                Results:        results,
                ExtractedPaths: executeScanParameters.extractedPaths,
                Files:          files,
                FailedQueries:  failedQueries,
        }, nil</span>
}

func getExcludeResultsMap(excludeResults []string) map[string]bool <span class="cov1" title="1">{
        excludeResultsMap := make(map[string]bool)
        for _, er := range excludeResults </span><span class="cov0" title="0">{
                excludeResultsMap[er] = true
        }</span>
        <span class="cov1" title="1">return excludeResultsMap</span>
}

func getSecretsRegexRules(regexRulesPath string) (regexRulesContent string, err error) <span class="cov10" title="3">{
        if len(regexRulesPath) &gt; 0 </span><span class="cov6" title="2">{
                b, err := os.ReadFile(regexRulesPath)
                if err != nil </span><span class="cov1" title="1">{
                        return regexRulesContent, err
                }</span>
                <span class="cov1" title="1">regexRulesContent = string(b)</span>
        } else<span class="cov1" title="1"> {
                regexRulesContent = assets.SecretsQueryRegexRulesJSON
        }</span>

        <span class="cov6" title="2">return regexRulesContent, nil</span>
}

func (c *Client) createQueryFilter() *source.QueryInspectorParameters <span class="cov6" title="2">{
        excludeQueries := source.ExcludeQueries{
                ByIDs:        c.ScanParams.ExcludeQueries,
                ByCategories: c.ScanParams.ExcludeCategories,
                BySeverities: c.ScanParams.ExcludeSeverities,
        }

        includeQueries := source.IncludeQueries{
                ByIDs: c.ScanParams.IncludeQueries,
        }

        queryFilter := source.QueryInspectorParameters{
                IncludeQueries: includeQueries,
                ExcludeQueries: excludeQueries,
                InputDataPath:  c.ScanParams.InputData,
                BomQueries:     c.ScanParams.BillOfMaterials,
        }

        return &amp;queryFilter
}</span>

func (c *Client) createService(
        inspector *engine.Inspector,
        secretsInspector *secrets.Inspector,
        paths []string,
        t kics.Tracker,
        store kics.Storage,
        querySource *source.FilesystemSource) ([]*kics.Service, error) <span class="cov0" title="0">{
        filesSource, err := c.getFileSystemSourceProvider(paths)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>

        <span class="cov0" title="0">combinedParser, err := parser.NewBuilder().
                Add(&amp;jsonParser.Parser{}).
                Add(&amp;yamlParser.Parser{}).
                Add(terraformParser.NewDefault()).
                Add(&amp;dockerParser.Parser{}).
                Add(&amp;protoParser.Parser{}).
                Add(&amp;buildahParser.Parser{}).
                Build(querySource.Types, querySource.CloudProviders)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>

        // combinedResolver to be used to resolve files and templates
        <span class="cov0" title="0">combinedResolver, err := resolver.NewBuilder().
                Add(&amp;helm.Resolver{}).
                Build()
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>

        <span class="cov0" title="0">services := make([]*kics.Service, 0, len(combinedParser))

        for _, parser := range combinedParser </span><span class="cov0" title="0">{
                services = append(
                        services,
                        &amp;kics.Service{
                                SourceProvider:   filesSource,
                                Storage:          store,
                                Parser:           parser,
                                Inspector:        inspector,
                                SecretsInspector: secretsInspector,
                                Tracker:          t,
                                Resolver:         combinedResolver,
                        },
                )
        }</span>
        <span class="cov0" title="0">return services, nil</span>
}

func (c *Client) getFileSystemSourceProvider(paths []string) (*provider.FileSystemSourceProvider, error) <span class="cov0" title="0">{
        var excludePaths []string
        if c.ScanParams.PayloadPath != "" </span><span class="cov0" title="0">{
                excludePaths = append(excludePaths, c.ScanParams.PayloadPath)
        }</span>

        <span class="cov0" title="0">if len(c.ScanParams.ExcludePaths) &gt; 0 </span><span class="cov0" title="0">{
                excludePaths = append(excludePaths, c.ScanParams.ExcludePaths...)
        }</span>

        <span class="cov0" title="0">filesSource, err := provider.NewFileSystemSourceProvider(paths, excludePaths)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov0" title="0">return filesSource, nil</span>
}
</pre>
		
		<pre class="file" id="file114" style="display: none">package scan

import (
        "context"
        "fmt"
        "os"
        "path/filepath"
        "regexp"
        "strings"

        consoleHelpers "github.com/Checkmarx/kics/internal/console/helpers"
        "github.com/Checkmarx/kics/pkg/analyzer"
        "github.com/Checkmarx/kics/pkg/engine/provider"
        "github.com/Checkmarx/kics/pkg/model"
        consolePrinter "github.com/Checkmarx/kics/pkg/printer"
        "github.com/Checkmarx/kics/pkg/utils"
        "github.com/pkg/errors"
        "github.com/rs/zerolog/log"
)

var (
        terraformerRegex = regexp.MustCompile(`^terraformer::`)
        kuberneterRegex  = regexp.MustCompile(`^kuberneter::`)
)

func (c *Client) prepareAndAnalyzePaths(ctx context.Context) (provider.ExtractedPath, error) <span class="cov0" title="0">{
        err := c.preparePaths()
        if err != nil </span><span class="cov0" title="0">{
                return provider.ExtractedPath{}, err
        }</span>

        <span class="cov0" title="0">regularPaths, terraformerPaths, kuberneterPaths := extractPathType(c.ScanParams.Path)

        terraformerExPaths, err := provider.GetTerraformerSources(terraformerPaths, c.ScanParams.OutputPath)
        if err != nil </span><span class="cov0" title="0">{
                return provider.ExtractedPath{}, err
        }</span>

        <span class="cov0" title="0">kuberneterExPaths, err := provider.GetKuberneterSources(ctx, kuberneterPaths, c.ScanParams.OutputPath)
        if err != nil </span><span class="cov0" title="0">{
                return provider.ExtractedPath{}, err
        }</span>

        <span class="cov0" title="0">regularExPaths, err := provider.GetSources(regularPaths)
        if err != nil </span><span class="cov0" title="0">{
                return provider.ExtractedPath{}, err
        }</span>

        <span class="cov0" title="0">allPaths := combinePaths(terraformerExPaths, kuberneterExPaths, regularExPaths)

        log.Info().Msgf("Total files in the project: %d", getTotalFiles(allPaths.Path))

        a := &amp;analyzer.Analyzer{
                Paths:             allPaths.Path,
                Types:             c.ScanParams.Platform,
                Exc:               c.ScanParams.ExcludePaths,
                GitIgnoreFileName: ".gitignore",
                ExcludeGitIgnore:  c.ScanParams.ExcludeGitIgnore,
        }

        pathTypes, errAnalyze := analyzePaths(a)

        if errAnalyze != nil </span><span class="cov0" title="0">{
                return provider.ExtractedPath{}, errAnalyze
        }</span>

        <span class="cov0" title="0">if len(pathTypes.Types) == 0 </span><span class="cov0" title="0">{
                return provider.ExtractedPath{}, nil
        }</span>

        <span class="cov0" title="0">c.ScanParams.Platform = pathTypes.Types
        c.ScanParams.ExcludePaths = pathTypes.Exc

        return allPaths, nil</span>
}

func combinePaths(terraformer, kuberneter, regular provider.ExtractedPath) provider.ExtractedPath <span class="cov4" title="4">{
        var combinedPaths provider.ExtractedPath
        paths := make([]string, 0)
        combinedPathsEx := make(map[string]model.ExtractedPathObject)
        paths = append(paths, terraformer.Path...)
        paths = append(paths, kuberneter.Path...)
        paths = append(paths, regular.Path...)
        combinedPaths.Path = paths
        for k, v := range regular.ExtractionMap </span><span class="cov3" title="3">{
                combinedPathsEx[k] = v
        }</span>
        <span class="cov4" title="4">for k, v := range terraformer.ExtractionMap </span><span class="cov1" title="1">{
                combinedPathsEx[k] = v
        }</span>
        <span class="cov4" title="4">for k, v := range kuberneter.ExtractionMap </span><span class="cov1" title="1">{
                combinedPathsEx[k] = v
        }</span>

        <span class="cov4" title="4">combinedPaths.ExtractionMap = combinedPathsEx
        return combinedPaths</span>
}

func (c *Client) preparePaths() error <span class="cov3" title="3">{
        var err error
        err = c.GetQueryPath()
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>
        <span class="cov3" title="3">err = c.getLibraryPath()
        if err != nil </span><span class="cov1" title="1">{
                return err
        }</span>
        <span class="cov2" title="2">return nil</span>
}

// GetQueryPath gets all the queries paths
func (c *Client) GetQueryPath() error <span class="cov5" title="6">{
        queriesPath := make([]string, 0)
        if c.ScanParams.ChangedDefaultQueryPath </span><span class="cov4" title="5">{
                for _, queryPath := range c.ScanParams.QueriesPath </span><span class="cov5" title="8">{
                        extractedQueriesPath, errExtractQueries := resolvePath(queryPath, "queries-path")
                        if errExtractQueries != nil </span><span class="cov0" title="0">{
                                return errExtractQueries
                        }</span>
                        <span class="cov5" title="8">queriesPath = append(queriesPath, extractedQueriesPath)</span>
                }
        } else<span class="cov1" title="1"> {
                log.Debug().Msgf("Looking for queries in executable path and in current work directory")
                defaultQueryPath, errDefaultQueryPath := consoleHelpers.GetDefaultQueryPath(c.ScanParams.QueriesPath[0])
                if errDefaultQueryPath != nil </span><span class="cov1" title="1">{
                        return errors.Wrap(errDefaultQueryPath, "unable to find queries")
                }</span>
                <span class="cov0" title="0">queriesPath = append(queriesPath, defaultQueryPath)</span>
        }
        <span class="cov4" title="5">c.ScanParams.QueriesPath = queriesPath
        return nil</span>
}

func (c *Client) getLibraryPath() error <span class="cov5" title="6">{
        if c.ScanParams.ChangedDefaultLibrariesPath </span><span class="cov4" title="4">{
                extractedLibrariesPath, errExtractLibraries := resolvePath(c.ScanParams.LibrariesPath, "libraries-path")
                if errExtractLibraries != nil </span><span class="cov2" title="2">{
                        return errExtractLibraries
                }</span>

                <span class="cov2" title="2">c.ScanParams.LibrariesPath = extractedLibrariesPath</span>
        }
        <span class="cov4" title="4">return nil</span>
}

func resolvePath(flagContent, flagName string) (string, error) <span class="cov6" title="12">{
        extractedPath, errExtractPath := provider.GetSources([]string{flagContent})
        if errExtractPath != nil </span><span class="cov2" title="2">{
                return "", errExtractPath
        }</span>
        <span class="cov6" title="10">if len(extractedPath.Path) != 1 </span><span class="cov0" title="0">{
                return "", fmt.Errorf("could not find a valid path (--%s) on %s", flagName, flagContent)
        }</span>
        <span class="cov6" title="10">log.Debug().Msgf("Trying to load path (--%s) from %s", flagName, flagContent)
        return extractedPath.Path[0], nil</span>
}

// analyzePaths will analyze the paths to scan to determine which type of queries to load
// and which files should be ignored, it then updates the types and exclude flags variables
// with the results found
func analyzePaths(a *analyzer.Analyzer) (model.AnalyzedPaths, error) <span class="cov1" title="1">{
        var err error
        var pathsFlag model.AnalyzedPaths
        excluded := make([]string, 0)

        pathsFlag, err = analyzer.Analyze(a)
        if err != nil </span><span class="cov0" title="0">{
                log.Err(err)
                return model.AnalyzedPaths{}, err
        }</span>

        <span class="cov1" title="1">logLoadingQueriesType(pathsFlag.Types)

        excluded = append(excluded, a.Exc...)
        excluded = append(excluded, pathsFlag.Exc...)
        pathsFlag.Exc = excluded
        return pathsFlag, nil</span>
}

func logLoadingQueriesType(types []string) <span class="cov4" title="4">{
        if len(types) == 0 </span><span class="cov1" title="1">{
                log.Info().Msg("No queries were loaded")
                return
        }</span>

        <span class="cov3" title="3">log.Info().Msgf("Loading queries of type: %s", strings.Join(types, ", "))</span>
}

func extractPathType(paths []string) (regular, terraformer, kuberneter []string) <span class="cov4" title="4">{
        for _, path := range paths </span><span class="cov4" title="4">{
                if terraformerRegex.MatchString(path) </span><span class="cov1" title="1">{
                        terraformer = append(terraformer, terraformerRegex.ReplaceAllString(path, ""))
                }</span> else<span class="cov3" title="3"> if kuberneterRegex.MatchString(path) </span><span class="cov1" title="1">{
                        kuberneter = append(kuberneter, kuberneterRegex.ReplaceAllString(path, ""))
                }</span> else<span class="cov2" title="2"> {
                        regular = append(regular, path)
                }</span>
        }
        <span class="cov4" title="4">return</span>
}

func deleteExtractionFolder(extractionMap map[string]model.ExtractedPathObject) <span class="cov1" title="1">{
        for extractionFile := range extractionMap </span><span class="cov0" title="0">{
                if strings.Contains(extractionFile, "kics-extract-terraformer") ||
                        strings.Contains(extractionFile, "kics-extract-kuberneter") </span><span class="cov0" title="0">{
                        continue</span>
                }
                <span class="cov0" title="0">err := os.RemoveAll(extractionFile)
                if err != nil </span><span class="cov0" title="0">{
                        log.Err(err).Msg("Failed to delete KICS extraction folder")
                }</span>
        }
}

func contributionAppeal(customPrint *consolePrinter.Printer, queriesPath []string) <span class="cov3" title="3">{
        if !utils.ContainsInString(filepath.Join("assets", "queries"), queriesPath) </span><span class="cov2" title="2">{
                msg := "\nAre you using a custom query? If so, feel free to contribute to KICS!\n"
                contributionPage := "Check out how to do it: https://github.com/Checkmarx/kics/blob/master/docs/CONTRIBUTING.md\n"

                output := customPrint.ContributionMessage.Sprintf(msg + contributionPage)
                fmt.Println(output)
        }</span>
}

// printVersionCheck - Prints and logs warning if not using KICS latest version
func printVersionCheck(customPrint *consolePrinter.Printer, s *model.Summary) <span class="cov3" title="3">{
        if !s.LatestVersion.Latest </span><span class="cov1" title="1">{
                message := fmt.Sprintf("A new version 'v%s' of KICS is available, please consider updating", s.LatestVersion.LatestVersionTag)

                fmt.Println(customPrint.VersionMessage.Sprintf(message))
                log.Warn().Msgf(message)
        }</span>
}

func getTotalFiles(paths []string) int <span class="cov4" title="4">{
        files := 0
        for _, path := range paths </span><span class="cov4" title="5">{
                if err := filepath.Walk(path, func(path string, info os.FileInfo, err error) error </span><span class="cov10" title="45">{
                        if err != nil </span><span class="cov1" title="1">{
                                return err
                        }</span>

                        <span class="cov9" title="44">if !info.IsDir() </span><span class="cov9" title="36">{
                                files++
                        }</span>

                        <span class="cov9" title="44">return nil</span>
                }); err != nil <span class="cov1" title="1">{
                        log.Error().Msgf("failed to walk path %s: %s", path, err)
                }</span>
        }
        <span class="cov4" title="4">return files</span>
}
</pre>
		
		<pre class="file" id="file115" style="display: none">package scanner

import (
        "context"
        "fmt"
        "sync"

        "github.com/Checkmarx/kics/internal/metrics"
        "github.com/Checkmarx/kics/pkg/kics"
        "github.com/Checkmarx/kics/pkg/progress"
)

type serviceSlice []*kics.Service

func PrepareAndScan(ctx context.Context, scanID string, proBarBuilder progress.PbBuilder, services serviceSlice) error <span class="cov0" title="0">{
        metrics.Metric.Start("prepare_sources")
        var wg sync.WaitGroup
        wgDone := make(chan bool)
        errCh := make(chan error)
        var wgProg sync.WaitGroup

        for _, service := range services </span><span class="cov0" title="0">{
                wg.Add(1)
                go service.PrepareSources(ctx, scanID, &amp;wg, errCh)
        }</span>

        <span class="cov0" title="0">go func() </span><span class="cov0" title="0">{
                defer func() </span><span class="cov0" title="0">{
                        close(wgDone)
                }</span>()
                <span class="cov0" title="0">wg.Wait()
                wgProg.Wait()</span>
        }()

        <span class="cov0" title="0">select </span>{
        case &lt;-wgDone:<span class="cov0" title="0">
                metrics.Metric.Stop()
                err := StartScan(ctx, scanID, proBarBuilder, services)
                if err != nil </span><span class="cov0" title="0">{
                        return err
                }</span>
                <span class="cov0" title="0">break</span>
        case err := &lt;-errCh:<span class="cov0" title="0">
                close(errCh)
                return err</span>
        }
        <span class="cov0" title="0">return nil</span>
}

// StartScan will run concurrent scans by parser
func StartScan(ctx context.Context, scanID string, proBarBuilder progress.PbBuilder, services serviceSlice) error <span class="cov1" title="1">{
        defer metrics.Metric.Stop()
        metrics.Metric.Start("start_scan")
        var wg sync.WaitGroup
        wgDone := make(chan bool)
        errCh := make(chan error)
        currentQuery := make(chan int64, 1)
        var wgProg sync.WaitGroup

        total := services.GetQueriesLength()
        if total != 0 </span><span class="cov1" title="1">{
                startProgressBar(total, &amp;wgProg, currentQuery, proBarBuilder)
        }</span>

        <span class="cov1" title="1">for _, service := range services </span><span class="cov10" title="4">{
                wg.Add(1)
                go service.StartScan(ctx, scanID, errCh, &amp;wg, currentQuery)
        }</span>

        <span class="cov1" title="1">go func() </span><span class="cov1" title="1">{
                defer func() </span><span class="cov1" title="1">{
                        close(currentQuery)
                        close(wgDone)
                        fmt.Println("\r")
                }</span>()
                <span class="cov1" title="1">wg.Wait()
                wgProg.Wait()</span>
        }()

        <span class="cov1" title="1">select </span>{
        case &lt;-wgDone:<span class="cov1" title="1">
                break</span>
        case err := &lt;-errCh:<span class="cov0" title="0">
                close(errCh)
                return err</span>
        }
        <span class="cov1" title="1">return nil</span>
}

// GetQueriesLength returns the Total of queries for all Services
func (s serviceSlice) GetQueriesLength() int <span class="cov1" title="1">{
        count := 0
        for _, service := range s </span><span class="cov10" title="4">{
                count += service.Inspector.LenQueriesByPlat(service.Parser.Platform)
                count += service.SecretsInspector.GetQueriesLength()
        }</span>
        <span class="cov1" title="1">return count</span>
}

func startProgressBar(total int, wg *sync.WaitGroup, progressChannel chan int64, proBarBuilder progress.PbBuilder) <span class="cov1" title="1">{
        wg.Add(1)
        progressBar := proBarBuilder.BuildCounter("Executing queries: ", total, wg, progressChannel)
        go progressBar.Start()
}</span>
</pre>
		
		<pre class="file" id="file116" style="display: none">package terraformer

import (
        "fmt"
        "io"
        "os"
        "os/exec"
        "path/filepath"
        "strings"
        "time"

        tfLogger "log"

        "github.com/pkg/errors"
        "github.com/rs/zerolog/log"
)

const terraformerPathLength = 2

// for testing purposes
var (
        runTerraformerFunc        = runTerraformer
        saveTerraformerOutputFunc = saveTerraformerOutput
)

// Path is a struct that contains the terraformer path information
type Path struct {
        CloudProvider string
        Regions       string
        Resources     string
        Projects      string
}

// Import imports the terraformer resources into the destination using terraformer
func Import(terraformerPath, destinationPath string) (string, error) <span class="cov10" title="4">{
        log.Info().Msg("importing terraformer resources")
        tfLogger.SetOutput(io.Discard)

        // extracts relevant info from KICS terraformer path syntax
        pathOptions, err := extractTerraformerOptions(terraformerPath)
        if err != nil </span><span class="cov1" title="1">{
                return "", errors.Wrap(err, "wrong terraformer path syntax")
        }</span>
        <span class="cov8" title="3">if destinationPath == "" </span><span class="cov8" title="3">{
                destinationPath, err = os.Getwd()
                if err != nil </span><span class="cov0" title="0">{
                        return "", errors.Wrap(err, "failed to get working directory")
                }</span>
        }

        // set destination folder path where the terraform resources will be saved
        <span class="cov8" title="3">destFolderName := fmt.Sprintf("kics-extract-terraformer-%s", time.Now().Format("01-02-2006"))
        destination := filepath.Join(destinationPath, destFolderName)

        // run terraformer
        output, err := runTerraformerFunc(pathOptions, destination)
        if err != nil </span><span class="cov0" title="0">{
                // save terraformer output
                _ = saveTerraformerOutputFunc(destination, output)
                return "", errors.Wrap(err, "failed to import resources")
        }</span>

        // save terraformer output
        <span class="cov8" title="3">err = saveTerraformerOutputFunc(destination, output)
        if err != nil </span><span class="cov0" title="0">{
                return "", errors.Wrap(err, "failed to import resources")
        }</span>

        // clean unwanted files like output.tf
        <span class="cov8" title="3">cleanUnwantedFiles(destination)

        return destination, nil</span>
}

// extractTerraformerOptions extracts all the information from the KICS terraformer path syntax without the prefix 'terraformer::'
// {CloudProvider}:{Resources}:{Regions}:{Projects}
func extractTerraformerOptions(path string) (*Path, error) <span class="cov10" title="4">{
        pathInfo := strings.Split(path, ":")
        if len(pathInfo) != terraformerPathLength &amp;&amp;
                len(pathInfo) != terraformerPathLength+2 &amp;&amp;
                len(pathInfo) != terraformerPathLength+1 </span><span class="cov1" title="1">{
                return nil, errors.New("wrong terraformer path syntax")
        }</span>
        <span class="cov8" title="3">return &amp;Path{
                CloudProvider: pathInfo[0],
                Regions:       getRegions(pathInfo),
                Resources:     strings.ReplaceAll(pathInfo[1], "/", ","),
                Projects:      getProjects(pathInfo),
        }, nil</span>
}

// getProjects gets all the projects pointed in the KICS terraformer path syntax
// projects are only required for gcp
func getProjects(pathInfo []string) string <span class="cov8" title="3">{
        if len(pathInfo) == terraformerPathLength+2 </span><span class="cov1" title="1">{
                return strings.ReplaceAll(pathInfo[3], "/", ",")
        }</span>

        <span class="cov5" title="2">return ""</span>
}

// getRegions gets all the regions pointed in the KICS terraformer path syntax
// regions are only required for aws and gcp
func getRegions(pathInfo []string) string <span class="cov8" title="3">{
        if len(pathInfo) &gt;= terraformerPathLength+1 </span><span class="cov5" title="2">{
                return strings.ReplaceAll(pathInfo[2], "/", ",")
        }</span>

        <span class="cov1" title="1">return ""</span>
}

// buildArgs build the args for the command terraformer
func buildArgs(pathOptions *Path, destination string) []string <span class="cov5" title="2">{
        // the terraformer command for gcp is google
        if pathOptions.CloudProvider == "gcp" </span><span class="cov1" title="1">{
                pathOptions.CloudProvider = "google"
        }</span>

        <span class="cov5" title="2">args := []string{
                "import", pathOptions.CloudProvider,
                "--resources=" + pathOptions.Resources,
                "-o", destination,
                "--verbose",
        }

        // probably we will need to define the profile to ""
        if pathOptions.CloudProvider == "aws" </span><span class="cov1" title="1">{
                args = append(args, "--regions="+pathOptions.Regions, "--profile=")
        }</span>

        // the flag '--projects' is only required for gcp
        <span class="cov5" title="2">if pathOptions.Projects != "" &amp;&amp; pathOptions.CloudProvider == "google" </span><span class="cov1" title="1">{
                args = append(args, "--regions="+pathOptions.Regions, "--projects="+pathOptions.Projects)
        }</span>

        <span class="cov5" title="2">return args</span>
}

// runTerraformer runs the terraformer binary
func runTerraformer(pathOptions *Path, destination string) (string, error) <span class="cov0" title="0">{
        args := buildArgs(pathOptions, destination)

        cmd := exec.Command("terraformer", args...) //#nosec
        cmd.Env = append(os.Environ(), "AWS_PROFILE=default")

        output, err := cmd.CombinedOutput()

        return string(output), err
}</span>

// saveTerraformerOutput verifies if the destination folder exists
// if not, it means that someting went wrong in the terraformer command
// it also saves the terraformer command output in the destination folder
func saveTerraformerOutput(destination, output string) error <span class="cov0" title="0">{
        _, err := os.Stat(destination)
        save(destination, output, err)

        return err
}</span>
</pre>
		
		<pre class="file" id="file117" style="display: none">package terraformer

import (
        "io/fs"
        "os"
        "path/filepath"

        "github.com/rs/zerolog/log"
)

// save saves the terraformer command output in the destination folder
func save(destination, output string, statErr error) <span class="cov0" title="0">{
        if statErr != nil </span><span class="cov0" title="0">{
                if err := os.MkdirAll(destination, os.ModePerm); err != nil </span><span class="cov0" title="0">{
                        log.Error().Msgf("failed to mkdir: %s", err)
                }</span>
        }

        <span class="cov0" title="0">filePath := filepath.Join(destination, "terraformer-output.txt")
        filepath.Clean(filePath)

        f, err := os.OpenFile(filePath, os.O_WRONLY|os.O_CREATE|os.O_TRUNC, os.ModePerm)

        if err != nil </span><span class="cov0" title="0">{
                log.Error().Msgf("failed to open file '%s': %s", filePath, err)
        }</span>

        <span class="cov0" title="0">defer func(f *os.File) </span><span class="cov0" title="0">{
                err = f.Close()
                if err != nil </span><span class="cov0" title="0">{
                        log.Err(err).Msgf("failed to close file: %s", filePath)
                }</span>
        }(f)

        <span class="cov0" title="0">if _, err = f.WriteString(output); err != nil </span><span class="cov0" title="0">{
                log.Error().Msgf("failed to write file '%s': %s", filePath, err)
        }</span>
}

// cleanUnwantedFiles deletes the output files from the destination folder
func cleanUnwantedFiles(destination string) <span class="cov10" title="3">{
        err := filepath.Walk(destination, func(path string, info fs.FileInfo, err error) error </span><span class="cov10" title="3">{
                if info != nil </span><span class="cov0" title="0">{
                        deleteOutputFile(path, info)
                }</span>
                <span class="cov10" title="3">return nil</span>
        })

        <span class="cov10" title="3">if err != nil </span><span class="cov0" title="0">{
                log.Err(err).Msg("failed to clean unwanted files")
        }</span>
}

// deleteOutputFile deletes a 'outputs.tf' file
func deleteOutputFile(path string, output fs.FileInfo) <span class="cov0" title="0">{
        if output.Name() == "outputs.tf" </span><span class="cov0" title="0">{
                err := os.Remove(path)
                if err != nil </span><span class="cov0" title="0">{
                        log.Err(err).Msgf("failed to remove outputs.tf in path %s", path)
                }</span>
        }
}
</pre>
		
		<pre class="file" id="file118" style="display: none">package utils

import (
        "regexp"

        "github.com/rs/zerolog/log"
        vault "github.com/sosedoff/ansible-vault-go"
)

// DecryptAnsibleVault verifies if the fileContent is encrypted by ansible-vault. If yes, the function decrypts it
func DecryptAnsibleVault(fileContent []byte, secret string) []byte <span class="cov8" title="1">{
        match, err := regexp.MatchString(`^\s*\$ANSIBLE_VAULT.*`, string(fileContent))
        if err != nil </span><span class="cov0" title="0">{
                return fileContent
        }</span>
        <span class="cov8" title="1">if secret != "" &amp;&amp; match </span><span class="cov8" title="1">{
                content, err := vault.Decrypt(string(fileContent), secret)

                if err == nil </span><span class="cov8" title="1">{
                        log.Info().Msg("Decrypting Ansible Vault file")
                        fileContent = []byte(content)
                }</span>
        }
        <span class="cov8" title="1">return fileContent</span>
}
</pre>
		
		<pre class="file" id="file119" style="display: none">package utils

import (
        "reflect"
        "strings"
)

// Contains if a function to check if list contains target
func Contains(target, list interface{}) bool <span class="cov6" title="6">{
        listVal := reflect.ValueOf(list)

        if listVal.Kind() == reflect.Slice || listVal.Kind() == reflect.Array </span><span class="cov6" title="5">{
                for i := 0; i &lt; listVal.Len(); i++ </span><span class="cov10" title="16">{
                        if listVal.Index(i).Interface() == target </span><span class="cov4" title="3">{
                                return true
                        }</span>
                }
        }

        <span class="cov4" title="3">return false</span>
}

// ContainsInString verifies if some string in list contains the specified target
func ContainsInString(target string, list []string) bool <span class="cov0" title="0">{
        for i := 0; i &lt; len(list); i++ </span><span class="cov0" title="0">{
                if strings.Contains(list[i], target) </span><span class="cov0" title="0">{
                        return true
                }</span>
        }
        <span class="cov0" title="0">return false</span>
}
</pre>
		
		<pre class="file" id="file120" style="display: none">package utils

import (
        "bytes"
        "os"
        "path/filepath"

        "github.com/rs/zerolog/log"
        "golang.org/x/tools/godoc/util"
)

// GetExtension gets the extension of a file path
func GetExtension(path string) string <span class="cov10" title="3">{
        targets := []string{"Dockerfile", "tfvars"}

        ext := filepath.Ext(path)

        if ext == "" </span><span class="cov6" title="2">{
                base := filepath.Base(path)

                if Contains(base, targets) </span><span class="cov1" title="1">{
                        ext = base
                }</span> else<span class="cov1" title="1"> if isTextFile(path) </span><span class="cov1" title="1">{
                        ext = "possibleDockerfile"
                }</span>
        }

        <span class="cov10" title="3">return ext</span>
}

func isTextFile(path string) bool <span class="cov1" title="1">{
        info, err := os.Stat(path)
        if err != nil </span><span class="cov0" title="0">{
                log.Error().Msgf("failed to get file info: %s", err)
                return false
        }</span>

        <span class="cov1" title="1">if info.IsDir() </span><span class="cov0" title="0">{
                return false
        }</span>

        <span class="cov1" title="1">content, err := os.ReadFile(filepath.Clean(path))
        if err != nil </span><span class="cov0" title="0">{
                log.Error().Msgf("failed to analyze file: %s", err)
                return false
        }</span>

        <span class="cov1" title="1">content = bytes.Replace(content, []byte("\r"), []byte(""), -1)

        isText := util.IsText(content)

        return isText</span>
}
</pre>
		
		<pre class="file" id="file121" style="display: none">package utils

import "sort"

// SortedKeys returns a sorted slice with all map keys
func SortedKeys(mapToSort map[string]string) []string <span class="cov1" title="1">{
        keys := make([]string, 0, len(mapToSort))
        for k := range mapToSort </span><span class="cov10" title="3">{
                keys = append(keys, k)
        }</span>
        <span class="cov1" title="1">sort.Strings(keys)
        return keys</span>
}

// MergeMaps merges two maps
func MergeMaps(map1, map2 map[string]interface{}) <span class="cov1" title="1">{
        for key, value := range map2 </span><span class="cov1" title="1">{
                map1[key] = value
        }</span>
}
</pre>
		
		<pre class="file" id="file122" style="display: none">package utils

import (
        "os"
        "strconv"
        "sync"
        "time"
)

// ======== Golang way to create random number for tmp dir naming =============
var rand uint32
var randmu sync.Mutex

const tempDirFormat = 1e9

func reseed() uint32 <span class="cov1" title="1">{
        return uint32(time.Now().UnixNano() + int64(os.Getpid()))
}</span>

// NextRandom returns a random number
func NextRandom() string <span class="cov10" title="2">{
        randmu.Lock()
        r := rand
        if r == 0 </span><span class="cov1" title="1">{
                r = reseed()
        }</span>
        <span class="cov10" title="2">r = r*1664525 + 1013904223 // constants from Numerical Recipes
        rand = r
        randmu.Unlock()
        return strconv.Itoa(int(tempDirFormat + r%tempDirFormat))[1:]</span>
}

// ==============================================================================
</pre>
		
		<pre class="file" id="file123" style="display: none">package utils

import "strings"

// SplitLines splits the document by line
func SplitLines(content string) *[]string <span class="cov8" title="1">{
        text := strings.ReplaceAll(content, "\r", "")
        split := strings.Split(text, "\n")

        return &amp;split
}</span>
</pre>
		
		<pre class="file" id="file124" style="display: none">package test

import (
        "bytes"
        "encoding/json"
        "errors"
        "fmt"
        "io"
        "os"
        "path/filepath"
        "strings"

        "github.com/Checkmarx/kics/pkg/model"
        "github.com/spf13/cobra"
)

const (
        // ValidUUIDRegex is a constant representing a regular expression rule to validate UUID string
        ValidUUIDRegex = `(?i)^[0-9a-f]{8}-[0-9a-f]{4}-[0-5][0-9a-f]{3}-[089ab][0-9a-f]{3}-[0-9a-f]{12}$`
        positive       = "positive.tf"
)

type execute func() error

// CaptureOutput changes default stdout to intercept into a buffer, converts it to string and returns it
func CaptureOutput(funcToExec execute) (string, error) <span class="cov0" title="0">{
        old := os.Stdout
        r, w, _ := os.Pipe()
        os.Stdout = w

        err := funcToExec()

        outC := make(chan string)

        go func() </span><span class="cov0" title="0">{
                var buf bytes.Buffer
                if _, errs := io.Copy(&amp;buf, r); errs != nil </span><span class="cov0" title="0">{
                        return
                }</span>
                <span class="cov0" title="0">outC &lt;- buf.String()</span>
        }()

        <span class="cov0" title="0">if errs := w.Close(); errs != nil </span><span class="cov0" title="0">{
                return "", errs
        }</span>
        <span class="cov0" title="0">os.Stdout = old
        out := &lt;-outC

        return out, err</span>
}

// CaptureCommandOutput set cobra command args, if necessary, then capture the output
func CaptureCommandOutput(cmd *cobra.Command, args []string) (string, error) <span class="cov0" title="0">{
        if len(args) &gt; 0 </span><span class="cov0" title="0">{
                cmd.SetArgs(args)
        }</span>

        <span class="cov0" title="0">return CaptureOutput(cmd.Execute)</span>
}

// ChangeCurrentDir gets current working directory and changes to its parent until finds the desired directory
// or fail
func ChangeCurrentDir(desiredDir string) error <span class="cov1" title="2">{
        for currentDir, err := os.Getwd(); GetCurrentDirName(currentDir) != desiredDir; currentDir, err = os.Getwd() </span><span class="cov1" title="3">{
                if err == nil </span><span class="cov1" title="3">{
                        if err = os.Chdir(".."); err != nil </span><span class="cov0" title="0">{
                                fmt.Print(formatCurrentDirError(err))
                                return errors.New(formatCurrentDirError(err))
                        }</span>
                } else<span class="cov0" title="0"> {
                        return errors.New(formatCurrentDirError(err))
                }</span>
        }
        <span class="cov1" title="2">return nil</span>
}

func formatCurrentDirError(err error) string <span class="cov1" title="1">{
        return fmt.Sprintf("change path error = %v", err)
}</span>

// GetCurrentDirName returns current working directory
func GetCurrentDirName(path string) string <span class="cov2" title="7">{
        dirs := strings.Split(path, string(os.PathSeparator))
        if dirs[len(dirs)-1] == "" &amp;&amp; len(dirs) &gt; 1 </span><span class="cov1" title="1">{
                return dirs[len(dirs)-2]
        }</span>
        <span class="cov2" title="6">return dirs[len(dirs)-1]</span>
}

// StringifyStruct stringify struct for pretty print
func StringifyStruct(v interface{}) (string, error) <span class="cov0" title="0">{
        jsonValue, err := json.MarshalIndent(v, "", "  ")
        if err != nil </span><span class="cov0" title="0">{
                return "", err
        }</span>
        <span class="cov0" title="0">return string(jsonValue), nil</span>
}

// MapToStringSlice extract slice of keys from a map[string]string
func MapToStringSlice(stringKeyMap map[string]string) []string <span class="cov7" title="4892">{
        keys := make([]string, len(stringKeyMap))

        i := 0
        for k := range stringKeyMap </span><span class="cov10" title="73381">{
                keys[i] = k
                i++
        }</span>
        <span class="cov7" title="4892">return keys</span>
}

var queryHigh = model.QueryResult{
        QueryName:                   "ALB protocol is HTTP",
        QueryID:                     "de7f5e83-da88-4046-871f-ea18504b1d43",
        Description:                 "ALB protocol is HTTP Description",
        DescriptionID:               "504b1d43",
        CISDescriptionIDFormatted:   "testCISID",
        CISDescriptionTitle:         "testCISTitle",
        CISDescriptionTextFormatted: "testCISDescription",
        Severity:                    model.SeverityHigh,
        Files: []model.VulnerableFile{
                {
                        FileName:         positive,
                        Line:             25,
                        IssueType:        "MissingAttribute",
                        SearchKey:        "aws_alb_listener[front_end].default_action.redirect",
                        KeyExpectedValue: "'default_action.redirect.protocol' is equal 'HTTPS'",
                        KeyActualValue:   "'default_action.redirect.protocol' is missing",
                        Value:            nil,
                        VulnLines:        &amp;[]model.CodeLine{},
                },
                {
                        FileName:         positive,
                        Line:             19,
                        IssueType:        "IncorrectValue",
                        SearchKey:        "aws_alb_listener[front_end].default_action.redirect",
                        KeyExpectedValue: "'default_action.redirect.protocol' is equal 'HTTPS'",
                        KeyActualValue:   "'default_action.redirect.protocol' is equal 'HTTP'",
                        Value:            nil,
                        VulnLines:        &amp;[]model.CodeLine{},
                },
        },
}

var queryMedium = model.QueryResult{
        QueryName:     "AmazonMQ Broker Encryption Disabled",
        Description:   "AmazonMQ Broker should have Encryption Options defined",
        QueryID:       "3db3f534-e3a3-487f-88c7-0a9fbf64b702",
        CloudProvider: "AWS",
        Severity:      model.SeverityMedium,
        Files: []model.VulnerableFile{
                {
                        FileName:         positive,
                        Line:             1,
                        IssueType:        "MissingAttribute",
                        SimilarityID:     "6b76f7a507e200bb2c73468ec9649b099da96a4efa0f49a3bdc88e12476d8ee7",
                        SearchKey:        "resource.aws_mq_broker[positive1]",
                        KeyExpectedValue: "resource.aws_mq_broker[positive1].encryption_options is defined",
                        KeyActualValue:   "resource.aws_mq_broker[positive1].encryption_options is not defined",
                        Value:            nil,
                        VulnLines:        &amp;[]model.CodeLine{},
                },
        },
}

var queryMedium2 = model.QueryResult{
        QueryName: "GuardDuty Detector Disabled",
        QueryID:   "704dadd3-54fc-48ac-b6a0-02f170011473",
        Severity:  model.SeverityMedium,
        Files: []model.VulnerableFile{
                {
                        FileName:         filepath.Join("assets", "queries", "terraform", "aws", "guardduty_detector_disabled", "test", "positive.tf"),
                        Line:             2,
                        IssueType:        "IncorrectValue",
                        SearchKey:        "aws_guardduty_detector[positive1].enable",
                        KeyExpectedValue: "GuardDuty Detector should be Enabled",
                        KeyActualValue:   "GuardDuty Detector is not Enabled",
                        Value:            nil,
                        VulnLines:        &amp;[]model.CodeLine{},
                },
        },
        Platform:    "Terraform",
        Description: "Make sure that Amazon GuardDuty is Enabled",
}

var queryInfo = model.QueryResult{
        QueryName: "Resource Not Using Tags",
        QueryID:   "e38a8e0a-b88b-4902-b3fe-b0fcb17d5c10",
        Severity:  model.SeverityInfo,
        Files: []model.VulnerableFile{
                {
                        FileName:         filepath.Join("assets", "queries", "terraform", "aws", "guardduty_detector_disabled", "test", "negative.tf"),
                        Line:             1,
                        IssueType:        "MissingAttribute",
                        SearchKey:        "aws_guardduty_detector[{{negative1}}]",
                        KeyExpectedValue: "aws_guardduty_detector[{{negative1}}].tags is defined and not null",
                        KeyActualValue:   "aws_guardduty_detector[{{negative1}}].tags is undefined or null",
                        Value:            nil,
                        VulnLines:        &amp;[]model.CodeLine{},
                },
                {
                        FileName:         filepath.Join("assets", "queries", "terraform", "aws", "guardduty_detector_disabled", "test", "positive.tf"),
                        Line:             1,
                        IssueType:        "MissingAttribute",
                        SearchKey:        "aws_guardduty_detector[{{positive1}}]",
                        KeyExpectedValue: "aws_guardduty_detector[{{positive1}}].tags is defined and not null",
                        KeyActualValue:   "aws_guardduty_detector[{{positive1}}].tags is undefined or null",
                        Value:            nil,
                        VulnLines:        &amp;[]model.CodeLine{},
                },
        },
        Platform:    "Terraform",
        Description: "AWS services resource tags are an essential part of managing components",
}

// SummaryMock a summary to be used without running kics scan
var SummaryMock = model.Summary{
        Counters: model.Counters{
                ScannedFiles:           1,
                ParsedFiles:            1,
                FailedToScanFiles:      0,
                TotalQueries:           1,
                FailedToExecuteQueries: 0,
        },
        Queries: []model.QueryResult{
                queryHigh,
        },
        SeveritySummary: model.SeveritySummary{
                ScanID: "console",
                SeverityCounters: map[model.Severity]int{
                        model.SeverityInfo:   0,
                        model.SeverityLow:    0,
                        model.SeverityMedium: 0,
                        model.SeverityHigh:   2,
                },
                TotalCounter: 2,
        },
        ScannedPaths: []string{
                "./",
        },
}

// ComplexSummaryMock a summary with more results to be used without running kics scan
var ComplexSummaryMock = model.Summary{
        Counters: model.Counters{
                ScannedFiles:           2,
                ParsedFiles:            2,
                FailedToScanFiles:      0,
                TotalQueries:           2,
                FailedToExecuteQueries: 0,
        },
        Queries: []model.QueryResult{
                queryHigh,
                queryMedium,
        },
        SeveritySummary: model.SeveritySummary{
                ScanID: "console",
                SeverityCounters: map[model.Severity]int{
                        model.SeverityInfo:   0,
                        model.SeverityLow:    0,
                        model.SeverityMedium: 1,
                        model.SeverityHigh:   2,
                },
                TotalCounter: 3,
        },
        LatestVersion: model.Version{
                Latest: true,
        },
}

// ExampleSummaryMock a summary with specific results to CycloneDX report tests
var ExampleSummaryMock = model.Summary{
        Counters: model.Counters{
                ScannedFiles:           2,
                ParsedFiles:            2,
                FailedToScanFiles:      0,
                TotalQueries:           2,
                FailedToExecuteQueries: 0,
        },
        Queries: []model.QueryResult{
                queryInfo,
                queryMedium2,
        },
        SeveritySummary: model.SeveritySummary{
                ScanID: "console",
                SeverityCounters: map[model.Severity]int{
                        model.SeverityInfo:   2,
                        model.SeverityLow:    0,
                        model.SeverityMedium: 1,
                        model.SeverityHigh:   0,
                },
                TotalCounter: 3,
        },
        ScannedPaths: []string{
                "./",
        },
}

// SimpleSummaryMock a summary with specific results to ASFF report tests
var SimpleSummaryMock = model.Summary{
        Counters: model.Counters{
                ScannedFiles:           1,
                ParsedFiles:            1,
                FailedToScanFiles:      0,
                TotalQueries:           1,
                FailedToExecuteQueries: 0,
        },
        Queries: []model.QueryResult{
                queryMedium,
        },
        SeveritySummary: model.SeveritySummary{
                ScanID: "console",
                SeverityCounters: map[model.Severity]int{
                        model.SeverityInfo:   0,
                        model.SeverityLow:    0,
                        model.SeverityMedium: 1,
                        model.SeverityHigh:   0,
                },
                TotalCounter: 1,
        },
        ScannedPaths: []string{
                "./",
        },
}
</pre>
		
		</div>
	</body>
	<script>
	(function() {
		var files = document.getElementById('files');
		var visible;
		files.addEventListener('change', onChange, false);
		function select(part) {
			if (visible)
				visible.style.display = 'none';
			visible = document.getElementById(part);
			if (!visible)
				return;
			files.value = part;
			visible.style.display = 'block';
			location.hash = part;
		}
		function onChange() {
			select(files.value);
			window.scrollTo(0, 0);
		}
		if (location.hash != "") {
			select(location.hash.substr(1));
		}
		if (!visible) {
			select("file0");
		}
	})();
	</script>
</html>
